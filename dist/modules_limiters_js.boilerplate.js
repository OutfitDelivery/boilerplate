/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkboilerplate"] = self["webpackChunkboilerplate"] || []).push([["modules_limiters_js"],{

/***/ "./modules/limiters.js":
/*!*****************************!*\
  !*** ./modules/limiters.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"charLimit\": () => (/* binding */ charLimit),\n/* harmony export */   \"dynamicAssign\": () => (/* binding */ dynamicAssign),\n/* harmony export */   \"maxHeightCheck\": () => (/* binding */ maxHeightCheck),\n/* harmony export */   \"maxLineCheck\": () => (/* binding */ maxLineCheck),\n/* harmony export */   \"innerWidth\": () => (/* binding */ innerWidth),\n/* harmony export */   \"innerHeight\": () => (/* binding */ innerHeight),\n/* harmony export */   \"countLines\": () => (/* binding */ countLines)\n/* harmony export */ });\n// count the number of lines inside of the current direct element\r\nfunction countLines(target) {\r\n  let testBox = document.createElement(\"span\");\r\n  testBox.style.fontSize = target.style.fontSize;\r\n  testBox.style.display = \"inline-block\";\r\n  testBox.innerText = \"â €\";\r\n  target.appendChild(testBox);\r\n  let oneLineHeight = innerHeight(testBox);\r\n  testBox.remove();\r\n  let lines = innerHeight(target) / oneLineHeight;\r\n  target.dataset.lineCount = lines; // adds property for CSS targeting\r\n  return lines;\r\n}\r\n\r\n// Calculate height without padding.\r\nfunction innerHeight(el) {\r\n  var style = window.getComputedStyle(el, null);\r\n  var height = parseFloat(style.getPropertyValue(\"height\"));\r\n  var box_sizing = style.getPropertyValue(\"box-sizing\");\r\n  if (box_sizing == \"border-box\") {\r\n    var padding_top = parseFloat(style.getPropertyValue(\"padding-top\"));\r\n    var padding_bottom = parseFloat(style.getPropertyValue(\"padding-bottom\"));\r\n    var border_top = parseFloat(style.getPropertyValue(\"border-top-width\"));\r\n    var border_bottom = parseFloat(\r\n      style.getPropertyValue(\"border-bottom-width\")\r\n    );\r\n    height = height - padding_top - padding_bottom - border_top - border_bottom;\r\n  }\r\n  return height;\r\n}\r\n\r\n// Calculate width without padding.\r\nfunction innerWidth(el) {\r\n  var style = window.getComputedStyle(el, null);\r\n  var width = parseFloat(style.getPropertyValue(\"width\"));\r\n  var box_sizing = style.getPropertyValue(\"box-sizing\");\r\n  if (box_sizing == \"border-box\") {\r\n    var padding_left = parseFloat(style.getPropertyValue(\"padding-left\"));\r\n    var padding_right = parseFloat(style.getPropertyValue(\"padding-right\"));\r\n    var border_left = parseFloat(style.getPropertyValue(\"border-left-width\"));\r\n    var border_right = parseFloat(style.getPropertyValue(\"border-right-width\"));\r\n    width = width - padding_left - padding_right - border_left - border_right;\r\n  }\r\n  return width;\r\n}\r\n\r\nfunction maxLineCheck(orientation = \"portrait\") {\r\n  const isExportMode = window.location.href.indexOf(\"exports\") > -1;\r\n  const isLocalDev = window.location.href.indexOf(\"localhost\") > -1;\r\n  const preventExportOverflow =\r\n    document.body.dataset.preventExportOverflow === \"true\";\r\n  const isProjectKit = isLocalDev\r\n    ? undefined\r\n    : window.parent.document.querySelector(\".preview-frame\");\r\n\r\n  if ((isExportMode && preventExportOverflow) || isProjectKit) return;\r\n\r\n  const textBlocks = document.querySelectorAll(\"[data-max-line]\");\r\n\r\n  textBlocks.forEach((block) => {\r\n    const lineCount = countLines(block);\r\n    // Getting the data-max-line attribute value (max number of lines allowed) and letting the number of an alt if the page is landscape\r\n    const maxLine =\r\n      orientation == \"portrait\"\r\n        ? block.dataset.maxLine\r\n        : block.dataset.maxLineAlt || block.dataset.maxLine;\r\n\r\n    lineCount > maxLine\r\n      ? block.classList.add(\"overflow\")\r\n      : block.classList.remove(\"overflow\");\r\n  });\r\n  return true;\r\n}\r\n\r\n/**\r\n*Detailed instruction can be found here:\r\n https://github.com/aleks-frontend/max-height-check\r\n*/\r\nfunction maxHeightCheck(variation = \"primary\") {\r\n  const isExportMode = window.location.href.indexOf(\"exports\") > -1;\r\n  const isLocalDev = window.location.href.indexOf(\"localhost\") > -1;\r\n  const preventExportOverflow =\r\n    document.body.dataset.preventExportOverflow === \"true\";\r\n  const isProjectKit = isLocalDev\r\n    ? undefined\r\n    : window.parent.document.querySelector(\".preview-frame\");\r\n\r\n  if ((isExportMode && preventExportOverflow) || isProjectKit) return;\r\n\r\n  const textBlocks = document.querySelectorAll(\"[data-max-height]\");\r\n\r\n  textBlocks.forEach((block) => {\r\n    const dynamicCheck =\r\n      block.dataset.maxHeight == \"dynamic\" ||\r\n      block.dataset.maxHeightDynamic == \"true\";\r\n    if (dynamicCheck) dynamicAssign(block);\r\n\r\n    const cssCheck = block.dataset.maxHeight == \"css\";\r\n    const bodyComputedStyle = window.getComputedStyle(document.body);\r\n    const blockHeight = block.scrollHeight;\r\n    const unit = block.dataset.maxHeightUnit || \"px\";\r\n    const maxHeightAlt = block.dataset.maxHeightAlt || block.dataset.maxHeight;\r\n    let maxHeight =\r\n      variation == \"primary\" ? block.dataset.maxHeight : maxHeightAlt;\r\n\r\n    if (cssCheck) {\r\n      const computedBlockStyle = window.getComputedStyle(block);\r\n      maxHeight = parseFloat(computedBlockStyle.maxHeight);\r\n    } else {\r\n      // Setting the element's max-height\r\n      block.style.maxHeight = maxHeight + unit;\r\n\r\n      // Recalculating maxHeight in case 'rem' is set as a unit\r\n      if (unit == \"rem\")\r\n        maxHeight = maxHeight * parseFloat(bodyComputedStyle.fontSize);\r\n    }\r\n\r\n    // Adding an 'overflow' class to an element if it's offset height exceedes the max-line-height\r\n    blockHeight > maxHeight\r\n      ? block.classList.add(\"overflow\")\r\n      : block.classList.remove(\"overflow\");\r\n  });\r\n}\r\n\r\nfunction dynamicAssign(element) {\r\n  const container = element.parentNode;\r\n  container.style.overflow = \"hidden\";\r\n  const containerComputed = {\r\n    height: parseFloat(window.getComputedStyle(container).height),\r\n    top: parseFloat(window.getComputedStyle(container).paddingTop),\r\n    bottom: parseFloat(window.getComputedStyle(container).paddingBottom),\r\n  };\r\n  const containerHeight = Math.floor(\r\n    containerComputed.height - containerComputed.top - containerComputed.bottom\r\n  );\r\n  const subtrahends = [...container.querySelectorAll(\".js-subtrahend\")];\r\n\r\n  const subtrahendsHeight = subtrahends.reduce((totalHeight, subtrahend) => {\r\n    const subtrahendMargins = {\r\n      top: parseFloat(window.getComputedStyle(subtrahend).marginTop),\r\n      bottom: parseFloat(window.getComputedStyle(subtrahend).marginBottom),\r\n    };\r\n    return (\r\n      totalHeight +\r\n      subtrahend.offsetHeight +\r\n      subtrahendMargins.top +\r\n      subtrahendMargins.bottom\r\n    );\r\n  }, 0);\r\n\r\n  const dynamicHeight = containerHeight - subtrahendsHeight;\r\n\r\n  element.dataset.maxHeightDynamic = \"true\";\r\n  element.dataset.maxHeight = dynamicHeight;\r\n  container.style.overflow = \"visible\";\r\n}\r\n\r\n// Adding limit for the word length\r\nfunction charLimit() {\r\n  const elements = document.querySelectorAll(\"[data-char-limit]\");\r\n\r\n  elements.forEach((element) => {\r\n    const limit = element.dataset.charLimit;\r\n\r\n    if (element == null) {\r\n      return;\r\n    }\r\n    var tokenValue = element.querySelectorAll(\".token-value\");\r\n\r\n    if (tokenValue.length != 0) {\r\n      element = tokenValue.item(0);\r\n    }\r\n    var code = element.innerText;\r\n    if (code.length > limit) {\r\n      // Check Token Again\r\n      if (tokenValue.length != 0) {\r\n        element.parentNode.classList.add(\"overflow\");\r\n      } else {\r\n        element.classList.add(\"overflow\");\r\n      }\r\n    } else {\r\n      // Check Token Again\r\n      if (tokenValue.length != 0) {\r\n        element.parentNode.classList.remove(\"overflow\");\r\n      } else {\r\n        element.classList.remove(\"overflow\");\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n\n\n//# sourceURL=webpack://boilerplate/./modules/limiters.js?");

/***/ })

}]);