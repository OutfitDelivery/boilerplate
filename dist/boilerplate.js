(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["boilerplate"] = factory();
	else
		root["boilerplate"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./modules/fontfaceobserver.js":
/*!*************************************!*\
  !*** ./modules/fontfaceobserver.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* Font Face Observer v2.1.0 - © Bram Stein. License: BSD-3-Clause */
(function () {
  "use strict";

  var f,
      g = [];

  function l(a) {
    g.push(a);
    1 == g.length && f();
  }

  function m() {
    for (; g.length;) g[0](), g.shift();
  }

  f = function () {
    setTimeout(m);
  };

  function n(a) {
    this.a = p;
    this.b = void 0;
    this.f = [];
    var b = this;

    try {
      a(function (a) {
        q(b, a);
      }, function (a) {
        r(b, a);
      });
    } catch (c) {
      r(b, c);
    }
  }

  var p = 2;

  function t(a) {
    return new n(function (b, c) {
      c(a);
    });
  }

  function u(a) {
    return new n(function (b) {
      b(a);
    });
  }

  function q(a, b) {
    if (a.a == p) {
      if (b == a) throw new TypeError();
      var c = !1;

      try {
        var d = b && b.then;

        if (null != b && "object" == typeof b && "function" == typeof d) {
          d.call(b, function (b) {
            c || q(a, b);
            c = !0;
          }, function (b) {
            c || r(a, b);
            c = !0;
          });
          return;
        }
      } catch (e) {
        c || r(a, e);
        return;
      }

      a.a = 0;
      a.b = b;
      v(a);
    }
  }

  function r(a, b) {
    if (a.a == p) {
      if (b == a) throw new TypeError();
      a.a = 1;
      a.b = b;
      v(a);
    }
  }

  function v(a) {
    l(function () {
      if (a.a != p) for (; a.f.length;) {
        var b = a.f.shift(),
            c = b[0],
            d = b[1],
            e = b[2],
            b = b[3];

        try {
          0 == a.a ? "function" == typeof c ? e(c.call(void 0, a.b)) : e(a.b) : 1 == a.a && ("function" == typeof d ? e(d.call(void 0, a.b)) : b(a.b));
        } catch (h) {
          b(h);
        }
      }
    });
  }

  n.prototype.g = function (a) {
    return this.c(void 0, a);
  };

  n.prototype.c = function (a, b) {
    var c = this;
    return new n(function (d, e) {
      c.f.push([a, b, d, e]);
      v(c);
    });
  };

  function w(a) {
    return new n(function (b, c) {
      function d(c) {
        return function (d) {
          h[c] = d;
          e += 1;
          e == a.length && b(h);
        };
      }

      var e = 0,
          h = [];
      0 == a.length && b(h);

      for (var k = 0; k < a.length; k += 1) u(a[k]).c(d(k), c);
    });
  }

  function x(a) {
    return new n(function (b, c) {
      for (var d = 0; d < a.length; d += 1) u(a[d]).c(b, c);
    });
  }

  window.Promise || (window.Promise = n, window.Promise.resolve = u, window.Promise.reject = t, window.Promise.race = x, window.Promise.all = w, window.Promise.prototype.then = n.prototype.c, window.Promise.prototype["catch"] = n.prototype.g);
})();

function l(a, b) {
  document.addEventListener ? a.addEventListener("scroll", b, !1) : a.attachEvent("scroll", b);
}

function m(a) {
  document.body ? a() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function c() {
    document.removeEventListener("DOMContentLoaded", c);
    a();
  }) : document.attachEvent("onreadystatechange", function k() {
    if ("interactive" == document.readyState || "complete" == document.readyState) document.detachEvent("onreadystatechange", k), a();
  });
}

function t(a) {
  this.a = document.createElement("div");
  this.a.setAttribute("aria-hidden", "true");
  this.a.appendChild(document.createTextNode(a));
  this.b = document.createElement("span");
  this.c = document.createElement("span");
  this.h = document.createElement("span");
  this.f = document.createElement("span");
  this.g = -1;
  this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
  this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
  this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
  this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";
  this.b.appendChild(this.h);
  this.c.appendChild(this.f);
  this.a.appendChild(this.b);
  this.a.appendChild(this.c);
}

function u(a, b) {
  a.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + b + ";";
}

function z(a) {
  var b = a.a.offsetWidth,
      c = b + 100;
  a.f.style.width = c + "px";
  a.c.scrollLeft = c;
  a.b.scrollLeft = a.b.scrollWidth + 100;
  return a.g !== b ? (a.g = b, !0) : !1;
}

function A(a, b) {
  function c() {
    var a = k;
    z(a) && a.a.parentNode && b(a.g);
  }

  var k = a;
  l(a.b, c);
  l(a.c, c);
  z(a);
}

function B(a, b) {
  var c = b || {};
  this.family = a;
  this.style = c.style || "normal";
  this.weight = c.weight || "normal";
  this.stretch = c.stretch || "normal";

  this.load = function (a, b) {
    var c = this,
        k = a || "BESbswy",
        r = 0,
        n = b || 3e3,
        H = new Date().getTime();
    return new Promise(function (a, b) {
      if (J() && !G()) {
        var M = new Promise(function (a, b) {
          function e() {
            new Date().getTime() - H >= n ? b(Error("" + n + "ms timeout exceeded loading fonts")) : document.fonts.load(L(c, '"' + c.family + '"'), k).then(function (c) {
              1 <= c.length ? a() : setTimeout(e, 25);
            }, b);
          }

          e();
        }),
            N = new Promise(function (a, c) {
          r = setTimeout(function () {
            c(Error("" + n + "ms timeout exceeded loading fonts"));
          }, n);
        });
        Promise.race([N, M]).then(function () {
          clearTimeout(r);
          a(c);
        }, b);
      } else m(function () {
        function v() {
          var b;
          if (b = -1 != f && -1 != g || -1 != f && -1 != h || -1 != g && -1 != h) (b = f != g && f != h && g != h) || (null === C && (b = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), C = !!b && (536 > parseInt(b[1], 10) || 536 === parseInt(b[1], 10) && 11 >= parseInt(b[2], 10))), b = C && (f == w && g == w && h == w || f == x && g == x && h == x || f == y && g == y && h == y)), b = !b;
          b && (d.parentNode && d.parentNode.removeChild(d), clearTimeout(r), a(c));
        }

        function I() {
          if (new Date().getTime() - H >= n) d.parentNode && d.parentNode.removeChild(d), b(Error("" + n + "ms timeout exceeded loading fonts"));else {
            var a = document.hidden;
            if (!0 === a || void 0 === a) f = e.a.offsetWidth, g = p.a.offsetWidth, h = q.a.offsetWidth, v();
            r = setTimeout(I, 50);
          }
        }

        var e = new t(k),
            p = new t(k),
            q = new t(k),
            f = -1,
            g = -1,
            h = -1,
            w = -1,
            x = -1,
            y = -1,
            d = document.createElement("div");
        d.dir = "ltr";
        u(e, L(c, "sans-serif"));
        u(p, L(c, "serif"));
        u(q, L(c, "monospace"));
        d.appendChild(e.a);
        d.appendChild(p.a);
        d.appendChild(q.a);
        document.body.appendChild(d);
        w = e.a.offsetWidth;
        x = p.a.offsetWidth;
        y = q.a.offsetWidth;
        I();
        A(e, function (a) {
          f = a;
          v();
        });
        u(e, L(c, '"' + c.family + '",sans-serif'));
        A(p, function (a) {
          g = a;
          v();
        });
        u(p, L(c, '"' + c.family + '",serif'));
        A(q, function (a) {
          h = a;
          v();
        });
        u(q, L(c, '"' + c.family + '",monospace'));
      });
    });
  };
}

var C = null,
    D = null,
    E = null,
    F = null;

function G() {
  if (null === D) if (J() && /Apple/.test(window.navigator.vendor)) {
    var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);
    D = !!a && 603 > parseInt(a[1], 10);
  } else D = !1;
  return D;
}

function J() {
  null === F && (F = !!document.fonts);
  return F;
}

function K() {
  if (null === E) {
    var a = document.createElement("div");

    try {
      a.style.font = "condensed 100px sans-serif";
    } catch (b) {}

    E = "" !== a.style.font;
  }

  return E;
}

function L(a, b) {
  return [a.style, a.weight, K() ? a.stretch : "", "100px", b].join(" ");
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (B);

/***/ }),

/***/ "./modules/limiters.js":
/*!*****************************!*\
  !*** ./modules/limiters.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "charLimit": () => (/* binding */ charLimit),
/* harmony export */   "dynamicAssign": () => (/* binding */ dynamicAssign),
/* harmony export */   "maxHeightCheck": () => (/* binding */ maxHeightCheck),
/* harmony export */   "maxLineCheck": () => (/* binding */ maxLineCheck),
/* harmony export */   "getWidth": () => (/* binding */ getWidth),
/* harmony export */   "getHeight": () => (/* binding */ getHeight),
/* harmony export */   "countLines": () => (/* binding */ countLines),
/* harmony export */   "calculateTextMetrics": () => (/* binding */ calculateTextMetrics),
/* harmony export */   "lineClamp": () => (/* binding */ lineClamp),
/* harmony export */   "minLineCheck": () => (/* binding */ minLineCheck)
/* harmony export */ });
/* harmony import */ var _lineClamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lineClamp.js */ "./modules/lineClamp.js");


function hasHeightValue(el, target) {
  if (el.isSameNode(target)) {
    return el;
  }

  if (el.classList.contains('textFitted')) {
    return el;
  }

  if (['inline', 'inline-block'].includes(window.getComputedStyle(el).display) || isNaN(getHeight(el))) {
    return hasHeightValue(el.parentElement, target);
  } else {
    return el;
  }
} // find all text nodes under a given element


function textNodesUnder(el) {
  var n = null,
      a = [],
      walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);

  while (n = walk.nextNode()) {
    if (n.textContent.trim()) {
      let {
        parentElement
      } = n; // if (parentElement.isSameNode(el)) {
      //   return [el];
      // }

      let e = hasHeightValue(parentElement, el); // console.log(e)
      // if (e) exits and ins't already returned then add it to the list of elements to line check

      if (e && !a.includes(e)) {
        // if (e) has got a child in (a) then we need to remove that child to prevent double up of counting
        console.log('before', a);
        a = a.filter(i => {
          console.log(e.contains(i));
          return !e.contains(i);
        });
        console.log('after', a);
        a.push(e);
      }
    }
  }

  return a;
} // some elements don't have height values set correctly so we need to drill down 


function findTextNode(target) {
  // if (child && ['SPAN','TOKEN-VALUE','STRONG','P','EM',''].includes(child.tagName)) {
  if (target.firstElementChild && !['BR'].includes(target.firstElementChild.tagName)) {
    target = findTextNode(target.firstElementChild);
  }

  return target;
} // not so simple rounding for line counting purposes


function simpleRounding(num) {
  if (num > 10) {
    return Math.round(num); // return num.toFixed(0).replace(/(\.0+|0+)$/, '');
  }

  return Math.round(num); //.replace(/(\.0+|0+)$/, '');
} // count the number of lines inside of the current direct element


function countLines(elements, advanced) {
  var elType = Object.prototype.toString.call(elements);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    elements = [elements];
  }

  let result = [...elements].map(target => {
    if (true) {
      let muiltCount = 0;
      let textNodes = textNodesUnder(target); // console.log(textNodes, 'textNodes that have height')

      textNodes.forEach(el => {
        let metrics = calculateTextMetrics(el);
        let line = simpleRounding(metrics.lineCount); // console.log(el, metrics)

        if (line) {
          el.dataset.rawLinesCount = line;
          muiltCount += line;
        }
      });
      muiltCount = simpleRounding(muiltCount);
      target.dataset.calculatedLinesCount = muiltCount; // adds property for CSS targeting

      return muiltCount;
    } else {} // } else {
    // let metrics = calculateTextMetrics(target);
    // if (metrics.lineCount) {
    //   let lineCountRounded = simpleRounding(metrics.lineCount)
    //   target.dataset.calculatedLinesCount = lineCountRounded // adds property for CSS targeting
    //   target.dataset.rawLinesCount = metrics.lineCount; // adds property for CSS targeting
    //   return lineCountRounded
    // }
    // return null
    // }

  });

  if (result.length == 1) {
    return result[0];
  }

  return result;
}

let clampDefaults = {
  maxLines: 1,
  minFontSize: 18,
  useSoftClamp: true,
  ellipsis: '...'
};

function lineClamp(elements, config) {
  config = { ...clampDefaults,
    ...config
  };
  var elType = Object.prototype.toString.call(elements);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    elements = [elements];
  }

  return [...elements].map(element => {
    const clamp = new _lineClamp_js__WEBPACK_IMPORTED_MODULE_0__.default(element, config);
    clamp.apply();
    clamp.watch();
    return clamp;
  });
} // returns lineCount and line hieght info from this libaray https://github.com/tvanc/lineclamp


function calculateTextMetrics(elements, config) {
  var elType = Object.prototype.toString.call(elements);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    elements = [elements];
  }

  let result = [...elements].map(element => {
    return new _lineClamp_js__WEBPACK_IMPORTED_MODULE_0__.default(element, config).calculateTextMetrics();
  });

  if (result.length == 1) {
    return result[0];
  }

  return result;
} // Calculate height without padding.


function getHeight(el) {
  var style = window.getComputedStyle(el, null);
  var height = parseFloat(style.getPropertyValue("height"));
  var box_sizing = style.getPropertyValue("box-sizing");

  if (box_sizing === "border-box") {
    var padding_top = parseFloat(style.getPropertyValue("padding-top"));
    var padding_bottom = parseFloat(style.getPropertyValue("padding-bottom"));
    var border_top = parseFloat(style.getPropertyValue("border-top-width"));
    var border_bottom = parseFloat(style.getPropertyValue("border-bottom-width"));
    height = height - padding_top - padding_bottom - border_top - border_bottom;
  }

  el.dataset.calculatedHeight = height; // adds property for debuging

  return height;
} // Calculate width without padding.


function getWidth(el) {
  var style = window.getComputedStyle(el, null);
  var width = parseFloat(style.getPropertyValue("width"));
  var box_sizing = style.getPropertyValue("box-sizing");

  if (box_sizing === "border-box") {
    var padding_left = parseFloat(style.getPropertyValue("padding-left"));
    var padding_right = parseFloat(style.getPropertyValue("padding-right"));
    var border_left = parseFloat(style.getPropertyValue("border-left-width"));
    var border_right = parseFloat(style.getPropertyValue("border-right-width"));
    width = width - padding_left - padding_right - border_left - border_right;
  }

  el.dataset.calculatedWidth = width; // adds property for debuging

  return width;
}

function maxLineCheck(element = null) {
  const isExportMode = window.location.href.indexOf("exports") > -1;
  const isLocalDev = window.location.href.indexOf("localhost") > -1;
  const preventExportOverflow = document.body.dataset.preventExportOverflow === "true";
  const isProjectKit = isLocalDev ? undefined : window.parent.document.querySelector(".preview-frame");
  if (isExportMode && preventExportOverflow || isProjectKit) return;
  const blocks = document.querySelectorAll("[data-max-line]");
  blocks.forEach(block => {
    const lineCount = countLines(block); // Getting the data-max-line attribute value (max number of lines allowed) 

    const maxLine = block.dataset.maxLineAlt || block.dataset.maxLine;
    lineCount > maxLine ? block.classList.add("overflow") : block.classList.remove("overflow");
  });
  return true;
}

function minLineCheck(element = null) {
  const isExportMode = window.location.href.indexOf("exports") > -1;
  const isLocalDev = window.location.href.indexOf("localhost") > -1;
  const preventExportOverflow = document.body.dataset.preventExportOverflow === "true";
  const isProjectKit = isLocalDev ? undefined : window.parent.document.querySelector(".preview-frame");
  if (isExportMode && preventExportOverflow || isProjectKit) return;
  const blocks = document.querySelectorAll("[data-min-line]");
  blocks.forEach(block => {
    const lineCount = countLines(block); // Getting the data-max-line attribute value (max number of lines allowed) 

    const minLine = block.dataset.minLineAlt || block.dataset.maxLine;
    lineCount <= minLine ? block.classList.add("overflow") : block.classList.remove("overflow");
  });
  return true;
}
/**
*Detailed instruction can be found here:
 https://github.com/aleks-frontend/max-height-check
*/


function maxHeightCheck(element = null) {
  const isExportMode = window.location.href.indexOf("exports") > -1;
  const isLocalDev = window.location.href.indexOf("localhost") > -1;
  const preventExportOverflow = document.body.dataset.preventExportOverflow === "true";
  const isProjectKit = isLocalDev ? undefined : window.parent.document.querySelector(".preview-frame");
  if (isExportMode && preventExportOverflow || isProjectKit) return;
  const blocks = document.querySelectorAll("[data-max-height]");
  blocks.forEach(block => {
    if (block.dataset.maxHeight === "dynamic" || block.dataset.maxHeight === "parent" || block.dataset.maxHeightDynamic === "true") {
      dynamicAssign(block);
    }

    const blockHeight = getHeight(block);
    const maxHeight = block.dataset.maxHeight; // TODO improve this 

    if (block.dataset.maxHeight === "css") {
      const computedBlockStyle = window.getComputedStyle(block);
      const cssMaxHeight = parseFloat(computedBlockStyle.maxHeight);

      if (!cssMaxHeight) {
        console.error('There needs to be a max height set on the element if you want to use data-max-height="css"');
      }

      maxHeight = cssMaxHeight;
    } else {
      // Setting the element's max-height
      block.style.maxHeight = maxHeight + block.dataset.maxHeightUnit || "px"; // Recalculating maxHeight in case 'rem' is set as a unit

      if (block.dataset.maxHeightUnit === "rem") {
        maxHeight = maxHeight * parseFloat(window.getComputedStyle(document.body).fontSize);
      }
    } // Adding an 'overflow' class to an element if it's offset height exceedes the max-line-height


    blockHeight > maxHeight ? block.classList.add("overflow") : block.classList.remove("overflow");
  });
  return true;
}

function dynamicAssign(element = null) {
  const container = element.parentNode;
  container.style.overflow = "hidden"; // const containerComputed = {
  //   height: parseFloat(window.getComputedStyle(container).height),
  //   top: parseFloat(window.getComputedStyle(container).paddingTop),
  //   bottom: parseFloat(window.getComputedStyle(container).paddingBottom),
  // };
  // const containerHeight = Math.floor(
  //   containerComputed.height - containerComputed.top - containerComputed.bottom
  // );

  const containerHeight = getHeight(container); // TODO work out what subtrahend is 

  const subtrahends = [...container.querySelectorAll(".js-subtrahend")];
  const subtrahendsHeight = subtrahends.reduce((totalHeight, subtrahend) => {
    const subtrahendMargins = {
      top: parseFloat(window.getComputedStyle(subtrahend).marginTop),
      bottom: parseFloat(window.getComputedStyle(subtrahend).marginBottom)
    };
    return totalHeight + subtrahend.offsetHeight + subtrahendMargins.top + subtrahendMargins.bottom;
  }, 0);
  const dynamicHeight = containerHeight - subtrahendsHeight;
  element.dataset.maxHeightDynamic = "true";
  element.dataset.maxHeight = dynamicHeight;
  container.style.overflow = "visible";
  return dynamicHeight;
} // Adding limit for the word length


function charLimit(element = null) {
  const blocks = document.querySelectorAll("[data-char-limit]");
  blocks.forEach(element => {
    const limit = element.dataset.charLimit;

    if (element === null) {
      return;
    }

    var tokenValue = element.querySelectorAll(".token-value");

    if (tokenValue.length != 0) {
      element = tokenValue.item(0);
    }

    var code = element.innerText;
    element.dataset.calculatedCharCount = code.length;

    if (code.length > limit) {
      // Check Token Again
      if (tokenValue.length != 0) {
        element.parentNode.classList.add("overflow");
      } else {
        element.classList.add("overflow");
      }
    } else {
      // Check Token Again
      if (tokenValue.length != 0) {
        element.parentNode.classList.remove("overflow");
      } else {
        element.classList.remove("overflow");
      }
    }
  });
  return true;
}



/***/ }),

/***/ "./modules/lineClamp.js":
/*!******************************!*\
  !*** ./modules/lineClamp.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineClamp)
/* harmony export */ });
/* harmony import */ var _limiters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limiters.js */ "./modules/limiters.js");

/**
 * Reduces font size or trims text to make it fit within specified bounds.
 *
 * Supports clamping by number of lines or text height.
 *
 * Known limitations:
 * 1. Characters that distort line heights (emojis, zalgo) may cause
 * unexpected results.
 * 2. Calling {@see hardClamp()} wipes child elements. Future updates may allow
 * inline child elements to be preserved.
 *
 * @todo Split text metrics into own library
 * @todo Test non-LTR text
 */

class LineClamp {
  /**
   * @param {HTMLElement} element
   * The element to clamp.
   *
   * @param {Object} [options]
   * Options to govern clamping behavior.
   *
   * @param {number} [options.maxLines]
   * The maximum number of lines to allow. Defaults to 1.
   * To set a maximum height instead, use {@see options.maxHeight}
   *
   * @param {number} [options.maxHeight]
   * The maximum height (in pixels) of text in an element.
   * This option is undefined by default. Once set, it takes precedence over
   * {@see options.maxLines}. Note that this applies to the height of the text, not
   * the element itself. Restricting the height of the element can be achieved
   * with CSS <code>max-height</code>.
   *
   * @param {boolean} [options.useSoftClamp]
   * If true, reduce font size (soft clamp) to at least {@see options.minFontSize}
   * before resorting to trimming text. Defaults to false.
   *
   * @param {boolean} [options.hardClampAsFallback]
   * If true, resort to hard clamping if soft clamping reaches the minimum font size
   * and still doesn't fit within the max height or number of lines.
   * Defaults to true.
   *
   * @param {string} [options.ellipsis]
   * The character with which to represent clipped trailing text.
   * This option takes effect when "hard" clamping is used.
   *
   * @param {number} [options.minFontSize]
   * The lowest font size, in pixels, to try before resorting to removing
   * trailing text (hard clamping). Defaults to 1.
   *
   * @param {number} [options.maxFontSize]
   * The maximum font size in pixels. We'll start with this font size then
   * reduce until text fits constraints, or font size is equal to
   * {@see options.minFontSize}. Defaults to the element's initial computed font size.
   */
  constructor(element, {
    maxLines = undefined,
    maxHeight = undefined,
    useSoftClamp = false,
    hardClampAsFallback = true,
    minFontSize = 1,
    maxFontSize = undefined,
    ellipsis = "…"
  } = {}) {
    Object.defineProperty(this, "originalWords", {
      writable: false,
      value: element.textContent.match(/\S+\s*/g) || []
    });
    Object.defineProperty(this, "updateHandler", {
      writable: false,
      value: () => this.apply()
    });
    Object.defineProperty(this, "observer", {
      writable: false,
      value: new MutationObserver(this.updateHandler)
    });

    if (undefined === maxFontSize) {
      maxFontSize = parseInt(window.getComputedStyle(element).fontSize, 10);
    }

    this.element = element;
    this.maxLines = maxLines;
    this.maxHeight = maxHeight;
    this.useSoftClamp = useSoftClamp;
    this.hardClampAsFallback = hardClampAsFallback;
    this.minFontSize = minFontSize;
    this.maxFontSize = maxFontSize;
    this.ellipsis = ellipsis;
  }
  /**
   * Gather metrics about the layout of the element's text.
   * This is a somewhat expensive operation - call with care.
   *
   * @returns {TextMetrics}
   * Layout metrics for the clamped element's text.
   */


  calculateTextMetrics() {
    const element = this.element;
    const clone = element.cloneNode(true);
    const style = clone.style; // Append, don't replace

    style.cssText += ";min-height:0!important;max-height:none!important";
    element.replaceWith(clone);
    const naturalHeight = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone); // clone.offsetHeight
    // Clear to measure empty height. textContent faster than innerHTML

    clone.textContent = "";
    const naturalHeightWithoutText = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone); // clone.offsetHeight

    const textHeight = naturalHeight - naturalHeightWithoutText; // Fill element with single non-breaking space to find height of one line

    clone.textContent = "\xa0"; // Get height of element with only one line of text

    const naturalHeightWithOneLine = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone); // clone.offsetHeight

    const firstLineHeight = naturalHeightWithOneLine - naturalHeightWithoutText; // Add line (<br> + nbsp). appendChild() faster than innerHTML

    clone.appendChild(document.createElement("br"));
    clone.appendChild(document.createTextNode("\xa0"));
    const additionalLineHeight = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone) - naturalHeightWithOneLine; // clone.offsetHeight - naturalHeightWithOneLine

    const lineCount = 1 + (naturalHeight - naturalHeightWithOneLine) / additionalLineHeight; // Restore original content

    clone.replaceWith(element);
    /**
     * @typedef {Object} TextMetrics
     *
     * @property {textHeight}
     * The vertical space required to display the element's current text.
     * This is <em>not</em> necessarily the same as the height of the element.
     * This number may even be greater than the element's height in cases
     * where the text overflows the element's block axis.
     *
     * @property {naturalHeightWithOneLine}
     * The height of the element with only one line of text and without
     * minimum or maximum heights. This information may be helpful when
     * dealing with inline elements (and potentially other scenarios), where
     * the first line of text does not increase the element's height.
     *
     * @property {firstLineHeight}
     * The height that the first line of text adds to the element, i.e., the
     * difference between the height of the element while empty and the height
     * of the element while it contains one line of text. This number may be
     * zero for inline elements because the first line of text does not
     * increase the height of inline elements.
      * @property {additionalLineHeight}
     * The height that each line of text after the first adds to the element.
     *
     * @property {lineCount}
     * The number of lines of text the element contains.
     */

    return {
      textHeight,
      naturalHeightWithOneLine,
      firstLineHeight,
      additionalLineHeight,
      lineCount,
      naturalHeight
    };
  }
  /**
   * Watch for changes that may affect layout. Respond by reclamping if
   * necessary.
   */


  watch() {
    if (!this._watching) {
      window.addEventListener("resize", this.updateHandler); // Minimum required to detect changes to text nodes,
      // and wholesale replacement via innerHTML

      this.observer.observe(this.element, {
        characterData: true,
        subtree: true,
        childList: true,
        attributes: true
      });
      this._watching = true;
    }

    return this;
  }
  /**
   * Stop watching for layout changes.
   *
   * @returns {LineClamp}
   */


  unwatch() {
    this.observer.disconnect();
    window.removeEventListener("resize", this.updateHandler);
    this._watching = false;
    return this;
  }
  /**
   * Conduct either soft clamping or hard clamping, according to the value of
   * property {@see LineClamp.useSoftClamp}.
   */


  apply() {
    if (this.element.offsetHeight) {
      const previouslyWatching = this._watching; // Ignore internally started mutations, lest we recurse into oblivion

      this.unwatch();
      this.element.textContent = this.originalWords.join("");

      if (this.useSoftClamp) {
        this.softClamp();
      } else {
        this.hardClamp();
      } // Resume observation if previously watching


      if (previouslyWatching) {
        this.watch(false);
      }
    }

    return this;
  }
  /**
   * Trims text until it fits within constraints
   * (maximum height or number of lines).
   *
   * @see {LineClamp.maxLines}
   * @see {LineClamp.maxHeight}
   */


  hardClamp(skipCheck = true) {
    if (skipCheck || this.shouldClamp()) {
      let currentText;
      findBoundary(1, this.originalWords.length, val => {
        currentText = this.originalWords.slice(0, val).join(" ");
        this.element.textContent = currentText;
        return this.shouldClamp();
      }, (val, min, max) => {
        // Add one more word if not on max
        if (val > min) {
          currentText = this.originalWords.slice(0, max).join(" ");
        } // Then trim letters until it fits


        do {
          currentText = currentText.slice(0, -1);
          this.element.textContent = currentText + this.ellipsis;
        } while (this.shouldClamp()); // Broadcast more specific hardClamp event first


        emit(this, "lineclamp.hardclamp");
        emit(this, "lineclamp.clamp");
      });
    }

    return this;
  }
  /**
   * Reduces font size until text fits within the specified height or number of
   * lines. Resorts to using {@see hardClamp()} if text still exceeds clamp
   * parameters.
   */


  softClamp() {
    const style = this.element.style;
    const startSize = window.getComputedStyle(this.element).fontSize;
    style.fontSize = "";
    let done = false;
    let shouldClamp;
    findBoundary(this.minFontSize, this.maxFontSize, val => {
      style.fontSize = val + "px";
      shouldClamp = this.shouldClamp();
      return shouldClamp;
    }, (val, min) => {
      if (val > min) {
        style.fontSize = min + "px";
        shouldClamp = this.shouldClamp();
      }

      done = !shouldClamp;
    });
    const changed = style.fontSize !== startSize; // Emit specific softClamp event first

    if (changed) {
      emit(this, "lineclamp.softclamp");
    } // Don't emit `lineclamp.clamp` event twice.


    if (!done && this.hardClampAsFallback) {
      this.hardClamp(false);
    } else if (changed) {
      // hardClamp emits `lineclamp.clamp` too. Only emit from here if we're
      // not also hard clamping.
      emit(this, "lineclamp.clamp");
    }

    return this;
  }
  /**
   * @returns {boolean}
   * Whether height of text or number of lines exceed constraints.
   *
   * @see LineClamp.maxHeight
   * @see LineClamp.maxLines
   */


  shouldClamp() {
    const {
      lineCount,
      textHeight
    } = this.calculateTextMetrics();

    if (undefined !== this.maxHeight && undefined !== this.maxLines) {
      return textHeight > this.maxHeight || lineCount > this.maxLines;
    }

    if (undefined !== this.maxHeight) {
      return textHeight > this.maxHeight;
    }

    if (undefined !== this.maxLines) {
      return lineCount > this.maxLines;
    }

    throw new Error("maxLines or maxHeight must be set before calling shouldClamp().");
  }

}
/**
 * Performs a binary search for the point in a contigous range where a given
 * test callback will go from returning true to returning false.
 *
 * Since this uses a binary-search algorithm this is an O(log n) function,
 * where n = max - min.
 *
 * @param {Number} min
 * The lower boundary of the range.
 *
 * @param {Number} max
 * The upper boundary of the range.
 *
 * @param test
 * A callback that receives the current value in the range and returns a truthy or falsy value.
 *
 * @param done
 * A function to perform when complete. Receives the following parameters
 * - cursor
 * - maxPassingValue
 * - minFailingValue
 */

function findBoundary(min, max, test, done) {
  // start halfway through the range
  let cursor = (min + max) / 2;

  while (max > min) {
    if (test(cursor)) {
      max = cursor;
    } else {
      min = cursor;
    }

    if (max - min === 1) {
      done(cursor, min, max);
      break;
    }

    cursor = Math.floor((min + max) / 2);
  }
}

function emit(instance, type) {
  instance.element.dispatchEvent(new CustomEvent(type));
}

/***/ }),

/***/ "./modules/mto.js":
/*!************************!*\
  !*** ./modules/mto.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setupMTO": () => (/* binding */ setupMTO),
/* harmony export */   "getSidebar": () => (/* binding */ getSidebar)
/* harmony export */ });
// get sidebar element on the current page
const getSidebar = () => {
  let sidebar = window.top.document.querySelectorAll(".sidebar .current-list");

  if (sidebar.length > 0) {
    return [...sidebar].pop();
  } else {
    return undefined;
  }
};

const hideInput = inputValue => {
  getSidebar().querySelectorAll(".sidebar-items").forEach(input => {
    if (input.querySelector(".field-variable-tag").innerText === inputValue) {
      input.style.display = 'none';
    }
  });
};

const setupMTO = (teamMetadata, teamsAllowed = '', inputName = 'Team metadata') => {
  return new Promise((resolve, reject) => {
    try {
      // const sidebar = getSidebar();
      // state isn't global in v2 so this line is needed for that version but shouldn't be included in v3
      // const state = document.body.getAttribute("document-state");
      if (!state) {
        reject('please set the state attribute');
      } // if we are on any other page then we don't need to do anything to the sidebar and we can skip everything


      if (state === "template") {
        let mtoNotSupported = () => {
          if (getSidebar().firstChild.firstChild.lastChild.innerText == inputName) {
            getSidebar().querySelector('.choice-variable').innerHTML = "<p>".concat(inputName, " functionality is not available on a template level.</p>");
          }
        };

        setInterval(() => mtoNotSupported(), 500);
      }

      if (state === "document") {
        // turn teamsAllowed from string into array
        teamsAllowed = teamsAllowed.toLowerCase().split("_").join(" ").split(',').filter(n => n);

        let hideTeamsThatAreNotAllowed = () => {
          if (teamsAllowed.length > 0) {
            // if we are only allowing the user to select some of the teams then we should remove the ones that the user hasn't got access to. 
            if (getSidebar().firstChild.firstChild.lastChild.innerText == inputName) {
              getSidebar().querySelectorAll('.search-bar-wrapper').forEach(el => el.remove());
              getSidebar().querySelectorAll('.action-buttons').forEach(el => el.remove());
              getSidebar().querySelectorAll('.choice-variable .multichoice-edit-row').forEach(inputOption => {
                if (!teamsAllowed.includes(inputOption.querySelector("input").value)) {
                  inputOption.remove();
                } else {
                  let span = inputOption.querySelector("span"); // remove 4 digit number from start of input

                  if (span.innerText.match(/^[0-9]{4}/g)) {
                    span.innerText = span.innerText.substring(7);
                  }
                }
              });
            } else {// This means we are not on the MTO sidebar 
            }
          } else {
            // getSidebar().querySelector('.choice-variable').innerHTML = `<p>${inputName} is not available for your team. Please click back to continue editing your document.</p>`;
            hideInput(inputName);
          }
        };

        setInterval(() => hideTeamsThatAreNotAllowed(), 500);
        hideTeamsThatAreNotAllowed();
      }

      if (state === "template") {
        getSidebar().querySelectorAll('.choice-variable').innerHTML = "<p>".concat(inputName, " is only available on the edit page.</p>");
      }

      if (['document', 'export', 'preview'].includes(state)) {
        if (typeof window.handleMTOData === 'function') {
          window.handleMTOData(teamMetadata);
        }

        resolve(teamMetadata);
      }
    } catch (error) {
      console.error("An MTO error has occurred. Please try again later. If the issue still persists please contact Outfit Support");
      reject(error);
    }
  });
};



/***/ }),

/***/ "./modules/pageSetup.js":
/*!******************************!*\
  !*** ./modules/pageSetup.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "imageCompression": () => (/* binding */ imageCompression),
/* harmony export */   "ensureAllImagesLoaded": () => (/* binding */ ensureAllImagesLoaded)
/* harmony export */ });
const imageCompression = () => {
  var imageCompressEl = document.querySelectorAll("[data-custom-compression]");
  var editorString = "?qual=editor";

  function checkURL(editorString, url) {
    if (url.includes(editorString) || url.includes(".svg")) return false;
    return true;
  }

  imageCompressEl.forEach(el => {
    //Non Repo Images with data-custom-compression on img element itself
    var imgSrc = el.getAttribute("src");
    console.log(imgSrc);

    if (imgSrc) {
      //src attribute exists assume that this is an <img> element
      if (!checkURL(editorString, imgSrc)) return;
      el.setAttribute("src", imgSrc + editorString);
    } else {
      var imgEl = el.querySelector("img");
      if (!imgEl) return;
      var imgURL = imgEl.getAttribute("src");
      if (!checkURL(editorString, imgURL)) return;
      imgEl.setAttribute("src", imgURL + editorString);
      var bkgImgEl = el.querySelector(".outfit-resizable-background");
      if (!bkgImgEl) return;
      var bkgUrl = bkgImgEl.style.backgroundImage.slice(4, -1).replace(/"/g, "");
      if (!checkURL(editorString, bkgUrl)) return;
      bkgImgEl.style.backgroundImage = "url(\"".concat(bkgUrl).concat(editorString, "\")");
    }
  });
}; // https://blog.crimx.com/2017/03/09/get-all-images-in-dom-including-background-en/
// time out is set to 60 seconds as that is as long as the platform timeout


const ensureAllImagesLoaded = (doc = document, timeout = 6e4) => {
  return new Promise((resolve, reject) => {
    loadAllImages(Array.from(searchDOM(doc)), timeout).then(resolve, reject);
  });
};

const searchDOM = doc => {
  const srcChecker = /url\(\s*?['"]?\s*?(\S+?)\s*?["']?\s*?\)/i;
  return Array.from(doc.querySelectorAll('*')).reduce((collection, node) => {
    // bg src
    let prop = window.getComputedStyle(node, null).getPropertyValue('background-image'); // match `url(...)`

    let match = srcChecker.exec(prop);

    if (match) {
      collection.add(match[1]);
    }

    if (/^img$/i.test(node.tagName)) {
      // src from img tag
      collection.add(node.src);
    } else if (/^frame$/i.test(node.tagName)) {
      // iframe
      try {
        searchDOM(node.contentDocument || node.contentWindow.document).forEach(img => {
          if (img) {
            collection.add(img);
          }
        });
      } catch (e) {}
    }

    return collection;
  }, new Set());
};

const loadImage = (src, timeout = 5000) => {
  var imgPromise = new Promise((resolve, reject) => {
    let img = new Image();

    img.onload = () => {
      resolve({
        src: src,
        width: img.naturalWidth,
        height: img.naturalHeight
      });
    };

    img.onerror = reject;
    img.src = src;
  });
  var timer = new Promise((resolve, reject) => {
    setTimeout(reject, timeout);
  });
  return Promise.race([imgPromise, timer]);
};

const loadAllImages = (imgList, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    Promise.all(imgList.map(src => loadImage(src, timeout)).map(p => p.catch(e => false))).then(results => resolve(results.filter(r => r)));
  });
};



/***/ }),

/***/ "./modules/placeholder.js":
/*!********************************!*\
  !*** ./modules/placeholder.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setupPlaceholder)
/* harmony export */ });
function setupPlaceholder(placeholderVisibility, placeholderImages) {
  // If array length < 1 or the first item is "" or null or undefined
  if (placeholderImages.length < 1 || placeholderImages[0] == "" || placeholderImages[0] == null || placeholderImages[0] == undefined || placeholderVisibility == "hide") return;
  var pages = document.querySelectorAll(".page .container");
  pages.forEach((page, index) => {
    let placeholderImage = placeholderImages[index];
    if (placeholderImage == "" || placeholderImage == null || placeholderImage == undefined) placeholderImage = placeholderImages[0];
    let placeholderStructure = "<div class=\"placeholderImage\" style=\"background-image: url('".concat(placeholderImage, "')\"></div>");
    page.insertAdjacentHTML("afterbegin", placeholderStructure);
  });
}

/***/ }),

/***/ "./modules/replace.js":
/*!****************************!*\
  !*** ./modules/replace.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dynamicReplace": () => (/* binding */ dynamicReplace),
/* harmony export */   "dynamicReplaceSingle": () => (/* binding */ dynamicReplaceSingle),
/* harmony export */   "dynamicReplaceMulti": () => (/* binding */ dynamicReplaceMulti)
/* harmony export */ });
// render has an issue with replaceAll causing errors to be thrown which stops the render. This is a pollyfil for all renders
String.prototype.replaceAll = function (str, newStr) {
  // If a regex pattern
  if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
    return this.replace(str, newStr);
  } // If a string


  return this.split(str).join(newStr);
};

function dynamicReplace(selector = null, data = null) {
  if (selector != null && data != null) {
    dynamicReplaceMulti(selector, data);
  } else {
    dynamicReplaceSingle();
  }
}

function dynamicReplaceMulti(target, data) {
  const targets = document.querySelectorAll(target);
  if (targets.length === 0) return;
  targets.forEach(function (target) {
    data.forEach(function (item) {
      const inputValue = item[0];
      const lookup = item[1];

      if (target.innerText.includes(lookup) != -1 && (inputValue != "" || inputValue.length != 0)) {
        target.innerHTML = target.innerHTML.replaceAll(lookup, inputValue); //If found replace
      } else {
        let lookupSpan = "<span class='lookup-value'>".concat(lookup, "</span>"); // console.log(target.innerHTML);

        let temp = target.innerHTML.split(lookupSpan);
        temp = temp.map(x => x.replaceAll(lookup, lookupSpan));
        target.innerHTML = temp.join(lookupSpan);
      }
    });
  });
}

function dynamicReplaceSingle() {
  const elements = document.querySelectorAll("[data-replace-from]");
  if (elements.length === 0) return;
  elements.forEach(el => {
    const text = el.innerText;
    const html = el.innerHTML;
    const lookup = el.dataset.replaceFrom;
    const replace = el.dataset.replaceTo;

    if (text.search(lookup) != -1 && (replace != "" || replace.length != 0)) {
      el.innerHTML = html.replaceAll(lookup, replace);
    }
  });
}



/***/ }),

/***/ "./modules/textFit.js":
/*!****************************!*\
  !*** ./modules/textFit.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ textFit)
/* harmony export */ });
/* harmony import */ var _limiters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limiters.js */ "./modules/limiters.js");

/**
 * textFit v3.1.0
 * Previously known as jQuery.textFit
 * 11/2014 by STRML (strml.github.com)
 * MIT License
 *
 * To use: textFit(document.getElementById('target-div'), options);
 *
 * Will make the *text* content inside a container scale to fit the container
 * The container is required to have a set width and height
 * Uses binary search to fit text with minimal layout calls.
 * Version 2.0 does not use jQuery.
 */

/* global define:true, document:true, window:true, HTMLElement:true*/
// (function (root, factory) {
//   "use strict";
//   // UMD shim
//   if (typeof define === "function" && define.amd) {
//     // AMD
//     define([], factory);
//   } else if (typeof exports === "object") {
//     // Node/CommonJS
//     module.exports = factory();
//   } else {
//     // Browser
//     root.textFit = factory();
//   }
// })(typeof global === "object" ? global : this, function () {
//   "use strict";

var defaultSettings = {
  alignVert: false,
  // if true, textFit will align vertically using css tables
  alignHoriz: false,
  // if true, textFit will set text-align: center
  multiLine: false,
  // if true, textFit will not set white-space: no-wrap
  stopOverflow: false,
  // if true, a error we be thrown if the content is overflowing
  fontUnit: "rem",
  // what unit should the final font be. using rems or mm is sometimes useful
  fontChangeSize: 0.1,
  // how much should the font size by ajusted by each time. 0.1 and 0.01 is useful for when using a rem font unit
  minFontSize: 0.3,
  maxFontSize: 1,
  maxLine: false,
  reProcess: true,
  // if true, textFit will re-process already-fit nodes. Set to 'false' for better performance
  widthOnly: false,
  // if true, textFit will fit text to element width, regardless of text height
  alignVertWithFlexbox: false,
  // if true, textFit will use flexbox for vertical alignment
  display: "inline-block" // in case you need to change this

};
function textFit(els, options) {
  if (!options) options = {}; // Extend options.

  var settings = {};

  for (var key in defaultSettings) {
    if (options.hasOwnProperty(key)) {
      settings[key] = options[key];
    } else {
      settings[key] = defaultSettings[key];
    }
  } // Convert jQuery objects into arrays


  if (typeof els.toArray === "function") {
    els = els.toArray();
  } // Support passing a single el


  var elType = Object.prototype.toString.call(els);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    els = [els];
  } // Process each el we've passed.


  for (var i = 0; i < els.length; i++) {
    try {
      processItem(els[i], settings);
    } catch (e) {
      throw e;
    }
  }
}
;
/**
 * The meat. Given an el, make the text inside it fit its parent.
 * @param  {DOMElement} el       Child el.
 * @param  {Object} settings     Options for fit.
 */

function processItem(el, settings) {
  if (!isElement(el) || !settings.reProcess && el.getAttribute("textFitted")) {
    return false;
  } // Set textFitted attribute so we know this was processed.


  if (!settings.reProcess) {
    el.setAttribute("textFitted", 1);
  }

  var innerSpan, originalHeight, originalHTML, originalWidth;
  var low, mid, high; // Get element data.

  originalHTML = el.innerHTML;
  originalWidth = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(el);
  originalHeight = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(el); // Don't process if we can't find box dimensions

  if (!originalWidth || !settings.widthOnly && !originalHeight) {
    if (!settings.widthOnly) throw new Error("Set a height and width on the target element " + el.outerHTML + " before using textFit!");else throw new Error("Set a width on the target element " + el.outerHTML + " before using textFit!");
  }

  let textFittedSpan = el.querySelector("span.textFitted"); // Add textFitted span inside this container.

  if (!textFittedSpan) {
    innerSpan = document.createElement("span");
    innerSpan.className = "textFitted"; // Inline block ensure it takes on the size of its contents, even if they are enclosed
    // in other tags like <p>

    innerSpan.style["display"] = settings.display;
    innerSpan.innerHTML = originalHTML;
    el.innerHTML = "";
    el.appendChild(innerSpan);
  } else {
    // Reprocessing.
    innerSpan = textFittedSpan; // Remove vertical align if we're reprocessing.

    if (innerSpan.classList.contains("textFitAlignVert")) {
      innerSpan.className = innerSpan.className.replace("textFitAlignVert", "");
      innerSpan.style["height"] = "";
      el.className.replace("textFitAlignVertFlex", "");
    }
  } // Prepare & set alignment


  if (settings.alignHoriz) {
    el.style["text-align"] = "center";
    innerSpan.style["text-align"] = "center";
  }

  var maxLine = parseInt(el.dataset.maxLine || settings.maxLine);
  console.log(maxLine, 'maxline');
  var startingSize = innerSpan.style.fontSize;
  low = settings.minFontSize;
  high = settings.maxFontSize; // Binary search for highest best fit

  var size = low;

  while (low <= high) {
    mid = parseFloat(((high + low) / 2).toFixed(2));
    innerSpan.style.fontSize = mid + settings.fontUnit;
    var scrollWidth = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(innerSpan) <= originalWidth;
    var scrollHeight = settings.widthOnly || (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(innerSpan) <= originalHeight; // check if too many lines and if it is then we need to adjust the font size accordingly

    var maxLines = false;

    if (Number.isInteger(maxLine)) {
      var lineCount = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.countLines)(innerSpan);
      maxLines = lineCount > maxLine;
    }

    if (scrollWidth && scrollHeight && !maxLines) {
      size = mid;
      low = mid + settings.fontChangeSize;
    } else {
      high = mid - settings.fontChangeSize;
    } // await injection point

  }

  if (startingSize !== size + settings.fontUnit) {
    console.log("textFit font changed to:", size + settings.fontUnit);
  } // updating font if differs:


  if (innerSpan.style.fontSize != size + settings.fontUnit) innerSpan.style.fontSize = size + settings.fontUnit; // add the required CSS in order to stop overflows

  if (Number.isInteger(maxLine) || settings.stopOverflow) {
    // if (!document.getElementById("overflowStyleSheet")) {
    //   var style = [".overflow > span {", "overflow: hidden;", "}"].join("");
    //   var css = document.createElement("style");
    //   css.type = "text/css";
    //   css.id = "overflowStyleSheet";
    //   css.innerHTML = style;
    //   document.body.appendChild(css);
    // }
    // detect if data max lines has been exceeded
    if (Number.isInteger(maxLine)) {
      el.classList.remove("overflow");
      delete el.dataset.customOverflowMessage;
      var lineCount = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.countLines)(innerSpan);
      el.dataset.lineCount = lineCount;

      if (lineCount > maxLine) {
        // el.dataset.customOverflowMessage = "Too much content has been added for the allowed space";
        el.classList.add("overflow");
      }
    } // detect if the content is larger than it's parent


    if (settings.stopOverflow) {
      var overflow = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(el) < (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(innerSpan);

      if (overflow) {
        el.classList.add("overflow");
      }
    }
  } // Our height is finalized. If we are aligning vertically, set that up.


  if (settings.alignVert) {
    // addStyleSheet();
    var height = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(innerSpan);

    if (window.getComputedStyle(el)["position"] === "static") {
      el.style["position"] = "relative";
    }

    if (!innerSpan.classList.contains("textFitAlignVert")) {
      innerSpan.className = innerSpan.className + " textFitAlignVert";
    }

    innerSpan.style["height"] = height + "px";

    if (settings.alignVertWithFlexbox && !el.classList.contains("textFitAlignVertFlex")) {
      el.className = el.className + " textFitAlignVertFlex";
    }
  }
} // Returns true if it is a DOM element


function isElement(o) {
  return typeof HTMLElement === "object" ? o instanceof HTMLElement //DOM2
  : o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
}

/***/ }),

/***/ "./modules/utilities.js":
/*!******************************!*\
  !*** ./modules/utilities.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultsRemoved": () => (/* binding */ defaultsRemoved),
/* harmony export */   "loadLESS": () => (/* binding */ loadLESS),
/* harmony export */   "winLoad": () => (/* binding */ winLoad),
/* harmony export */   "domReady": () => (/* binding */ domReady),
/* harmony export */   "highestZ": () => (/* binding */ highestZ),
/* harmony export */   "setBrowserType": () => (/* binding */ setBrowserType),
/* harmony export */   "setSize": () => (/* binding */ setSize),
/* harmony export */   "fontsLoaded": () => (/* binding */ fontsLoaded),
/* harmony export */   "addCrop": () => (/* binding */ addCrop),
/* harmony export */   "setOutfitState": () => (/* binding */ setOutfitState)
/* harmony export */ });
/* harmony import */ var _fontfaceobserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fontfaceobserver.js */ "./modules/fontfaceobserver.js");


const defaultsRemoved = () => {
  // ensure that the user has changed important tempalte metadata
  return new Promise((resolve, reject) => {
    if (!document.querySelector('link[href$="main.css"]')) {
      console.log("%c Please include main.css in order to ensure that export is correct", 'background: #E41E46; color: white');
    }

    if (document.querySelector("style:not([data-href]):not(.injectedStyle):not(#mceDefaultStyles):not(#mceStyles):not([id^=less])")) {
      console.log("%c It is best practice not use styles in the html document. Please move all the styles to an extenal styles.css or styles.less file for constancy", 'background: #E41E46; color: white');
    }

    let title = document.title;

    if (title === "" || title === "PUT_TEMPLATE_NAME_HERE") {
      reject("Please put the name of the template in the title of the document");
    }

    let builtBy = document.querySelector('meta[name="template-built-by"]').getAttribute("content");

    if (builtBy === "" || builtBy === "PUT_YOUR_NAME_HERE") {
      reject("Please add your name in the document meta tags");
    }

    let scopeCard = document.querySelector('meta[name="scope"]').getAttribute("content");

    if (scopeCard === "" || scopeCard === "DTB-PUT_JIRA_NUMBER_HERE") {
      reject("Please add the scope card ID in the document meta tags");
    }

    let builtCard = document.querySelector('meta[name="build"]').getAttribute("content");

    if (builtCard === "" || builtCard === "DTB-PUT_JIRA_NUMBER_HERE") {
      reject("Please add the build card ID in the document meta tags");
    }

    if ([...document.head.childNodes].some(node => {
      if (node && node.data && node.nodeType === 8) {
        return node.data.includes("Template Admin Build Instructions");
      }
    })) {
      reject('Please remove the "Template Admin Build Instructions" comment from the top of the document');
    }

    resolve();
  });
};

const setOutfitState = trimMarks => {
  var mode = window.location.href.indexOf("exports") > -1 ? "export" : false;
  mode = !mode && window.location.href.indexOf("templates") > -1 ? "template" : mode;
  mode = !mode && window.location.href.indexOf("projects") > -1 ? "document" : mode;
  mode = !mode && window.location.href.indexOf("preview") > -1 ? "preview" : mode;
  mode = !mode && window.location.href.indexOf("localhost") > -1 ? "local" : mode;

  if (!mode) {
    mode = "error";
  }

  document.body.setAttribute("document-state", mode);
  document.body.setAttribute("data-trim", trimMarks);
  window.state = mode;
  return mode;
}; // display a message to block rendering for major issues


const blockRender = v => {
  document.querySelector("body").innerHTML = "\n    <style>.ujmju { position: absolute; background: #111820; color: white; font-family: sans-serif; font-size: 0.5rem; z-index: ".concat(highestZ(), "; height: 100%; width: 100%;}  .rsdie { margin: 1rem; width: 80%!important; } .rsdie p { font-size: 0.4rem; } </style>\n    <div class=\"ujmju\">\n      <div class=\"rsdie\">\n        <h2>\u26A0\uFE0F Rendering error detected</h2>\n        <h4>\u26A0Please enable <code>{ allowLegacyRendering: true }</code>\n        in the boilerplate or update this template to version 1.1 or 2.1</h4>\n        <p>This template is using renderer ").concat(v, "</p>\n        <p>Please contact support if you see this message.</p>\n      </div>\n    </div>");
}; // There is an error on render 2 where an extra pixel is added to the end of a template
// this casues a new page to be made. This fuction removes that extra pixel


const pageHeightSetup = (trimMarks, allowLegacyRendering) => {
  let agent = navigator.userAgent;

  if (agent.includes("OPTION 2.1")) {
    console.info("Renderer 2.1 Set");

    if (!trimMarks) {
      return "calc(100vh - 1px)";
    }

    return "100vh";
  } else if (agent.includes("OPTION 1.1")) {
    console.info("Renderer 1.1 Set");
    return "100vh";
  } else if (agent.includes("OPTION 1.0")) {
    if (!allowLegacyRendering) {
      blockRender("1.0");
    }

    return "100vh";
  } else if (agent.includes("OPTION 2.0")) {
    if (!allowLegacyRendering) {
      blockRender("2.0");
    }

    if (!trimMarks) {
      return "calc(100vh - 1px)";
    }

    return "100vh";
  } else {
    // console.error("Renderer Not Set");
    return "100vh";
  }
}; // Fix for the resizable background images - fullscreen and digital vairaitons only


const addCrop = (trimMarks, allowLegacyRendering) => {
  // crop and bleed
  var cropSVG = "<svg class=\"crop-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 21.6 21.6\" xmlns:v=\"https://vecta.io/nano\"><path d=\"M21 15V0m-6 21H0\" fill=\"none\" stroke=\"#000\" stroke-width=\"0.25\" stroke-miterlimit=\"10.0131\"/></svg>";
  let pageHeight = pageHeightSetup(trimMarks, allowLegacyRendering);
  document.querySelectorAll(".page").forEach(page => {
    page.style.height = pageHeight;

    if (trimMarks) {
      page.insertAdjacentHTML("afterbegin", "<div class=\"crop-marks\">\n  <div class=\"crop-mark top-left\">".concat(cropSVG, "</div>\n  <div class=\"crop-mark top-right\">").concat(cropSVG, "</div>\n  <div class=\"crop-mark bottom-left\">").concat(cropSVG, "</div>\n  <div class=\"crop-mark bottom-right\">").concat(cropSVG, "</div>\n  </div>"));
    }
  });
  Array.prototype.slice.call(document.querySelectorAll(".bleed")).forEach(bleed => {
    bleed.style.cssText = trimMarks ? "position: absolute; top: 4.41mm; right: 4.41mm; bottom: 4.41mm; left: 4.41mm;" : "position: absolute; top: -3mm; right: -3mm; bottom: -3mm; left: -3mm";
  });

  if (!trimMarks) {
    document.querySelectorAll(".outfit-resizable-background").forEach(el => {
      el.parentNode.style.left = "0";
      el.parentNode.style.right = "0";
      el.parentNode.style.top = "0";
      el.parentNode.style.bottom = "0";
      el.parentNode.style.width = "100%";
      el.parentNode.style.height = "100%";
    });
  }

  return pageHeight;
};

const fontsLoaded = fontsListed => {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(fontsListed)) {
      fontsListed = [fontsListed];
    }

    if (!fontsListed || fontsListed && fontsListed.length < 1 || fontsListed[0] === "PUT_ALL_FONT_NAMES_HERE") {
      reject("No fonts were put in the boilerplate config. For example { fonts: ['IBM Plex Sans'] }");
    } else {
      Promise.all(fontsListed.map(font => {
        return new _fontfaceobserver_js__WEBPACK_IMPORTED_MODULE_0__.default(font).load();
      })).then(el => {
        resolve(el);
      }).catch(reject);
    }
  });
};

const setSize = (trimMarks, exportReduceFont) => {
  const vw = (trimMarks ? window.innerWidth : window.innerWidth + 57.62) / 100;
  const vh = (trimMarks ? window.innerHeight : window.innerHeight + 57.62) / 100;
  const vmin = Math.min(vw, vh);
  const vmax = Math.max(vw, vh); // Saving the preliminary font size calculation

  const preliminaryCalc = vmin * 2 + vmax * 1.4 + vh * 2; // Reducing the preliminaryCalc value by reduceVal in export mode and in Firefox preview mode

  const finalCalc = window.state === "exports" ? preliminaryCalc - exportReduceFont / 100 * preliminaryCalc : preliminaryCalc;
  document.documentElement.style.fontSize = "".concat(finalCalc, "px");
  return finalCalc;
};

const setBrowserType = () => {
  let browser = {
    // Opera 8.0+
    isOpera: !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0,
    // Firefox 1.0+
    isFirefox: typeof InstallTrigger !== "undefined",
    // Safari 3.0+ "[object HTMLElementConstructor]"
    isSafari: /constructor/i.test(window.HTMLElement) || function (p) {
      return p.toString() === "[object SafariRemoteNotification]";
    }(!window["safari"] || typeof safari !== "undefined" && window["safari"].pushNotification),
    // Internet Explorer 6-11
    isIE:
    /*@cc_on!@*/
     false || !!document.documentMode,
    // Chrome 1 - 79
    isChrome: !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime),
    // mac detection
    isMac: window.navigator.appVersion.includes("Mac")
  }; //  Edge 20+

  browser["isEdge"] = !browser.isIE && !!window.StyleMedia; // Edge (based on chromium) detection

  browser["isEdgeChromium"] = browser.isChrome && navigator.userAgent.indexOf("Edg") != -1; // Blink engine detection

  browser["isBlink"] = (browser.isChrome || browser.isOpera) && !!window.CSS;
  Object.keys(browser).filter(key => {
    return browser[key];
  }).forEach(el => document.body.classList.add(el));
  window.browser = browser;
  return browser;
};

const highestZ = () => {
  return Array.from(document.querySelectorAll("body *")).map(a => parseFloat(window.getComputedStyle(a).zIndex)).filter(a => !isNaN(a)).sort().pop() + 1;
}; // wait for the dom to laod or continue if it has already loaded


const domReady = new Promise((resolve, reject) => {
  if (document.readyState === "complete" || document.readyState === "loaded" || document.readyState === "interactive") {
    resolve();
  } else {
    window.addEventListener("DOMContentLoaded", resolve);
    window.addEventListener("error", reject);
  }
}); // wait for the window to laod or continue if it has already loaded

const winLoad = new Promise((resolve, reject) => {
  if (document.readyState === "complete") {
    resolve();
  } else {
    window.addEventListener("load", resolve);
    window.addEventListener("error", reject);
  }
});

const loadLESS = (variables = {}) => {
  return new Promise(async (resolve, reject) => {
    try {
      if (document.querySelector('[type="text/less"]') !== null) {
        __webpack_require__(/*! less */ "./node_modules/less/dist/less.js");

        document.querySelectorAll('style[media=""][data-href$=".less"]:not([href])').forEach(e => e.remove());
      }

      resolve();
    } catch (e) {
      reject(e);
    }
  });
};



/***/ }),

/***/ "./node_modules/less/dist/less.js":
/*!****************************************!*\
  !*** ./node_modules/less/dist/less.js ***!
  \****************************************/
/***/ (function(module) {

/**
 * Less - Leaner CSS v4.1.1
 * http://lesscss.org
 * 
 * Copyright (c) 2009-2021, Alexis Sellier <self@cloudhead.net>
 * Licensed under the Apache-2.0 License.
 *
 * @license Apache-2.0
 */

(function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () { 'use strict';

    // Export a new default each time
    function defaultOptions () {
        return {
            /* Inline Javascript - @plugin still allowed */
            javascriptEnabled: false,
            /* Outputs a makefile import dependency list to stdout. */
            depends: false,
            /* (DEPRECATED) Compress using less built-in compression.
             * This does an okay job but does not utilise all the tricks of
             * dedicated css compression. */
            compress: false,
            /* Runs the less parser and just reports errors without any output. */
            lint: false,
            /* Sets available include paths.
             * If the file in an @import rule does not exist at that exact location,
             * less will look for it at the location(s) passed to this option.
             * You might use this for instance to specify a path to a library which
             * you want to be referenced simply and relatively in the less files. */
            paths: [],
            /* color output in the terminal */
            color: true,
            /* The strictImports controls whether the compiler will allow an @import inside of either
             * @media blocks or (a later addition) other selector blocks.
             * See: https://github.com/less/less.js/issues/656 */
            strictImports: false,
            /* Allow Imports from Insecure HTTPS Hosts */
            insecure: false,
            /* Allows you to add a path to every generated import and url in your css.
             * This does not affect less import statements that are processed, just ones
             * that are left in the output css. */
            rootpath: '',
            /* By default URLs are kept as-is, so if you import a file in a sub-directory
             * that references an image, exactly the same URL will be output in the css.
             * This option allows you to re-write URL's in imported files so that the
             * URL is always relative to the base imported file */
            rewriteUrls: false,
            /* How to process math
             *   0 always           - eagerly try to solve all operations
             *   1 parens-division  - require parens for division "/"
             *   2 parens | strict  - require parens for all operations
             *   3 strict-legacy    - legacy strict behavior (super-strict)
             */
            math: 1,
            /* Without this option, less attempts to guess at the output unit when it does maths. */
            strictUnits: false,
            /* Effectively the declaration is put at the top of your base Less file,
             * meaning it can be used but it also can be overridden if this variable
             * is defined in the file. */
            globalVars: null,
            /* As opposed to the global variable option, this puts the declaration at the
             * end of your base file, meaning it will override anything defined in your Less file. */
            modifyVars: null,
            /* This option allows you to specify a argument to go on to every URL.  */
            urlArgs: ''
        };
    }

    function extractId(href) {
        return href.replace(/^[a-z-]+:\/+?[^\/]+/, '') // Remove protocol & domain
            .replace(/[\?\&]livereload=\w+/, '') // Remove LiveReload cachebuster
            .replace(/^\//, '') // Remove root /
            .replace(/\.[a-zA-Z]+$/, '') // Remove simple extension
            .replace(/[^\.\w-]+/g, '-') // Replace illegal characters
            .replace(/\./g, ':'); // Replace dots with colons(for valid id)
    }
    function addDataAttr(options, tag) {
        for (var opt in tag.dataset) {
            if (tag.dataset.hasOwnProperty(opt)) {
                if (opt === 'env' || opt === 'dumpLineNumbers' || opt === 'rootpath' || opt === 'errorReporting') {
                    options[opt] = tag.dataset[opt];
                }
                else {
                    try {
                        options[opt] = JSON.parse(tag.dataset[opt]);
                    }
                    catch (_) { }
                }
            }
        }
    }

    var browser = {
        createCSS: function (document, styles, sheet) {
            // Strip the query-string
            var href = sheet.href || '';
            // If there is no title set, use the filename, minus the extension
            var id = "less:" + (sheet.title || extractId(href));
            // If this has already been inserted into the DOM, we may need to replace it
            var oldStyleNode = document.getElementById(id);
            var keepOldStyleNode = false;
            // Create a new stylesheet node for insertion or (if necessary) replacement
            var styleNode = document.createElement('style');
            styleNode.setAttribute('type', 'text/css');
            if (sheet.media) {
                styleNode.setAttribute('media', sheet.media);
            }
            styleNode.id = id;
            if (!styleNode.styleSheet) {
                styleNode.appendChild(document.createTextNode(styles));
                // If new contents match contents of oldStyleNode, don't replace oldStyleNode
                keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&
                    oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);
            }
            var head = document.getElementsByTagName('head')[0];
            // If there is no oldStyleNode, just append; otherwise, only append if we need
            // to replace oldStyleNode with an updated stylesheet
            if (oldStyleNode === null || keepOldStyleNode === false) {
                var nextEl = sheet && sheet.nextSibling || null;
                if (nextEl) {
                    nextEl.parentNode.insertBefore(styleNode, nextEl);
                }
                else {
                    head.appendChild(styleNode);
                }
            }
            if (oldStyleNode && keepOldStyleNode === false) {
                oldStyleNode.parentNode.removeChild(oldStyleNode);
            }
            // For IE.
            // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.
            // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head
            if (styleNode.styleSheet) {
                try {
                    styleNode.styleSheet.cssText = styles;
                }
                catch (e) {
                    throw new Error('Couldn\'t reassign styleSheet.cssText.');
                }
            }
        },
        currentScript: function (window) {
            var document = window.document;
            return document.currentScript || (function () {
                var scripts = document.getElementsByTagName('script');
                return scripts[scripts.length - 1];
            })();
        }
    };

    var addDefaultOptions = (function (window, options) {
        // use options from the current script tag data attribues
        addDataAttr(options, browser.currentScript(window));
        if (options.isFileProtocol === undefined) {
            options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);
        }
        // Load styles asynchronously (default: false)
        //
        // This is set to `false` by default, so that the body
        // doesn't start loading before the stylesheets are parsed.
        // Setting this to `true` can result in flickering.
        //
        options.async = options.async || false;
        options.fileAsync = options.fileAsync || false;
        // Interval between watch polls
        options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);
        options.env = options.env || (window.location.hostname == '127.0.0.1' ||
            window.location.hostname == '0.0.0.0' ||
            window.location.hostname == 'localhost' ||
            (window.location.port &&
                window.location.port.length > 0) ||
            options.isFileProtocol ? 'development'
            : 'production');
        var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);
        if (dumpLineNumbers) {
            options.dumpLineNumbers = dumpLineNumbers[1];
        }
        if (options.useFileCache === undefined) {
            options.useFileCache = true;
        }
        if (options.onReady === undefined) {
            options.onReady = true;
        }
        if (options.relativeUrls) {
            options.rewriteUrls = 'all';
        }
    });

    var logger = {
        error: function (msg) {
            this._fireEvent('error', msg);
        },
        warn: function (msg) {
            this._fireEvent('warn', msg);
        },
        info: function (msg) {
            this._fireEvent('info', msg);
        },
        debug: function (msg) {
            this._fireEvent('debug', msg);
        },
        addListener: function (listener) {
            this._listeners.push(listener);
        },
        removeListener: function (listener) {
            for (var i = 0; i < this._listeners.length; i++) {
                if (this._listeners[i] === listener) {
                    this._listeners.splice(i, 1);
                    return;
                }
            }
        },
        _fireEvent: function (type, msg) {
            for (var i = 0; i < this._listeners.length; i++) {
                var logFunction = this._listeners[i][type];
                if (logFunction) {
                    logFunction(msg);
                }
            }
        },
        _listeners: []
    };

    /**
     * @todo Document why this abstraction exists, and the relationship between
     *       environment, file managers, and plugin manager
     */
    var Environment = /** @class */ (function () {
        function Environment(externalEnvironment, fileManagers) {
            this.fileManagers = fileManagers || [];
            externalEnvironment = externalEnvironment || {};
            var optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];
            var requiredFunctions = [];
            var functions = requiredFunctions.concat(optionalFunctions);
            for (var i = 0; i < functions.length; i++) {
                var propName = functions[i];
                var environmentFunc = externalEnvironment[propName];
                if (environmentFunc) {
                    this[propName] = environmentFunc.bind(externalEnvironment);
                }
                else if (i < requiredFunctions.length) {
                    this.warn("missing required function in environment - " + propName);
                }
            }
        }
        Environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {
            if (!filename) {
                logger.warn('getFileManager called with no filename.. Please report this issue. continuing.');
            }
            if (currentDirectory == null) {
                logger.warn('getFileManager called with null directory.. Please report this issue. continuing.');
            }
            var fileManagers = this.fileManagers;
            if (options.pluginManager) {
                fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());
            }
            for (var i = fileManagers.length - 1; i >= 0; i--) {
                var fileManager = fileManagers[i];
                if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {
                    return fileManager;
                }
            }
            return null;
        };
        Environment.prototype.addFileManager = function (fileManager) {
            this.fileManagers.push(fileManager);
        };
        Environment.prototype.clearFileManagers = function () {
            this.fileManagers = [];
        };
        return Environment;
    }());

    var colors = {
        'aliceblue': '#f0f8ff',
        'antiquewhite': '#faebd7',
        'aqua': '#00ffff',
        'aquamarine': '#7fffd4',
        'azure': '#f0ffff',
        'beige': '#f5f5dc',
        'bisque': '#ffe4c4',
        'black': '#000000',
        'blanchedalmond': '#ffebcd',
        'blue': '#0000ff',
        'blueviolet': '#8a2be2',
        'brown': '#a52a2a',
        'burlywood': '#deb887',
        'cadetblue': '#5f9ea0',
        'chartreuse': '#7fff00',
        'chocolate': '#d2691e',
        'coral': '#ff7f50',
        'cornflowerblue': '#6495ed',
        'cornsilk': '#fff8dc',
        'crimson': '#dc143c',
        'cyan': '#00ffff',
        'darkblue': '#00008b',
        'darkcyan': '#008b8b',
        'darkgoldenrod': '#b8860b',
        'darkgray': '#a9a9a9',
        'darkgrey': '#a9a9a9',
        'darkgreen': '#006400',
        'darkkhaki': '#bdb76b',
        'darkmagenta': '#8b008b',
        'darkolivegreen': '#556b2f',
        'darkorange': '#ff8c00',
        'darkorchid': '#9932cc',
        'darkred': '#8b0000',
        'darksalmon': '#e9967a',
        'darkseagreen': '#8fbc8f',
        'darkslateblue': '#483d8b',
        'darkslategray': '#2f4f4f',
        'darkslategrey': '#2f4f4f',
        'darkturquoise': '#00ced1',
        'darkviolet': '#9400d3',
        'deeppink': '#ff1493',
        'deepskyblue': '#00bfff',
        'dimgray': '#696969',
        'dimgrey': '#696969',
        'dodgerblue': '#1e90ff',
        'firebrick': '#b22222',
        'floralwhite': '#fffaf0',
        'forestgreen': '#228b22',
        'fuchsia': '#ff00ff',
        'gainsboro': '#dcdcdc',
        'ghostwhite': '#f8f8ff',
        'gold': '#ffd700',
        'goldenrod': '#daa520',
        'gray': '#808080',
        'grey': '#808080',
        'green': '#008000',
        'greenyellow': '#adff2f',
        'honeydew': '#f0fff0',
        'hotpink': '#ff69b4',
        'indianred': '#cd5c5c',
        'indigo': '#4b0082',
        'ivory': '#fffff0',
        'khaki': '#f0e68c',
        'lavender': '#e6e6fa',
        'lavenderblush': '#fff0f5',
        'lawngreen': '#7cfc00',
        'lemonchiffon': '#fffacd',
        'lightblue': '#add8e6',
        'lightcoral': '#f08080',
        'lightcyan': '#e0ffff',
        'lightgoldenrodyellow': '#fafad2',
        'lightgray': '#d3d3d3',
        'lightgrey': '#d3d3d3',
        'lightgreen': '#90ee90',
        'lightpink': '#ffb6c1',
        'lightsalmon': '#ffa07a',
        'lightseagreen': '#20b2aa',
        'lightskyblue': '#87cefa',
        'lightslategray': '#778899',
        'lightslategrey': '#778899',
        'lightsteelblue': '#b0c4de',
        'lightyellow': '#ffffe0',
        'lime': '#00ff00',
        'limegreen': '#32cd32',
        'linen': '#faf0e6',
        'magenta': '#ff00ff',
        'maroon': '#800000',
        'mediumaquamarine': '#66cdaa',
        'mediumblue': '#0000cd',
        'mediumorchid': '#ba55d3',
        'mediumpurple': '#9370d8',
        'mediumseagreen': '#3cb371',
        'mediumslateblue': '#7b68ee',
        'mediumspringgreen': '#00fa9a',
        'mediumturquoise': '#48d1cc',
        'mediumvioletred': '#c71585',
        'midnightblue': '#191970',
        'mintcream': '#f5fffa',
        'mistyrose': '#ffe4e1',
        'moccasin': '#ffe4b5',
        'navajowhite': '#ffdead',
        'navy': '#000080',
        'oldlace': '#fdf5e6',
        'olive': '#808000',
        'olivedrab': '#6b8e23',
        'orange': '#ffa500',
        'orangered': '#ff4500',
        'orchid': '#da70d6',
        'palegoldenrod': '#eee8aa',
        'palegreen': '#98fb98',
        'paleturquoise': '#afeeee',
        'palevioletred': '#d87093',
        'papayawhip': '#ffefd5',
        'peachpuff': '#ffdab9',
        'peru': '#cd853f',
        'pink': '#ffc0cb',
        'plum': '#dda0dd',
        'powderblue': '#b0e0e6',
        'purple': '#800080',
        'rebeccapurple': '#663399',
        'red': '#ff0000',
        'rosybrown': '#bc8f8f',
        'royalblue': '#4169e1',
        'saddlebrown': '#8b4513',
        'salmon': '#fa8072',
        'sandybrown': '#f4a460',
        'seagreen': '#2e8b57',
        'seashell': '#fff5ee',
        'sienna': '#a0522d',
        'silver': '#c0c0c0',
        'skyblue': '#87ceeb',
        'slateblue': '#6a5acd',
        'slategray': '#708090',
        'slategrey': '#708090',
        'snow': '#fffafa',
        'springgreen': '#00ff7f',
        'steelblue': '#4682b4',
        'tan': '#d2b48c',
        'teal': '#008080',
        'thistle': '#d8bfd8',
        'tomato': '#ff6347',
        'turquoise': '#40e0d0',
        'violet': '#ee82ee',
        'wheat': '#f5deb3',
        'white': '#ffffff',
        'whitesmoke': '#f5f5f5',
        'yellow': '#ffff00',
        'yellowgreen': '#9acd32'
    };

    var unitConversions = {
        length: {
            'm': 1,
            'cm': 0.01,
            'mm': 0.001,
            'in': 0.0254,
            'px': 0.0254 / 96,
            'pt': 0.0254 / 72,
            'pc': 0.0254 / 72 * 12
        },
        duration: {
            's': 1,
            'ms': 0.001
        },
        angle: {
            'rad': 1 / (2 * Math.PI),
            'deg': 1 / 360,
            'grad': 1 / 400,
            'turn': 1
        }
    };

    var data = { colors: colors, unitConversions: unitConversions };

    /**
     * The reason why Node is a class and other nodes simply do not extend
     * from Node (since we're transpiling) is due to this issue:
     *
     * https://github.com/less/less.js/issues/3434
     */
    var Node = /** @class */ (function () {
        function Node() {
            this.parent = null;
            this.visibilityBlocks = undefined;
            this.nodeVisible = undefined;
            this.rootNode = null;
            this.parsed = null;
            var self = this;
            Object.defineProperty(this, 'currentFileInfo', {
                get: function () { return self.fileInfo(); }
            });
            Object.defineProperty(this, 'index', {
                get: function () { return self.getIndex(); }
            });
        }
        Node.prototype.setParent = function (nodes, parent) {
            function set(node) {
                if (node && node instanceof Node) {
                    node.parent = parent;
                }
            }
            if (Array.isArray(nodes)) {
                nodes.forEach(set);
            }
            else {
                set(nodes);
            }
        };
        Node.prototype.getIndex = function () {
            return this._index || (this.parent && this.parent.getIndex()) || 0;
        };
        Node.prototype.fileInfo = function () {
            return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};
        };
        Node.prototype.isRulesetLike = function () { return false; };
        Node.prototype.toCSS = function (context) {
            var strs = [];
            this.genCSS(context, {
                add: function (chunk, fileInfo, index) {
                    strs.push(chunk);
                },
                isEmpty: function () {
                    return strs.length === 0;
                }
            });
            return strs.join('');
        };
        Node.prototype.genCSS = function (context, output) {
            output.add(this.value);
        };
        Node.prototype.accept = function (visitor) {
            this.value = visitor.visit(this.value);
        };
        Node.prototype.eval = function () { return this; };
        Node.prototype._operate = function (context, op, a, b) {
            switch (op) {
                case '+': return a + b;
                case '-': return a - b;
                case '*': return a * b;
                case '/': return a / b;
            }
        };
        Node.prototype.fround = function (context, value) {
            var precision = context && context.numPrecision;
            // add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:
            return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;
        };
        Node.compare = function (a, b) {
            /* returns:
             -1: a < b
             0: a = b
             1: a > b
             and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */
            if ((a.compare) &&
                // for "symmetric results" force toCSS-based comparison
                // of Quoted or Anonymous if either value is one of those
                !(b.type === 'Quoted' || b.type === 'Anonymous')) {
                return a.compare(b);
            }
            else if (b.compare) {
                return -b.compare(a);
            }
            else if (a.type !== b.type) {
                return undefined;
            }
            a = a.value;
            b = b.value;
            if (!Array.isArray(a)) {
                return a === b ? 0 : undefined;
            }
            if (a.length !== b.length) {
                return undefined;
            }
            for (var i = 0; i < a.length; i++) {
                if (Node.compare(a[i], b[i]) !== 0) {
                    return undefined;
                }
            }
            return 0;
        };
        Node.numericCompare = function (a, b) {
            return a < b ? -1
                : a === b ? 0
                    : a > b ? 1 : undefined;
        };
        // Returns true if this node represents root of ast imported by reference
        Node.prototype.blocksVisibility = function () {
            if (this.visibilityBlocks == null) {
                this.visibilityBlocks = 0;
            }
            return this.visibilityBlocks !== 0;
        };
        Node.prototype.addVisibilityBlock = function () {
            if (this.visibilityBlocks == null) {
                this.visibilityBlocks = 0;
            }
            this.visibilityBlocks = this.visibilityBlocks + 1;
        };
        Node.prototype.removeVisibilityBlock = function () {
            if (this.visibilityBlocks == null) {
                this.visibilityBlocks = 0;
            }
            this.visibilityBlocks = this.visibilityBlocks - 1;
        };
        // Turns on node visibility - if called node will be shown in output regardless
        // of whether it comes from import by reference or not
        Node.prototype.ensureVisibility = function () {
            this.nodeVisible = true;
        };
        // Turns off node visibility - if called node will NOT be shown in output regardless
        // of whether it comes from import by reference or not
        Node.prototype.ensureInvisibility = function () {
            this.nodeVisible = false;
        };
        // return values:
        // false - the node must not be visible
        // true - the node must be visible
        // undefined or null - the node has the same visibility as its parent
        Node.prototype.isVisible = function () {
            return this.nodeVisible;
        };
        Node.prototype.visibilityInfo = function () {
            return {
                visibilityBlocks: this.visibilityBlocks,
                nodeVisible: this.nodeVisible
            };
        };
        Node.prototype.copyVisibilityInfo = function (info) {
            if (!info) {
                return;
            }
            this.visibilityBlocks = info.visibilityBlocks;
            this.nodeVisible = info.nodeVisible;
        };
        return Node;
    }());

    //
    // RGB Colors - #ff0014, #eee
    //
    var Color = function (rgb, a, originalForm) {
        var self = this;
        //
        // The end goal here, is to parse the arguments
        // into an integer triplet, such as `128, 255, 0`
        //
        // This facilitates operations and conversions.
        //
        if (Array.isArray(rgb)) {
            this.rgb = rgb;
        }
        else if (rgb.length >= 6) {
            this.rgb = [];
            rgb.match(/.{2}/g).map(function (c, i) {
                if (i < 3) {
                    self.rgb.push(parseInt(c, 16));
                }
                else {
                    self.alpha = (parseInt(c, 16)) / 255;
                }
            });
        }
        else {
            this.rgb = [];
            rgb.split('').map(function (c, i) {
                if (i < 3) {
                    self.rgb.push(parseInt(c + c, 16));
                }
                else {
                    self.alpha = (parseInt(c + c, 16)) / 255;
                }
            });
        }
        this.alpha = this.alpha || (typeof a === 'number' ? a : 1);
        if (typeof originalForm !== 'undefined') {
            this.value = originalForm;
        }
    };
    Color.prototype = Object.assign(new Node(), {
        type: 'Color',
        luma: function () {
            var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255;
            r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);
            g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);
            b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);
            return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        },
        genCSS: function (context, output) {
            output.add(this.toCSS(context));
        },
        toCSS: function (context, doNotCompress) {
            var compress = context && context.compress && !doNotCompress;
            var color;
            var alpha;
            var colorFunction;
            var args = [];
            // `value` is set if this color was originally
            // converted from a named color string so we need
            // to respect this and try to output named color too.
            alpha = this.fround(context, this.alpha);
            if (this.value) {
                if (this.value.indexOf('rgb') === 0) {
                    if (alpha < 1) {
                        colorFunction = 'rgba';
                    }
                }
                else if (this.value.indexOf('hsl') === 0) {
                    if (alpha < 1) {
                        colorFunction = 'hsla';
                    }
                    else {
                        colorFunction = 'hsl';
                    }
                }
                else {
                    return this.value;
                }
            }
            else {
                if (alpha < 1) {
                    colorFunction = 'rgba';
                }
            }
            switch (colorFunction) {
                case 'rgba':
                    args = this.rgb.map(function (c) {
                        return clamp(Math.round(c), 255);
                    }).concat(clamp(alpha, 1));
                    break;
                case 'hsla':
                    args.push(clamp(alpha, 1));
                case 'hsl':
                    color = this.toHSL();
                    args = [
                        this.fround(context, color.h),
                        this.fround(context, color.s * 100) + "%",
                        this.fround(context, color.l * 100) + "%"
                    ].concat(args);
            }
            if (colorFunction) {
                // Values are capped between `0` and `255`, rounded and zero-padded.
                return colorFunction + "(" + args.join("," + (compress ? '' : ' ')) + ")";
            }
            color = this.toRGB();
            if (compress) {
                var splitcolor = color.split('');
                // Convert color to short format
                if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
                    color = "#" + splitcolor[1] + splitcolor[3] + splitcolor[5];
                }
            }
            return color;
        },
        //
        // Operations have to be done per-channel, if not,
        // channels will spill onto each other. Once we have
        // our result, in the form of an integer triplet,
        // we create a new Color node to hold the result.
        //
        operate: function (context, op, other) {
            var rgb = new Array(3);
            var alpha = this.alpha * (1 - other.alpha) + other.alpha;
            for (var c = 0; c < 3; c++) {
                rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);
            }
            return new Color(rgb, alpha);
        },
        toRGB: function () {
            return toHex(this.rgb);
        },
        toHSL: function () {
            var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255, a = this.alpha;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h;
            var s;
            var l = (max + min) / 2;
            var d = max - min;
            if (max === min) {
                h = s = 0;
            }
            else {
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s, l: l, a: a };
        },
        // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        toHSV: function () {
            var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255, a = this.alpha;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h;
            var s;
            var v = max;
            var d = max - min;
            if (max === 0) {
                s = 0;
            }
            else {
                s = d / max;
            }
            if (max === min) {
                h = 0;
            }
            else {
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s, v: v, a: a };
        },
        toARGB: function () {
            return toHex([this.alpha * 255].concat(this.rgb));
        },
        compare: function (x) {
            return (x.rgb &&
                x.rgb[0] === this.rgb[0] &&
                x.rgb[1] === this.rgb[1] &&
                x.rgb[2] === this.rgb[2] &&
                x.alpha === this.alpha) ? 0 : undefined;
        }
    });
    Color.fromKeyword = function (keyword) {
        var c;
        var key = keyword.toLowerCase();
        if (colors.hasOwnProperty(key)) {
            c = new Color(colors[key].slice(1));
        }
        else if (key === 'transparent') {
            c = new Color([0, 0, 0], 0);
        }
        if (c) {
            c.value = keyword;
            return c;
        }
    };
    function clamp(v, max) {
        return Math.min(Math.max(v, 0), max);
    }
    function toHex(v) {
        return "#" + v.map(function (c) {
            c = clamp(Math.round(c), 255);
            return (c < 16 ? '0' : '') + c.toString(16);
        }).join('');
    }

    var Paren = function (node) {
        this.value = node;
    };
    Paren.prototype = Object.assign(new Node(), {
        type: 'Paren',
        genCSS: function (context, output) {
            output.add('(');
            this.value.genCSS(context, output);
            output.add(')');
        },
        eval: function (context) {
            return new Paren(this.value.eval(context));
        }
    });

    var _noSpaceCombinators = {
        '': true,
        ' ': true,
        '|': true
    };
    var Combinator = function (value) {
        if (value === ' ') {
            this.value = ' ';
            this.emptyOrWhitespace = true;
        }
        else {
            this.value = value ? value.trim() : '';
            this.emptyOrWhitespace = this.value === '';
        }
    };
    Combinator.prototype = Object.assign(new Node(), {
        type: 'Combinator',
        genCSS: function (context, output) {
            var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';
            output.add(spaceOrEmpty + this.value + spaceOrEmpty);
        }
    });

    var Element = function (combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {
        this.combinator = combinator instanceof Combinator ?
            combinator : new Combinator(combinator);
        if (typeof value === 'string') {
            this.value = value.trim();
        }
        else if (value) {
            this.value = value;
        }
        else {
            this.value = '';
        }
        this.isVariable = isVariable;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.copyVisibilityInfo(visibilityInfo);
        this.setParent(this.combinator, this);
    };
    Element.prototype = Object.assign(new Node(), {
        type: 'Element',
        accept: function (visitor) {
            var value = this.value;
            this.combinator = visitor.visit(this.combinator);
            if (typeof value === 'object') {
                this.value = visitor.visit(value);
            }
        },
        eval: function (context) {
            return new Element(this.combinator, this.value.eval ? this.value.eval(context) : this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        clone: function () {
            return new Element(this.combinator, this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        genCSS: function (context, output) {
            output.add(this.toCSS(context), this.fileInfo(), this.getIndex());
        },
        toCSS: function (context) {
            context = context || {};
            var value = this.value;
            var firstSelector = context.firstSelector;
            if (value instanceof Paren) {
                // selector in parens should not be affected by outer selector
                // flags (breaks only interpolated selectors - see #1973)
                context.firstSelector = true;
            }
            value = value.toCSS ? value.toCSS(context) : value;
            context.firstSelector = firstSelector;
            if (value === '' && this.combinator.value.charAt(0) === '&') {
                return '';
            }
            else {
                return this.combinator.toCSS(context) + value;
            }
        }
    });

    var Math$1 = {
        ALWAYS: 0,
        PARENS_DIVISION: 1,
        PARENS: 2
        // removed - STRICT_LEGACY: 3
    };
    var RewriteUrls = {
        OFF: 0,
        LOCAL: 1,
        ALL: 2
    };

    /**
     * Returns the object type of the given payload
     *
     * @param {*} payload
     * @returns {string}
     */
    function getType(payload) {
        return Object.prototype.toString.call(payload).slice(8, -1);
    }
    /**
     * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
     *
     * @param {*} payload
     * @returns {payload is Record<string, any>}
     */
    function isPlainObject(payload) {
        if (getType(payload) !== 'Object')
            return false;
        return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
    }
    /**
     * Returns whether the payload is an array
     *
     * @param {any} payload
     * @returns {payload is any[]}
     */
    function isArray(payload) {
        return getType(payload) === 'Array';
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
        var propType = {}.propertyIsEnumerable.call(originalObject, key)
            ? 'enumerable'
            : 'nonenumerable';
        if (propType === 'enumerable')
            carry[key] = newVal;
        if (includeNonenumerable && propType === 'nonenumerable') {
            Object.defineProperty(carry, key, {
                value: newVal,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
    }
    /**
     * Copy (clone) an object and all its props recursively to get rid of any prop referenced of the original object. Arrays are also cloned, however objects inside arrays are still linked.
     *
     * @export
     * @template T
     * @param {T} target Target can be anything
     * @param {Options} [options={}] Options can be `props` or `nonenumerable`
     * @returns {T} the target with replaced values
     * @export
     */
    function copy(target, options) {
        if (options === void 0) { options = {}; }
        if (isArray(target))
            return target.map(function (i) { return copy(i, options); });
        if (!isPlainObject(target))
            return target;
        var props = Object.getOwnPropertyNames(target);
        var symbols = Object.getOwnPropertySymbols(target);
        return __spreadArrays(props, symbols).reduce(function (carry, key) {
            if (isArray(options.props) && !options.props.includes(key)) {
                return carry;
            }
            var val = target[key];
            var newVal = copy(val, options);
            assignProp(carry, key, newVal, target, options.nonenumerable);
            return carry;
        }, {});
    }

    /* jshint proto: true */
    function getLocation(index, inputStream) {
        var n = index + 1;
        var line = null;
        var column = -1;
        while (--n >= 0 && inputStream.charAt(n) !== '\n') {
            column++;
        }
        if (typeof index === 'number') {
            line = (inputStream.slice(0, index).match(/\n/g) || '').length;
        }
        return {
            line: line,
            column: column
        };
    }
    function copyArray(arr) {
        var i;
        var length = arr.length;
        var copy = new Array(length);
        for (i = 0; i < length; i++) {
            copy[i] = arr[i];
        }
        return copy;
    }
    function clone(obj) {
        var cloned = {};
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                cloned[prop] = obj[prop];
            }
        }
        return cloned;
    }
    function defaults(obj1, obj2) {
        var newObj = obj2 || {};
        if (!obj2._defaults) {
            newObj = {};
            var defaults_1 = copy(obj1);
            newObj._defaults = defaults_1;
            var cloned = obj2 ? copy(obj2) : {};
            Object.assign(newObj, defaults_1, cloned);
        }
        return newObj;
    }
    function copyOptions(obj1, obj2) {
        if (obj2 && obj2._defaults) {
            return obj2;
        }
        var opts = defaults(obj1, obj2);
        if (opts.strictMath) {
            opts.math = Math$1.PARENS;
        }
        // Back compat with changed relativeUrls option
        if (opts.relativeUrls) {
            opts.rewriteUrls = RewriteUrls.ALL;
        }
        if (typeof opts.math === 'string') {
            switch (opts.math.toLowerCase()) {
                case 'always':
                    opts.math = Math$1.ALWAYS;
                    break;
                case 'parens-division':
                    opts.math = Math$1.PARENS_DIVISION;
                    break;
                case 'strict':
                case 'parens':
                    opts.math = Math$1.PARENS;
                    break;
                default:
                    opts.math = Math$1.PARENS;
            }
        }
        if (typeof opts.rewriteUrls === 'string') {
            switch (opts.rewriteUrls.toLowerCase()) {
                case 'off':
                    opts.rewriteUrls = RewriteUrls.OFF;
                    break;
                case 'local':
                    opts.rewriteUrls = RewriteUrls.LOCAL;
                    break;
                case 'all':
                    opts.rewriteUrls = RewriteUrls.ALL;
                    break;
            }
        }
        return opts;
    }
    function merge(obj1, obj2) {
        for (var prop in obj2) {
            if (obj2.hasOwnProperty(prop)) {
                obj1[prop] = obj2[prop];
            }
        }
        return obj1;
    }
    function flattenArray(arr, result) {
        if (result === void 0) { result = []; }
        for (var i = 0, length_1 = arr.length; i < length_1; i++) {
            var value = arr[i];
            if (Array.isArray(value)) {
                flattenArray(value, result);
            }
            else {
                if (value !== undefined) {
                    result.push(value);
                }
            }
        }
        return result;
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getLocation: getLocation,
        copyArray: copyArray,
        clone: clone,
        defaults: defaults,
        copyOptions: copyOptions,
        merge: merge,
        flattenArray: flattenArray
    });

    var anonymousFunc = /(<anonymous>|Function):(\d+):(\d+)/;
    /**
     * This is a centralized class of any error that could be thrown internally (mostly by the parser).
     * Besides standard .message it keeps some additional data like a path to the file where the error
     * occurred along with line and column numbers.
     *
     * @class
     * @extends Error
     * @type {module.LessError}
     *
     * @prop {string} type
     * @prop {string} filename
     * @prop {number} index
     * @prop {number} line
     * @prop {number} column
     * @prop {number} callLine
     * @prop {number} callExtract
     * @prop {string[]} extract
     *
     * @param {Object} e              - An error object to wrap around or just a descriptive object
     * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?
     * @param {string} [currentFilename]
     */
    var LessError = function (e, fileContentMap, currentFilename) {
        Error.call(this);
        var filename = e.filename || currentFilename;
        this.message = e.message;
        this.stack = e.stack;
        if (fileContentMap && filename) {
            var input = fileContentMap.contents[filename];
            var loc = getLocation(e.index, input);
            var line = loc.line;
            var col = loc.column;
            var callLine = e.call && getLocation(e.call, input).line;
            var lines = input ? input.split('\n') : '';
            this.type = e.type || 'Syntax';
            this.filename = filename;
            this.index = e.index;
            this.line = typeof line === 'number' ? line + 1 : null;
            this.column = col;
            if (!this.line && this.stack) {
                var found = this.stack.match(anonymousFunc);
                /**
                 * We have to figure out how this environment stringifies anonymous functions
                 * so we can correctly map plugin errors.
                 *
                 * Note, in Node 8, the output of anonymous funcs varied based on parameters
                 * being present or not, so we inject dummy params.
                 */
                var func = new Function('a', 'throw new Error()');
                var lineAdjust = 0;
                try {
                    func();
                }
                catch (e) {
                    var match = e.stack.match(anonymousFunc);
                    var line = parseInt(match[2]);
                    lineAdjust = 1 - line;
                }
                if (found) {
                    if (found[2]) {
                        this.line = parseInt(found[2]) + lineAdjust;
                    }
                    if (found[3]) {
                        this.column = parseInt(found[3]);
                    }
                }
            }
            this.callLine = callLine + 1;
            this.callExtract = lines[callLine];
            this.extract = [
                lines[this.line - 2],
                lines[this.line - 1],
                lines[this.line]
            ];
        }
    };
    if (typeof Object.create === 'undefined') {
        var F = function () { };
        F.prototype = Error.prototype;
        LessError.prototype = new F();
    }
    else {
        LessError.prototype = Object.create(Error.prototype);
    }
    LessError.prototype.constructor = LessError;
    /**
     * An overridden version of the default Object.prototype.toString
     * which uses additional information to create a helpful message.
     *
     * @param {Object} options
     * @returns {string}
     */
    LessError.prototype.toString = function (options) {
        options = options || {};
        var message = '';
        var extract = this.extract || [];
        var error = [];
        var stylize = function (str) { return str; };
        if (options.stylize) {
            var type = typeof options.stylize;
            if (type !== 'function') {
                throw Error("options.stylize should be a function, got a " + type + "!");
            }
            stylize = options.stylize;
        }
        if (this.line !== null) {
            if (typeof extract[0] === 'string') {
                error.push(stylize(this.line - 1 + " " + extract[0], 'grey'));
            }
            if (typeof extract[1] === 'string') {
                var errorTxt = this.line + " ";
                if (extract[1]) {
                    errorTxt += extract[1].slice(0, this.column) +
                        stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +
                            extract[1].slice(this.column + 1), 'red'), 'inverse');
                }
                error.push(errorTxt);
            }
            if (typeof extract[2] === 'string') {
                error.push(stylize(this.line + 1 + " " + extract[2], 'grey'));
            }
            error = error.join('\n') + stylize('', 'reset') + "\n";
        }
        message += stylize(this.type + "Error: " + this.message, 'red');
        if (this.filename) {
            message += stylize(' in ', 'red') + this.filename;
        }
        if (this.line) {
            message += stylize(" on line " + this.line + ", column " + (this.column + 1) + ":", 'grey');
        }
        message += "\n" + error;
        if (this.callLine) {
            message += stylize('from ', 'red') + (this.filename || '') + "/n";
            message += stylize(this.callLine, 'grey') + " " + this.callExtract + "/n";
        }
        return message;
    };

    var Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {
        this.extendList = extendList;
        this.condition = condition;
        this.evaldCondition = !condition;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.elements = this.getElements(elements);
        this.mixinElements_ = undefined;
        this.copyVisibilityInfo(visibilityInfo);
        this.setParent(this.elements, this);
    };
    Selector.prototype = Object.assign(new Node(), {
        type: 'Selector',
        accept: function (visitor) {
            if (this.elements) {
                this.elements = visitor.visitArray(this.elements);
            }
            if (this.extendList) {
                this.extendList = visitor.visitArray(this.extendList);
            }
            if (this.condition) {
                this.condition = visitor.visit(this.condition);
            }
        },
        createDerived: function (elements, extendList, evaldCondition) {
            elements = this.getElements(elements);
            var newSelector = new Selector(elements, extendList || this.extendList, null, this.getIndex(), this.fileInfo(), this.visibilityInfo());
            newSelector.evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;
            newSelector.mediaEmpty = this.mediaEmpty;
            return newSelector;
        },
        getElements: function (els) {
            if (!els) {
                return [new Element('', '&', false, this._index, this._fileInfo)];
            }
            if (typeof els === 'string') {
                this.parse.parseNode(els, ['selector'], this._index, this._fileInfo, function (err, result) {
                    if (err) {
                        throw new LessError({
                            index: err.index,
                            message: err.message
                        }, this.parse.imports, this._fileInfo.filename);
                    }
                    els = result[0].elements;
                });
            }
            return els;
        },
        createEmptySelectors: function () {
            var el = new Element('', '&', false, this._index, this._fileInfo), sels = [new Selector([el], null, null, this._index, this._fileInfo)];
            sels[0].mediaEmpty = true;
            return sels;
        },
        match: function (other) {
            var elements = this.elements;
            var len = elements.length;
            var olen;
            var i;
            other = other.mixinElements();
            olen = other.length;
            if (olen === 0 || len < olen) {
                return 0;
            }
            else {
                for (i = 0; i < olen; i++) {
                    if (elements[i].value !== other[i]) {
                        return 0;
                    }
                }
            }
            return olen; // return number of matched elements
        },
        mixinElements: function () {
            if (this.mixinElements_) {
                return this.mixinElements_;
            }
            var elements = this.elements.map(function (v) {
                return v.combinator.value + (v.value.value || v.value);
            }).join('').match(/[,&#\*\.\w-]([\w-]|(\\.))*/g);
            if (elements) {
                if (elements[0] === '&') {
                    elements.shift();
                }
            }
            else {
                elements = [];
            }
            return (this.mixinElements_ = elements);
        },
        isJustParentSelector: function () {
            return !this.mediaEmpty &&
                this.elements.length === 1 &&
                this.elements[0].value === '&' &&
                (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');
        },
        eval: function (context) {
            var evaldCondition = this.condition && this.condition.eval(context);
            var elements = this.elements;
            var extendList = this.extendList;
            elements = elements && elements.map(function (e) { return e.eval(context); });
            extendList = extendList && extendList.map(function (extend) { return extend.eval(context); });
            return this.createDerived(elements, extendList, evaldCondition);
        },
        genCSS: function (context, output) {
            var i, element;
            if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {
                output.add(' ', this.fileInfo(), this.getIndex());
            }
            for (i = 0; i < this.elements.length; i++) {
                element = this.elements[i];
                element.genCSS(context, output);
            }
        },
        getIsOutput: function () {
            return this.evaldCondition;
        }
    });

    var Value = function (value) {
        if (!value) {
            throw new Error('Value requires an array argument');
        }
        if (!Array.isArray(value)) {
            this.value = [value];
        }
        else {
            this.value = value;
        }
    };
    Value.prototype = Object.assign(new Node(), {
        type: 'Value',
        accept: function (visitor) {
            if (this.value) {
                this.value = visitor.visitArray(this.value);
            }
        },
        eval: function (context) {
            if (this.value.length === 1) {
                return this.value[0].eval(context);
            }
            else {
                return new Value(this.value.map(function (v) {
                    return v.eval(context);
                }));
            }
        },
        genCSS: function (context, output) {
            var i;
            for (i = 0; i < this.value.length; i++) {
                this.value[i].genCSS(context, output);
                if (i + 1 < this.value.length) {
                    output.add((context && context.compress) ? ',' : ', ');
                }
            }
        }
    });

    var Keyword = function (value) {
        this.value = value;
    };
    Keyword.prototype = Object.assign(new Node(), {
        type: 'Keyword',
        genCSS: function (context, output) {
            if (this.value === '%') {
                throw { type: 'Syntax', message: 'Invalid % without number' };
            }
            output.add(this.value);
        }
    });
    Keyword.True = new Keyword('true');
    Keyword.False = new Keyword('false');

    var Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
        this.value = value;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.mapLines = mapLines;
        this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;
        this.allowRoot = true;
        this.copyVisibilityInfo(visibilityInfo);
    };
    Anonymous.prototype = Object.assign(new Node(), {
        type: 'Anonymous',
        eval: function () {
            return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
        },
        compare: function (other) {
            return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
        },
        isRulesetLike: function () {
            return this.rulesetLike;
        },
        genCSS: function (context, output) {
            this.nodeVisible = Boolean(this.value);
            if (this.nodeVisible) {
                output.add(this.value, this._fileInfo, this._index, this.mapLines);
            }
        }
    });

    var MATH = Math$1;
    function evalName(context, name) {
        var value = '';
        var i;
        var n = name.length;
        var output = { add: function (s) { value += s; } };
        for (i = 0; i < n; i++) {
            name[i].eval(context).genCSS(context, output);
        }
        return value;
    }
    var Declaration = function (name, value, important, merge, index, currentFileInfo, inline, variable) {
        this.name = name;
        this.value = (value instanceof Node) ? value : new Value([value ? new Anonymous(value) : null]);
        this.important = important ? " " + important.trim() : '';
        this.merge = merge;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.inline = inline || false;
        this.variable = (variable !== undefined) ? variable
            : (name.charAt && (name.charAt(0) === '@'));
        this.allowRoot = true;
        this.setParent(this.value, this);
    };
    Declaration.prototype = Object.assign(new Node(), {
        type: 'Declaration',
        genCSS: function (context, output) {
            output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());
            try {
                this.value.genCSS(context, output);
            }
            catch (e) {
                e.index = this._index;
                e.filename = this._fileInfo.filename;
                throw e;
            }
            output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);
        },
        eval: function (context) {
            var mathBypass = false, prevMath, name = this.name, evaldValue, variable = this.variable;
            if (typeof name !== 'string') {
                // expand 'primitive' name directly to get
                // things faster (~10% for benchmark.less):
                name = (name.length === 1) && (name[0] instanceof Keyword) ?
                    name[0].value : evalName(context, name);
                variable = false; // never treat expanded interpolation as new variable name
            }
            // @todo remove when parens-division is default
            if (name === 'font' && context.math === MATH.ALWAYS) {
                mathBypass = true;
                prevMath = context.math;
                context.math = MATH.PARENS_DIVISION;
            }
            try {
                context.importantScope.push({});
                evaldValue = this.value.eval(context);
                if (!this.variable && evaldValue.type === 'DetachedRuleset') {
                    throw { message: 'Rulesets cannot be evaluated on a property.',
                        index: this.getIndex(), filename: this.fileInfo().filename };
                }
                var important = this.important;
                var importantResult = context.importantScope.pop();
                if (!important && importantResult.important) {
                    important = importantResult.important;
                }
                return new Declaration(name, evaldValue, important, this.merge, this.getIndex(), this.fileInfo(), this.inline, variable);
            }
            catch (e) {
                if (typeof e.index !== 'number') {
                    e.index = this.getIndex();
                    e.filename = this.fileInfo().filename;
                }
                throw e;
            }
            finally {
                if (mathBypass) {
                    context.math = prevMath;
                }
            }
        },
        makeImportant: function () {
            return new Declaration(this.name, this.value, '!important', this.merge, this.getIndex(), this.fileInfo(), this.inline);
        }
    });

    var debugInfo = /** @class */ (function () {
        function debugInfo(context, ctx, lineSeparator) {
            var result = '';
            if (context.dumpLineNumbers && !context.compress) {
                switch (context.dumpLineNumbers) {
                    case 'comments':
                        result = debugInfo.asComment(ctx);
                        break;
                    case 'mediaquery':
                        result = debugInfo.asMediaQuery(ctx);
                        break;
                    case 'all':
                        result = debugInfo.asComment(ctx) + (lineSeparator || '') + debugInfo.asMediaQuery(ctx);
                        break;
                }
            }
            return result;
        }
        debugInfo.asComment = function (ctx) {
            return "/* line " + ctx.debugInfo.lineNumber + ", " + ctx.debugInfo.fileName + " */\n";
        };
        debugInfo.asMediaQuery = function (ctx) {
            var filenameWithProtocol = ctx.debugInfo.fileName;
            if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
                filenameWithProtocol = "file://" + filenameWithProtocol;
            }
            return "@media -sass-debug-info{filename{font-family:" + filenameWithProtocol.replace(/([.:\/\\])/g, function (a) {
                if (a == '\\') {
                    a = '\/';
                }
                return "\\" + a;
            }) + "}line{font-family:\\00003" + ctx.debugInfo.lineNumber + "}}\n";
        };
        return debugInfo;
    }());

    var Comment = function (value, isLineComment, index, currentFileInfo) {
        this.value = value;
        this.isLineComment = isLineComment;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.allowRoot = true;
    };
    Comment.prototype = Object.assign(new Node(), {
        type: 'Comment',
        genCSS: function (context, output) {
            if (this.debugInfo) {
                output.add(debugInfo(context, this), this.fileInfo(), this.getIndex());
            }
            output.add(this.value);
        },
        isSilent: function (context) {
            var isCompressed = context.compress && this.value[2] !== '!';
            return this.isLineComment || isCompressed;
        }
    });

    var contexts = {};
    var copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {
        if (!original) {
            return;
        }
        for (var i = 0; i < propertiesToCopy.length; i++) {
            if (original.hasOwnProperty(propertiesToCopy[i])) {
                destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];
            }
        }
    };
    /*
     parse is used whilst parsing
     */
    var parseCopyProperties = [
        // options
        'paths',
        'rewriteUrls',
        'rootpath',
        'strictImports',
        'insecure',
        'dumpLineNumbers',
        'compress',
        'syncImport',
        'chunkInput',
        'mime',
        'useFileCache',
        // context
        'processImports',
        // Used by the import manager to stop multiple import visitors being created.
        'pluginManager' // Used as the plugin manager for the session
    ];
    contexts.Parse = function (options) {
        copyFromOriginal(options, this, parseCopyProperties);
        if (typeof this.paths === 'string') {
            this.paths = [this.paths];
        }
    };
    var evalCopyProperties = [
        'paths',
        'compress',
        'math',
        'strictUnits',
        'sourceMap',
        'importMultiple',
        'urlArgs',
        'javascriptEnabled',
        'pluginManager',
        'importantScope',
        'rewriteUrls' // option - whether to adjust URL's to be relative
    ];
    contexts.Eval = function (options, frames) {
        copyFromOriginal(options, this, evalCopyProperties);
        if (typeof this.paths === 'string') {
            this.paths = [this.paths];
        }
        this.frames = frames || [];
        this.importantScope = this.importantScope || [];
    };
    contexts.Eval.prototype.enterCalc = function () {
        if (!this.calcStack) {
            this.calcStack = [];
        }
        this.calcStack.push(true);
        this.inCalc = true;
    };
    contexts.Eval.prototype.exitCalc = function () {
        this.calcStack.pop();
        if (!this.calcStack.length) {
            this.inCalc = false;
        }
    };
    contexts.Eval.prototype.inParenthesis = function () {
        if (!this.parensStack) {
            this.parensStack = [];
        }
        this.parensStack.push(true);
    };
    contexts.Eval.prototype.outOfParenthesis = function () {
        this.parensStack.pop();
    };
    contexts.Eval.prototype.inCalc = false;
    contexts.Eval.prototype.mathOn = true;
    contexts.Eval.prototype.isMathOn = function (op) {
        if (!this.mathOn) {
            return false;
        }
        if (op === '/' && this.math !== Math$1.ALWAYS && (!this.parensStack || !this.parensStack.length)) {
            return false;
        }
        if (this.math > Math$1.PARENS_DIVISION) {
            return this.parensStack && this.parensStack.length;
        }
        return true;
    };
    contexts.Eval.prototype.pathRequiresRewrite = function (path) {
        var isRelative = this.rewriteUrls === RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;
        return isRelative(path);
    };
    contexts.Eval.prototype.rewritePath = function (path, rootpath) {
        var newPath;
        rootpath = rootpath || '';
        newPath = this.normalizePath(rootpath + path);
        // If a path was explicit relative and the rootpath was not an absolute path
        // we must ensure that the new path is also explicit relative.
        if (isPathLocalRelative(path) &&
            isPathRelative(rootpath) &&
            isPathLocalRelative(newPath) === false) {
            newPath = "./" + newPath;
        }
        return newPath;
    };
    contexts.Eval.prototype.normalizePath = function (path) {
        var segments = path.split('/').reverse();
        var segment;
        path = [];
        while (segments.length !== 0) {
            segment = segments.pop();
            switch (segment) {
                case '.':
                    break;
                case '..':
                    if ((path.length === 0) || (path[path.length - 1] === '..')) {
                        path.push(segment);
                    }
                    else {
                        path.pop();
                    }
                    break;
                default:
                    path.push(segment);
                    break;
            }
        }
        return path.join('/');
    };
    function isPathRelative(path) {
        return !/^(?:[a-z-]+:|\/|#)/i.test(path);
    }
    function isPathLocalRelative(path) {
        return path.charAt(0) === '.';
    }
    // todo - do the same for the toCSS ?

    function makeRegistry(base) {
        return {
            _data: {},
            add: function (name, func) {
                // precautionary case conversion, as later querying of
                // the registry by function-caller uses lower case as well.
                name = name.toLowerCase();
                if (this._data.hasOwnProperty(name)) ;
                this._data[name] = func;
            },
            addMultiple: function (functions) {
                var _this = this;
                Object.keys(functions).forEach(function (name) {
                    _this.add(name, functions[name]);
                });
            },
            get: function (name) {
                return this._data[name] || (base && base.get(name));
            },
            getLocalFunctions: function () {
                return this._data;
            },
            inherit: function () {
                return makeRegistry(this);
            },
            create: function (base) {
                return makeRegistry(base);
            }
        };
    }
    var functionRegistry = makeRegistry(null);

    var defaultFunc = {
        eval: function () {
            var v = this.value_;
            var e = this.error_;
            if (e) {
                throw e;
            }
            if (v != null) {
                return v ? Keyword.True : Keyword.False;
            }
        },
        value: function (v) {
            this.value_ = v;
        },
        error: function (e) {
            this.error_ = e;
        },
        reset: function () {
            this.value_ = this.error_ = null;
        }
    };

    var Ruleset = function (selectors, rules, strictImports, visibilityInfo) {
        this.selectors = selectors;
        this.rules = rules;
        this._lookups = {};
        this._variables = null;
        this._properties = null;
        this.strictImports = strictImports;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
        this.setParent(this.selectors, this);
        this.setParent(this.rules, this);
    };
    Ruleset.prototype = Object.assign(new Node(), {
        type: 'Ruleset',
        isRuleset: true,
        isRulesetLike: function () { return true; },
        accept: function (visitor) {
            if (this.paths) {
                this.paths = visitor.visitArray(this.paths, true);
            }
            else if (this.selectors) {
                this.selectors = visitor.visitArray(this.selectors);
            }
            if (this.rules && this.rules.length) {
                this.rules = visitor.visitArray(this.rules);
            }
        },
        eval: function (context) {
            var selectors;
            var selCnt;
            var selector;
            var i;
            var hasVariable;
            var hasOnePassingSelector = false;
            if (this.selectors && (selCnt = this.selectors.length)) {
                selectors = new Array(selCnt);
                defaultFunc.error({
                    type: 'Syntax',
                    message: 'it is currently only allowed in parametric mixin guards,'
                });
                for (i = 0; i < selCnt; i++) {
                    selector = this.selectors[i].eval(context);
                    for (var j = 0; j < selector.elements.length; j++) {
                        if (selector.elements[j].isVariable) {
                            hasVariable = true;
                            break;
                        }
                    }
                    selectors[i] = selector;
                    if (selector.evaldCondition) {
                        hasOnePassingSelector = true;
                    }
                }
                if (hasVariable) {
                    var toParseSelectors = new Array(selCnt);
                    for (i = 0; i < selCnt; i++) {
                        selector = selectors[i];
                        toParseSelectors[i] = selector.toCSS(context);
                    }
                    this.parse.parseNode(toParseSelectors.join(','), ["selectors"], selectors[0].getIndex(), selectors[0].fileInfo(), function (err, result) {
                        if (result) {
                            selectors = flattenArray(result);
                        }
                    });
                }
                defaultFunc.reset();
            }
            else {
                hasOnePassingSelector = true;
            }
            var rules = this.rules ? copyArray(this.rules) : null;
            var ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());
            var rule;
            var subRule;
            ruleset.originalRuleset = this;
            ruleset.root = this.root;
            ruleset.firstRoot = this.firstRoot;
            ruleset.allowImports = this.allowImports;
            if (this.debugInfo) {
                ruleset.debugInfo = this.debugInfo;
            }
            if (!hasOnePassingSelector) {
                rules.length = 0;
            }
            // inherit a function registry from the frames stack when possible;
            // otherwise from the global registry
            ruleset.functionRegistry = (function (frames) {
                var i = 0;
                var n = frames.length;
                var found;
                for (; i !== n; ++i) {
                    found = frames[i].functionRegistry;
                    if (found) {
                        return found;
                    }
                }
                return functionRegistry;
            }(context.frames)).inherit();
            // push the current ruleset to the frames stack
            var ctxFrames = context.frames;
            ctxFrames.unshift(ruleset);
            // currrent selectors
            var ctxSelectors = context.selectors;
            if (!ctxSelectors) {
                context.selectors = ctxSelectors = [];
            }
            ctxSelectors.unshift(this.selectors);
            // Evaluate imports
            if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {
                ruleset.evalImports(context);
            }
            // Store the frames around mixin definitions,
            // so they can be evaluated like closures when the time comes.
            var rsRules = ruleset.rules;
            for (i = 0; (rule = rsRules[i]); i++) {
                if (rule.evalFirst) {
                    rsRules[i] = rule.eval(context);
                }
            }
            var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;
            // Evaluate mixin calls.
            for (i = 0; (rule = rsRules[i]); i++) {
                if (rule.type === 'MixinCall') {
                    /* jshint loopfunc:true */
                    rules = rule.eval(context).filter(function (r) {
                        if ((r instanceof Declaration) && r.variable) {
                            // do not pollute the scope if the variable is
                            // already there. consider returning false here
                            // but we need a way to "return" variable from mixins
                            return !(ruleset.variable(r.name));
                        }
                        return true;
                    });
                    rsRules.splice.apply(rsRules, [i, 1].concat(rules));
                    i += rules.length - 1;
                    ruleset.resetCache();
                }
                else if (rule.type === 'VariableCall') {
                    /* jshint loopfunc:true */
                    rules = rule.eval(context).rules.filter(function (r) {
                        if ((r instanceof Declaration) && r.variable) {
                            // do not pollute the scope at all
                            return false;
                        }
                        return true;
                    });
                    rsRules.splice.apply(rsRules, [i, 1].concat(rules));
                    i += rules.length - 1;
                    ruleset.resetCache();
                }
            }
            // Evaluate everything else
            for (i = 0; (rule = rsRules[i]); i++) {
                if (!rule.evalFirst) {
                    rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;
                }
            }
            // Evaluate everything else
            for (i = 0; (rule = rsRules[i]); i++) {
                // for rulesets, check if it is a css guard and can be removed
                if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
                    // check if it can be folded in (e.g. & where)
                    if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {
                        rsRules.splice(i--, 1);
                        for (var j = 0; (subRule = rule.rules[j]); j++) {
                            if (subRule instanceof Node) {
                                subRule.copyVisibilityInfo(rule.visibilityInfo());
                                if (!(subRule instanceof Declaration) || !subRule.variable) {
                                    rsRules.splice(++i, 0, subRule);
                                }
                            }
                        }
                    }
                }
            }
            // Pop the stack
            ctxFrames.shift();
            ctxSelectors.shift();
            if (context.mediaBlocks) {
                for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {
                    context.mediaBlocks[i].bubbleSelectors(selectors);
                }
            }
            return ruleset;
        },
        evalImports: function (context) {
            var rules = this.rules;
            var i;
            var importRules;
            if (!rules) {
                return;
            }
            for (i = 0; i < rules.length; i++) {
                if (rules[i].type === 'Import') {
                    importRules = rules[i].eval(context);
                    if (importRules && (importRules.length || importRules.length === 0)) {
                        rules.splice.apply(rules, [i, 1].concat(importRules));
                        i += importRules.length - 1;
                    }
                    else {
                        rules.splice(i, 1, importRules);
                    }
                    this.resetCache();
                }
            }
        },
        makeImportant: function () {
            var result = new Ruleset(this.selectors, this.rules.map(function (r) {
                if (r.makeImportant) {
                    return r.makeImportant();
                }
                else {
                    return r;
                }
            }), this.strictImports, this.visibilityInfo());
            return result;
        },
        matchArgs: function (args) {
            return !args || args.length === 0;
        },
        // lets you call a css selector with a guard
        matchCondition: function (args, context) {
            var lastSelector = this.selectors[this.selectors.length - 1];
            if (!lastSelector.evaldCondition) {
                return false;
            }
            if (lastSelector.condition &&
                !lastSelector.condition.eval(new contexts.Eval(context, context.frames))) {
                return false;
            }
            return true;
        },
        resetCache: function () {
            this._rulesets = null;
            this._variables = null;
            this._properties = null;
            this._lookups = {};
        },
        variables: function () {
            if (!this._variables) {
                this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {
                    if (r instanceof Declaration && r.variable === true) {
                        hash[r.name] = r;
                    }
                    // when evaluating variables in an import statement, imports have not been eval'd
                    // so we need to go inside import statements.
                    // guard against root being a string (in the case of inlined less)
                    if (r.type === 'Import' && r.root && r.root.variables) {
                        var vars = r.root.variables();
                        for (var name_1 in vars) {
                            if (vars.hasOwnProperty(name_1)) {
                                hash[name_1] = r.root.variable(name_1);
                            }
                        }
                    }
                    return hash;
                }, {});
            }
            return this._variables;
        },
        properties: function () {
            if (!this._properties) {
                this._properties = !this.rules ? {} : this.rules.reduce(function (hash, r) {
                    if (r instanceof Declaration && r.variable !== true) {
                        var name_2 = (r.name.length === 1) && (r.name[0] instanceof Keyword) ?
                            r.name[0].value : r.name;
                        // Properties don't overwrite as they can merge
                        if (!hash["$" + name_2]) {
                            hash["$" + name_2] = [r];
                        }
                        else {
                            hash["$" + name_2].push(r);
                        }
                    }
                    return hash;
                }, {});
            }
            return this._properties;
        },
        variable: function (name) {
            var decl = this.variables()[name];
            if (decl) {
                return this.parseValue(decl);
            }
        },
        property: function (name) {
            var decl = this.properties()[name];
            if (decl) {
                return this.parseValue(decl);
            }
        },
        lastDeclaration: function () {
            for (var i = this.rules.length; i > 0; i--) {
                var decl = this.rules[i - 1];
                if (decl instanceof Declaration) {
                    return this.parseValue(decl);
                }
            }
        },
        parseValue: function (toParse) {
            var self = this;
            function transformDeclaration(decl) {
                if (decl.value instanceof Anonymous && !decl.parsed) {
                    if (typeof decl.value.value === 'string') {
                        this.parse.parseNode(decl.value.value, ['value', 'important'], decl.value.getIndex(), decl.fileInfo(), function (err, result) {
                            if (err) {
                                decl.parsed = true;
                            }
                            if (result) {
                                decl.value = result[0];
                                decl.important = result[1] || '';
                                decl.parsed = true;
                            }
                        });
                    }
                    else {
                        decl.parsed = true;
                    }
                    return decl;
                }
                else {
                    return decl;
                }
            }
            if (!Array.isArray(toParse)) {
                return transformDeclaration.call(self, toParse);
            }
            else {
                var nodes_1 = [];
                toParse.forEach(function (n) {
                    nodes_1.push(transformDeclaration.call(self, n));
                });
                return nodes_1;
            }
        },
        rulesets: function () {
            if (!this.rules) {
                return [];
            }
            var filtRules = [];
            var rules = this.rules;
            var i;
            var rule;
            for (i = 0; (rule = rules[i]); i++) {
                if (rule.isRuleset) {
                    filtRules.push(rule);
                }
            }
            return filtRules;
        },
        prependRule: function (rule) {
            var rules = this.rules;
            if (rules) {
                rules.unshift(rule);
            }
            else {
                this.rules = [rule];
            }
            this.setParent(rule, this);
        },
        find: function (selector, self, filter) {
            self = self || this;
            var rules = [];
            var match;
            var foundMixins;
            var key = selector.toCSS();
            if (key in this._lookups) {
                return this._lookups[key];
            }
            this.rulesets().forEach(function (rule) {
                if (rule !== self) {
                    for (var j = 0; j < rule.selectors.length; j++) {
                        match = selector.match(rule.selectors[j]);
                        if (match) {
                            if (selector.elements.length > match) {
                                if (!filter || filter(rule)) {
                                    foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);
                                    for (var i = 0; i < foundMixins.length; ++i) {
                                        foundMixins[i].path.push(rule);
                                    }
                                    Array.prototype.push.apply(rules, foundMixins);
                                }
                            }
                            else {
                                rules.push({ rule: rule, path: [] });
                            }
                            break;
                        }
                    }
                }
            });
            this._lookups[key] = rules;
            return rules;
        },
        genCSS: function (context, output) {
            var i;
            var j;
            var charsetRuleNodes = [];
            var ruleNodes = [];
            var // Line number debugging
            debugInfo$1;
            var rule;
            var path;
            context.tabLevel = (context.tabLevel || 0);
            if (!this.root) {
                context.tabLevel++;
            }
            var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');
            var tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');
            var sep;
            var charsetNodeIndex = 0;
            var importNodeIndex = 0;
            for (i = 0; (rule = this.rules[i]); i++) {
                if (rule instanceof Comment) {
                    if (importNodeIndex === i) {
                        importNodeIndex++;
                    }
                    ruleNodes.push(rule);
                }
                else if (rule.isCharset && rule.isCharset()) {
                    ruleNodes.splice(charsetNodeIndex, 0, rule);
                    charsetNodeIndex++;
                    importNodeIndex++;
                }
                else if (rule.type === 'Import') {
                    ruleNodes.splice(importNodeIndex, 0, rule);
                    importNodeIndex++;
                }
                else {
                    ruleNodes.push(rule);
                }
            }
            ruleNodes = charsetRuleNodes.concat(ruleNodes);
            // If this is the root node, we don't render
            // a selector, or {}.
            if (!this.root) {
                debugInfo$1 = debugInfo(context, this, tabSetStr);
                if (debugInfo$1) {
                    output.add(debugInfo$1);
                    output.add(tabSetStr);
                }
                var paths = this.paths;
                var pathCnt = paths.length;
                var pathSubCnt = void 0;
                sep = context.compress ? ',' : (",\n" + tabSetStr);
                for (i = 0; i < pathCnt; i++) {
                    path = paths[i];
                    if (!(pathSubCnt = path.length)) {
                        continue;
                    }
                    if (i > 0) {
                        output.add(sep);
                    }
                    context.firstSelector = true;
                    path[0].genCSS(context, output);
                    context.firstSelector = false;
                    for (j = 1; j < pathSubCnt; j++) {
                        path[j].genCSS(context, output);
                    }
                }
                output.add((context.compress ? '{' : ' {\n') + tabRuleStr);
            }
            // Compile rules and rulesets
            for (i = 0; (rule = ruleNodes[i]); i++) {
                if (i + 1 === ruleNodes.length) {
                    context.lastRule = true;
                }
                var currentLastRule = context.lastRule;
                if (rule.isRulesetLike(rule)) {
                    context.lastRule = false;
                }
                if (rule.genCSS) {
                    rule.genCSS(context, output);
                }
                else if (rule.value) {
                    output.add(rule.value.toString());
                }
                context.lastRule = currentLastRule;
                if (!context.lastRule && rule.isVisible()) {
                    output.add(context.compress ? '' : ("\n" + tabRuleStr));
                }
                else {
                    context.lastRule = false;
                }
            }
            if (!this.root) {
                output.add((context.compress ? '}' : "\n" + tabSetStr + "}"));
                context.tabLevel--;
            }
            if (!output.isEmpty() && !context.compress && this.firstRoot) {
                output.add('\n');
            }
        },
        joinSelectors: function (paths, context, selectors) {
            for (var s = 0; s < selectors.length; s++) {
                this.joinSelector(paths, context, selectors[s]);
            }
        },
        joinSelector: function (paths, context, selector) {
            function createParenthesis(elementsToPak, originalElement) {
                var replacementParen, j;
                if (elementsToPak.length === 0) {
                    replacementParen = new Paren(elementsToPak[0]);
                }
                else {
                    var insideParent = new Array(elementsToPak.length);
                    for (j = 0; j < elementsToPak.length; j++) {
                        insideParent[j] = new Element(null, elementsToPak[j], originalElement.isVariable, originalElement._index, originalElement._fileInfo);
                    }
                    replacementParen = new Paren(new Selector(insideParent));
                }
                return replacementParen;
            }
            function createSelector(containedElement, originalElement) {
                var element, selector;
                element = new Element(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);
                selector = new Selector([element]);
                return selector;
            }
            // joins selector path from `beginningPath` with selector path in `addPath`
            // `replacedElement` contains element that is being replaced by `addPath`
            // returns concatenated path
            function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
                var newSelectorPath, lastSelector, newJoinedSelector;
                // our new selector path
                newSelectorPath = [];
                // construct the joined selector - if & is the first thing this will be empty,
                // if not newJoinedSelector will be the last set of elements in the selector
                if (beginningPath.length > 0) {
                    newSelectorPath = copyArray(beginningPath);
                    lastSelector = newSelectorPath.pop();
                    newJoinedSelector = originalSelector.createDerived(copyArray(lastSelector.elements));
                }
                else {
                    newJoinedSelector = originalSelector.createDerived([]);
                }
                if (addPath.length > 0) {
                    // /deep/ is a CSS4 selector - (removed, so should deprecate)
                    // that is valid without anything in front of it
                    // so if the & does not have a combinator that is "" or " " then
                    // and there is a combinator on the parent, then grab that.
                    // this also allows + a { & .b { .a & { ... though not sure why you would want to do that
                    var combinator = replacedElement.combinator;
                    var parentEl = addPath[0].elements[0];
                    if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
                        combinator = parentEl.combinator;
                    }
                    // join the elements so far with the first part of the parent
                    newJoinedSelector.elements.push(new Element(combinator, parentEl.value, replacedElement.isVariable, replacedElement._index, replacedElement._fileInfo));
                    newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
                }
                // now add the joined selector - but only if it is not empty
                if (newJoinedSelector.elements.length !== 0) {
                    newSelectorPath.push(newJoinedSelector);
                }
                // put together the parent selectors after the join (e.g. the rest of the parent)
                if (addPath.length > 1) {
                    var restOfPath = addPath.slice(1);
                    restOfPath = restOfPath.map(function (selector) {
                        return selector.createDerived(selector.elements, []);
                    });
                    newSelectorPath = newSelectorPath.concat(restOfPath);
                }
                return newSelectorPath;
            }
            // joins selector path from `beginningPath` with every selector path in `addPaths` array
            // `replacedElement` contains element that is being replaced by `addPath`
            // returns array with all concatenated paths
            function addAllReplacementsIntoPath(beginningPath, addPaths, replacedElement, originalSelector, result) {
                var j;
                for (j = 0; j < beginningPath.length; j++) {
                    var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);
                    result.push(newSelectorPath);
                }
                return result;
            }
            function mergeElementsOnToSelectors(elements, selectors) {
                var i, sel;
                if (elements.length === 0) {
                    return;
                }
                if (selectors.length === 0) {
                    selectors.push([new Selector(elements)]);
                    return;
                }
                for (i = 0; (sel = selectors[i]); i++) {
                    // if the previous thing in sel is a parent this needs to join on to it
                    if (sel.length > 0) {
                        sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
                    }
                    else {
                        sel.push(new Selector(elements));
                    }
                }
            }
            // replace all parent selectors inside `inSelector` by content of `context` array
            // resulting selectors are returned inside `paths` array
            // returns true if `inSelector` contained at least one parent selector
            function replaceParentSelector(paths, context, inSelector) {
                // The paths are [[Selector]]
                // The first list is a list of comma separated selectors
                // The inner list is a list of inheritance separated selectors
                // e.g.
                // .a, .b {
                //   .c {
                //   }
                // }
                // == [[.a] [.c]] [[.b] [.c]]
                //
                var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;
                function findNestedSelector(element) {
                    var maybeSelector;
                    if (!(element.value instanceof Paren)) {
                        return null;
                    }
                    maybeSelector = element.value.value;
                    if (!(maybeSelector instanceof Selector)) {
                        return null;
                    }
                    return maybeSelector;
                }
                // the elements from the current selector so far
                currentElements = [];
                // the current list of new selectors to add to the path.
                // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors
                // by the parents
                newSelectors = [
                    []
                ];
                for (i = 0; (el = inSelector.elements[i]); i++) {
                    // non parent reference elements just get added
                    if (el.value !== '&') {
                        var nestedSelector = findNestedSelector(el);
                        if (nestedSelector != null) {
                            // merge the current list of non parent selector elements
                            // on to the current list of selectors to add
                            mergeElementsOnToSelectors(currentElements, newSelectors);
                            var nestedPaths = [];
                            var replaced = void 0;
                            var replacedNewSelectors = [];
                            replaced = replaceParentSelector(nestedPaths, context, nestedSelector);
                            hadParentSelector = hadParentSelector || replaced;
                            // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors
                            for (k = 0; k < nestedPaths.length; k++) {
                                var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);
                                addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);
                            }
                            newSelectors = replacedNewSelectors;
                            currentElements = [];
                        }
                        else {
                            currentElements.push(el);
                        }
                    }
                    else {
                        hadParentSelector = true;
                        // the new list of selectors to add
                        selectorsMultiplied = [];
                        // merge the current list of non parent selector elements
                        // on to the current list of selectors to add
                        mergeElementsOnToSelectors(currentElements, newSelectors);
                        // loop through our current selectors
                        for (j = 0; j < newSelectors.length; j++) {
                            sel = newSelectors[j];
                            // if we don't have any parent paths, the & might be in a mixin so that it can be used
                            // whether there are parents or not
                            if (context.length === 0) {
                                // the combinator used on el should now be applied to the next element instead so that
                                // it is not lost
                                if (sel.length > 0) {
                                    sel[0].elements.push(new Element(el.combinator, '', el.isVariable, el._index, el._fileInfo));
                                }
                                selectorsMultiplied.push(sel);
                            }
                            else {
                                // and the parent selectors
                                for (k = 0; k < context.length; k++) {
                                    // We need to put the current selectors
                                    // then join the last selector's elements on to the parents selectors
                                    var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);
                                    // add that to our new set of selectors
                                    selectorsMultiplied.push(newSelectorPath);
                                }
                            }
                        }
                        // our new selectors has been multiplied, so reset the state
                        newSelectors = selectorsMultiplied;
                        currentElements = [];
                    }
                }
                // if we have any elements left over (e.g. .a& .b == .b)
                // add them on to all the current selectors
                mergeElementsOnToSelectors(currentElements, newSelectors);
                for (i = 0; i < newSelectors.length; i++) {
                    length = newSelectors[i].length;
                    if (length > 0) {
                        paths.push(newSelectors[i]);
                        lastSelector = newSelectors[i][length - 1];
                        newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
                    }
                }
                return hadParentSelector;
            }
            function deriveSelector(visibilityInfo, deriveFrom) {
                var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
                newSelector.copyVisibilityInfo(visibilityInfo);
                return newSelector;
            }
            // joinSelector code follows
            var i, newPaths, hadParentSelector;
            newPaths = [];
            hadParentSelector = replaceParentSelector(newPaths, context, selector);
            if (!hadParentSelector) {
                if (context.length > 0) {
                    newPaths = [];
                    for (i = 0; i < context.length; i++) {
                        var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));
                        concatenated.push(selector);
                        newPaths.push(concatenated);
                    }
                }
                else {
                    newPaths = [[selector]];
                }
            }
            for (i = 0; i < newPaths.length; i++) {
                paths.push(newPaths[i]);
            }
        }
    });

    var AtRule = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {
        var i;
        this.name = name;
        this.value = (value instanceof Node) ? value : (value ? new Anonymous(value) : value);
        if (rules) {
            if (Array.isArray(rules)) {
                this.rules = rules;
            }
            else {
                this.rules = [rules];
                this.rules[0].selectors = (new Selector([], null, null, index, currentFileInfo)).createEmptySelectors();
            }
            for (i = 0; i < this.rules.length; i++) {
                this.rules[i].allowImports = true;
            }
            this.setParent(this.rules, this);
        }
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.debugInfo = debugInfo;
        this.isRooted = isRooted || false;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
    };
    AtRule.prototype = Object.assign(new Node(), {
        type: 'AtRule',
        accept: function (visitor) {
            var value = this.value, rules = this.rules;
            if (rules) {
                this.rules = visitor.visitArray(rules);
            }
            if (value) {
                this.value = visitor.visit(value);
            }
        },
        isRulesetLike: function () {
            return this.rules || !this.isCharset();
        },
        isCharset: function () {
            return '@charset' === this.name;
        },
        genCSS: function (context, output) {
            var value = this.value, rules = this.rules;
            output.add(this.name, this.fileInfo(), this.getIndex());
            if (value) {
                output.add(' ');
                value.genCSS(context, output);
            }
            if (rules) {
                this.outputRuleset(context, output, rules);
            }
            else {
                output.add(';');
            }
        },
        eval: function (context) {
            var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;
            // media stored inside other atrule should not bubble over it
            // backpup media bubbling information
            mediaPathBackup = context.mediaPath;
            mediaBlocksBackup = context.mediaBlocks;
            // deleted media bubbling information
            context.mediaPath = [];
            context.mediaBlocks = [];
            if (value) {
                value = value.eval(context);
            }
            if (rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                rules = [rules[0].eval(context)];
                rules[0].root = true;
            }
            // restore media bubbling information
            context.mediaPath = mediaPathBackup;
            context.mediaBlocks = mediaBlocksBackup;
            return new AtRule(this.name, value, rules, this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());
        },
        variable: function (name) {
            if (this.rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                return Ruleset.prototype.variable.call(this.rules[0], name);
            }
        },
        find: function () {
            if (this.rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                return Ruleset.prototype.find.apply(this.rules[0], arguments);
            }
        },
        rulesets: function () {
            if (this.rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                return Ruleset.prototype.rulesets.apply(this.rules[0]);
            }
        },
        outputRuleset: function (context, output, rules) {
            var ruleCnt = rules.length;
            var i;
            context.tabLevel = (context.tabLevel | 0) + 1;
            // Compressed
            if (context.compress) {
                output.add('{');
                for (i = 0; i < ruleCnt; i++) {
                    rules[i].genCSS(context, output);
                }
                output.add('}');
                context.tabLevel--;
                return;
            }
            // Non-compressed
            var tabSetStr = "\n" + Array(context.tabLevel).join('  '), tabRuleStr = tabSetStr + "  ";
            if (!ruleCnt) {
                output.add(" {" + tabSetStr + "}");
            }
            else {
                output.add(" {" + tabRuleStr);
                rules[0].genCSS(context, output);
                for (i = 1; i < ruleCnt; i++) {
                    output.add(tabRuleStr);
                    rules[i].genCSS(context, output);
                }
                output.add(tabSetStr + "}");
            }
            context.tabLevel--;
        }
    });

    var DetachedRuleset = function (ruleset, frames) {
        this.ruleset = ruleset;
        this.frames = frames;
        this.setParent(this.ruleset, this);
    };
    DetachedRuleset.prototype = Object.assign(new Node(), {
        type: 'DetachedRuleset',
        evalFirst: true,
        accept: function (visitor) {
            this.ruleset = visitor.visit(this.ruleset);
        },
        eval: function (context) {
            var frames = this.frames || copyArray(context.frames);
            return new DetachedRuleset(this.ruleset, frames);
        },
        callEval: function (context) {
            return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);
        }
    });

    var Unit = function (numerator, denominator, backupUnit) {
        this.numerator = numerator ? copyArray(numerator).sort() : [];
        this.denominator = denominator ? copyArray(denominator).sort() : [];
        if (backupUnit) {
            this.backupUnit = backupUnit;
        }
        else if (numerator && numerator.length) {
            this.backupUnit = numerator[0];
        }
    };
    Unit.prototype = Object.assign(new Node(), {
        type: 'Unit',
        clone: function () {
            return new Unit(copyArray(this.numerator), copyArray(this.denominator), this.backupUnit);
        },
        genCSS: function (context, output) {
            // Dimension checks the unit is singular and throws an error if in strict math mode.
            var strictUnits = context && context.strictUnits;
            if (this.numerator.length === 1) {
                output.add(this.numerator[0]); // the ideal situation
            }
            else if (!strictUnits && this.backupUnit) {
                output.add(this.backupUnit);
            }
            else if (!strictUnits && this.denominator.length) {
                output.add(this.denominator[0]);
            }
        },
        toString: function () {
            var i, returnStr = this.numerator.join('*');
            for (i = 0; i < this.denominator.length; i++) {
                returnStr += "/" + this.denominator[i];
            }
            return returnStr;
        },
        compare: function (other) {
            return this.is(other.toString()) ? 0 : undefined;
        },
        is: function (unitString) {
            return this.toString().toUpperCase() === unitString.toUpperCase();
        },
        isLength: function () {
            return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());
        },
        isEmpty: function () {
            return this.numerator.length === 0 && this.denominator.length === 0;
        },
        isSingular: function () {
            return this.numerator.length <= 1 && this.denominator.length === 0;
        },
        map: function (callback) {
            var i;
            for (i = 0; i < this.numerator.length; i++) {
                this.numerator[i] = callback(this.numerator[i], false);
            }
            for (i = 0; i < this.denominator.length; i++) {
                this.denominator[i] = callback(this.denominator[i], true);
            }
        },
        usedUnits: function () {
            var group;
            var result = {};
            var mapUnit;
            var groupName;
            mapUnit = function (atomicUnit) {
                /* jshint loopfunc:true */
                if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
                    result[groupName] = atomicUnit;
                }
                return atomicUnit;
            };
            for (groupName in unitConversions) {
                if (unitConversions.hasOwnProperty(groupName)) {
                    group = unitConversions[groupName];
                    this.map(mapUnit);
                }
            }
            return result;
        },
        cancel: function () {
            var counter = {};
            var atomicUnit;
            var i;
            for (i = 0; i < this.numerator.length; i++) {
                atomicUnit = this.numerator[i];
                counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
            }
            for (i = 0; i < this.denominator.length; i++) {
                atomicUnit = this.denominator[i];
                counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
            }
            this.numerator = [];
            this.denominator = [];
            for (atomicUnit in counter) {
                if (counter.hasOwnProperty(atomicUnit)) {
                    var count = counter[atomicUnit];
                    if (count > 0) {
                        for (i = 0; i < count; i++) {
                            this.numerator.push(atomicUnit);
                        }
                    }
                    else if (count < 0) {
                        for (i = 0; i < -count; i++) {
                            this.denominator.push(atomicUnit);
                        }
                    }
                }
            }
            this.numerator.sort();
            this.denominator.sort();
        }
    });

    //
    // A number with a unit
    //
    var Dimension = function (value, unit) {
        this.value = parseFloat(value);
        if (isNaN(this.value)) {
            throw new Error('Dimension is not a number.');
        }
        this.unit = (unit && unit instanceof Unit) ? unit :
            new Unit(unit ? [unit] : undefined);
        this.setParent(this.unit, this);
    };
    Dimension.prototype = Object.assign(new Node(), {
        type: 'Dimension',
        accept: function (visitor) {
            this.unit = visitor.visit(this.unit);
        },
        eval: function (context) {
            return this;
        },
        toColor: function () {
            return new Color([this.value, this.value, this.value]);
        },
        genCSS: function (context, output) {
            if ((context && context.strictUnits) && !this.unit.isSingular()) {
                throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: " + this.unit.toString());
            }
            var value = this.fround(context, this.value);
            var strValue = String(value);
            if (value !== 0 && value < 0.000001 && value > -0.000001) {
                // would be output 1e-6 etc.
                strValue = value.toFixed(20).replace(/0+$/, '');
            }
            if (context && context.compress) {
                // Zero values doesn't need a unit
                if (value === 0 && this.unit.isLength()) {
                    output.add(strValue);
                    return;
                }
                // Float values doesn't need a leading zero
                if (value > 0 && value < 1) {
                    strValue = (strValue).substr(1);
                }
            }
            output.add(strValue);
            this.unit.genCSS(context, output);
        },
        // In an operation between two Dimensions,
        // we default to the first Dimension's unit,
        // so `1px + 2` will yield `3px`.
        operate: function (context, op, other) {
            /* jshint noempty:false */
            var value = this._operate(context, op, this.value, other.value);
            var unit = this.unit.clone();
            if (op === '+' || op === '-') {
                if (unit.numerator.length === 0 && unit.denominator.length === 0) {
                    unit = other.unit.clone();
                    if (this.unit.backupUnit) {
                        unit.backupUnit = this.unit.backupUnit;
                    }
                }
                else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) ;
                else {
                    other = other.convertTo(this.unit.usedUnits());
                    if (context.strictUnits && other.unit.toString() !== unit.toString()) {
                        throw new Error("Incompatible units. Change the units or use the unit function. "
                            + ("Bad units: '" + unit.toString() + "' and '" + other.unit.toString() + "'."));
                    }
                    value = this._operate(context, op, this.value, other.value);
                }
            }
            else if (op === '*') {
                unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
                unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
                unit.cancel();
            }
            else if (op === '/') {
                unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
                unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
                unit.cancel();
            }
            return new Dimension(value, unit);
        },
        compare: function (other) {
            var a, b;
            if (!(other instanceof Dimension)) {
                return undefined;
            }
            if (this.unit.isEmpty() || other.unit.isEmpty()) {
                a = this;
                b = other;
            }
            else {
                a = this.unify();
                b = other.unify();
                if (a.unit.compare(b.unit) !== 0) {
                    return undefined;
                }
            }
            return Node.numericCompare(a.value, b.value);
        },
        unify: function () {
            return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });
        },
        convertTo: function (conversions) {
            var value = this.value;
            var unit = this.unit.clone();
            var i;
            var groupName;
            var group;
            var targetUnit;
            var derivedConversions = {};
            var applyUnit;
            if (typeof conversions === 'string') {
                for (i in unitConversions) {
                    if (unitConversions[i].hasOwnProperty(conversions)) {
                        derivedConversions = {};
                        derivedConversions[i] = conversions;
                    }
                }
                conversions = derivedConversions;
            }
            applyUnit = function (atomicUnit, denominator) {
                /* jshint loopfunc:true */
                if (group.hasOwnProperty(atomicUnit)) {
                    if (denominator) {
                        value = value / (group[atomicUnit] / group[targetUnit]);
                    }
                    else {
                        value = value * (group[atomicUnit] / group[targetUnit]);
                    }
                    return targetUnit;
                }
                return atomicUnit;
            };
            for (groupName in conversions) {
                if (conversions.hasOwnProperty(groupName)) {
                    targetUnit = conversions[groupName];
                    group = unitConversions[groupName];
                    unit.map(applyUnit);
                }
            }
            unit.cancel();
            return new Dimension(value, unit);
        }
    });

    var MATH$1 = Math$1;
    var Operation = function (op, operands, isSpaced) {
        this.op = op.trim();
        this.operands = operands;
        this.isSpaced = isSpaced;
    };
    Operation.prototype = Object.assign(new Node(), {
        type: 'Operation',
        accept: function (visitor) {
            this.operands = visitor.visitArray(this.operands);
        },
        eval: function (context) {
            var a = this.operands[0].eval(context), b = this.operands[1].eval(context), op;
            if (context.isMathOn(this.op)) {
                op = this.op === './' ? '/' : this.op;
                if (a instanceof Dimension && b instanceof Color) {
                    a = a.toColor();
                }
                if (b instanceof Dimension && a instanceof Color) {
                    b = b.toColor();
                }
                if (!a.operate || !b.operate) {
                    if ((a instanceof Operation || b instanceof Operation)
                        && a.op === '/' && context.math === MATH$1.PARENS_DIVISION) {
                        return new Operation(this.op, [a, b], this.isSpaced);
                    }
                    throw { type: 'Operation',
                        message: 'Operation on an invalid type' };
                }
                return a.operate(context, op, b);
            }
            else {
                return new Operation(this.op, [a, b], this.isSpaced);
            }
        },
        genCSS: function (context, output) {
            this.operands[0].genCSS(context, output);
            if (this.isSpaced) {
                output.add(' ');
            }
            output.add(this.op);
            if (this.isSpaced) {
                output.add(' ');
            }
            this.operands[1].genCSS(context, output);
        }
    });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArrays$1() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var Expression = function (value, noSpacing) {
        this.value = value;
        this.noSpacing = noSpacing;
        if (!value) {
            throw new Error('Expression requires an array parameter');
        }
    };
    Expression.prototype = Object.assign(new Node(), {
        type: 'Expression',
        accept: function (visitor) {
            this.value = visitor.visitArray(this.value);
        },
        eval: function (context) {
            var returnValue;
            var mathOn = context.isMathOn();
            var inParenthesis = this.parens;
            var doubleParen = false;
            if (inParenthesis) {
                context.inParenthesis();
            }
            if (this.value.length > 1) {
                returnValue = new Expression(this.value.map(function (e) {
                    if (!e.eval) {
                        return e;
                    }
                    return e.eval(context);
                }), this.noSpacing);
            }
            else if (this.value.length === 1) {
                if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {
                    doubleParen = true;
                }
                returnValue = this.value[0].eval(context);
            }
            else {
                returnValue = this;
            }
            if (inParenthesis) {
                context.outOfParenthesis();
            }
            if (this.parens && this.parensInOp && !mathOn && !doubleParen
                && (!(returnValue instanceof Dimension))) {
                returnValue = new Paren(returnValue);
            }
            return returnValue;
        },
        genCSS: function (context, output) {
            for (var i = 0; i < this.value.length; i++) {
                this.value[i].genCSS(context, output);
                if (!this.noSpacing && i + 1 < this.value.length) {
                    output.add(' ');
                }
            }
        },
        throwAwayComments: function () {
            this.value = this.value.filter(function (v) {
                return !(v instanceof Comment);
            });
        }
    });

    var functionCaller = /** @class */ (function () {
        function functionCaller(name, context, index, currentFileInfo) {
            this.name = name.toLowerCase();
            this.index = index;
            this.context = context;
            this.currentFileInfo = currentFileInfo;
            this.func = context.frames[0].functionRegistry.get(this.name);
        }
        functionCaller.prototype.isValid = function () {
            return Boolean(this.func);
        };
        functionCaller.prototype.call = function (args) {
            var _this = this;
            if (!(Array.isArray(args))) {
                args = [args];
            }
            var evalArgs = this.func.evalArgs;
            if (evalArgs !== false) {
                args = args.map(function (a) { return a.eval(_this.context); });
            }
            var commentFilter = function (item) { return !(item.type === 'Comment'); };
            // This code is terrible and should be replaced as per this issue...
            // https://github.com/less/less.js/issues/2477
            args = args
                .filter(commentFilter)
                .map(function (item) {
                if (item.type === 'Expression') {
                    var subNodes = item.value.filter(commentFilter);
                    if (subNodes.length === 1) {
                        return subNodes[0];
                    }
                    else {
                        return new Expression(subNodes);
                    }
                }
                return item;
            });
            if (evalArgs === false) {
                return this.func.apply(this, __spreadArrays$1([this.context], args));
            }
            return this.func.apply(this, args);
        };
        return functionCaller;
    }());

    //
    // A function call node.
    //
    var Call = function (name, args, index, currentFileInfo) {
        this.name = name;
        this.args = args;
        this.calc = name === 'calc';
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    Call.prototype = Object.assign(new Node(), {
        type: 'Call',
        accept: function (visitor) {
            if (this.args) {
                this.args = visitor.visitArray(this.args);
            }
        },
        //
        // When evaluating a function call,
        // we either find the function in the functionRegistry,
        // in which case we call it, passing the  evaluated arguments,
        // if this returns null or we cannot find the function, we
        // simply print it out as it appeared originally [2].
        //
        // The reason why we evaluate the arguments, is in the case where
        // we try to pass a variable to a function, like: `saturate(@color)`.
        // The function should receive the value, not the variable.
        //
        eval: function (context) {
            var _this = this;
            /**
             * Turn off math for calc(), and switch back on for evaluating nested functions
             */
            var currentMathContext = context.mathOn;
            context.mathOn = !this.calc;
            if (this.calc || context.inCalc) {
                context.enterCalc();
            }
            var exitCalc = function () {
                if (_this.calc || context.inCalc) {
                    context.exitCalc();
                }
                context.mathOn = currentMathContext;
            };
            var result;
            var funcCaller = new functionCaller(this.name, context, this.getIndex(), this.fileInfo());
            if (funcCaller.isValid()) {
                try {
                    result = funcCaller.call(this.args);
                    exitCalc();
                }
                catch (e) {
                    if (e.hasOwnProperty('line') && e.hasOwnProperty('column')) {
                        throw e;
                    }
                    throw {
                        type: e.type || 'Runtime',
                        message: "Error evaluating function `" + this.name + "`" + (e.message ? ": " + e.message : ''),
                        index: this.getIndex(),
                        filename: this.fileInfo().filename,
                        line: e.lineNumber,
                        column: e.columnNumber
                    };
                }
            }
            if (result !== null && result !== undefined) {
                // Results that that are not nodes are cast as Anonymous nodes
                // Falsy values or booleans are returned as empty nodes
                if (!(result instanceof Node)) {
                    if (!result || result === true) {
                        result = new Anonymous(null);
                    }
                    else {
                        result = new Anonymous(result.toString());
                    }
                }
                result._index = this._index;
                result._fileInfo = this._fileInfo;
                return result;
            }
            var args = this.args.map(function (a) { return a.eval(context); });
            exitCalc();
            return new Call(this.name, args, this.getIndex(), this.fileInfo());
        },
        genCSS: function (context, output) {
            output.add(this.name + "(", this.fileInfo(), this.getIndex());
            for (var i = 0; i < this.args.length; i++) {
                this.args[i].genCSS(context, output);
                if (i + 1 < this.args.length) {
                    output.add(', ');
                }
            }
            output.add(')');
        }
    });

    var Variable = function (name, index, currentFileInfo) {
        this.name = name;
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    Variable.prototype = Object.assign(new Node(), {
        type: 'Variable',
        eval: function (context) {
            var variable, name = this.name;
            if (name.indexOf('@@') === 0) {
                name = "@" + new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value;
            }
            if (this.evaluating) {
                throw { type: 'Name', message: "Recursive variable definition for " + name, filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            this.evaluating = true;
            variable = this.find(context.frames, function (frame) {
                var v = frame.variable(name);
                if (v) {
                    if (v.important) {
                        var importantScope = context.importantScope[context.importantScope.length - 1];
                        importantScope.important = v.important;
                    }
                    // If in calc, wrap vars in a function call to cascade evaluate args first
                    if (context.inCalc) {
                        return (new Call('_SELF', [v.value])).eval(context);
                    }
                    else {
                        return v.value.eval(context);
                    }
                }
            });
            if (variable) {
                this.evaluating = false;
                return variable;
            }
            else {
                throw { type: 'Name', message: "variable " + name + " is undefined", filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
        },
        find: function (obj, fun) {
            for (var i = 0, r = void 0; i < obj.length; i++) {
                r = fun.call(obj, obj[i]);
                if (r) {
                    return r;
                }
            }
            return null;
        }
    });

    var Property = function (name, index, currentFileInfo) {
        this.name = name;
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    Property.prototype = Object.assign(new Node(), {
        type: 'Property',
        eval: function (context) {
            var property;
            var name = this.name;
            // TODO: shorten this reference
            var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;
            if (this.evaluating) {
                throw { type: 'Name', message: "Recursive property reference for " + name, filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            this.evaluating = true;
            property = this.find(context.frames, function (frame) {
                var v;
                var vArr = frame.property(name);
                if (vArr) {
                    for (var i = 0; i < vArr.length; i++) {
                        v = vArr[i];
                        vArr[i] = new Declaration(v.name, v.value, v.important, v.merge, v.index, v.currentFileInfo, v.inline, v.variable);
                    }
                    mergeRules(vArr);
                    v = vArr[vArr.length - 1];
                    if (v.important) {
                        var importantScope = context.importantScope[context.importantScope.length - 1];
                        importantScope.important = v.important;
                    }
                    v = v.value.eval(context);
                    return v;
                }
            });
            if (property) {
                this.evaluating = false;
                return property;
            }
            else {
                throw { type: 'Name', message: "Property '" + name + "' is undefined", filename: this.currentFileInfo.filename,
                    index: this.index };
            }
        },
        find: function (obj, fun) {
            for (var i = 0, r = void 0; i < obj.length; i++) {
                r = fun.call(obj, obj[i]);
                if (r) {
                    return r;
                }
            }
            return null;
        }
    });

    var Attribute = function (key, op, value) {
        this.key = key;
        this.op = op;
        this.value = value;
    };
    Attribute.prototype = Object.assign(new Node(), {
        type: 'Attribute',
        eval: function (context) {
            return new Attribute(this.key.eval ? this.key.eval(context) : this.key, this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);
        },
        genCSS: function (context, output) {
            output.add(this.toCSS(context));
        },
        toCSS: function (context) {
            var value = this.key.toCSS ? this.key.toCSS(context) : this.key;
            if (this.op) {
                value += this.op;
                value += (this.value.toCSS ? this.value.toCSS(context) : this.value);
            }
            return "[" + value + "]";
        }
    });

    var Quoted = function (str, content, escaped, index, currentFileInfo) {
        this.escaped = (escaped == null) ? true : escaped;
        this.value = content || '';
        this.quote = str.charAt(0);
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.variableRegex = /@\{([\w-]+)\}/g;
        this.propRegex = /\$\{([\w-]+)\}/g;
        this.allowRoot = escaped;
    };
    Quoted.prototype = Object.assign(new Node(), {
        type: 'Quoted',
        genCSS: function (context, output) {
            if (!this.escaped) {
                output.add(this.quote, this.fileInfo(), this.getIndex());
            }
            output.add(this.value);
            if (!this.escaped) {
                output.add(this.quote);
            }
        },
        containsVariables: function () {
            return this.value.match(this.variableRegex);
        },
        eval: function (context) {
            var that = this;
            var value = this.value;
            var variableReplacement = function (_, name) {
                var v = new Variable("@" + name, that.getIndex(), that.fileInfo()).eval(context, true);
                return (v instanceof Quoted) ? v.value : v.toCSS();
            };
            var propertyReplacement = function (_, name) {
                var v = new Property("$" + name, that.getIndex(), that.fileInfo()).eval(context, true);
                return (v instanceof Quoted) ? v.value : v.toCSS();
            };
            function iterativeReplace(value, regexp, replacementFnc) {
                var evaluatedValue = value;
                do {
                    value = evaluatedValue.toString();
                    evaluatedValue = value.replace(regexp, replacementFnc);
                } while (value !== evaluatedValue);
                return evaluatedValue;
            }
            value = iterativeReplace(value, this.variableRegex, variableReplacement);
            value = iterativeReplace(value, this.propRegex, propertyReplacement);
            return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());
        },
        compare: function (other) {
            // when comparing quoted strings allow the quote to differ
            if (other.type === 'Quoted' && !this.escaped && !other.escaped) {
                return Node.numericCompare(this.value, other.value);
            }
            else {
                return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
            }
        }
    });

    function escapePath(path) {
        return path.replace(/[\(\)'"\s]/g, function (match) { return "\\" + match; });
    }
    var URL = function (val, index, currentFileInfo, isEvald) {
        this.value = val;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.isEvald = isEvald;
    };
    URL.prototype = Object.assign(new Node(), {
        type: 'Url',
        accept: function (visitor) {
            this.value = visitor.visit(this.value);
        },
        genCSS: function (context, output) {
            output.add('url(');
            this.value.genCSS(context, output);
            output.add(')');
        },
        eval: function (context) {
            var val = this.value.eval(context);
            var rootpath;
            if (!this.isEvald) {
                // Add the rootpath if the URL requires a rewrite
                rootpath = this.fileInfo() && this.fileInfo().rootpath;
                if (typeof rootpath === 'string' &&
                    typeof val.value === 'string' &&
                    context.pathRequiresRewrite(val.value)) {
                    if (!val.quote) {
                        rootpath = escapePath(rootpath);
                    }
                    val.value = context.rewritePath(val.value, rootpath);
                }
                else {
                    val.value = context.normalizePath(val.value);
                }
                // Add url args if enabled
                if (context.urlArgs) {
                    if (!val.value.match(/^\s*data:/)) {
                        var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';
                        var urlArgs = delimiter + context.urlArgs;
                        if (val.value.indexOf('#') !== -1) {
                            val.value = val.value.replace('#', urlArgs + "#");
                        }
                        else {
                            val.value += urlArgs;
                        }
                    }
                }
            }
            return new URL(val, this.getIndex(), this.fileInfo(), true);
        }
    });

    var Media = function (value, features, index, currentFileInfo, visibilityInfo) {
        this._index = index;
        this._fileInfo = currentFileInfo;
        var selectors = (new Selector([], null, null, this._index, this._fileInfo)).createEmptySelectors();
        this.features = new Value(features);
        this.rules = [new Ruleset(selectors, value)];
        this.rules[0].allowImports = true;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
        this.setParent(selectors, this);
        this.setParent(this.features, this);
        this.setParent(this.rules, this);
    };
    Media.prototype = Object.assign(new AtRule(), {
        type: 'Media',
        isRulesetLike: function () {
            return true;
        },
        accept: function (visitor) {
            if (this.features) {
                this.features = visitor.visit(this.features);
            }
            if (this.rules) {
                this.rules = visitor.visitArray(this.rules);
            }
        },
        genCSS: function (context, output) {
            output.add('@media ', this._fileInfo, this._index);
            this.features.genCSS(context, output);
            this.outputRuleset(context, output, this.rules);
        },
        eval: function (context) {
            if (!context.mediaBlocks) {
                context.mediaBlocks = [];
                context.mediaPath = [];
            }
            var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());
            if (this.debugInfo) {
                this.rules[0].debugInfo = this.debugInfo;
                media.debugInfo = this.debugInfo;
            }
            media.features = this.features.eval(context);
            context.mediaPath.push(media);
            context.mediaBlocks.push(media);
            this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
            context.frames.unshift(this.rules[0]);
            media.rules = [this.rules[0].eval(context)];
            context.frames.shift();
            context.mediaPath.pop();
            return context.mediaPath.length === 0 ? media.evalTop(context) :
                media.evalNested(context);
        },
        evalTop: function (context) {
            var result = this;
            // Render all dependent Media blocks.
            if (context.mediaBlocks.length > 1) {
                var selectors = (new Selector([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();
                result = new Ruleset(selectors, context.mediaBlocks);
                result.multiMedia = true;
                result.copyVisibilityInfo(this.visibilityInfo());
                this.setParent(result, this);
            }
            delete context.mediaBlocks;
            delete context.mediaPath;
            return result;
        },
        evalNested: function (context) {
            var i;
            var value;
            var path = context.mediaPath.concat([this]);
            // Extract the media-query conditions separated with `,` (OR).
            for (i = 0; i < path.length; i++) {
                value = path[i].features instanceof Value ?
                    path[i].features.value : path[i].features;
                path[i] = Array.isArray(value) ? value : [value];
            }
            // Trace all permutations to generate the resulting media-query.
            //
            // (a, b and c) with nested (d, e) ->
            //    a and d
            //    a and e
            //    b and c and d
            //    b and c and e
            this.features = new Value(this.permute(path).map(function (path) {
                path = path.map(function (fragment) { return fragment.toCSS ? fragment : new Anonymous(fragment); });
                for (i = path.length - 1; i > 0; i--) {
                    path.splice(i, 0, new Anonymous('and'));
                }
                return new Expression(path);
            }));
            this.setParent(this.features, this);
            // Fake a tree-node that doesn't output anything.
            return new Ruleset([], []);
        },
        permute: function (arr) {
            if (arr.length === 0) {
                return [];
            }
            else if (arr.length === 1) {
                return arr[0];
            }
            else {
                var result = [];
                var rest = this.permute(arr.slice(1));
                for (var i = 0; i < rest.length; i++) {
                    for (var j = 0; j < arr[0].length; j++) {
                        result.push([arr[0][j]].concat(rest[i]));
                    }
                }
                return result;
            }
        },
        bubbleSelectors: function (selectors) {
            if (!selectors) {
                return;
            }
            this.rules = [new Ruleset(copyArray(selectors), [this.rules[0]])];
            this.setParent(this.rules, this);
        }
    });

    //
    // CSS @import node
    //
    // The general strategy here is that we don't want to wait
    // for the parsing to be completed, before we start importing
    // the file. That's because in the context of a browser,
    // most of the time will be spent waiting for the server to respond.
    //
    // On creation, we push the import path to our import queue, though
    // `import,push`, we also pass it a callback, which it'll call once
    // the file has been fetched, and parsed.
    //
    var Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {
        this.options = options;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.path = path;
        this.features = features;
        this.allowRoot = true;
        if (this.options.less !== undefined || this.options.inline) {
            this.css = !this.options.less || this.options.inline;
        }
        else {
            var pathValue = this.getPath();
            if (pathValue && /[#\.\&\?]css([\?;].*)?$/.test(pathValue)) {
                this.css = true;
            }
        }
        this.copyVisibilityInfo(visibilityInfo);
        this.setParent(this.features, this);
        this.setParent(this.path, this);
    };
    Import.prototype = Object.assign(new Node(), {
        type: 'Import',
        accept: function (visitor) {
            if (this.features) {
                this.features = visitor.visit(this.features);
            }
            this.path = visitor.visit(this.path);
            if (!this.options.isPlugin && !this.options.inline && this.root) {
                this.root = visitor.visit(this.root);
            }
        },
        genCSS: function (context, output) {
            if (this.css && this.path._fileInfo.reference === undefined) {
                output.add('@import ', this._fileInfo, this._index);
                this.path.genCSS(context, output);
                if (this.features) {
                    output.add(' ');
                    this.features.genCSS(context, output);
                }
                output.add(';');
            }
        },
        getPath: function () {
            return (this.path instanceof URL) ?
                this.path.value.value : this.path.value;
        },
        isVariableImport: function () {
            var path = this.path;
            if (path instanceof URL) {
                path = path.value;
            }
            if (path instanceof Quoted) {
                return path.containsVariables();
            }
            return true;
        },
        evalForImport: function (context) {
            var path = this.path;
            if (path instanceof URL) {
                path = path.value;
            }
            return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());
        },
        evalPath: function (context) {
            var path = this.path.eval(context);
            var fileInfo = this._fileInfo;
            if (!(path instanceof URL)) {
                // Add the rootpath if the URL requires a rewrite
                var pathValue = path.value;
                if (fileInfo &&
                    pathValue &&
                    context.pathRequiresRewrite(pathValue)) {
                    path.value = context.rewritePath(pathValue, fileInfo.rootpath);
                }
                else {
                    path.value = context.normalizePath(path.value);
                }
            }
            return path;
        },
        eval: function (context) {
            var result = this.doEval(context);
            if (this.options.reference || this.blocksVisibility()) {
                if (result.length || result.length === 0) {
                    result.forEach(function (node) {
                        node.addVisibilityBlock();
                    });
                }
                else {
                    result.addVisibilityBlock();
                }
            }
            return result;
        },
        doEval: function (context) {
            var ruleset;
            var registry;
            var features = this.features && this.features.eval(context);
            if (this.options.isPlugin) {
                if (this.root && this.root.eval) {
                    try {
                        this.root.eval(context);
                    }
                    catch (e) {
                        e.message = 'Plugin error during evaluation';
                        throw new LessError(e, this.root.imports, this.root.filename);
                    }
                }
                registry = context.frames[0] && context.frames[0].functionRegistry;
                if (registry && this.root && this.root.functions) {
                    registry.addMultiple(this.root.functions);
                }
                return [];
            }
            if (this.skip) {
                if (typeof this.skip === 'function') {
                    this.skip = this.skip();
                }
                if (this.skip) {
                    return [];
                }
            }
            if (this.options.inline) {
                var contents = new Anonymous(this.root, 0, {
                    filename: this.importedFilename,
                    reference: this.path._fileInfo && this.path._fileInfo.reference
                }, true, true);
                return this.features ? new Media([contents], this.features.value) : [contents];
            }
            else if (this.css) {
                var newImport = new Import(this.evalPath(context), features, this.options, this._index);
                if (!newImport.css && this.error) {
                    throw this.error;
                }
                return newImport;
            }
            else if (this.root) {
                ruleset = new Ruleset(null, copyArray(this.root.rules));
                ruleset.evalImports(context);
                return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;
            }
            else {
                return [];
            }
        }
    });

    var JsEvalNode = function () { };
    JsEvalNode.prototype = Object.assign(new Node(), {
        evaluateJavaScript: function (expression, context) {
            var result;
            var that = this;
            var evalContext = {};
            if (!context.javascriptEnabled) {
                throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',
                    filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            expression = expression.replace(/@\{([\w-]+)\}/g, function (_, name) {
                return that.jsify(new Variable("@" + name, that.getIndex(), that.fileInfo()).eval(context));
            });
            try {
                expression = new Function("return (" + expression + ")");
            }
            catch (e) {
                throw { message: "JavaScript evaluation error: " + e.message + " from `" + expression + "`", filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            var variables = context.frames[0].variables();
            for (var k in variables) {
                if (variables.hasOwnProperty(k)) {
                    /* jshint loopfunc:true */
                    evalContext[k.slice(1)] = {
                        value: variables[k].value,
                        toJS: function () {
                            return this.value.eval(context).toCSS();
                        }
                    };
                }
            }
            try {
                result = expression.call(evalContext);
            }
            catch (e) {
                throw { message: "JavaScript evaluation error: '" + e.name + ": " + e.message.replace(/["]/g, '\'') + "'", filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            return result;
        },
        jsify: function (obj) {
            if (Array.isArray(obj.value) && (obj.value.length > 1)) {
                return "[" + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + "]";
            }
            else {
                return obj.toCSS();
            }
        }
    });

    var JavaScript = function (string, escaped, index, currentFileInfo) {
        this.escaped = escaped;
        this.expression = string;
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    JavaScript.prototype = Object.assign(new JsEvalNode(), {
        type: 'JavaScript',
        eval: function (context) {
            var result = this.evaluateJavaScript(this.expression, context);
            var type = typeof result;
            if (type === 'number' && !isNaN(result)) {
                return new Dimension(result);
            }
            else if (type === 'string') {
                return new Quoted("\"" + result + "\"", result, this.escaped, this._index);
            }
            else if (Array.isArray(result)) {
                return new Anonymous(result.join(', '));
            }
            else {
                return new Anonymous(result);
            }
        }
    });

    var Assignment = function (key, val) {
        this.key = key;
        this.value = val;
    };
    Assignment.prototype = Object.assign(new Node(), {
        type: 'Assignment',
        accept: function (visitor) {
            this.value = visitor.visit(this.value);
        },
        eval: function (context) {
            if (this.value.eval) {
                return new Assignment(this.key, this.value.eval(context));
            }
            return this;
        },
        genCSS: function (context, output) {
            output.add(this.key + "=");
            if (this.value.genCSS) {
                this.value.genCSS(context, output);
            }
            else {
                output.add(this.value);
            }
        }
    });

    var Condition = function (op, l, r, i, negate) {
        this.op = op.trim();
        this.lvalue = l;
        this.rvalue = r;
        this._index = i;
        this.negate = negate;
    };
    Condition.prototype = Object.assign(new Node(), {
        type: 'Condition',
        accept: function (visitor) {
            this.lvalue = visitor.visit(this.lvalue);
            this.rvalue = visitor.visit(this.rvalue);
        },
        eval: function (context) {
            var result = (function (op, a, b) {
                switch (op) {
                    case 'and': return a && b;
                    case 'or': return a || b;
                    default:
                        switch (Node.compare(a, b)) {
                            case -1:
                                return op === '<' || op === '=<' || op === '<=';
                            case 0:
                                return op === '=' || op === '>=' || op === '=<' || op === '<=';
                            case 1:
                                return op === '>' || op === '>=';
                            default:
                                return false;
                        }
                }
            })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));
            return this.negate ? !result : result;
        }
    });

    var UnicodeDescriptor = function (value) {
        this.value = value;
    };
    UnicodeDescriptor.prototype = Object.assign(new Node(), {
        type: 'UnicodeDescriptor'
    });

    var Negative = function (node) {
        this.value = node;
    };
    Negative.prototype = Object.assign(new Node(), {
        type: 'Negative',
        genCSS: function (context, output) {
            output.add('-');
            this.value.genCSS(context, output);
        },
        eval: function (context) {
            if (context.isMathOn()) {
                return (new Operation('*', [new Dimension(-1), this.value])).eval(context);
            }
            return new Negative(this.value.eval(context));
        }
    });

    var Extend = function (selector, option, index, currentFileInfo, visibilityInfo) {
        this.selector = selector;
        this.option = option;
        this.object_id = Extend.next_id++;
        this.parent_ids = [this.object_id];
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
        switch (option) {
            case 'all':
                this.allowBefore = true;
                this.allowAfter = true;
                break;
            default:
                this.allowBefore = false;
                this.allowAfter = false;
                break;
        }
        this.setParent(this.selector, this);
    };
    Extend.prototype = Object.assign(new Node(), {
        type: 'Extend',
        accept: function (visitor) {
            this.selector = visitor.visit(this.selector);
        },
        eval: function (context) {
            return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        clone: function (context) {
            return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        // it concatenates (joins) all selectors in selector array
        findSelfSelectors: function (selectors) {
            var selfElements = [], i, selectorElements;
            for (i = 0; i < selectors.length; i++) {
                selectorElements = selectors[i].elements;
                // duplicate the logic in genCSS function inside the selector node.
                // future TODO - move both logics into the selector joiner visitor
                if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {
                    selectorElements[0].combinator.value = ' ';
                }
                selfElements = selfElements.concat(selectors[i].elements);
            }
            this.selfSelectors = [new Selector(selfElements)];
            this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
        }
    });
    Extend.next_id = 0;

    var VariableCall = function (variable, index, currentFileInfo) {
        this.variable = variable;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.allowRoot = true;
    };
    VariableCall.prototype = Object.assign(new Node(), {
        type: 'VariableCall',
        eval: function (context) {
            var rules;
            var detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context);
            var error = new LessError({ message: "Could not evaluate variable call " + this.variable });
            if (!detachedRuleset.ruleset) {
                if (detachedRuleset.rules) {
                    rules = detachedRuleset;
                }
                else if (Array.isArray(detachedRuleset)) {
                    rules = new Ruleset('', detachedRuleset);
                }
                else if (Array.isArray(detachedRuleset.value)) {
                    rules = new Ruleset('', detachedRuleset.value);
                }
                else {
                    throw error;
                }
                detachedRuleset = new DetachedRuleset(rules);
            }
            if (detachedRuleset.ruleset) {
                return detachedRuleset.callEval(context);
            }
            throw error;
        }
    });

    var NamespaceValue = function (ruleCall, lookups, index, fileInfo) {
        this.value = ruleCall;
        this.lookups = lookups;
        this._index = index;
        this._fileInfo = fileInfo;
    };
    NamespaceValue.prototype = Object.assign(new Node(), {
        type: 'NamespaceValue',
        eval: function (context) {
            var i, name, rules = this.value.eval(context);
            for (i = 0; i < this.lookups.length; i++) {
                name = this.lookups[i];
                /**
                 * Eval'd DRs return rulesets.
                 * Eval'd mixins return rules, so let's make a ruleset if we need it.
                 * We need to do this because of late parsing of values
                 */
                if (Array.isArray(rules)) {
                    rules = new Ruleset([new Selector()], rules);
                }
                if (name === '') {
                    rules = rules.lastDeclaration();
                }
                else if (name.charAt(0) === '@') {
                    if (name.charAt(1) === '@') {
                        name = "@" + new Variable(name.substr(1)).eval(context).value;
                    }
                    if (rules.variables) {
                        rules = rules.variable(name);
                    }
                    if (!rules) {
                        throw { type: 'Name', message: "variable " + name + " not found", filename: this.fileInfo().filename,
                            index: this.getIndex() };
                    }
                }
                else {
                    if (name.substring(0, 2) === '$@') {
                        name = "$" + new Variable(name.substr(1)).eval(context).value;
                    }
                    else {
                        name = name.charAt(0) === '$' ? name : "$" + name;
                    }
                    if (rules.properties) {
                        rules = rules.property(name);
                    }
                    if (!rules) {
                        throw { type: 'Name', message: "property \"" + name.substr(1) + "\" not found", filename: this.fileInfo().filename,
                            index: this.getIndex() };
                    }
                    // Properties are an array of values, since a ruleset can have multiple props.
                    // We pick the last one (the "cascaded" value)
                    rules = rules[rules.length - 1];
                }
                if (rules.value) {
                    rules = rules.eval(context).value;
                }
                if (rules.ruleset) {
                    rules = rules.ruleset.eval(context);
                }
            }
            return rules;
        }
    });

    var Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {
        this.name = name || 'anonymous mixin';
        this.selectors = [new Selector([new Element(null, name, false, this._index, this._fileInfo)])];
        this.params = params;
        this.condition = condition;
        this.variadic = variadic;
        this.arity = params.length;
        this.rules = rules;
        this._lookups = {};
        var optionalParameters = [];
        this.required = params.reduce(function (count, p) {
            if (!p.name || (p.name && !p.value)) {
                return count + 1;
            }
            else {
                optionalParameters.push(p.name);
                return count;
            }
        }, 0);
        this.optionalParameters = optionalParameters;
        this.frames = frames;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
    };
    Definition.prototype = Object.assign(new Ruleset(), {
        type: 'MixinDefinition',
        evalFirst: true,
        accept: function (visitor) {
            if (this.params && this.params.length) {
                this.params = visitor.visitArray(this.params);
            }
            this.rules = visitor.visitArray(this.rules);
            if (this.condition) {
                this.condition = visitor.visit(this.condition);
            }
        },
        evalParams: function (context, mixinEnv, args, evaldArguments) {
            /* jshint boss:true */
            var frame = new Ruleset(null, null);
            var varargs;
            var arg;
            var params = copyArray(this.params);
            var i;
            var j;
            var val;
            var name;
            var isNamedFound;
            var argIndex;
            var argsLength = 0;
            if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
                frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
            }
            mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));
            if (args) {
                args = copyArray(args);
                argsLength = args.length;
                for (i = 0; i < argsLength; i++) {
                    arg = args[i];
                    if (name = (arg && arg.name)) {
                        isNamedFound = false;
                        for (j = 0; j < params.length; j++) {
                            if (!evaldArguments[j] && name === params[j].name) {
                                evaldArguments[j] = arg.value.eval(context);
                                frame.prependRule(new Declaration(name, arg.value.eval(context)));
                                isNamedFound = true;
                                break;
                            }
                        }
                        if (isNamedFound) {
                            args.splice(i, 1);
                            i--;
                            continue;
                        }
                        else {
                            throw { type: 'Runtime', message: "Named argument for " + this.name + " " + args[i].name + " not found" };
                        }
                    }
                }
            }
            argIndex = 0;
            for (i = 0; i < params.length; i++) {
                if (evaldArguments[i]) {
                    continue;
                }
                arg = args && args[argIndex];
                if (name = params[i].name) {
                    if (params[i].variadic) {
                        varargs = [];
                        for (j = argIndex; j < argsLength; j++) {
                            varargs.push(args[j].value.eval(context));
                        }
                        frame.prependRule(new Declaration(name, new Expression(varargs).eval(context)));
                    }
                    else {
                        val = arg && arg.value;
                        if (val) {
                            // This was a mixin call, pass in a detached ruleset of it's eval'd rules
                            if (Array.isArray(val)) {
                                val = new DetachedRuleset(new Ruleset('', val));
                            }
                            else {
                                val = val.eval(context);
                            }
                        }
                        else if (params[i].value) {
                            val = params[i].value.eval(mixinEnv);
                            frame.resetCache();
                        }
                        else {
                            throw { type: 'Runtime', message: "wrong number of arguments for " + this.name + " (" + argsLength + " for " + this.arity + ")" };
                        }
                        frame.prependRule(new Declaration(name, val));
                        evaldArguments[i] = val;
                    }
                }
                if (params[i].variadic && args) {
                    for (j = argIndex; j < argsLength; j++) {
                        evaldArguments[j] = args[j].value.eval(context);
                    }
                }
                argIndex++;
            }
            return frame;
        },
        makeImportant: function () {
            var rules = !this.rules ? this.rules : this.rules.map(function (r) {
                if (r.makeImportant) {
                    return r.makeImportant(true);
                }
                else {
                    return r;
                }
            });
            var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);
            return result;
        },
        eval: function (context) {
            return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || copyArray(context.frames));
        },
        evalCall: function (context, args, important) {
            var _arguments = [];
            var mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;
            var frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments);
            var rules;
            var ruleset;
            frame.prependRule(new Declaration('@arguments', new Expression(_arguments).eval(context)));
            rules = copyArray(this.rules);
            ruleset = new Ruleset(null, rules);
            ruleset.originalRuleset = this;
            ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));
            if (important) {
                ruleset = ruleset.makeImportant();
            }
            return ruleset;
        },
        matchCondition: function (args, context) {
            if (this.condition && !this.condition.eval(new contexts.Eval(context, [this.evalParams(context, /* the parameter variables */ new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]
                .concat(this.frames || []) // the parent namespace/mixin frames
                .concat(context.frames)))) { // the current environment frames
                return false;
            }
            return true;
        },
        matchArgs: function (args, context) {
            var allArgsCnt = (args && args.length) || 0;
            var len;
            var optionalParameters = this.optionalParameters;
            var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {
                if (optionalParameters.indexOf(p.name) < 0) {
                    return count + 1;
                }
                else {
                    return count;
                }
            }, 0);
            if (!this.variadic) {
                if (requiredArgsCnt < this.required) {
                    return false;
                }
                if (allArgsCnt > this.params.length) {
                    return false;
                }
            }
            else {
                if (requiredArgsCnt < (this.required - 1)) {
                    return false;
                }
            }
            // check patterns
            len = Math.min(requiredArgsCnt, this.arity);
            for (var i = 0; i < len; i++) {
                if (!this.params[i].name && !this.params[i].variadic) {
                    if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {
                        return false;
                    }
                }
            }
            return true;
        }
    });

    var MixinCall = function (elements, args, index, currentFileInfo, important) {
        this.selector = new Selector(elements);
        this.arguments = args || [];
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.important = important;
        this.allowRoot = true;
        this.setParent(this.selector, this);
    };
    MixinCall.prototype = Object.assign(new Node(), {
        type: 'MixinCall',
        accept: function (visitor) {
            if (this.selector) {
                this.selector = visitor.visit(this.selector);
            }
            if (this.arguments.length) {
                this.arguments = visitor.visitArray(this.arguments);
            }
        },
        eval: function (context) {
            var mixins;
            var mixin;
            var mixinPath;
            var args = [];
            var arg;
            var argValue;
            var rules = [];
            var match = false;
            var i;
            var m;
            var f;
            var isRecursive;
            var isOneFound;
            var candidates = [];
            var candidate;
            var conditionResult = [];
            var defaultResult;
            var defFalseEitherCase = -1;
            var defNone = 0;
            var defTrue = 1;
            var defFalse = 2;
            var count;
            var originalRuleset;
            var noArgumentsFilter;
            this.selector = this.selector.eval(context);
            function calcDefGroup(mixin, mixinPath) {
                var f, p, namespace;
                for (f = 0; f < 2; f++) {
                    conditionResult[f] = true;
                    defaultFunc.value(f);
                    for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {
                        namespace = mixinPath[p];
                        if (namespace.matchCondition) {
                            conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);
                        }
                    }
                    if (mixin.matchCondition) {
                        conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);
                    }
                }
                if (conditionResult[0] || conditionResult[1]) {
                    if (conditionResult[0] != conditionResult[1]) {
                        return conditionResult[1] ?
                            defTrue : defFalse;
                    }
                    return defNone;
                }
                return defFalseEitherCase;
            }
            for (i = 0; i < this.arguments.length; i++) {
                arg = this.arguments[i];
                argValue = arg.value.eval(context);
                if (arg.expand && Array.isArray(argValue.value)) {
                    argValue = argValue.value;
                    for (m = 0; m < argValue.length; m++) {
                        args.push({ value: argValue[m] });
                    }
                }
                else {
                    args.push({ name: arg.name, value: argValue });
                }
            }
            noArgumentsFilter = function (rule) { return rule.matchArgs(null, context); };
            for (i = 0; i < context.frames.length; i++) {
                if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {
                    isOneFound = true;
                    // To make `default()` function independent of definition order we have two "subpasses" here.
                    // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),
                    // and build candidate list with corresponding flags. Then, when we know all possible matches,
                    // we make a final decision.
                    for (m = 0; m < mixins.length; m++) {
                        mixin = mixins[m].rule;
                        mixinPath = mixins[m].path;
                        isRecursive = false;
                        for (f = 0; f < context.frames.length; f++) {
                            if ((!(mixin instanceof Definition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {
                                isRecursive = true;
                                break;
                            }
                        }
                        if (isRecursive) {
                            continue;
                        }
                        if (mixin.matchArgs(args, context)) {
                            candidate = { mixin: mixin, group: calcDefGroup(mixin, mixinPath) };
                            if (candidate.group !== defFalseEitherCase) {
                                candidates.push(candidate);
                            }
                            match = true;
                        }
                    }
                    defaultFunc.reset();
                    count = [0, 0, 0];
                    for (m = 0; m < candidates.length; m++) {
                        count[candidates[m].group]++;
                    }
                    if (count[defNone] > 0) {
                        defaultResult = defFalse;
                    }
                    else {
                        defaultResult = defTrue;
                        if ((count[defTrue] + count[defFalse]) > 1) {
                            throw { type: 'Runtime', message: "Ambiguous use of `default()` found when matching for `" + this.format(args) + "`", index: this.getIndex(), filename: this.fileInfo().filename };
                        }
                    }
                    for (m = 0; m < candidates.length; m++) {
                        candidate = candidates[m].group;
                        if ((candidate === defNone) || (candidate === defaultResult)) {
                            try {
                                mixin = candidates[m].mixin;
                                if (!(mixin instanceof Definition)) {
                                    originalRuleset = mixin.originalRuleset || mixin;
                                    mixin = new Definition('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
                                    mixin.originalRuleset = originalRuleset;
                                }
                                var newRules = mixin.evalCall(context, args, this.important).rules;
                                this._setVisibilityToReplacement(newRules);
                                Array.prototype.push.apply(rules, newRules);
                            }
                            catch (e) {
                                throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };
                            }
                        }
                    }
                    if (match) {
                        return rules;
                    }
                }
            }
            if (isOneFound) {
                throw { type: 'Runtime', message: "No matching definition was found for `" + this.format(args) + "`", index: this.getIndex(), filename: this.fileInfo().filename };
            }
            else {
                throw { type: 'Name', message: this.selector.toCSS().trim() + " is undefined", index: this.getIndex(), filename: this.fileInfo().filename };
            }
        },
        _setVisibilityToReplacement: function (replacement) {
            var i, rule;
            if (this.blocksVisibility()) {
                for (i = 0; i < replacement.length; i++) {
                    rule = replacement[i];
                    rule.addVisibilityBlock();
                }
            }
        },
        format: function (args) {
            return this.selector.toCSS().trim() + "(" + (args ? args.map(function (a) {
                var argValue = '';
                if (a.name) {
                    argValue += a.name + ":";
                }
                if (a.value.toCSS) {
                    argValue += a.value.toCSS();
                }
                else {
                    argValue += '???';
                }
                return argValue;
            }).join(', ') : '') + ")";
        }
    });

    var tree = {
        Node: Node, Color: Color, AtRule: AtRule, DetachedRuleset: DetachedRuleset, Operation: Operation,
        Dimension: Dimension, Unit: Unit, Keyword: Keyword, Variable: Variable, Property: Property,
        Ruleset: Ruleset, Element: Element, Attribute: Attribute, Combinator: Combinator, Selector: Selector,
        Quoted: Quoted, Expression: Expression, Declaration: Declaration, Call: Call, URL: URL, Import: Import,
        Comment: Comment, Anonymous: Anonymous, Value: Value, JavaScript: JavaScript, Assignment: Assignment,
        Condition: Condition, Paren: Paren, Media: Media, UnicodeDescriptor: UnicodeDescriptor, Negative: Negative,
        Extend: Extend, VariableCall: VariableCall, NamespaceValue: NamespaceValue,
        mixin: {
            Call: MixinCall,
            Definition: Definition
        }
    };

    var AbstractFileManager = /** @class */ (function () {
        function AbstractFileManager() {
        }
        AbstractFileManager.prototype.getPath = function (filename) {
            var j = filename.lastIndexOf('?');
            if (j > 0) {
                filename = filename.slice(0, j);
            }
            j = filename.lastIndexOf('/');
            if (j < 0) {
                j = filename.lastIndexOf('\\');
            }
            if (j < 0) {
                return '';
            }
            return filename.slice(0, j + 1);
        };
        AbstractFileManager.prototype.tryAppendExtension = function (path, ext) {
            return /(\.[a-z]*$)|([\?;].*)$/.test(path) ? path : path + ext;
        };
        AbstractFileManager.prototype.tryAppendLessExtension = function (path) {
            return this.tryAppendExtension(path, '.less');
        };
        AbstractFileManager.prototype.supportsSync = function () {
            return false;
        };
        AbstractFileManager.prototype.alwaysMakePathsAbsolute = function () {
            return false;
        };
        AbstractFileManager.prototype.isPathAbsolute = function (filename) {
            return (/^(?:[a-z-]+:|\/|\\|#)/i).test(filename);
        };
        // TODO: pull out / replace?
        AbstractFileManager.prototype.join = function (basePath, laterPath) {
            if (!basePath) {
                return laterPath;
            }
            return basePath + laterPath;
        };
        AbstractFileManager.prototype.pathDiff = function (url, baseUrl) {
            // diff between two paths to create a relative path
            var urlParts = this.extractUrlParts(url);
            var baseUrlParts = this.extractUrlParts(baseUrl);
            var i;
            var max;
            var urlDirectories;
            var baseUrlDirectories;
            var diff = '';
            if (urlParts.hostPart !== baseUrlParts.hostPart) {
                return '';
            }
            max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
            for (i = 0; i < max; i++) {
                if (baseUrlParts.directories[i] !== urlParts.directories[i]) {
                    break;
                }
            }
            baseUrlDirectories = baseUrlParts.directories.slice(i);
            urlDirectories = urlParts.directories.slice(i);
            for (i = 0; i < baseUrlDirectories.length - 1; i++) {
                diff += '../';
            }
            for (i = 0; i < urlDirectories.length - 1; i++) {
                diff += urlDirectories[i] + "/";
            }
            return diff;
        };
        // helper function, not part of API
        AbstractFileManager.prototype.extractUrlParts = function (url, baseUrl) {
            // urlParts[1] = protocol://hostname/ OR /
            // urlParts[2] = / if path relative to host base
            // urlParts[3] = directories
            // urlParts[4] = filename
            // urlParts[5] = parameters
            var urlPartsRegex = /^((?:[a-z-]+:)?\/{2}(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/i;
            var urlParts = url.match(urlPartsRegex);
            var returner = {};
            var rawDirectories = [];
            var directories = [];
            var i;
            var baseUrlParts;
            if (!urlParts) {
                throw new Error("Could not parse sheet href - '" + url + "'");
            }
            // Stylesheets in IE don't always return the full path
            if (baseUrl && (!urlParts[1] || urlParts[2])) {
                baseUrlParts = baseUrl.match(urlPartsRegex);
                if (!baseUrlParts) {
                    throw new Error("Could not parse page url - '" + baseUrl + "'");
                }
                urlParts[1] = urlParts[1] || baseUrlParts[1] || '';
                if (!urlParts[2]) {
                    urlParts[3] = baseUrlParts[3] + urlParts[3];
                }
            }
            if (urlParts[3]) {
                rawDirectories = urlParts[3].replace(/\\/g, '/').split('/');
                // collapse '..' and skip '.'
                for (i = 0; i < rawDirectories.length; i++) {
                    if (rawDirectories[i] === '..') {
                        directories.pop();
                    }
                    else if (rawDirectories[i] !== '.') {
                        directories.push(rawDirectories[i]);
                    }
                }
            }
            returner.hostPart = urlParts[1];
            returner.directories = directories;
            returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');
            returner.path = (urlParts[1] || '') + directories.join('/');
            returner.filename = urlParts[4];
            returner.fileUrl = returner.path + (urlParts[4] || '');
            returner.url = returner.fileUrl + (urlParts[5] || '');
            return returner;
        };
        return AbstractFileManager;
    }());

    var AbstractPluginLoader = /** @class */ (function () {
        function AbstractPluginLoader() {
            // Implemented by Node.js plugin loader
            this.require = function () {
                return null;
            };
        }
        AbstractPluginLoader.prototype.evalPlugin = function (contents, context, imports, pluginOptions, fileInfo) {
            var loader, registry, pluginObj, localModule, pluginManager, filename, result;
            pluginManager = context.pluginManager;
            if (fileInfo) {
                if (typeof fileInfo === 'string') {
                    filename = fileInfo;
                }
                else {
                    filename = fileInfo.filename;
                }
            }
            var shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;
            if (filename) {
                pluginObj = pluginManager.get(filename);
                if (pluginObj) {
                    result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                    if (result) {
                        return result;
                    }
                    try {
                        if (pluginObj.use) {
                            pluginObj.use.call(this.context, pluginObj);
                        }
                    }
                    catch (e) {
                        e.message = e.message || 'Error during @plugin call';
                        return new LessError(e, imports, filename);
                    }
                    return pluginObj;
                }
            }
            localModule = {
                exports: {},
                pluginManager: pluginManager,
                fileInfo: fileInfo
            };
            registry = functionRegistry.create();
            var registerPlugin = function (obj) {
                pluginObj = obj;
            };
            try {
                loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);
                loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);
            }
            catch (e) {
                return new LessError(e, imports, filename);
            }
            if (!pluginObj) {
                pluginObj = localModule.exports;
            }
            pluginObj = this.validatePlugin(pluginObj, filename, shortname);
            if (pluginObj instanceof LessError) {
                return pluginObj;
            }
            if (pluginObj) {
                pluginObj.imports = imports;
                pluginObj.filename = filename;
                // For < 3.x (or unspecified minVersion) - setOptions() before install()
                if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {
                    result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                    if (result) {
                        return result;
                    }
                }
                // Run on first load
                pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);
                pluginObj.functions = registry.getLocalFunctions();
                // Need to call setOptions again because the pluginObj might have functions
                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                if (result) {
                    return result;
                }
                // Run every @plugin call
                try {
                    if (pluginObj.use) {
                        pluginObj.use.call(this.context, pluginObj);
                    }
                }
                catch (e) {
                    e.message = e.message || 'Error during @plugin call';
                    return new LessError(e, imports, filename);
                }
            }
            else {
                return new LessError({ message: 'Not a valid plugin' }, imports, filename);
            }
            return pluginObj;
        };
        AbstractPluginLoader.prototype.trySetOptions = function (plugin, filename, name, options) {
            if (options && !plugin.setOptions) {
                return new LessError({
                    message: "Options have been provided but the plugin " + name + " does not support any options."
                });
            }
            try {
                plugin.setOptions && plugin.setOptions(options);
            }
            catch (e) {
                return new LessError(e);
            }
        };
        AbstractPluginLoader.prototype.validatePlugin = function (plugin, filename, name) {
            if (plugin) {
                // support plugins being a function
                // so that the plugin can be more usable programmatically
                if (typeof plugin === 'function') {
                    plugin = new plugin();
                }
                if (plugin.minVersion) {
                    if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {
                        return new LessError({
                            message: "Plugin " + name + " requires version " + this.versionToString(plugin.minVersion)
                        });
                    }
                }
                return plugin;
            }
            return null;
        };
        AbstractPluginLoader.prototype.compareVersion = function (aVersion, bVersion) {
            if (typeof aVersion === 'string') {
                aVersion = aVersion.match(/^(\d+)\.?(\d+)?\.?(\d+)?/);
                aVersion.shift();
            }
            for (var i = 0; i < aVersion.length; i++) {
                if (aVersion[i] !== bVersion[i]) {
                    return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;
                }
            }
            return 0;
        };
        AbstractPluginLoader.prototype.versionToString = function (version) {
            var versionString = '';
            for (var i = 0; i < version.length; i++) {
                versionString += (versionString ? '.' : '') + version[i];
            }
            return versionString;
        };
        AbstractPluginLoader.prototype.printUsage = function (plugins) {
            for (var i = 0; i < plugins.length; i++) {
                var plugin = plugins[i];
                if (plugin.printUsage) {
                    plugin.printUsage();
                }
            }
        };
        return AbstractPluginLoader;
    }());

    var _visitArgs = { visitDeeper: true };
    var _hasIndexed = false;
    function _noop(node) {
        return node;
    }
    function indexNodeTypes(parent, ticker) {
        // add .typeIndex to tree node types for lookup table
        var key, child;
        for (key in parent) {
            /* eslint guard-for-in: 0 */
            child = parent[key];
            switch (typeof child) {
                case 'function':
                    // ignore bound functions directly on tree which do not have a prototype
                    // or aren't nodes
                    if (child.prototype && child.prototype.type) {
                        child.prototype.typeIndex = ticker++;
                    }
                    break;
                case 'object':
                    ticker = indexNodeTypes(child, ticker);
                    break;
            }
        }
        return ticker;
    }
    var Visitor = /** @class */ (function () {
        function Visitor(implementation) {
            this._implementation = implementation;
            this._visitInCache = {};
            this._visitOutCache = {};
            if (!_hasIndexed) {
                indexNodeTypes(tree, 1);
                _hasIndexed = true;
            }
        }
        Visitor.prototype.visit = function (node) {
            if (!node) {
                return node;
            }
            var nodeTypeIndex = node.typeIndex;
            if (!nodeTypeIndex) {
                // MixinCall args aren't a node type?
                if (node.value && node.value.typeIndex) {
                    this.visit(node.value);
                }
                return node;
            }
            var impl = this._implementation;
            var func = this._visitInCache[nodeTypeIndex];
            var funcOut = this._visitOutCache[nodeTypeIndex];
            var visitArgs = _visitArgs;
            var fnName;
            visitArgs.visitDeeper = true;
            if (!func) {
                fnName = "visit" + node.type;
                func = impl[fnName] || _noop;
                funcOut = impl[fnName + "Out"] || _noop;
                this._visitInCache[nodeTypeIndex] = func;
                this._visitOutCache[nodeTypeIndex] = funcOut;
            }
            if (func !== _noop) {
                var newNode = func.call(impl, node, visitArgs);
                if (node && impl.isReplacing) {
                    node = newNode;
                }
            }
            if (visitArgs.visitDeeper && node) {
                if (node.length) {
                    for (var i = 0, cnt = node.length; i < cnt; i++) {
                        if (node[i].accept) {
                            node[i].accept(this);
                        }
                    }
                }
                else if (node.accept) {
                    node.accept(this);
                }
            }
            if (funcOut != _noop) {
                funcOut.call(impl, node);
            }
            return node;
        };
        Visitor.prototype.visitArray = function (nodes, nonReplacing) {
            if (!nodes) {
                return nodes;
            }
            var cnt = nodes.length;
            var i;
            // Non-replacing
            if (nonReplacing || !this._implementation.isReplacing) {
                for (i = 0; i < cnt; i++) {
                    this.visit(nodes[i]);
                }
                return nodes;
            }
            // Replacing
            var out = [];
            for (i = 0; i < cnt; i++) {
                var evald = this.visit(nodes[i]);
                if (evald === undefined) {
                    continue;
                }
                if (!evald.splice) {
                    out.push(evald);
                }
                else if (evald.length) {
                    this.flatten(evald, out);
                }
            }
            return out;
        };
        Visitor.prototype.flatten = function (arr, out) {
            if (!out) {
                out = [];
            }
            var cnt, i, item, nestedCnt, j, nestedItem;
            for (i = 0, cnt = arr.length; i < cnt; i++) {
                item = arr[i];
                if (item === undefined) {
                    continue;
                }
                if (!item.splice) {
                    out.push(item);
                    continue;
                }
                for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {
                    nestedItem = item[j];
                    if (nestedItem === undefined) {
                        continue;
                    }
                    if (!nestedItem.splice) {
                        out.push(nestedItem);
                    }
                    else if (nestedItem.length) {
                        this.flatten(nestedItem, out);
                    }
                }
            }
            return out;
        };
        return Visitor;
    }());

    var ImportSequencer = /** @class */ (function () {
        function ImportSequencer(onSequencerEmpty) {
            this.imports = [];
            this.variableImports = [];
            this._onSequencerEmpty = onSequencerEmpty;
            this._currentDepth = 0;
        }
        ImportSequencer.prototype.addImport = function (callback) {
            var importSequencer = this, importItem = {
                callback: callback,
                args: null,
                isReady: false
            };
            this.imports.push(importItem);
            return function () {
                importItem.args = Array.prototype.slice.call(arguments, 0);
                importItem.isReady = true;
                importSequencer.tryRun();
            };
        };
        ImportSequencer.prototype.addVariableImport = function (callback) {
            this.variableImports.push(callback);
        };
        ImportSequencer.prototype.tryRun = function () {
            this._currentDepth++;
            try {
                while (true) {
                    while (this.imports.length > 0) {
                        var importItem = this.imports[0];
                        if (!importItem.isReady) {
                            return;
                        }
                        this.imports = this.imports.slice(1);
                        importItem.callback.apply(null, importItem.args);
                    }
                    if (this.variableImports.length === 0) {
                        break;
                    }
                    var variableImport = this.variableImports[0];
                    this.variableImports = this.variableImports.slice(1);
                    variableImport();
                }
            }
            finally {
                this._currentDepth--;
            }
            if (this._currentDepth === 0 && this._onSequencerEmpty) {
                this._onSequencerEmpty();
            }
        };
        return ImportSequencer;
    }());

    var ImportVisitor = function (importer, finish) {
        this._visitor = new Visitor(this);
        this._importer = importer;
        this._finish = finish;
        this.context = new contexts.Eval();
        this.importCount = 0;
        this.onceFileDetectionMap = {};
        this.recursionDetector = {};
        this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));
    };
    ImportVisitor.prototype = {
        isReplacing: false,
        run: function (root) {
            try {
                // process the contents
                this._visitor.visit(root);
            }
            catch (e) {
                this.error = e;
            }
            this.isFinished = true;
            this._sequencer.tryRun();
        },
        _onSequencerEmpty: function () {
            if (!this.isFinished) {
                return;
            }
            this._finish(this.error);
        },
        visitImport: function (importNode, visitArgs) {
            var inlineCSS = importNode.options.inline;
            if (!importNode.css || inlineCSS) {
                var context = new contexts.Eval(this.context, copyArray(this.context.frames));
                var importParent = context.frames[0];
                this.importCount++;
                if (importNode.isVariableImport()) {
                    this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
                }
                else {
                    this.processImportNode(importNode, context, importParent);
                }
            }
            visitArgs.visitDeeper = false;
        },
        processImportNode: function (importNode, context, importParent) {
            var evaldImportNode;
            var inlineCSS = importNode.options.inline;
            try {
                evaldImportNode = importNode.evalForImport(context);
            }
            catch (e) {
                if (!e.filename) {
                    e.index = importNode.getIndex();
                    e.filename = importNode.fileInfo().filename;
                }
                // attempt to eval properly and treat as css
                importNode.css = true;
                // if that fails, this error will be thrown
                importNode.error = e;
            }
            if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {
                if (evaldImportNode.options.multiple) {
                    context.importMultiple = true;
                }
                // try appending if we haven't determined if it is css or not
                var tryAppendLessExtension = evaldImportNode.css === undefined;
                for (var i = 0; i < importParent.rules.length; i++) {
                    if (importParent.rules[i] === importNode) {
                        importParent.rules[i] = evaldImportNode;
                        break;
                    }
                }
                var onImported = this.onImported.bind(this, evaldImportNode, context), sequencedOnImported = this._sequencer.addImport(onImported);
                this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(), evaldImportNode.options, sequencedOnImported);
            }
            else {
                this.importCount--;
                if (this.isFinished) {
                    this._sequencer.tryRun();
                }
            }
        },
        onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {
            if (e) {
                if (!e.filename) {
                    e.index = importNode.getIndex();
                    e.filename = importNode.fileInfo().filename;
                }
                this.error = e;
            }
            var importVisitor = this, inlineCSS = importNode.options.inline, isPlugin = importNode.options.isPlugin, isOptional = importNode.options.optional, duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;
            if (!context.importMultiple) {
                if (duplicateImport) {
                    importNode.skip = true;
                }
                else {
                    importNode.skip = function () {
                        if (fullPath in importVisitor.onceFileDetectionMap) {
                            return true;
                        }
                        importVisitor.onceFileDetectionMap[fullPath] = true;
                        return false;
                    };
                }
            }
            if (!fullPath && isOptional) {
                importNode.skip = true;
            }
            if (root) {
                importNode.root = root;
                importNode.importedFilename = fullPath;
                if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
                    importVisitor.recursionDetector[fullPath] = true;
                    var oldContext = this.context;
                    this.context = context;
                    try {
                        this._visitor.visit(root);
                    }
                    catch (e) {
                        this.error = e;
                    }
                    this.context = oldContext;
                }
            }
            importVisitor.importCount--;
            if (importVisitor.isFinished) {
                importVisitor._sequencer.tryRun();
            }
        },
        visitDeclaration: function (declNode, visitArgs) {
            if (declNode.value.type === 'DetachedRuleset') {
                this.context.frames.unshift(declNode);
            }
            else {
                visitArgs.visitDeeper = false;
            }
        },
        visitDeclarationOut: function (declNode) {
            if (declNode.value.type === 'DetachedRuleset') {
                this.context.frames.shift();
            }
        },
        visitAtRule: function (atRuleNode, visitArgs) {
            this.context.frames.unshift(atRuleNode);
        },
        visitAtRuleOut: function (atRuleNode) {
            this.context.frames.shift();
        },
        visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
            this.context.frames.unshift(mixinDefinitionNode);
        },
        visitMixinDefinitionOut: function (mixinDefinitionNode) {
            this.context.frames.shift();
        },
        visitRuleset: function (rulesetNode, visitArgs) {
            this.context.frames.unshift(rulesetNode);
        },
        visitRulesetOut: function (rulesetNode) {
            this.context.frames.shift();
        },
        visitMedia: function (mediaNode, visitArgs) {
            this.context.frames.unshift(mediaNode.rules[0]);
        },
        visitMediaOut: function (mediaNode) {
            this.context.frames.shift();
        }
    };

    var SetTreeVisibilityVisitor = /** @class */ (function () {
        function SetTreeVisibilityVisitor(visible) {
            this.visible = visible;
        }
        SetTreeVisibilityVisitor.prototype.run = function (root) {
            this.visit(root);
        };
        SetTreeVisibilityVisitor.prototype.visitArray = function (nodes) {
            if (!nodes) {
                return nodes;
            }
            var cnt = nodes.length;
            var i;
            for (i = 0; i < cnt; i++) {
                this.visit(nodes[i]);
            }
            return nodes;
        };
        SetTreeVisibilityVisitor.prototype.visit = function (node) {
            if (!node) {
                return node;
            }
            if (node.constructor === Array) {
                return this.visitArray(node);
            }
            if (!node.blocksVisibility || node.blocksVisibility()) {
                return node;
            }
            if (this.visible) {
                node.ensureVisibility();
            }
            else {
                node.ensureInvisibility();
            }
            node.accept(this);
            return node;
        };
        return SetTreeVisibilityVisitor;
    }());

    /* jshint loopfunc:true */
    var ExtendFinderVisitor = /** @class */ (function () {
        function ExtendFinderVisitor() {
            this._visitor = new Visitor(this);
            this.contexts = [];
            this.allExtendsStack = [[]];
        }
        ExtendFinderVisitor.prototype.run = function (root) {
            root = this._visitor.visit(root);
            root.allExtends = this.allExtendsStack[0];
            return root;
        };
        ExtendFinderVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ExtendFinderVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ExtendFinderVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
            if (rulesetNode.root) {
                return;
            }
            var i;
            var j;
            var extend;
            var allSelectorsExtendList = [];
            var extendList;
            // get &:extend(.a); rules which apply to all selectors in this ruleset
            var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;
            for (i = 0; i < ruleCnt; i++) {
                if (rulesetNode.rules[i] instanceof tree.Extend) {
                    allSelectorsExtendList.push(rules[i]);
                    rulesetNode.extendOnEveryPath = true;
                }
            }
            // now find every selector and apply the extends that apply to all extends
            // and the ones which apply to an individual extend
            var paths = rulesetNode.paths;
            for (i = 0; i < paths.length; i++) {
                var selectorPath = paths[i], selector = selectorPath[selectorPath.length - 1], selExtendList = selector.extendList;
                extendList = selExtendList ? copyArray(selExtendList).concat(allSelectorsExtendList)
                    : allSelectorsExtendList;
                if (extendList) {
                    extendList = extendList.map(function (allSelectorsExtend) {
                        return allSelectorsExtend.clone();
                    });
                }
                for (j = 0; j < extendList.length; j++) {
                    this.foundExtends = true;
                    extend = extendList[j];
                    extend.findSelfSelectors(selectorPath);
                    extend.ruleset = rulesetNode;
                    if (j === 0) {
                        extend.firstExtendOnThisSelectorPath = true;
                    }
                    this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);
                }
            }
            this.contexts.push(rulesetNode.selectors);
        };
        ExtendFinderVisitor.prototype.visitRulesetOut = function (rulesetNode) {
            if (!rulesetNode.root) {
                this.contexts.length = this.contexts.length - 1;
            }
        };
        ExtendFinderVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
            mediaNode.allExtends = [];
            this.allExtendsStack.push(mediaNode.allExtends);
        };
        ExtendFinderVisitor.prototype.visitMediaOut = function (mediaNode) {
            this.allExtendsStack.length = this.allExtendsStack.length - 1;
        };
        ExtendFinderVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
            atRuleNode.allExtends = [];
            this.allExtendsStack.push(atRuleNode.allExtends);
        };
        ExtendFinderVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
            this.allExtendsStack.length = this.allExtendsStack.length - 1;
        };
        return ExtendFinderVisitor;
    }());
    var ProcessExtendsVisitor = /** @class */ (function () {
        function ProcessExtendsVisitor() {
            this._visitor = new Visitor(this);
        }
        ProcessExtendsVisitor.prototype.run = function (root) {
            var extendFinder = new ExtendFinderVisitor();
            this.extendIndices = {};
            extendFinder.run(root);
            if (!extendFinder.foundExtends) {
                return root;
            }
            root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));
            this.allExtendsStack = [root.allExtends];
            var newRoot = this._visitor.visit(root);
            this.checkExtendsForNonMatched(root.allExtends);
            return newRoot;
        };
        ProcessExtendsVisitor.prototype.checkExtendsForNonMatched = function (extendList) {
            var indices = this.extendIndices;
            extendList.filter(function (extend) {
                return !extend.hasFoundMatches && extend.parent_ids.length == 1;
            }).forEach(function (extend) {
                var selector = '_unknown_';
                try {
                    selector = extend.selector.toCSS({});
                }
                catch (_) { }
                if (!indices[extend.index + " " + selector]) {
                    indices[extend.index + " " + selector] = true;
                    logger.warn("extend '" + selector + "' has no matches");
                }
            });
        };
        ProcessExtendsVisitor.prototype.doExtendChaining = function (extendsList, extendsListTarget, iterationCount) {
            //
            // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering
            // and pasting the selector we would do normally, but we are also adding an extend with the same target selector
            // this means this new extend can then go and alter other extends
            //
            // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors
            // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already
            // processed if we look at each selector at a time, as is done in visitRuleset
            var extendIndex;
            var targetExtendIndex;
            var matches;
            var extendsToAdd = [];
            var newSelector;
            var extendVisitor = this;
            var selectorPath;
            var extend;
            var targetExtend;
            var newExtend;
            iterationCount = iterationCount || 0;
            // loop through comparing every extend with every target extend.
            // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place
            // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one
            // and the second is the target.
            // the separation into two lists allows us to process a subset of chains with a bigger set, as is the
            // case when processing media queries
            for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
                for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {
                    extend = extendsList[extendIndex];
                    targetExtend = extendsListTarget[targetExtendIndex];
                    // look for circular references
                    if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {
                        continue;
                    }
                    // find a match in the target extends self selector (the bit before :extend)
                    selectorPath = [targetExtend.selfSelectors[0]];
                    matches = extendVisitor.findMatch(extend, selectorPath);
                    if (matches.length) {
                        extend.hasFoundMatches = true;
                        // we found a match, so for each self selector..
                        extend.selfSelectors.forEach(function (selfSelector) {
                            var info = targetExtend.visibilityInfo();
                            // process the extend as usual
                            newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());
                            // but now we create a new extend from it
                            newExtend = new (tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);
                            newExtend.selfSelectors = newSelector;
                            // add the extend onto the list of extends for that selector
                            newSelector[newSelector.length - 1].extendList = [newExtend];
                            // record that we need to add it.
                            extendsToAdd.push(newExtend);
                            newExtend.ruleset = targetExtend.ruleset;
                            // remember its parents for circular references
                            newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);
                            // only process the selector once.. if we have :extend(.a,.b) then multiple
                            // extends will look at the same selector path, so when extending
                            // we know that any others will be duplicates in terms of what is added to the css
                            if (targetExtend.firstExtendOnThisSelectorPath) {
                                newExtend.firstExtendOnThisSelectorPath = true;
                                targetExtend.ruleset.paths.push(newSelector);
                            }
                        });
                    }
                }
            }
            if (extendsToAdd.length) {
                // try to detect circular references to stop a stack overflow.
                // may no longer be needed.
                this.extendChainCount++;
                if (iterationCount > 100) {
                    var selectorOne = '{unable to calculate}';
                    var selectorTwo = '{unable to calculate}';
                    try {
                        selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
                        selectorTwo = extendsToAdd[0].selector.toCSS();
                    }
                    catch (e) { }
                    throw { message: "extend circular reference detected. One of the circular extends is currently:" + selectorOne + ":extend(" + selectorTwo + ")" };
                }
                // now process the new extends on the existing rules so that we can handle a extending b extending c extending
                // d extending e...
                return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
            }
            else {
                return extendsToAdd;
            }
        };
        ProcessExtendsVisitor.prototype.visitDeclaration = function (ruleNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ProcessExtendsVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ProcessExtendsVisitor.prototype.visitSelector = function (selectorNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ProcessExtendsVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
            if (rulesetNode.root) {
                return;
            }
            var matches;
            var pathIndex;
            var extendIndex;
            var allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];
            var selectorsToAdd = [];
            var extendVisitor = this;
            var selectorPath;
            // look at each selector path in the ruleset, find any extend matches and then copy, find and replace
            for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
                for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
                    selectorPath = rulesetNode.paths[pathIndex];
                    // extending extends happens initially, before the main pass
                    if (rulesetNode.extendOnEveryPath) {
                        continue;
                    }
                    var extendList = selectorPath[selectorPath.length - 1].extendList;
                    if (extendList && extendList.length) {
                        continue;
                    }
                    matches = this.findMatch(allExtends[extendIndex], selectorPath);
                    if (matches.length) {
                        allExtends[extendIndex].hasFoundMatches = true;
                        allExtends[extendIndex].selfSelectors.forEach(function (selfSelector) {
                            var extendedSelectors;
                            extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
                            selectorsToAdd.push(extendedSelectors);
                        });
                    }
                }
            }
            rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
        };
        ProcessExtendsVisitor.prototype.findMatch = function (extend, haystackSelectorPath) {
            //
            // look through the haystack selector path to try and find the needle - extend.selector
            // returns an array of selector matches that can then be replaced
            //
            var haystackSelectorIndex;
            var hackstackSelector;
            var hackstackElementIndex;
            var haystackElement;
            var targetCombinator;
            var i;
            var extendVisitor = this;
            var needleElements = extend.selector.elements;
            var potentialMatches = [];
            var potentialMatch;
            var matches = [];
            // loop through the haystack elements
            for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
                hackstackSelector = haystackSelectorPath[haystackSelectorIndex];
                for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {
                    haystackElement = hackstackSelector.elements[hackstackElementIndex];
                    // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.
                    if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {
                        potentialMatches.push({ pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,
                            initialCombinator: haystackElement.combinator });
                    }
                    for (i = 0; i < potentialMatches.length; i++) {
                        potentialMatch = potentialMatches[i];
                        // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don't
                        // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to
                        // work out what the resulting combinator will be
                        targetCombinator = haystackElement.combinator.value;
                        if (targetCombinator === '' && hackstackElementIndex === 0) {
                            targetCombinator = ' ';
                        }
                        // if we don't match, null our match to indicate failure
                        if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||
                            (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {
                            potentialMatch = null;
                        }
                        else {
                            potentialMatch.matched++;
                        }
                        // if we are still valid and have finished, test whether we have elements after and whether these are allowed
                        if (potentialMatch) {
                            potentialMatch.finished = potentialMatch.matched === needleElements.length;
                            if (potentialMatch.finished &&
                                (!extend.allowAfter &&
                                    (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {
                                potentialMatch = null;
                            }
                        }
                        // if null we remove, if not, we are still valid, so either push as a valid match or continue
                        if (potentialMatch) {
                            if (potentialMatch.finished) {
                                potentialMatch.length = needleElements.length;
                                potentialMatch.endPathIndex = haystackSelectorIndex;
                                potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match
                                potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again
                                matches.push(potentialMatch);
                            }
                        }
                        else {
                            potentialMatches.splice(i, 1);
                            i--;
                        }
                    }
                }
            }
            return matches;
        };
        ProcessExtendsVisitor.prototype.isElementValuesEqual = function (elementValue1, elementValue2) {
            if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {
                return elementValue1 === elementValue2;
            }
            if (elementValue1 instanceof tree.Attribute) {
                if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
                    return false;
                }
                if (!elementValue1.value || !elementValue2.value) {
                    if (elementValue1.value || elementValue2.value) {
                        return false;
                    }
                    return true;
                }
                elementValue1 = elementValue1.value.value || elementValue1.value;
                elementValue2 = elementValue2.value.value || elementValue2.value;
                return elementValue1 === elementValue2;
            }
            elementValue1 = elementValue1.value;
            elementValue2 = elementValue2.value;
            if (elementValue1 instanceof tree.Selector) {
                if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
                    return false;
                }
                for (var i = 0; i < elementValue1.elements.length; i++) {
                    if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {
                        if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {
                            return false;
                        }
                    }
                    if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        ProcessExtendsVisitor.prototype.extendSelector = function (matches, selectorPath, replacementSelector, isVisible) {
            // for a set of matches, replace each match with the replacement selector
            var currentSelectorPathIndex = 0, currentSelectorPathElementIndex = 0, path = [], matchIndex, selector, firstElement, match, newElements;
            for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
                match = matches[matchIndex];
                selector = selectorPath[match.pathIndex];
                firstElement = new tree.Element(match.initialCombinator, replacementSelector.elements[0].value, replacementSelector.elements[0].isVariable, replacementSelector.elements[0].getIndex(), replacementSelector.elements[0].fileInfo());
                if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
                    path[path.length - 1].elements = path[path.length - 1]
                        .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
                    currentSelectorPathElementIndex = 0;
                    currentSelectorPathIndex++;
                }
                newElements = selector.elements
                    .slice(currentSelectorPathElementIndex, match.index)
                    .concat([firstElement])
                    .concat(replacementSelector.elements.slice(1));
                if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
                    path[path.length - 1].elements =
                        path[path.length - 1].elements.concat(newElements);
                }
                else {
                    path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));
                    path.push(new tree.Selector(newElements));
                }
                currentSelectorPathIndex = match.endPathIndex;
                currentSelectorPathElementIndex = match.endPathElementIndex;
                if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
                    currentSelectorPathElementIndex = 0;
                    currentSelectorPathIndex++;
                }
            }
            if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
                path[path.length - 1].elements = path[path.length - 1]
                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
                currentSelectorPathIndex++;
            }
            path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
            path = path.map(function (currentValue) {
                // we can re-use elements here, because the visibility property matters only for selectors
                var derived = currentValue.createDerived(currentValue.elements);
                if (isVisible) {
                    derived.ensureVisibility();
                }
                else {
                    derived.ensureInvisibility();
                }
                return derived;
            });
            return path;
        };
        ProcessExtendsVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
            var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
            newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
            this.allExtendsStack.push(newAllExtends);
        };
        ProcessExtendsVisitor.prototype.visitMediaOut = function (mediaNode) {
            var lastIndex = this.allExtendsStack.length - 1;
            this.allExtendsStack.length = lastIndex;
        };
        ProcessExtendsVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
            var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
            newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));
            this.allExtendsStack.push(newAllExtends);
        };
        ProcessExtendsVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
            var lastIndex = this.allExtendsStack.length - 1;
            this.allExtendsStack.length = lastIndex;
        };
        return ProcessExtendsVisitor;
    }());

    var JoinSelectorVisitor = /** @class */ (function () {
        function JoinSelectorVisitor() {
            this.contexts = [[]];
            this._visitor = new Visitor(this);
        }
        JoinSelectorVisitor.prototype.run = function (root) {
            return this._visitor.visit(root);
        };
        JoinSelectorVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        JoinSelectorVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        JoinSelectorVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
            var context = this.contexts[this.contexts.length - 1];
            var paths = [];
            var selectors;
            this.contexts.push(paths);
            if (!rulesetNode.root) {
                selectors = rulesetNode.selectors;
                if (selectors) {
                    selectors = selectors.filter(function (selector) { return selector.getIsOutput(); });
                    rulesetNode.selectors = selectors.length ? selectors : (selectors = null);
                    if (selectors) {
                        rulesetNode.joinSelectors(paths, context, selectors);
                    }
                }
                if (!selectors) {
                    rulesetNode.rules = null;
                }
                rulesetNode.paths = paths;
            }
        };
        JoinSelectorVisitor.prototype.visitRulesetOut = function (rulesetNode) {
            this.contexts.length = this.contexts.length - 1;
        };
        JoinSelectorVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
            var context = this.contexts[this.contexts.length - 1];
            mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);
        };
        JoinSelectorVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
            var context = this.contexts[this.contexts.length - 1];
            if (atRuleNode.rules && atRuleNode.rules.length) {
                atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);
            }
        };
        return JoinSelectorVisitor;
    }());

    var CSSVisitorUtils = /** @class */ (function () {
        function CSSVisitorUtils(context) {
            this._visitor = new Visitor(this);
            this._context = context;
        }
        CSSVisitorUtils.prototype.containsSilentNonBlockedChild = function (bodyRules) {
            var rule;
            if (!bodyRules) {
                return false;
            }
            for (var r = 0; r < bodyRules.length; r++) {
                rule = bodyRules[r];
                if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
                    // the atrule contains something that was referenced (likely by extend)
                    // therefore it needs to be shown in output too
                    return true;
                }
            }
            return false;
        };
        CSSVisitorUtils.prototype.keepOnlyVisibleChilds = function (owner) {
            if (owner && owner.rules) {
                owner.rules = owner.rules.filter(function (thing) { return thing.isVisible(); });
            }
        };
        CSSVisitorUtils.prototype.isEmpty = function (owner) {
            return (owner && owner.rules)
                ? (owner.rules.length === 0) : true;
        };
        CSSVisitorUtils.prototype.hasVisibleSelector = function (rulesetNode) {
            return (rulesetNode && rulesetNode.paths)
                ? (rulesetNode.paths.length > 0) : false;
        };
        CSSVisitorUtils.prototype.resolveVisibility = function (node, originalRules) {
            if (!node.blocksVisibility()) {
                if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {
                    return;
                }
                return node;
            }
            var compiledRulesBody = node.rules[0];
            this.keepOnlyVisibleChilds(compiledRulesBody);
            if (this.isEmpty(compiledRulesBody)) {
                return;
            }
            node.ensureVisibility();
            node.removeVisibilityBlock();
            return node;
        };
        CSSVisitorUtils.prototype.isVisibleRuleset = function (rulesetNode) {
            if (rulesetNode.firstRoot) {
                return true;
            }
            if (this.isEmpty(rulesetNode)) {
                return false;
            }
            if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
                return false;
            }
            return true;
        };
        return CSSVisitorUtils;
    }());
    var ToCSSVisitor = function (context) {
        this._visitor = new Visitor(this);
        this._context = context;
        this.utils = new CSSVisitorUtils(context);
    };
    ToCSSVisitor.prototype = {
        isReplacing: true,
        run: function (root) {
            return this._visitor.visit(root);
        },
        visitDeclaration: function (declNode, visitArgs) {
            if (declNode.blocksVisibility() || declNode.variable) {
                return;
            }
            return declNode;
        },
        visitMixinDefinition: function (mixinNode, visitArgs) {
            // mixin definitions do not get eval'd - this means they keep state
            // so we have to clear that state here so it isn't used if toCSS is called twice
            mixinNode.frames = [];
        },
        visitExtend: function (extendNode, visitArgs) {
        },
        visitComment: function (commentNode, visitArgs) {
            if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
                return;
            }
            return commentNode;
        },
        visitMedia: function (mediaNode, visitArgs) {
            var originalRules = mediaNode.rules[0].rules;
            mediaNode.accept(this._visitor);
            visitArgs.visitDeeper = false;
            return this.utils.resolveVisibility(mediaNode, originalRules);
        },
        visitImport: function (importNode, visitArgs) {
            if (importNode.blocksVisibility()) {
                return;
            }
            return importNode;
        },
        visitAtRule: function (atRuleNode, visitArgs) {
            if (atRuleNode.rules && atRuleNode.rules.length) {
                return this.visitAtRuleWithBody(atRuleNode, visitArgs);
            }
            else {
                return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);
            }
        },
        visitAnonymous: function (anonymousNode, visitArgs) {
            if (!anonymousNode.blocksVisibility()) {
                anonymousNode.accept(this._visitor);
                return anonymousNode;
            }
        },
        visitAtRuleWithBody: function (atRuleNode, visitArgs) {
            // if there is only one nested ruleset and that one has no path, then it is
            // just fake ruleset
            function hasFakeRuleset(atRuleNode) {
                var bodyRules = atRuleNode.rules;
                return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
            }
            function getBodyRules(atRuleNode) {
                var nodeRules = atRuleNode.rules;
                if (hasFakeRuleset(atRuleNode)) {
                    return nodeRules[0].rules;
                }
                return nodeRules;
            }
            // it is still true that it is only one ruleset in array
            // this is last such moment
            // process childs
            var originalRules = getBodyRules(atRuleNode);
            atRuleNode.accept(this._visitor);
            visitArgs.visitDeeper = false;
            if (!this.utils.isEmpty(atRuleNode)) {
                this._mergeRules(atRuleNode.rules[0].rules);
            }
            return this.utils.resolveVisibility(atRuleNode, originalRules);
        },
        visitAtRuleWithoutBody: function (atRuleNode, visitArgs) {
            if (atRuleNode.blocksVisibility()) {
                return;
            }
            if (atRuleNode.name === '@charset') {
                // Only output the debug info together with subsequent @charset definitions
                // a comment (or @media statement) before the actual @charset atrule would
                // be considered illegal css as it has to be on the first line
                if (this.charset) {
                    if (atRuleNode.debugInfo) {
                        var comment = new tree.Comment("/* " + atRuleNode.toCSS(this._context).replace(/\n/g, '') + " */\n");
                        comment.debugInfo = atRuleNode.debugInfo;
                        return this._visitor.visit(comment);
                    }
                    return;
                }
                this.charset = true;
            }
            return atRuleNode;
        },
        checkValidNodes: function (rules, isRoot) {
            if (!rules) {
                return;
            }
            for (var i = 0; i < rules.length; i++) {
                var ruleNode = rules[i];
                if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {
                    throw { message: 'Properties must be inside selector blocks. They cannot be in the root',
                        index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
                }
                if (ruleNode instanceof tree.Call) {
                    throw { message: "Function '" + ruleNode.name + "' did not return a root node", index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
                }
                if (ruleNode.type && !ruleNode.allowRoot) {
                    throw { message: ruleNode.type + " node returned by a function is not valid here", index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
                }
            }
        },
        visitRuleset: function (rulesetNode, visitArgs) {
            // at this point rulesets are nested into each other
            var rule;
            var rulesets = [];
            this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);
            if (!rulesetNode.root) {
                // remove invisible paths
                this._compileRulesetPaths(rulesetNode);
                // remove rulesets from this ruleset body and compile them separately
                var nodeRules = rulesetNode.rules;
                var nodeRuleCnt = nodeRules ? nodeRules.length : 0;
                for (var i = 0; i < nodeRuleCnt;) {
                    rule = nodeRules[i];
                    if (rule && rule.rules) {
                        // visit because we are moving them out from being a child
                        rulesets.push(this._visitor.visit(rule));
                        nodeRules.splice(i, 1);
                        nodeRuleCnt--;
                        continue;
                    }
                    i++;
                }
                // accept the visitor to remove rules and refactor itself
                // then we can decide nogw whether we want it or not
                // compile body
                if (nodeRuleCnt > 0) {
                    rulesetNode.accept(this._visitor);
                }
                else {
                    rulesetNode.rules = null;
                }
                visitArgs.visitDeeper = false;
            }
            else { // if (! rulesetNode.root) {
                rulesetNode.accept(this._visitor);
                visitArgs.visitDeeper = false;
            }
            if (rulesetNode.rules) {
                this._mergeRules(rulesetNode.rules);
                this._removeDuplicateRules(rulesetNode.rules);
            }
            // now decide whether we keep the ruleset
            if (this.utils.isVisibleRuleset(rulesetNode)) {
                rulesetNode.ensureVisibility();
                rulesets.splice(0, 0, rulesetNode);
            }
            if (rulesets.length === 1) {
                return rulesets[0];
            }
            return rulesets;
        },
        _compileRulesetPaths: function (rulesetNode) {
            if (rulesetNode.paths) {
                rulesetNode.paths = rulesetNode.paths
                    .filter(function (p) {
                    var i;
                    if (p[0].elements[0].combinator.value === ' ') {
                        p[0].elements[0].combinator = new (tree.Combinator)('');
                    }
                    for (i = 0; i < p.length; i++) {
                        if (p[i].isVisible() && p[i].getIsOutput()) {
                            return true;
                        }
                    }
                    return false;
                });
            }
        },
        _removeDuplicateRules: function (rules) {
            if (!rules) {
                return;
            }
            // remove duplicates
            var ruleCache = {};
            var ruleList;
            var rule;
            var i;
            for (i = rules.length - 1; i >= 0; i--) {
                rule = rules[i];
                if (rule instanceof tree.Declaration) {
                    if (!ruleCache[rule.name]) {
                        ruleCache[rule.name] = rule;
                    }
                    else {
                        ruleList = ruleCache[rule.name];
                        if (ruleList instanceof tree.Declaration) {
                            ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
                        }
                        var ruleCSS = rule.toCSS(this._context);
                        if (ruleList.indexOf(ruleCSS) !== -1) {
                            rules.splice(i, 1);
                        }
                        else {
                            ruleList.push(ruleCSS);
                        }
                    }
                }
            }
        },
        _mergeRules: function (rules) {
            if (!rules) {
                return;
            }
            var groups = {};
            var groupsArr = [];
            for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (rule.merge) {
                    var key = rule.name;
                    groups[key] ? rules.splice(i--, 1) :
                        groupsArr.push(groups[key] = []);
                    groups[key].push(rule);
                }
            }
            groupsArr.forEach(function (group) {
                if (group.length > 0) {
                    var result_1 = group[0];
                    var space_1 = [];
                    var comma_1 = [new tree.Expression(space_1)];
                    group.forEach(function (rule) {
                        if ((rule.merge === '+') && (space_1.length > 0)) {
                            comma_1.push(new tree.Expression(space_1 = []));
                        }
                        space_1.push(rule.value);
                        result_1.important = result_1.important || rule.important;
                    });
                    result_1.value = new tree.Value(comma_1);
                }
            });
        }
    };

    var visitors = {
        Visitor: Visitor,
        ImportVisitor: ImportVisitor,
        MarkVisibleSelectorsVisitor: SetTreeVisibilityVisitor,
        ExtendVisitor: ProcessExtendsVisitor,
        JoinSelectorVisitor: JoinSelectorVisitor,
        ToCSSVisitor: ToCSSVisitor
    };

    // Split the input into chunks.
    function chunker (input, fail) {
        var len = input.length;
        var level = 0;
        var parenLevel = 0;
        var lastOpening;
        var lastOpeningParen;
        var lastMultiComment;
        var lastMultiCommentEndBrace;
        var chunks = [];
        var emitFrom = 0;
        var chunkerCurrentIndex;
        var currentChunkStartIndex;
        var cc;
        var cc2;
        var matched;
        function emitChunk(force) {
            var len = chunkerCurrentIndex - emitFrom;
            if (((len < 512) && !force) || !len) {
                return;
            }
            chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
            emitFrom = chunkerCurrentIndex + 1;
        }
        for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
            cc = input.charCodeAt(chunkerCurrentIndex);
            if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {
                // a-z or whitespace
                continue;
            }
            switch (cc) {
                case 40: // (
                    parenLevel++;
                    lastOpeningParen = chunkerCurrentIndex;
                    continue;
                case 41: // )
                    if (--parenLevel < 0) {
                        return fail('missing opening `(`', chunkerCurrentIndex);
                    }
                    continue;
                case 59: // ;
                    if (!parenLevel) {
                        emitChunk();
                    }
                    continue;
                case 123: // {
                    level++;
                    lastOpening = chunkerCurrentIndex;
                    continue;
                case 125: // }
                    if (--level < 0) {
                        return fail('missing opening `{`', chunkerCurrentIndex);
                    }
                    if (!level && !parenLevel) {
                        emitChunk();
                    }
                    continue;
                case 92: // \
                    if (chunkerCurrentIndex < len - 1) {
                        chunkerCurrentIndex++;
                        continue;
                    }
                    return fail('unescaped `\\`', chunkerCurrentIndex);
                case 34:
                case 39:
                case 96: // ", ' and `
                    matched = 0;
                    currentChunkStartIndex = chunkerCurrentIndex;
                    for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                        cc2 = input.charCodeAt(chunkerCurrentIndex);
                        if (cc2 > 96) {
                            continue;
                        }
                        if (cc2 == cc) {
                            matched = 1;
                            break;
                        }
                        if (cc2 == 92) { // \
                            if (chunkerCurrentIndex == len - 1) {
                                return fail('unescaped `\\`', chunkerCurrentIndex);
                            }
                            chunkerCurrentIndex++;
                        }
                    }
                    if (matched) {
                        continue;
                    }
                    return fail("unmatched `" + String.fromCharCode(cc) + "`", currentChunkStartIndex);
                case 47: // /, check for comment
                    if (parenLevel || (chunkerCurrentIndex == len - 1)) {
                        continue;
                    }
                    cc2 = input.charCodeAt(chunkerCurrentIndex + 1);
                    if (cc2 == 47) {
                        // //, find lnfeed
                        for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                            cc2 = input.charCodeAt(chunkerCurrentIndex);
                            if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) {
                                break;
                            }
                        }
                    }
                    else if (cc2 == 42) {
                        // /*, find */
                        lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
                        for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
                            cc2 = input.charCodeAt(chunkerCurrentIndex);
                            if (cc2 == 125) {
                                lastMultiCommentEndBrace = chunkerCurrentIndex;
                            }
                            if (cc2 != 42) {
                                continue;
                            }
                            if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
                                break;
                            }
                        }
                        if (chunkerCurrentIndex == len - 1) {
                            return fail('missing closing `*/`', currentChunkStartIndex);
                        }
                        chunkerCurrentIndex++;
                    }
                    continue;
                case 42: // *, check for unmatched */
                    if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {
                        return fail('unmatched `/*`', chunkerCurrentIndex);
                    }
                    continue;
            }
        }
        if (level !== 0) {
            if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {
                return fail('missing closing `}` or `*/`', lastOpening);
            }
            else {
                return fail('missing closing `}`', lastOpening);
            }
        }
        else if (parenLevel !== 0) {
            return fail('missing closing `)`', lastOpeningParen);
        }
        emitChunk(true);
        return chunks;
    }

    var getParserInput = (function () {
        var // Less input string
        input;
        var // current chunk
        j;
        var // holds state for backtracking
        saveStack = [];
        var // furthest index the parser has gone to
        furthest;
        var // if this is furthest we got to, this is the probably cause
        furthestPossibleErrorMessage;
        var // chunkified input
        chunks;
        var // current chunk
        current;
        var // index of current chunk, in `input`
        currentPos;
        var parserInput = {};
        var CHARCODE_SPACE = 32;
        var CHARCODE_TAB = 9;
        var CHARCODE_LF = 10;
        var CHARCODE_CR = 13;
        var CHARCODE_PLUS = 43;
        var CHARCODE_COMMA = 44;
        var CHARCODE_FORWARD_SLASH = 47;
        var CHARCODE_9 = 57;
        function skipWhitespace(length) {
            var oldi = parserInput.i;
            var oldj = j;
            var curr = parserInput.i - currentPos;
            var endIndex = parserInput.i + current.length - curr;
            var mem = (parserInput.i += length);
            var inp = input;
            var c;
            var nextChar;
            var comment;
            for (; parserInput.i < endIndex; parserInput.i++) {
                c = inp.charCodeAt(parserInput.i);
                if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {
                    nextChar = inp.charAt(parserInput.i + 1);
                    if (nextChar === '/') {
                        comment = { index: parserInput.i, isLineComment: true };
                        var nextNewLine = inp.indexOf('\n', parserInput.i + 2);
                        if (nextNewLine < 0) {
                            nextNewLine = endIndex;
                        }
                        parserInput.i = nextNewLine;
                        comment.text = inp.substr(comment.index, parserInput.i - comment.index);
                        parserInput.commentStore.push(comment);
                        continue;
                    }
                    else if (nextChar === '*') {
                        var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);
                        if (nextStarSlash >= 0) {
                            comment = {
                                index: parserInput.i,
                                text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
                                isLineComment: false
                            };
                            parserInput.i += comment.text.length - 1;
                            parserInput.commentStore.push(comment);
                            continue;
                        }
                    }
                    break;
                }
                if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {
                    break;
                }
            }
            current = current.slice(length + parserInput.i - mem + curr);
            currentPos = parserInput.i;
            if (!current.length) {
                if (j < chunks.length - 1) {
                    current = chunks[++j];
                    skipWhitespace(0); // skip space at the beginning of a chunk
                    return true; // things changed
                }
                parserInput.finished = true;
            }
            return oldi !== parserInput.i || oldj !== j;
        }
        parserInput.save = function () {
            currentPos = parserInput.i;
            saveStack.push({ current: current, i: parserInput.i, j: j });
        };
        parserInput.restore = function (possibleErrorMessage) {
            if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {
                furthest = parserInput.i;
                furthestPossibleErrorMessage = possibleErrorMessage;
            }
            var state = saveStack.pop();
            current = state.current;
            currentPos = parserInput.i = state.i;
            j = state.j;
        };
        parserInput.forget = function () {
            saveStack.pop();
        };
        parserInput.isWhitespace = function (offset) {
            var pos = parserInput.i + (offset || 0);
            var code = input.charCodeAt(pos);
            return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);
        };
        // Specialization of $(tok)
        parserInput.$re = function (tok) {
            if (parserInput.i > currentPos) {
                current = current.slice(parserInput.i - currentPos);
                currentPos = parserInput.i;
            }
            var m = tok.exec(current);
            if (!m) {
                return null;
            }
            skipWhitespace(m[0].length);
            if (typeof m === 'string') {
                return m;
            }
            return m.length === 1 ? m[0] : m;
        };
        parserInput.$char = function (tok) {
            if (input.charAt(parserInput.i) !== tok) {
                return null;
            }
            skipWhitespace(1);
            return tok;
        };
        parserInput.$str = function (tok) {
            var tokLength = tok.length;
            // https://jsperf.com/string-startswith/21
            for (var i = 0; i < tokLength; i++) {
                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
                    return null;
                }
            }
            skipWhitespace(tokLength);
            return tok;
        };
        parserInput.$quoted = function (loc) {
            var pos = loc || parserInput.i;
            var startChar = input.charAt(pos);
            if (startChar !== '\'' && startChar !== '"') {
                return;
            }
            var length = input.length;
            var currentPosition = pos;
            for (var i = 1; i + currentPosition < length; i++) {
                var nextChar = input.charAt(i + currentPosition);
                switch (nextChar) {
                    case '\\':
                        i++;
                        continue;
                    case '\r':
                    case '\n':
                        break;
                    case startChar:
                        var str = input.substr(currentPosition, i + 1);
                        if (!loc && loc !== 0) {
                            skipWhitespace(i + 1);
                            return str;
                        }
                        return [startChar, str];
                }
            }
            return null;
        };
        /**
         * Permissive parsing. Ignores everything except matching {} [] () and quotes
         * until matching token (outside of blocks)
         */
        parserInput.$parseUntil = function (tok) {
            var quote = '';
            var returnVal = null;
            var inComment = false;
            var blockDepth = 0;
            var blockStack = [];
            var parseGroups = [];
            var length = input.length;
            var startPos = parserInput.i;
            var lastPos = parserInput.i;
            var i = parserInput.i;
            var loop = true;
            var testChar;
            if (typeof tok === 'string') {
                testChar = function (char) { return char === tok; };
            }
            else {
                testChar = function (char) { return tok.test(char); };
            }
            do {
                var nextChar = input.charAt(i);
                if (blockDepth === 0 && testChar(nextChar)) {
                    returnVal = input.substr(lastPos, i - lastPos);
                    if (returnVal) {
                        parseGroups.push(returnVal);
                    }
                    else {
                        parseGroups.push(' ');
                    }
                    returnVal = parseGroups;
                    skipWhitespace(i - startPos);
                    loop = false;
                }
                else {
                    if (inComment) {
                        if (nextChar === '*' &&
                            input.charAt(i + 1) === '/') {
                            i++;
                            blockDepth--;
                            inComment = false;
                        }
                        i++;
                        continue;
                    }
                    switch (nextChar) {
                        case '\\':
                            i++;
                            nextChar = input.charAt(i);
                            parseGroups.push(input.substr(lastPos, i - lastPos + 1));
                            lastPos = i + 1;
                            break;
                        case '/':
                            if (input.charAt(i + 1) === '*') {
                                i++;
                                inComment = true;
                                blockDepth++;
                            }
                            break;
                        case '\'':
                        case '"':
                            quote = parserInput.$quoted(i);
                            if (quote) {
                                parseGroups.push(input.substr(lastPos, i - lastPos), quote);
                                i += quote[1].length - 1;
                                lastPos = i + 1;
                            }
                            else {
                                skipWhitespace(i - startPos);
                                returnVal = nextChar;
                                loop = false;
                            }
                            break;
                        case '{':
                            blockStack.push('}');
                            blockDepth++;
                            break;
                        case '(':
                            blockStack.push(')');
                            blockDepth++;
                            break;
                        case '[':
                            blockStack.push(']');
                            blockDepth++;
                            break;
                        case '}':
                        case ')':
                        case ']':
                            var expected = blockStack.pop();
                            if (nextChar === expected) {
                                blockDepth--;
                            }
                            else {
                                // move the parser to the error and return expected
                                skipWhitespace(i - startPos);
                                returnVal = expected;
                                loop = false;
                            }
                    }
                    i++;
                    if (i > length) {
                        loop = false;
                    }
                }
            } while (loop);
            return returnVal ? returnVal : null;
        };
        parserInput.autoCommentAbsorb = true;
        parserInput.commentStore = [];
        parserInput.finished = false;
        // Same as $(), but don't change the state of the parser,
        // just return the match.
        parserInput.peek = function (tok) {
            if (typeof tok === 'string') {
                // https://jsperf.com/string-startswith/21
                for (var i = 0; i < tok.length; i++) {
                    if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
                        return false;
                    }
                }
                return true;
            }
            else {
                return tok.test(current);
            }
        };
        // Specialization of peek()
        // TODO remove or change some currentChar calls to peekChar
        parserInput.peekChar = function (tok) { return input.charAt(parserInput.i) === tok; };
        parserInput.currentChar = function () { return input.charAt(parserInput.i); };
        parserInput.prevChar = function () { return input.charAt(parserInput.i - 1); };
        parserInput.getInput = function () { return input; };
        parserInput.peekNotNumeric = function () {
            var c = input.charCodeAt(parserInput.i);
            // Is the first char of the dimension 0-9, '.', '+' or '-'
            return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;
        };
        parserInput.start = function (str, chunkInput, failFunction) {
            input = str;
            parserInput.i = j = currentPos = furthest = 0;
            // chunking apparently makes things quicker (but my tests indicate
            // it might actually make things slower in node at least)
            // and it is a non-perfect parse - it can't recognise
            // unquoted urls, meaning it can't distinguish comments
            // meaning comments with quotes or {}() in them get 'counted'
            // and then lead to parse errors.
            // In addition if the chunking chunks in the wrong place we might
            // not be able to parse a parser statement in one go
            // this is officially deprecated but can be switched on via an option
            // in the case it causes too much performance issues.
            if (chunkInput) {
                chunks = chunker(str, failFunction);
            }
            else {
                chunks = [str];
            }
            current = chunks[0];
            skipWhitespace(0);
        };
        parserInput.end = function () {
            var message;
            var isFinished = parserInput.i >= input.length;
            if (parserInput.i < furthest) {
                message = furthestPossibleErrorMessage;
                parserInput.i = furthest;
            }
            return {
                isFinished: isFinished,
                furthest: parserInput.i,
                furthestPossibleErrorMessage: message,
                furthestReachedEnd: parserInput.i >= input.length - 1,
                furthestChar: input[parserInput.i]
            };
        };
        return parserInput;
    });

    //
    // less.js - parser
    //
    //    A relatively straight-forward predictive parser.
    //    There is no tokenization/lexing stage, the input is parsed
    //    in one sweep.
    //
    //    To make the parser fast enough to run in the browser, several
    //    optimization had to be made:
    //
    //    - Matching and slicing on a huge input is often cause of slowdowns.
    //      The solution is to chunkify the input into smaller strings.
    //      The chunks are stored in the `chunks` var,
    //      `j` holds the current chunk index, and `currentPos` holds
    //      the index of the current chunk in relation to `input`.
    //      This gives us an almost 4x speed-up.
    //
    //    - In many cases, we don't need to match individual tokens;
    //      for example, if a value doesn't hold any variables, operations
    //      or dynamic references, the parser can effectively 'skip' it,
    //      treating it as a literal.
    //      An example would be '1px solid #000' - which evaluates to itself,
    //      we don't need to know what the individual components are.
    //      The drawback, of course is that you don't get the benefits of
    //      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
    //      and a smaller speed-up in the code-gen.
    //
    //
    //    Token matching is done with the `$` function, which either takes
    //    a terminal string or regexp, or a non-terminal function to call.
    //    It also takes care of moving all the indices forwards.
    //
    var Parser = function Parser(context, imports, fileInfo) {
        var parsers;
        var parserInput = getParserInput();
        function error(msg, type) {
            throw new LessError({
                index: parserInput.i,
                filename: fileInfo.filename,
                type: type || 'Syntax',
                message: msg
            }, imports);
        }
        function expect(arg, msg) {
            // some older browsers return typeof 'function' for RegExp
            var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);
            if (result) {
                return result;
            }
            error(msg || (typeof arg === 'string'
                ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'"
                : 'unexpected token'));
        }
        // Specialization of expect()
        function expectChar(arg, msg) {
            if (parserInput.$char(arg)) {
                return arg;
            }
            error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
        }
        function getDebugInfo(index) {
            var filename = fileInfo.filename;
            return {
                lineNumber: getLocation(index, parserInput.getInput()).line + 1,
                fileName: filename
            };
        }
        /**
         *  Used after initial parsing to create nodes on the fly
         *
         *  @param {String} str          - string to parse
         *  @param {Array}  parseList    - array of parsers to run input through e.g. ["value", "important"]
         *  @param {Number} currentIndex - start number to begin indexing
         *  @param {Object} fileInfo     - fileInfo to attach to created nodes
         */
        function parseNode(str, parseList, currentIndex, fileInfo, callback) {
            var result;
            var returnNodes = [];
            var parser = parserInput;
            try {
                parser.start(str, false, function fail(msg, index) {
                    callback({
                        message: msg,
                        index: index + currentIndex
                    });
                });
                for (var x = 0, p = void 0, i = void 0; (p = parseList[x]); x++) {
                    i = parser.i;
                    result = parsers[p]();
                    if (result) {
                        try {
                            result._index = i + currentIndex;
                            result._fileInfo = fileInfo;
                        }
                        catch (e) { }
                        returnNodes.push(result);
                    }
                    else {
                        returnNodes.push(null);
                    }
                }
                var endInfo = parser.end();
                if (endInfo.isFinished) {
                    callback(null, returnNodes);
                }
                else {
                    callback(true, null);
                }
            }
            catch (e) {
                throw new LessError({
                    index: e.index + currentIndex,
                    message: e.message
                }, imports, fileInfo.filename);
            }
        }
        //
        // The Parser
        //
        return {
            parserInput: parserInput,
            imports: imports,
            fileInfo: fileInfo,
            parseNode: parseNode,
            //
            // Parse an input string into an abstract syntax tree,
            // @param str A string containing 'less' markup
            // @param callback call `callback` when done.
            // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
            //
            parse: function (str, callback, additionalData) {
                var root;
                var error = null;
                var globalVars;
                var modifyVars;
                var ignored;
                var preText = '';
                globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + "\n" : '';
                modifyVars = (additionalData && additionalData.modifyVars) ? "\n" + Parser.serializeVars(additionalData.modifyVars) : '';
                if (context.pluginManager) {
                    var preProcessors = context.pluginManager.getPreProcessors();
                    for (var i = 0; i < preProcessors.length; i++) {
                        str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });
                    }
                }
                if (globalVars || (additionalData && additionalData.banner)) {
                    preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;
                    ignored = imports.contentsIgnoredChars;
                    ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
                    ignored[fileInfo.filename] += preText.length;
                }
                str = str.replace(/\r\n?/g, '\n');
                // Remove potential UTF Byte Order Mark
                str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
                imports.contents[fileInfo.filename] = str;
                // Start with the primary rule.
                // The whole syntax tree is held under a Ruleset node,
                // with the `root` property set to true, so no `{}` are
                // output. The callback is called when the input is parsed.
                try {
                    parserInput.start(str, context.chunkInput, function fail(msg, index) {
                        throw new LessError({
                            index: index,
                            type: 'Parse',
                            message: msg,
                            filename: fileInfo.filename
                        }, imports);
                    });
                    tree.Node.prototype.parse = this;
                    root = new tree.Ruleset(null, this.parsers.primary());
                    tree.Node.prototype.rootNode = root;
                    root.root = true;
                    root.firstRoot = true;
                    root.functionRegistry = functionRegistry.inherit();
                }
                catch (e) {
                    return callback(new LessError(e, imports, fileInfo.filename));
                }
                // If `i` is smaller than the `input.length - 1`,
                // it means the parser wasn't able to parse the whole
                // string, so we've got a parsing error.
                //
                // We try to extract a \n delimited string,
                // showing the line where the parse error occurred.
                // We split it up into two parts (the part which parsed,
                // and the part which didn't), so we can color them differently.
                var endInfo = parserInput.end();
                if (!endInfo.isFinished) {
                    var message = endInfo.furthestPossibleErrorMessage;
                    if (!message) {
                        message = 'Unrecognised input';
                        if (endInfo.furthestChar === '}') {
                            message += '. Possibly missing opening \'{\'';
                        }
                        else if (endInfo.furthestChar === ')') {
                            message += '. Possibly missing opening \'(\'';
                        }
                        else if (endInfo.furthestReachedEnd) {
                            message += '. Possibly missing something';
                        }
                    }
                    error = new LessError({
                        type: 'Parse',
                        message: message,
                        index: endInfo.furthest,
                        filename: fileInfo.filename
                    }, imports);
                }
                var finish = function (e) {
                    e = error || e || imports.error;
                    if (e) {
                        if (!(e instanceof LessError)) {
                            e = new LessError(e, imports, fileInfo.filename);
                        }
                        return callback(e);
                    }
                    else {
                        return callback(null, root);
                    }
                };
                if (context.processImports !== false) {
                    new visitors.ImportVisitor(imports, finish)
                        .run(root);
                }
                else {
                    return finish();
                }
            },
            //
            // Here in, the parsing rules/functions
            //
            // The basic structure of the syntax tree generated is as follows:
            //
            //   Ruleset ->  Declaration -> Value -> Expression -> Entity
            //
            // Here's some Less code:
            //
            //    .class {
            //      color: #fff;
            //      border: 1px solid #000;
            //      width: @w + 4px;
            //      > .child {...}
            //    }
            //
            // And here's what the parse tree might look like:
            //
            //     Ruleset (Selector '.class', [
            //         Declaration ("color",  Value ([Expression [Color #fff]]))
            //         Declaration ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
            //         Declaration ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
            //         Ruleset (Selector [Element '>', '.child'], [...])
            //     ])
            //
            //  In general, most rules will try to parse a token with the `$re()` function, and if the return
            //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
            //  first, before parsing, that's when we use `peek()`.
            //
            parsers: parsers = {
                //
                // The `primary` rule is the *entry* and *exit* point of the parser.
                // The rules here can appear at any level of the parse tree.
                //
                // The recursive nature of the grammar is an interplay between the `block`
                // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
                // as represented by this simplified grammar:
                //
                //     primary  →  (ruleset | declaration)+
                //     ruleset  →  selector+ block
                //     block    →  '{' primary '}'
                //
                // Only at one point is the primary rule not called from the
                // block rule: at the root level.
                //
                primary: function () {
                    var mixin = this.mixin;
                    var root = [];
                    var node;
                    while (true) {
                        while (true) {
                            node = this.comment();
                            if (!node) {
                                break;
                            }
                            root.push(node);
                        }
                        // always process comments before deciding if finished
                        if (parserInput.finished) {
                            break;
                        }
                        if (parserInput.peek('}')) {
                            break;
                        }
                        node = this.extendRule();
                        if (node) {
                            root = root.concat(node);
                            continue;
                        }
                        node = mixin.definition() || this.declaration() || mixin.call(false, false) ||
                            this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();
                        if (node) {
                            root.push(node);
                        }
                        else {
                            var foundSemiColon = false;
                            while (parserInput.$char(';')) {
                                foundSemiColon = true;
                            }
                            if (!foundSemiColon) {
                                break;
                            }
                        }
                    }
                    return root;
                },
                // comments are collected by the main parsing mechanism and then assigned to nodes
                // where the current structure allows it
                comment: function () {
                    if (parserInput.commentStore.length) {
                        var comment = parserInput.commentStore.shift();
                        return new (tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);
                    }
                },
                //
                // Entities are tokens which can be found inside an Expression
                //
                entities: {
                    mixinLookup: function () {
                        return parsers.mixin.call(true, true);
                    },
                    //
                    // A string, which supports escaping " and '
                    //
                    //     "milky way" 'he\'s the one!'
                    //
                    quoted: function (forceEscaped) {
                        var str;
                        var index = parserInput.i;
                        var isEscaped = false;
                        parserInput.save();
                        if (parserInput.$char('~')) {
                            isEscaped = true;
                        }
                        else if (forceEscaped) {
                            parserInput.restore();
                            return;
                        }
                        str = parserInput.$quoted();
                        if (!str) {
                            parserInput.restore();
                            return;
                        }
                        parserInput.forget();
                        return new (tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);
                    },
                    //
                    // A catch-all word, such as:
                    //
                    //     black border-collapse
                    //
                    keyword: function () {
                        var k = parserInput.$char('%') || parserInput.$re(/^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]?/);
                        if (k) {
                            return tree.Color.fromKeyword(k) || new (tree.Keyword)(k);
                        }
                    },
                    //
                    // A function call
                    //
                    //     rgb(255, 0, 255)
                    //
                    // The arguments are parsed with the `entities.arguments` parser.
                    //
                    call: function () {
                        var name;
                        var args;
                        var func;
                        var index = parserInput.i;
                        // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                        if (parserInput.peek(/^url\(/i)) {
                            return;
                        }
                        parserInput.save();
                        name = parserInput.$re(/^([\w-]+|%|~|progid:[\w\.]+)\(/);
                        if (!name) {
                            parserInput.forget();
                            return;
                        }
                        name = name[1];
                        func = this.customFuncCall(name);
                        if (func) {
                            args = func.parse();
                            if (args && func.stop) {
                                parserInput.forget();
                                return args;
                            }
                        }
                        args = this.arguments(args);
                        if (!parserInput.$char(')')) {
                            parserInput.restore('Could not parse call arguments or missing \')\'');
                            return;
                        }
                        parserInput.forget();
                        return new (tree.Call)(name, args, index, fileInfo);
                    },
                    //
                    // Parsing rules for functions with non-standard args, e.g.:
                    //
                    //     boolean(not(2 > 1))
                    //
                    //     This is a quick prototype, to be modified/improved when
                    //     more custom-parsed funcs come (e.g. `selector(...)`)
                    //
                    customFuncCall: function (name) {
                        /* Ideally the table is to be moved out of here for faster perf.,
                           but it's quite tricky since it relies on all these `parsers`
                           and `expect` available only here */
                        return {
                            alpha: f(parsers.ieAlpha, true),
                            boolean: f(condition),
                            'if': f(condition)
                        }[name.toLowerCase()];
                        function f(parse, stop) {
                            return {
                                parse: parse,
                                stop: stop // when true - stop after parse() and return its result, 
                                // otherwise continue for plain args
                            };
                        }
                        function condition() {
                            return [expect(parsers.condition, 'expected condition')];
                        }
                    },
                    arguments: function (prevArgs) {
                        var argsComma = prevArgs || [];
                        var argsSemiColon = [];
                        var isSemiColonSeparated;
                        var value;
                        parserInput.save();
                        while (true) {
                            if (prevArgs) {
                                prevArgs = false;
                            }
                            else {
                                value = parsers.detachedRuleset() || this.assignment() || parsers.expression();
                                if (!value) {
                                    break;
                                }
                                if (value.value && value.value.length == 1) {
                                    value = value.value[0];
                                }
                                argsComma.push(value);
                            }
                            if (parserInput.$char(',')) {
                                continue;
                            }
                            if (parserInput.$char(';') || isSemiColonSeparated) {
                                isSemiColonSeparated = true;
                                value = (argsComma.length < 1) ? argsComma[0]
                                    : new tree.Value(argsComma);
                                argsSemiColon.push(value);
                                argsComma = [];
                            }
                        }
                        parserInput.forget();
                        return isSemiColonSeparated ? argsSemiColon : argsComma;
                    },
                    literal: function () {
                        return this.dimension() ||
                            this.color() ||
                            this.quoted() ||
                            this.unicodeDescriptor();
                    },
                    // Assignments are argument entities for calls.
                    // They are present in ie filter properties as shown below.
                    //
                    //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
                    //
                    assignment: function () {
                        var key;
                        var value;
                        parserInput.save();
                        key = parserInput.$re(/^\w+(?=\s?=)/i);
                        if (!key) {
                            parserInput.restore();
                            return;
                        }
                        if (!parserInput.$char('=')) {
                            parserInput.restore();
                            return;
                        }
                        value = parsers.entity();
                        if (value) {
                            parserInput.forget();
                            return new (tree.Assignment)(key, value);
                        }
                        else {
                            parserInput.restore();
                        }
                    },
                    //
                    // Parse url() tokens
                    //
                    // We use a specific rule for urls, because they don't really behave like
                    // standard function calls. The difference is that the argument doesn't have
                    // to be enclosed within a string, so it can't be parsed as an Expression.
                    //
                    url: function () {
                        var value;
                        var index = parserInput.i;
                        parserInput.autoCommentAbsorb = false;
                        if (!parserInput.$str('url(')) {
                            parserInput.autoCommentAbsorb = true;
                            return;
                        }
                        value = this.quoted() || this.variable() || this.property() ||
                            parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || '';
                        parserInput.autoCommentAbsorb = true;
                        expectChar(')');
                        return new (tree.URL)((value.value != null ||
                            value instanceof tree.Variable ||
                            value instanceof tree.Property) ?
                            value : new (tree.Anonymous)(value, index), index, fileInfo);
                    },
                    //
                    // A Variable entity, such as `@fink`, in
                    //
                    //     width: @fink + 2px
                    //
                    // We use a different parser for variable definitions,
                    // see `parsers.variable`.
                    //
                    variable: function () {
                        var ch;
                        var name;
                        var index = parserInput.i;
                        parserInput.save();
                        if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\w-]+/))) {
                            ch = parserInput.currentChar();
                            if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\s/)) {
                                // this may be a VariableCall lookup
                                var result = parsers.variableCall(name);
                                if (result) {
                                    parserInput.forget();
                                    return result;
                                }
                            }
                            parserInput.forget();
                            return new (tree.Variable)(name, index, fileInfo);
                        }
                        parserInput.restore();
                    },
                    // A variable entity using the protective {} e.g. @{var}
                    variableCurly: function () {
                        var curly;
                        var index = parserInput.i;
                        if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
                            return new (tree.Variable)("@" + curly[1], index, fileInfo);
                        }
                    },
                    //
                    // A Property accessor, such as `$color`, in
                    //
                    //     background-color: $color
                    //
                    property: function () {
                        var name;
                        var index = parserInput.i;
                        if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\$[\w-]+/))) {
                            return new (tree.Property)(name, index, fileInfo);
                        }
                    },
                    // A property entity useing the protective {} e.g. ${prop}
                    propertyCurly: function () {
                        var curly;
                        var index = parserInput.i;
                        if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\$\{([\w-]+)\}/))) {
                            return new (tree.Property)("$" + curly[1], index, fileInfo);
                        }
                    },
                    //
                    // A Hexadecimal color
                    //
                    //     #4F3C2F
                    //
                    // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
                    //
                    color: function () {
                        var rgb;
                        parserInput.save();
                        if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\w.#\[])?/))) {
                            if (!rgb[2]) {
                                parserInput.forget();
                                return new (tree.Color)(rgb[1], undefined, rgb[0]);
                            }
                        }
                        parserInput.restore();
                    },
                    colorKeyword: function () {
                        parserInput.save();
                        var autoCommentAbsorb = parserInput.autoCommentAbsorb;
                        parserInput.autoCommentAbsorb = false;
                        var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
                        parserInput.autoCommentAbsorb = autoCommentAbsorb;
                        if (!k) {
                            parserInput.forget();
                            return;
                        }
                        parserInput.restore();
                        var color = tree.Color.fromKeyword(k);
                        if (color) {
                            parserInput.$str(k);
                            return color;
                        }
                    },
                    //
                    // A Dimension, that is, a number and a unit
                    //
                    //     0.5em 95%
                    //
                    dimension: function () {
                        if (parserInput.peekNotNumeric()) {
                            return;
                        }
                        var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
                        if (value) {
                            return new (tree.Dimension)(value[1], value[2]);
                        }
                    },
                    //
                    // A unicode descriptor, as is used in unicode-range
                    //
                    // U+0??  or U+00A1-00A9
                    //
                    unicodeDescriptor: function () {
                        var ud;
                        ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
                        if (ud) {
                            return new (tree.UnicodeDescriptor)(ud[0]);
                        }
                    },
                    //
                    // JavaScript code to be evaluated
                    //
                    //     `window.location.href`
                    //
                    javascript: function () {
                        var js;
                        var index = parserInput.i;
                        parserInput.save();
                        var escape = parserInput.$char('~');
                        var jsQuote = parserInput.$char('`');
                        if (!jsQuote) {
                            parserInput.restore();
                            return;
                        }
                        js = parserInput.$re(/^[^`]*`/);
                        if (js) {
                            parserInput.forget();
                            return new (tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);
                        }
                        parserInput.restore('invalid javascript definition');
                    }
                },
                //
                // The variable part of a variable definition. Used in the `rule` parser
                //
                //     @fink:
                //
                variable: function () {
                    var name;
                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*:/))) {
                        return name[1];
                    }
                },
                //
                // Call a variable value to retrieve a detached ruleset
                // or a value from a detached ruleset's rules.
                //
                //     @fink();
                //     @fink;
                //     color: @fink[@color];
                //
                variableCall: function (parsedName) {
                    var lookups;
                    var i = parserInput.i;
                    var inValue = !!parsedName;
                    var name = parsedName;
                    parserInput.save();
                    if (name || (parserInput.currentChar() === '@'
                        && (name = parserInput.$re(/^(@[\w-]+)(\(\s*\))?/)))) {
                        lookups = this.mixin.ruleLookups();
                        if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {
                            parserInput.restore('Missing \'[...]\' lookup in variable call');
                            return;
                        }
                        if (!inValue) {
                            name = name[1];
                        }
                        var call = new tree.VariableCall(name, i, fileInfo);
                        if (!inValue && parsers.end()) {
                            parserInput.forget();
                            return call;
                        }
                        else {
                            parserInput.forget();
                            return new tree.NamespaceValue(call, lookups, i, fileInfo);
                        }
                    }
                    parserInput.restore();
                },
                //
                // extend syntax - used to extend selectors
                //
                extend: function (isRule) {
                    var elements;
                    var e;
                    var index = parserInput.i;
                    var option;
                    var extendList;
                    var extend;
                    if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {
                        return;
                    }
                    do {
                        option = null;
                        elements = null;
                        while (!(option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
                            e = this.element();
                            if (!e) {
                                break;
                            }
                            if (elements) {
                                elements.push(e);
                            }
                            else {
                                elements = [e];
                            }
                        }
                        option = option && option[1];
                        if (!elements) {
                            error('Missing target selector for :extend().');
                        }
                        extend = new (tree.Extend)(new (tree.Selector)(elements), option, index, fileInfo);
                        if (extendList) {
                            extendList.push(extend);
                        }
                        else {
                            extendList = [extend];
                        }
                    } while (parserInput.$char(','));
                    expect(/^\)/);
                    if (isRule) {
                        expect(/^;/);
                    }
                    return extendList;
                },
                //
                // extendRule - used in a rule to extend all the parent selectors
                //
                extendRule: function () {
                    return this.extend(true);
                },
                //
                // Mixins
                //
                mixin: {
                    //
                    // A Mixin call, with an optional argument list
                    //
                    //     #mixins > .square(#fff);
                    //     #mixins.square(#fff);
                    //     .rounded(4px, black);
                    //     .button;
                    //
                    // We can lookup / return a value using the lookup syntax:
                    //
                    //     color: #mixin.square(#fff)[@color];
                    //
                    // The `while` loop is there because mixins can be
                    // namespaced, but we only support the child and descendant
                    // selector for now.
                    //
                    call: function (inValue, getLookup) {
                        var s = parserInput.currentChar();
                        var important = false;
                        var lookups;
                        var index = parserInput.i;
                        var elements;
                        var args;
                        var hasParens;
                        if (s !== '.' && s !== '#') {
                            return;
                        }
                        parserInput.save(); // stop us absorbing part of an invalid selector
                        elements = this.elements();
                        if (elements) {
                            if (parserInput.$char('(')) {
                                args = this.args(true).args;
                                expectChar(')');
                                hasParens = true;
                            }
                            if (getLookup !== false) {
                                lookups = this.ruleLookups();
                            }
                            if (getLookup === true && !lookups) {
                                parserInput.restore();
                                return;
                            }
                            if (inValue && !lookups && !hasParens) {
                                // This isn't a valid in-value mixin call
                                parserInput.restore();
                                return;
                            }
                            if (!inValue && parsers.important()) {
                                important = true;
                            }
                            if (inValue || parsers.end()) {
                                parserInput.forget();
                                var mixin = new (tree.mixin.Call)(elements, args, index, fileInfo, !lookups && important);
                                if (lookups) {
                                    return new tree.NamespaceValue(mixin, lookups);
                                }
                                else {
                                    return mixin;
                                }
                            }
                        }
                        parserInput.restore();
                    },
                    /**
                     * Matching elements for mixins
                     * (Start with . or # and can have > )
                     */
                    elements: function () {
                        var elements;
                        var e;
                        var c;
                        var elem;
                        var elemIndex;
                        var re = /^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;
                        while (true) {
                            elemIndex = parserInput.i;
                            e = parserInput.$re(re);
                            if (!e) {
                                break;
                            }
                            elem = new (tree.Element)(c, e, false, elemIndex, fileInfo);
                            if (elements) {
                                elements.push(elem);
                            }
                            else {
                                elements = [elem];
                            }
                            c = parserInput.$char('>');
                        }
                        return elements;
                    },
                    args: function (isCall) {
                        var entities = parsers.entities;
                        var returner = { args: null, variadic: false };
                        var expressions = [];
                        var argsSemiColon = [];
                        var argsComma = [];
                        var isSemiColonSeparated;
                        var expressionContainsNamed;
                        var name;
                        var nameLoop;
                        var value;
                        var arg;
                        var expand;
                        var hasSep = true;
                        parserInput.save();
                        while (true) {
                            if (isCall) {
                                arg = parsers.detachedRuleset() || parsers.expression();
                            }
                            else {
                                parserInput.commentStore.length = 0;
                                if (parserInput.$str('...')) {
                                    returner.variadic = true;
                                    if (parserInput.$char(';') && !isSemiColonSeparated) {
                                        isSemiColonSeparated = true;
                                    }
                                    (isSemiColonSeparated ? argsSemiColon : argsComma)
                                        .push({ variadic: true });
                                    break;
                                }
                                arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);
                            }
                            if (!arg || !hasSep) {
                                break;
                            }
                            nameLoop = null;
                            if (arg.throwAwayComments) {
                                arg.throwAwayComments();
                            }
                            value = arg;
                            var val = null;
                            if (isCall) {
                                // Variable
                                if (arg.value && arg.value.length == 1) {
                                    val = arg.value[0];
                                }
                            }
                            else {
                                val = arg;
                            }
                            if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {
                                if (parserInput.$char(':')) {
                                    if (expressions.length > 0) {
                                        if (isSemiColonSeparated) {
                                            error('Cannot mix ; and , as delimiter types');
                                        }
                                        expressionContainsNamed = true;
                                    }
                                    value = parsers.detachedRuleset() || parsers.expression();
                                    if (!value) {
                                        if (isCall) {
                                            error('could not understand value for named argument');
                                        }
                                        else {
                                            parserInput.restore();
                                            returner.args = [];
                                            return returner;
                                        }
                                    }
                                    nameLoop = (name = val.name);
                                }
                                else if (parserInput.$str('...')) {
                                    if (!isCall) {
                                        returner.variadic = true;
                                        if (parserInput.$char(';') && !isSemiColonSeparated) {
                                            isSemiColonSeparated = true;
                                        }
                                        (isSemiColonSeparated ? argsSemiColon : argsComma)
                                            .push({ name: arg.name, variadic: true });
                                        break;
                                    }
                                    else {
                                        expand = true;
                                    }
                                }
                                else if (!isCall) {
                                    name = nameLoop = val.name;
                                    value = null;
                                }
                            }
                            if (value) {
                                expressions.push(value);
                            }
                            argsComma.push({ name: nameLoop, value: value, expand: expand });
                            if (parserInput.$char(',')) {
                                hasSep = true;
                                continue;
                            }
                            hasSep = parserInput.$char(';') === ';';
                            if (hasSep || isSemiColonSeparated) {
                                if (expressionContainsNamed) {
                                    error('Cannot mix ; and , as delimiter types');
                                }
                                isSemiColonSeparated = true;
                                if (expressions.length > 1) {
                                    value = new (tree.Value)(expressions);
                                }
                                argsSemiColon.push({ name: name, value: value, expand: expand });
                                name = null;
                                expressions = [];
                                expressionContainsNamed = false;
                            }
                        }
                        parserInput.forget();
                        returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
                        return returner;
                    },
                    //
                    // A Mixin definition, with a list of parameters
                    //
                    //     .rounded (@radius: 2px, @color) {
                    //        ...
                    //     }
                    //
                    // Until we have a finer grained state-machine, we have to
                    // do a look-ahead, to make sure we don't have a mixin call.
                    // See the `rule` function for more information.
                    //
                    // We start by matching `.rounded (`, and then proceed on to
                    // the argument list, which has optional default values.
                    // We store the parameters in `params`, with a `value` key,
                    // if there is a value, such as in the case of `@radius`.
                    //
                    // Once we've got our params list, and a closing `)`, we parse
                    // the `{...}` block.
                    //
                    definition: function () {
                        var name;
                        var params = [];
                        var match;
                        var ruleset;
                        var cond;
                        var variadic = false;
                        if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||
                            parserInput.peek(/^[^{]*\}/)) {
                            return;
                        }
                        parserInput.save();
                        match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
                        if (match) {
                            name = match[1];
                            var argInfo = this.args(false);
                            params = argInfo.args;
                            variadic = argInfo.variadic;
                            // .mixincall("@{a}");
                            // looks a bit like a mixin definition..
                            // also
                            // .mixincall(@a: {rule: set;});
                            // so we have to be nice and restore
                            if (!parserInput.$char(')')) {
                                parserInput.restore('Missing closing \')\'');
                                return;
                            }
                            parserInput.commentStore.length = 0;
                            if (parserInput.$str('when')) { // Guard
                                cond = expect(parsers.conditions, 'expected condition');
                            }
                            ruleset = parsers.block();
                            if (ruleset) {
                                parserInput.forget();
                                return new (tree.mixin.Definition)(name, params, ruleset, cond, variadic);
                            }
                            else {
                                parserInput.restore();
                            }
                        }
                        else {
                            parserInput.restore();
                        }
                    },
                    ruleLookups: function () {
                        var rule;
                        var lookups = [];
                        if (parserInput.currentChar() !== '[') {
                            return;
                        }
                        while (true) {
                            parserInput.save();
                            rule = this.lookupValue();
                            if (!rule && rule !== '') {
                                parserInput.restore();
                                break;
                            }
                            lookups.push(rule);
                            parserInput.forget();
                        }
                        if (lookups.length > 0) {
                            return lookups;
                        }
                    },
                    lookupValue: function () {
                        parserInput.save();
                        if (!parserInput.$char('[')) {
                            parserInput.restore();
                            return;
                        }
                        var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);
                        if (!parserInput.$char(']')) {
                            parserInput.restore();
                            return;
                        }
                        if (name || name === '') {
                            parserInput.forget();
                            return name;
                        }
                        parserInput.restore();
                    }
                },
                //
                // Entities are the smallest recognized token,
                // and can be found inside a rule's value.
                //
                entity: function () {
                    var entities = this.entities;
                    return this.comment() || entities.literal() || entities.variable() || entities.url() ||
                        entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||
                        entities.javascript();
                },
                //
                // A Declaration terminator. Note that we use `peek()` to check for '}',
                // because the `block` rule will be expecting it, but we still need to make sure
                // it's there, if ';' was omitted.
                //
                end: function () {
                    return parserInput.$char(';') || parserInput.peek('}');
                },
                //
                // IE's alpha function
                //
                //     alpha(opacity=88)
                //
                ieAlpha: function () {
                    var value;
                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                    if (!parserInput.$re(/^opacity=/i)) {
                        return;
                    }
                    value = parserInput.$re(/^\d+/);
                    if (!value) {
                        value = expect(parsers.entities.variable, 'Could not parse alpha');
                        value = "@{" + value.name.slice(1) + "}";
                    }
                    expectChar(')');
                    return new tree.Quoted('', "alpha(opacity=" + value + ")");
                },
                //
                // A Selector Element
                //
                //     div
                //     + h1
                //     #socks
                //     input[type="text"]
                //
                // Elements are the building blocks for Selectors,
                // they are made out of a `Combinator` (see combinator rule),
                // and an element name, such as a tag a class, or `*`.
                //
                element: function () {
                    var e;
                    var c;
                    var v;
                    var index = parserInput.i;
                    c = this.combinator();
                    e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
                        parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||
                        parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||
                        parserInput.$re(/^\([^&()@]+\)/) || parserInput.$re(/^[\.#:](?=@)/) ||
                        this.entities.variableCurly();
                    if (!e) {
                        parserInput.save();
                        if (parserInput.$char('(')) {
                            if ((v = this.selector(false)) && parserInput.$char(')')) {
                                e = new (tree.Paren)(v);
                                parserInput.forget();
                            }
                            else {
                                parserInput.restore('Missing closing \')\'');
                            }
                        }
                        else {
                            parserInput.forget();
                        }
                    }
                    if (e) {
                        return new (tree.Element)(c, e, e instanceof tree.Variable, index, fileInfo);
                    }
                },
                //
                // Combinators combine elements together, in a Selector.
                //
                // Because our parser isn't white-space sensitive, special care
                // has to be taken, when parsing the descendant combinator, ` `,
                // as it's an empty space. We have to check the previous character
                // in the input, to see if it's a ` ` character. More info on how
                // we deal with this in *combinator.js*.
                //
                combinator: function () {
                    var c = parserInput.currentChar();
                    if (c === '/') {
                        parserInput.save();
                        var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
                        if (slashedCombinator) {
                            parserInput.forget();
                            return new (tree.Combinator)(slashedCombinator);
                        }
                        parserInput.restore();
                    }
                    if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
                        parserInput.i++;
                        if (c === '^' && parserInput.currentChar() === '^') {
                            c = '^^';
                            parserInput.i++;
                        }
                        while (parserInput.isWhitespace()) {
                            parserInput.i++;
                        }
                        return new (tree.Combinator)(c);
                    }
                    else if (parserInput.isWhitespace(-1)) {
                        return new (tree.Combinator)(' ');
                    }
                    else {
                        return new (tree.Combinator)(null);
                    }
                },
                //
                // A CSS Selector
                // with less extensions e.g. the ability to extend and guard
                //
                //     .class > div + h1
                //     li a:hover
                //
                // Selectors are made out of one or more Elements, see above.
                //
                selector: function (isLess) {
                    var index = parserInput.i;
                    var elements;
                    var extendList;
                    var c;
                    var e;
                    var allExtends;
                    var when;
                    var condition;
                    isLess = isLess !== false;
                    while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {
                        if (when) {
                            condition = expect(this.conditions, 'expected condition');
                        }
                        else if (condition) {
                            error('CSS guard can only be used at the end of selector');
                        }
                        else if (extendList) {
                            if (allExtends) {
                                allExtends = allExtends.concat(extendList);
                            }
                            else {
                                allExtends = extendList;
                            }
                        }
                        else {
                            if (allExtends) {
                                error('Extend can only be used at the end of selector');
                            }
                            c = parserInput.currentChar();
                            if (elements) {
                                elements.push(e);
                            }
                            else {
                                elements = [e];
                            }
                            e = null;
                        }
                        if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
                            break;
                        }
                    }
                    if (elements) {
                        return new (tree.Selector)(elements, allExtends, condition, index, fileInfo);
                    }
                    if (allExtends) {
                        error('Extend must be used to extend a selector, it cannot be used on its own');
                    }
                },
                selectors: function () {
                    var s;
                    var selectors;
                    while (true) {
                        s = this.selector();
                        if (!s) {
                            break;
                        }
                        if (selectors) {
                            selectors.push(s);
                        }
                        else {
                            selectors = [s];
                        }
                        parserInput.commentStore.length = 0;
                        if (s.condition && selectors.length > 1) {
                            error("Guards are only currently allowed on a single selector.");
                        }
                        if (!parserInput.$char(',')) {
                            break;
                        }
                        if (s.condition) {
                            error("Guards are only currently allowed on a single selector.");
                        }
                        parserInput.commentStore.length = 0;
                    }
                    return selectors;
                },
                attribute: function () {
                    if (!parserInput.$char('[')) {
                        return;
                    }
                    var entities = this.entities;
                    var key;
                    var val;
                    var op;
                    if (!(key = entities.variableCurly())) {
                        key = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
                    }
                    op = parserInput.$re(/^[|~*$^]?=/);
                    if (op) {
                        val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
                    }
                    expectChar(']');
                    return new (tree.Attribute)(key, op, val);
                },
                //
                // The `block` rule is used by `ruleset` and `mixin.definition`.
                // It's a wrapper around the `primary` rule, with added `{}`.
                //
                block: function () {
                    var content;
                    if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {
                        return content;
                    }
                },
                blockRuleset: function () {
                    var block = this.block();
                    if (block) {
                        block = new tree.Ruleset(null, block);
                    }
                    return block;
                },
                detachedRuleset: function () {
                    var argInfo;
                    var params;
                    var variadic;
                    parserInput.save();
                    if (parserInput.$re(/^[.#]\(/)) {
                        /**
                         * DR args currently only implemented for each() function, and not
                         * yet settable as `@dr: #(@arg) {}`
                         * This should be done when DRs are merged with mixins.
                         * See: https://github.com/less/less-meta/issues/16
                         */
                        argInfo = this.mixin.args(false);
                        params = argInfo.args;
                        variadic = argInfo.variadic;
                        if (!parserInput.$char(')')) {
                            parserInput.restore();
                            return;
                        }
                    }
                    var blockRuleset = this.blockRuleset();
                    if (blockRuleset) {
                        parserInput.forget();
                        if (params) {
                            return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);
                        }
                        return new tree.DetachedRuleset(blockRuleset);
                    }
                    parserInput.restore();
                },
                //
                // div, .class, body > p {...}
                //
                ruleset: function () {
                    var selectors;
                    var rules;
                    var debugInfo;
                    parserInput.save();
                    if (context.dumpLineNumbers) {
                        debugInfo = getDebugInfo(parserInput.i);
                    }
                    selectors = this.selectors();
                    if (selectors && (rules = this.block())) {
                        parserInput.forget();
                        var ruleset = new (tree.Ruleset)(selectors, rules, context.strictImports);
                        if (context.dumpLineNumbers) {
                            ruleset.debugInfo = debugInfo;
                        }
                        return ruleset;
                    }
                    else {
                        parserInput.restore();
                    }
                },
                declaration: function () {
                    var name;
                    var value;
                    var index = parserInput.i;
                    var hasDR;
                    var c = parserInput.currentChar();
                    var important;
                    var merge;
                    var isVariable;
                    if (c === '.' || c === '#' || c === '&' || c === ':') {
                        return;
                    }
                    parserInput.save();
                    name = this.variable() || this.ruleProperty();
                    if (name) {
                        isVariable = typeof name === 'string';
                        if (isVariable) {
                            value = this.detachedRuleset();
                            if (value) {
                                hasDR = true;
                            }
                        }
                        parserInput.commentStore.length = 0;
                        if (!value) {
                            // a name returned by this.ruleProperty() is always an array of the form:
                            // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
                            // where each item is a tree.Keyword or tree.Variable
                            merge = !isVariable && name.length > 1 && name.pop().value;
                            // Custom property values get permissive parsing
                            if (name[0].value && name[0].value.slice(0, 2) === '--') {
                                value = this.permissiveValue();
                            }
                            // Try to store values as anonymous
                            // If we need the value later we'll re-parse it in ruleset.parseValue
                            else {
                                value = this.anonymousValue();
                            }
                            if (value) {
                                parserInput.forget();
                                // anonymous values absorb the end ';' which is required for them to work
                                return new (tree.Declaration)(name, value, false, merge, index, fileInfo);
                            }
                            if (!value) {
                                value = this.value();
                            }
                            if (value) {
                                important = this.important();
                            }
                            else if (isVariable) {
                                // As a last resort, try permissiveValue
                                value = this.permissiveValue();
                            }
                        }
                        if (value && (this.end() || hasDR)) {
                            parserInput.forget();
                            return new (tree.Declaration)(name, value, important, merge, index, fileInfo);
                        }
                        else {
                            parserInput.restore();
                        }
                    }
                    else {
                        parserInput.restore();
                    }
                },
                anonymousValue: function () {
                    var index = parserInput.i;
                    var match = parserInput.$re(/^([^.#@\$+\/'"*`(;{}-]*);/);
                    if (match) {
                        return new (tree.Anonymous)(match[1], index);
                    }
                },
                /**
                 * Used for custom properties, at-rules, and variables (as fallback)
                 * Parses almost anything inside of {} [] () "" blocks
                 * until it reaches outer-most tokens.
                 *
                 * First, it will try to parse comments and entities to reach
                 * the end. This is mostly like the Expression parser except no
                 * math is allowed.
                 */
                permissiveValue: function (untilTokens) {
                    var i;
                    var e;
                    var done;
                    var value;
                    var tok = untilTokens || ';';
                    var index = parserInput.i;
                    var result = [];
                    function testCurrentChar() {
                        var char = parserInput.currentChar();
                        if (typeof tok === 'string') {
                            return char === tok;
                        }
                        else {
                            return tok.test(char);
                        }
                    }
                    if (testCurrentChar()) {
                        return;
                    }
                    value = [];
                    do {
                        e = this.comment();
                        if (e) {
                            value.push(e);
                            continue;
                        }
                        e = this.entity();
                        if (e) {
                            value.push(e);
                        }
                    } while (e);
                    done = testCurrentChar();
                    if (value.length > 0) {
                        value = new (tree.Expression)(value);
                        if (done) {
                            return value;
                        }
                        else {
                            result.push(value);
                        }
                        // Preserve space before $parseUntil as it will not
                        if (parserInput.prevChar() === ' ') {
                            result.push(new tree.Anonymous(' ', index));
                        }
                    }
                    parserInput.save();
                    value = parserInput.$parseUntil(tok);
                    if (value) {
                        if (typeof value === 'string') {
                            error("Expected '" + value + "'", 'Parse');
                        }
                        if (value.length === 1 && value[0] === ' ') {
                            parserInput.forget();
                            return new tree.Anonymous('', index);
                        }
                        var item = void 0;
                        for (i = 0; i < value.length; i++) {
                            item = value[i];
                            if (Array.isArray(item)) {
                                // Treat actual quotes as normal quoted values
                                result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));
                            }
                            else {
                                if (i === value.length - 1) {
                                    item = item.trim();
                                }
                                // Treat like quoted values, but replace vars like unquoted expressions
                                var quote = new tree.Quoted('\'', item, true, index, fileInfo);
                                quote.variableRegex = /@([\w-]+)/g;
                                quote.propRegex = /\$([\w-]+)/g;
                                result.push(quote);
                            }
                        }
                        parserInput.forget();
                        return new tree.Expression(result, true);
                    }
                    parserInput.restore();
                },
                //
                // An @import atrule
                //
                //     @import "lib";
                //
                // Depending on our environment, importing is done differently:
                // In the browser, it's an XHR request, in Node, it would be a
                // file-system operation. The function used for importing is
                // stored in `import`, which we pass to the Import constructor.
                //
                'import': function () {
                    var path;
                    var features;
                    var index = parserInput.i;
                    var dir = parserInput.$re(/^@import?\s+/);
                    if (dir) {
                        var options = (dir ? this.importOptions() : null) || {};
                        if ((path = this.entities.quoted() || this.entities.url())) {
                            features = this.mediaFeatures();
                            if (!parserInput.$char(';')) {
                                parserInput.i = index;
                                error('missing semi-colon or unrecognised media features on import');
                            }
                            features = features && new (tree.Value)(features);
                            return new (tree.Import)(path, features, options, index, fileInfo);
                        }
                        else {
                            parserInput.i = index;
                            error('malformed import statement');
                        }
                    }
                },
                importOptions: function () {
                    var o;
                    var options = {};
                    var optionName;
                    var value;
                    // list of options, surrounded by parens
                    if (!parserInput.$char('(')) {
                        return null;
                    }
                    do {
                        o = this.importOption();
                        if (o) {
                            optionName = o;
                            value = true;
                            switch (optionName) {
                                case 'css':
                                    optionName = 'less';
                                    value = false;
                                    break;
                                case 'once':
                                    optionName = 'multiple';
                                    value = false;
                                    break;
                            }
                            options[optionName] = value;
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                    } while (o);
                    expectChar(')');
                    return options;
                },
                importOption: function () {
                    var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
                    if (opt) {
                        return opt[1];
                    }
                },
                mediaFeature: function () {
                    var entities = this.entities;
                    var nodes = [];
                    var e;
                    var p;
                    parserInput.save();
                    do {
                        e = entities.keyword() || entities.variable() || entities.mixinLookup();
                        if (e) {
                            nodes.push(e);
                        }
                        else if (parserInput.$char('(')) {
                            p = this.property();
                            e = this.value();
                            if (parserInput.$char(')')) {
                                if (p && e) {
                                    nodes.push(new (tree.Paren)(new (tree.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));
                                }
                                else if (e) {
                                    nodes.push(new (tree.Paren)(e));
                                }
                                else {
                                    error('badly formed media feature definition');
                                }
                            }
                            else {
                                error('Missing closing \')\'', 'Parse');
                            }
                        }
                    } while (e);
                    parserInput.forget();
                    if (nodes.length > 0) {
                        return new (tree.Expression)(nodes);
                    }
                },
                mediaFeatures: function () {
                    var entities = this.entities;
                    var features = [];
                    var e;
                    do {
                        e = this.mediaFeature();
                        if (e) {
                            features.push(e);
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                        else {
                            e = entities.variable() || entities.mixinLookup();
                            if (e) {
                                features.push(e);
                                if (!parserInput.$char(',')) {
                                    break;
                                }
                            }
                        }
                    } while (e);
                    return features.length > 0 ? features : null;
                },
                media: function () {
                    var features;
                    var rules;
                    var media;
                    var debugInfo;
                    var index = parserInput.i;
                    if (context.dumpLineNumbers) {
                        debugInfo = getDebugInfo(index);
                    }
                    parserInput.save();
                    if (parserInput.$str('@media')) {
                        features = this.mediaFeatures();
                        rules = this.block();
                        if (!rules) {
                            error('media definitions require block statements after any features');
                        }
                        parserInput.forget();
                        media = new (tree.Media)(rules, features, index, fileInfo);
                        if (context.dumpLineNumbers) {
                            media.debugInfo = debugInfo;
                        }
                        return media;
                    }
                    parserInput.restore();
                },
                //
                // A @plugin directive, used to import plugins dynamically.
                //
                //     @plugin (args) "lib";
                //
                plugin: function () {
                    var path;
                    var args;
                    var options;
                    var index = parserInput.i;
                    var dir = parserInput.$re(/^@plugin?\s+/);
                    if (dir) {
                        args = this.pluginArgs();
                        if (args) {
                            options = {
                                pluginArgs: args,
                                isPlugin: true
                            };
                        }
                        else {
                            options = { isPlugin: true };
                        }
                        if ((path = this.entities.quoted() || this.entities.url())) {
                            if (!parserInput.$char(';')) {
                                parserInput.i = index;
                                error('missing semi-colon on @plugin');
                            }
                            return new (tree.Import)(path, null, options, index, fileInfo);
                        }
                        else {
                            parserInput.i = index;
                            error('malformed @plugin statement');
                        }
                    }
                },
                pluginArgs: function () {
                    // list of options, surrounded by parens
                    parserInput.save();
                    if (!parserInput.$char('(')) {
                        parserInput.restore();
                        return null;
                    }
                    var args = parserInput.$re(/^\s*([^\);]+)\)\s*/);
                    if (args[1]) {
                        parserInput.forget();
                        return args[1].trim();
                    }
                    else {
                        parserInput.restore();
                        return null;
                    }
                },
                //
                // A CSS AtRule
                //
                //     @charset "utf-8";
                //
                atrule: function () {
                    var index = parserInput.i;
                    var name;
                    var value;
                    var rules;
                    var nonVendorSpecificName;
                    var hasIdentifier;
                    var hasExpression;
                    var hasUnknown;
                    var hasBlock = true;
                    var isRooted = true;
                    if (parserInput.currentChar() !== '@') {
                        return;
                    }
                    value = this['import']() || this.plugin() || this.media();
                    if (value) {
                        return value;
                    }
                    parserInput.save();
                    name = parserInput.$re(/^@[a-z-]+/);
                    if (!name) {
                        return;
                    }
                    nonVendorSpecificName = name;
                    if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {
                        nonVendorSpecificName = "@" + name.slice(name.indexOf('-', 2) + 1);
                    }
                    switch (nonVendorSpecificName) {
                        case '@charset':
                            hasIdentifier = true;
                            hasBlock = false;
                            break;
                        case '@namespace':
                            hasExpression = true;
                            hasBlock = false;
                            break;
                        case '@keyframes':
                        case '@counter-style':
                            hasIdentifier = true;
                            break;
                        case '@document':
                        case '@supports':
                            hasUnknown = true;
                            isRooted = false;
                            break;
                        default:
                            hasUnknown = true;
                            break;
                    }
                    parserInput.commentStore.length = 0;
                    if (hasIdentifier) {
                        value = this.entity();
                        if (!value) {
                            error("expected " + name + " identifier");
                        }
                    }
                    else if (hasExpression) {
                        value = this.expression();
                        if (!value) {
                            error("expected " + name + " expression");
                        }
                    }
                    else if (hasUnknown) {
                        value = this.permissiveValue(/^[{;]/);
                        hasBlock = (parserInput.currentChar() === '{');
                        if (!value) {
                            if (!hasBlock && parserInput.currentChar() !== ';') {
                                error(name + " rule is missing block or ending semi-colon");
                            }
                        }
                        else if (!value.value) {
                            value = null;
                        }
                    }
                    if (hasBlock) {
                        rules = this.blockRuleset();
                    }
                    if (rules || (!hasBlock && value && parserInput.$char(';'))) {
                        parserInput.forget();
                        return new (tree.AtRule)(name, value, rules, index, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);
                    }
                    parserInput.restore('at-rule options not recognised');
                },
                //
                // A Value is a comma-delimited list of Expressions
                //
                //     font-family: Baskerville, Georgia, serif;
                //
                // In a Rule, a Value represents everything after the `:`,
                // and before the `;`.
                //
                value: function () {
                    var e;
                    var expressions = [];
                    var index = parserInput.i;
                    do {
                        e = this.expression();
                        if (e) {
                            expressions.push(e);
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                    } while (e);
                    if (expressions.length > 0) {
                        return new (tree.Value)(expressions, index);
                    }
                },
                important: function () {
                    if (parserInput.currentChar() === '!') {
                        return parserInput.$re(/^! *important/);
                    }
                },
                sub: function () {
                    var a;
                    var e;
                    parserInput.save();
                    if (parserInput.$char('(')) {
                        a = this.addition();
                        if (a && parserInput.$char(')')) {
                            parserInput.forget();
                            e = new (tree.Expression)([a]);
                            e.parens = true;
                            return e;
                        }
                        parserInput.restore('Expected \')\'');
                        return;
                    }
                    parserInput.restore();
                },
                multiplication: function () {
                    var m;
                    var a;
                    var op;
                    var operation;
                    var isSpaced;
                    m = this.operand();
                    if (m) {
                        isSpaced = parserInput.isWhitespace(-1);
                        while (true) {
                            if (parserInput.peek(/^\/[*\/]/)) {
                                break;
                            }
                            parserInput.save();
                            op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');
                            if (!op) {
                                parserInput.forget();
                                break;
                            }
                            a = this.operand();
                            if (!a) {
                                parserInput.restore();
                                break;
                            }
                            parserInput.forget();
                            m.parensInOp = true;
                            a.parensInOp = true;
                            operation = new (tree.Operation)(op, [operation || m, a], isSpaced);
                            isSpaced = parserInput.isWhitespace(-1);
                        }
                        return operation || m;
                    }
                },
                addition: function () {
                    var m;
                    var a;
                    var op;
                    var operation;
                    var isSpaced;
                    m = this.multiplication();
                    if (m) {
                        isSpaced = parserInput.isWhitespace(-1);
                        while (true) {
                            op = parserInput.$re(/^[-+]\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));
                            if (!op) {
                                break;
                            }
                            a = this.multiplication();
                            if (!a) {
                                break;
                            }
                            m.parensInOp = true;
                            a.parensInOp = true;
                            operation = new (tree.Operation)(op, [operation || m, a], isSpaced);
                            isSpaced = parserInput.isWhitespace(-1);
                        }
                        return operation || m;
                    }
                },
                conditions: function () {
                    var a;
                    var b;
                    var index = parserInput.i;
                    var condition;
                    a = this.condition(true);
                    if (a) {
                        while (true) {
                            if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
                                break;
                            }
                            b = this.condition(true);
                            if (!b) {
                                break;
                            }
                            condition = new (tree.Condition)('or', condition || a, b, index);
                        }
                        return condition || a;
                    }
                },
                condition: function (needsParens) {
                    var result;
                    var logical;
                    var next;
                    function or() {
                        return parserInput.$str('or');
                    }
                    result = this.conditionAnd(needsParens);
                    if (!result) {
                        return;
                    }
                    logical = or();
                    if (logical) {
                        next = this.condition(needsParens);
                        if (next) {
                            result = new (tree.Condition)(logical, result, next);
                        }
                        else {
                            return;
                        }
                    }
                    return result;
                },
                conditionAnd: function (needsParens) {
                    var result;
                    var logical;
                    var next;
                    var self = this;
                    function insideCondition() {
                        var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);
                        if (!cond && !needsParens) {
                            return self.atomicCondition(needsParens);
                        }
                        return cond;
                    }
                    function and() {
                        return parserInput.$str('and');
                    }
                    result = insideCondition();
                    if (!result) {
                        return;
                    }
                    logical = and();
                    if (logical) {
                        next = this.conditionAnd(needsParens);
                        if (next) {
                            result = new (tree.Condition)(logical, result, next);
                        }
                        else {
                            return;
                        }
                    }
                    return result;
                },
                negatedCondition: function (needsParens) {
                    if (parserInput.$str('not')) {
                        var result = this.parenthesisCondition(needsParens);
                        if (result) {
                            result.negate = !result.negate;
                        }
                        return result;
                    }
                },
                parenthesisCondition: function (needsParens) {
                    function tryConditionFollowedByParenthesis(me) {
                        var body;
                        parserInput.save();
                        body = me.condition(needsParens);
                        if (!body) {
                            parserInput.restore();
                            return;
                        }
                        if (!parserInput.$char(')')) {
                            parserInput.restore();
                            return;
                        }
                        parserInput.forget();
                        return body;
                    }
                    var body;
                    parserInput.save();
                    if (!parserInput.$str('(')) {
                        parserInput.restore();
                        return;
                    }
                    body = tryConditionFollowedByParenthesis(this);
                    if (body) {
                        parserInput.forget();
                        return body;
                    }
                    body = this.atomicCondition(needsParens);
                    if (!body) {
                        parserInput.restore();
                        return;
                    }
                    if (!parserInput.$char(')')) {
                        parserInput.restore("expected ')' got '" + parserInput.currentChar() + "'");
                        return;
                    }
                    parserInput.forget();
                    return body;
                },
                atomicCondition: function (needsParens) {
                    var entities = this.entities;
                    var index = parserInput.i;
                    var a;
                    var b;
                    var c;
                    var op;
                    function cond() {
                        return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();
                    }
                    cond = cond.bind(this);
                    a = cond();
                    if (a) {
                        if (parserInput.$char('>')) {
                            if (parserInput.$char('=')) {
                                op = '>=';
                            }
                            else {
                                op = '>';
                            }
                        }
                        else if (parserInput.$char('<')) {
                            if (parserInput.$char('=')) {
                                op = '<=';
                            }
                            else {
                                op = '<';
                            }
                        }
                        else if (parserInput.$char('=')) {
                            if (parserInput.$char('>')) {
                                op = '=>';
                            }
                            else if (parserInput.$char('<')) {
                                op = '=<';
                            }
                            else {
                                op = '=';
                            }
                        }
                        if (op) {
                            b = cond();
                            if (b) {
                                c = new (tree.Condition)(op, a, b, index, false);
                            }
                            else {
                                error('expected expression');
                            }
                        }
                        else {
                            c = new (tree.Condition)('=', a, new (tree.Keyword)('true'), index, false);
                        }
                        return c;
                    }
                },
                //
                // An operand is anything that can be part of an operation,
                // such as a Color, or a Variable
                //
                operand: function () {
                    var entities = this.entities;
                    var negate;
                    if (parserInput.peek(/^-[@\$\(]/)) {
                        negate = parserInput.$char('-');
                    }
                    var o = this.sub() || entities.dimension() ||
                        entities.color() || entities.variable() ||
                        entities.property() || entities.call() ||
                        entities.quoted(true) || entities.colorKeyword() ||
                        entities.mixinLookup();
                    if (negate) {
                        o.parensInOp = true;
                        o = new (tree.Negative)(o);
                    }
                    return o;
                },
                //
                // Expressions either represent mathematical operations,
                // or white-space delimited Entities.
                //
                //     1px solid black
                //     @var * 2
                //
                expression: function () {
                    var entities = [];
                    var e;
                    var delim;
                    var index = parserInput.i;
                    do {
                        e = this.comment();
                        if (e) {
                            entities.push(e);
                            continue;
                        }
                        e = this.addition() || this.entity();
                        if (e instanceof tree.Comment) {
                            e = null;
                        }
                        if (e) {
                            entities.push(e);
                            // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
                            if (!parserInput.peek(/^\/[\/*]/)) {
                                delim = parserInput.$char('/');
                                if (delim) {
                                    entities.push(new (tree.Anonymous)(delim, index));
                                }
                            }
                        }
                    } while (e);
                    if (entities.length > 0) {
                        return new (tree.Expression)(entities);
                    }
                },
                property: function () {
                    var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
                    if (name) {
                        return name[1];
                    }
                },
                ruleProperty: function () {
                    var name = [];
                    var index = [];
                    var s;
                    var k;
                    parserInput.save();
                    var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
                    if (simpleProperty) {
                        name = [new (tree.Keyword)(simpleProperty[1])];
                        parserInput.forget();
                        return name;
                    }
                    function match(re) {
                        var i = parserInput.i;
                        var chunk = parserInput.$re(re);
                        if (chunk) {
                            index.push(i);
                            return name.push(chunk[1]);
                        }
                    }
                    match(/^(\*?)/);
                    while (true) {
                        if (!match(/^((?:[\w-]+)|(?:[@\$]\{[\w-]+\}))/)) {
                            break;
                        }
                    }
                    if ((name.length > 1) && match(/^((?:\+_|\+)?)\s*:/)) {
                        parserInput.forget();
                        // at last, we have the complete match now. move forward,
                        // convert name particles to tree objects and return:
                        if (name[0] === '') {
                            name.shift();
                            index.shift();
                        }
                        for (k = 0; k < name.length; k++) {
                            s = name[k];
                            name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?
                                new (tree.Keyword)(s) :
                                (s.charAt(0) === '@' ?
                                    new (tree.Variable)("@" + s.slice(2, -1), index[k], fileInfo) :
                                    new (tree.Property)("$" + s.slice(2, -1), index[k], fileInfo));
                        }
                        return name;
                    }
                    parserInput.restore();
                }
            }
        };
    };
    Parser.serializeVars = function (vars) {
        var s = '';
        for (var name_1 in vars) {
            if (Object.hasOwnProperty.call(vars, name_1)) {
                var value = vars[name_1];
                s += ((name_1[0] === '@') ? '' : '@') + name_1 + ": " + value + ((String(value).slice(-1) === ';') ? '' : ';');
            }
        }
        return s;
    };

    function boolean(condition) {
        return condition ? Keyword.True : Keyword.False;
    }
    /**
     * Functions with evalArgs set to false are sent context
     * as the first argument.
     */
    function If(context, condition, trueValue, falseValue) {
        return condition.eval(context) ? trueValue.eval(context)
            : (falseValue ? falseValue.eval(context) : new Anonymous);
    }
    If.evalArgs = false;
    function isdefined(context, variable) {
        try {
            variable.eval(context);
            return Keyword.True;
        }
        catch (e) {
            return Keyword.False;
        }
    }
    isdefined.evalArgs = false;
    var boolean$1 = { isdefined: isdefined, boolean: boolean, 'if': If };

    var colorFunctions;
    function clamp$1(val) {
        return Math.min(1, Math.max(0, val));
    }
    function hsla(origColor, hsl) {
        var color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);
        if (color) {
            if (origColor.value &&
                /^(rgb|hsl)/.test(origColor.value)) {
                color.value = origColor.value;
            }
            else {
                color.value = 'rgb';
            }
            return color;
        }
    }
    function toHSL(color) {
        if (color.toHSL) {
            return color.toHSL();
        }
        else {
            throw new Error('Argument cannot be evaluated to a color');
        }
    }
    function toHSV(color) {
        if (color.toHSV) {
            return color.toHSV();
        }
        else {
            throw new Error('Argument cannot be evaluated to a color');
        }
    }
    function number(n) {
        if (n instanceof Dimension) {
            return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);
        }
        else if (typeof n === 'number') {
            return n;
        }
        else {
            throw {
                type: 'Argument',
                message: 'color functions take numbers as parameters'
            };
        }
    }
    function scaled(n, size) {
        if (n instanceof Dimension && n.unit.is('%')) {
            return parseFloat(n.value * size / 100);
        }
        else {
            return number(n);
        }
    }
    colorFunctions = {
        rgb: function (r, g, b) {
            var a = 1;
            /**
             * Comma-less syntax
             *   e.g. rgb(0 128 255 / 50%)
             */
            if (r instanceof Expression) {
                var val = r.value;
                r = val[0];
                g = val[1];
                b = val[2];
                /**
                 * @todo - should this be normalized in
                 *   function caller? Or parsed differently?
                 */
                if (b instanceof Operation) {
                    var op = b;
                    b = op.operands[0];
                    a = op.operands[1];
                }
            }
            var color = colorFunctions.rgba(r, g, b, a);
            if (color) {
                color.value = 'rgb';
                return color;
            }
        },
        rgba: function (r, g, b, a) {
            try {
                if (r instanceof Color) {
                    if (g) {
                        a = number(g);
                    }
                    else {
                        a = r.alpha;
                    }
                    return new Color(r.rgb, a, 'rgba');
                }
                var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });
                a = number(a);
                return new Color(rgb, a, 'rgba');
            }
            catch (e) { }
        },
        hsl: function (h, s, l) {
            var a = 1;
            if (h instanceof Expression) {
                var val = h.value;
                h = val[0];
                s = val[1];
                l = val[2];
                if (l instanceof Operation) {
                    var op = l;
                    l = op.operands[0];
                    a = op.operands[1];
                }
            }
            var color = colorFunctions.hsla(h, s, l, a);
            if (color) {
                color.value = 'hsl';
                return color;
            }
        },
        hsla: function (h, s, l, a) {
            try {
                if (h instanceof Color) {
                    if (s) {
                        a = number(s);
                    }
                    else {
                        a = h.alpha;
                    }
                    return new Color(h.rgb, a, 'hsla');
                }
                var m1_1;
                var m2_1;
                function hue(h) {
                    h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
                    if (h * 6 < 1) {
                        return m1_1 + (m2_1 - m1_1) * h * 6;
                    }
                    else if (h * 2 < 1) {
                        return m2_1;
                    }
                    else if (h * 3 < 2) {
                        return m1_1 + (m2_1 - m1_1) * (2 / 3 - h) * 6;
                    }
                    else {
                        return m1_1;
                    }
                }
                h = (number(h) % 360) / 360;
                s = clamp$1(number(s));
                l = clamp$1(number(l));
                a = clamp$1(number(a));
                m2_1 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                m1_1 = l * 2 - m2_1;
                var rgb = [
                    hue(h + 1 / 3) * 255,
                    hue(h) * 255,
                    hue(h - 1 / 3) * 255
                ];
                a = number(a);
                return new Color(rgb, a, 'hsla');
            }
            catch (e) { }
        },
        hsv: function (h, s, v) {
            return colorFunctions.hsva(h, s, v, 1.0);
        },
        hsva: function (h, s, v, a) {
            h = ((number(h) % 360) / 360) * 360;
            s = number(s);
            v = number(v);
            a = number(a);
            var i;
            var f;
            i = Math.floor((h / 60) % 6);
            f = (h / 60) - i;
            var vs = [v,
                v * (1 - s),
                v * (1 - f * s),
                v * (1 - (1 - f) * s)];
            var perm = [[0, 3, 1],
                [2, 0, 1],
                [1, 0, 3],
                [1, 2, 0],
                [3, 1, 0],
                [0, 1, 2]];
            return colorFunctions.rgba(vs[perm[i][0]] * 255, vs[perm[i][1]] * 255, vs[perm[i][2]] * 255, a);
        },
        hue: function (color) {
            return new Dimension(toHSL(color).h);
        },
        saturation: function (color) {
            return new Dimension(toHSL(color).s * 100, '%');
        },
        lightness: function (color) {
            return new Dimension(toHSL(color).l * 100, '%');
        },
        hsvhue: function (color) {
            return new Dimension(toHSV(color).h);
        },
        hsvsaturation: function (color) {
            return new Dimension(toHSV(color).s * 100, '%');
        },
        hsvvalue: function (color) {
            return new Dimension(toHSV(color).v * 100, '%');
        },
        red: function (color) {
            return new Dimension(color.rgb[0]);
        },
        green: function (color) {
            return new Dimension(color.rgb[1]);
        },
        blue: function (color) {
            return new Dimension(color.rgb[2]);
        },
        alpha: function (color) {
            return new Dimension(toHSL(color).a);
        },
        luma: function (color) {
            return new Dimension(color.luma() * color.alpha * 100, '%');
        },
        luminance: function (color) {
            var luminance = (0.2126 * color.rgb[0] / 255) +
                (0.7152 * color.rgb[1] / 255) +
                (0.0722 * color.rgb[2] / 255);
            return new Dimension(luminance * color.alpha * 100, '%');
        },
        saturate: function (color, amount, method) {
            // filter: saturate(3.2);
            // should be kept as is, so check for color
            if (!color.rgb) {
                return null;
            }
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.s += hsl.s * amount.value / 100;
            }
            else {
                hsl.s += amount.value / 100;
            }
            hsl.s = clamp$1(hsl.s);
            return hsla(color, hsl);
        },
        desaturate: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.s -= hsl.s * amount.value / 100;
            }
            else {
                hsl.s -= amount.value / 100;
            }
            hsl.s = clamp$1(hsl.s);
            return hsla(color, hsl);
        },
        lighten: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.l += hsl.l * amount.value / 100;
            }
            else {
                hsl.l += amount.value / 100;
            }
            hsl.l = clamp$1(hsl.l);
            return hsla(color, hsl);
        },
        darken: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.l -= hsl.l * amount.value / 100;
            }
            else {
                hsl.l -= amount.value / 100;
            }
            hsl.l = clamp$1(hsl.l);
            return hsla(color, hsl);
        },
        fadein: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.a += hsl.a * amount.value / 100;
            }
            else {
                hsl.a += amount.value / 100;
            }
            hsl.a = clamp$1(hsl.a);
            return hsla(color, hsl);
        },
        fadeout: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.a -= hsl.a * amount.value / 100;
            }
            else {
                hsl.a -= amount.value / 100;
            }
            hsl.a = clamp$1(hsl.a);
            return hsla(color, hsl);
        },
        fade: function (color, amount) {
            var hsl = toHSL(color);
            hsl.a = amount.value / 100;
            hsl.a = clamp$1(hsl.a);
            return hsla(color, hsl);
        },
        spin: function (color, amount) {
            var hsl = toHSL(color);
            var hue = (hsl.h + amount.value) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return hsla(color, hsl);
        },
        //
        // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein
        // http://sass-lang.com
        //
        mix: function (color1, color2, weight) {
            if (!weight) {
                weight = new Dimension(50);
            }
            var p = weight.value / 100.0;
            var w = p * 2 - 1;
            var a = toHSL(color1).a - toHSL(color2).a;
            var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
            var w2 = 1 - w1;
            var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
                color1.rgb[1] * w1 + color2.rgb[1] * w2,
                color1.rgb[2] * w1 + color2.rgb[2] * w2];
            var alpha = color1.alpha * p + color2.alpha * (1 - p);
            return new Color(rgb, alpha);
        },
        greyscale: function (color) {
            return colorFunctions.desaturate(color, new Dimension(100));
        },
        contrast: function (color, dark, light, threshold) {
            // filter: contrast(3.2);
            // should be kept as is, so check for color
            if (!color.rgb) {
                return null;
            }
            if (typeof light === 'undefined') {
                light = colorFunctions.rgba(255, 255, 255, 1.0);
            }
            if (typeof dark === 'undefined') {
                dark = colorFunctions.rgba(0, 0, 0, 1.0);
            }
            // Figure out which is actually light and dark:
            if (dark.luma() > light.luma()) {
                var t = light;
                light = dark;
                dark = t;
            }
            if (typeof threshold === 'undefined') {
                threshold = 0.43;
            }
            else {
                threshold = number(threshold);
            }
            if (color.luma() < threshold) {
                return light;
            }
            else {
                return dark;
            }
        },
        // Changes made in 2.7.0 - Reverted in 3.0.0
        // contrast: function (color, color1, color2, threshold) {
        //     // Return which of `color1` and `color2` has the greatest contrast with `color`
        //     // according to the standard WCAG contrast ratio calculation.
        //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        //     // The threshold param is no longer used, in line with SASS.
        //     // filter: contrast(3.2);
        //     // should be kept as is, so check for color
        //     if (!color.rgb) {
        //         return null;
        //     }
        //     if (typeof color1 === 'undefined') {
        //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);
        //     }
        //     if (typeof color2 === 'undefined') {
        //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);
        //     }
        //     var contrast1, contrast2;
        //     var luma = color.luma();
        //     var luma1 = color1.luma();
        //     var luma2 = color2.luma();
        //     // Calculate contrast ratios for each color
        //     if (luma > luma1) {
        //         contrast1 = (luma + 0.05) / (luma1 + 0.05);
        //     } else {
        //         contrast1 = (luma1 + 0.05) / (luma + 0.05);
        //     }
        //     if (luma > luma2) {
        //         contrast2 = (luma + 0.05) / (luma2 + 0.05);
        //     } else {
        //         contrast2 = (luma2 + 0.05) / (luma + 0.05);
        //     }
        //     if (contrast1 > contrast2) {
        //         return color1;
        //     } else {
        //         return color2;
        //     }
        // },
        argb: function (color) {
            return new Anonymous(color.toARGB());
        },
        color: function (c) {
            if ((c instanceof Quoted) &&
                (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {
                var val = c.value.slice(1);
                return new Color(val, undefined, "#" + val);
            }
            if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {
                c.value = undefined;
                return c;
            }
            throw {
                type: 'Argument',
                message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'
            };
        },
        tint: function (color, amount) {
            return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);
        },
        shade: function (color, amount) {
            return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);
        }
    };
    var color = colorFunctions;

    // Color Blending
    // ref: http://www.w3.org/TR/compositing-1
    function colorBlend(mode, color1, color2) {
        var ab = color1.alpha; // result
        var // backdrop
        cb;
        var as = color2.alpha;
        var // source
        cs;
        var ar;
        var cr;
        var r = [];
        ar = as + ab * (1 - as);
        for (var i = 0; i < 3; i++) {
            cb = color1.rgb[i] / 255;
            cs = color2.rgb[i] / 255;
            cr = mode(cb, cs);
            if (ar) {
                cr = (as * cs + ab * (cb -
                    as * (cb + cs - cr))) / ar;
            }
            r[i] = cr * 255;
        }
        return new Color(r, ar);
    }
    var colorBlendModeFunctions = {
        multiply: function (cb, cs) {
            return cb * cs;
        },
        screen: function (cb, cs) {
            return cb + cs - cb * cs;
        },
        overlay: function (cb, cs) {
            cb *= 2;
            return (cb <= 1) ?
                colorBlendModeFunctions.multiply(cb, cs) :
                colorBlendModeFunctions.screen(cb - 1, cs);
        },
        softlight: function (cb, cs) {
            var d = 1;
            var e = cb;
            if (cs > 0.5) {
                e = 1;
                d = (cb > 0.25) ? Math.sqrt(cb)
                    : ((16 * cb - 12) * cb + 4) * cb;
            }
            return cb - (1 - 2 * cs) * e * (d - cb);
        },
        hardlight: function (cb, cs) {
            return colorBlendModeFunctions.overlay(cs, cb);
        },
        difference: function (cb, cs) {
            return Math.abs(cb - cs);
        },
        exclusion: function (cb, cs) {
            return cb + cs - 2 * cb * cs;
        },
        // non-w3c functions:
        average: function (cb, cs) {
            return (cb + cs) / 2;
        },
        negation: function (cb, cs) {
            return 1 - Math.abs(cb + cs - 1);
        }
    };
    for (var f in colorBlendModeFunctions) {
        if (colorBlendModeFunctions.hasOwnProperty(f)) {
            colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);
        }
    }

    var dataUri = (function (environment) {
        var fallback = function (functionThis, node) { return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context); };
        return { 'data-uri': function (mimetypeNode, filePathNode) {
                if (!filePathNode) {
                    filePathNode = mimetypeNode;
                    mimetypeNode = null;
                }
                var mimetype = mimetypeNode && mimetypeNode.value;
                var filePath = filePathNode.value;
                var currentFileInfo = this.currentFileInfo;
                var currentDirectory = currentFileInfo.rewriteUrls ?
                    currentFileInfo.currentDirectory : currentFileInfo.entryPath;
                var fragmentStart = filePath.indexOf('#');
                var fragment = '';
                if (fragmentStart !== -1) {
                    fragment = filePath.slice(fragmentStart);
                    filePath = filePath.slice(0, fragmentStart);
                }
                var context = clone(this.context);
                context.rawBuffer = true;
                var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);
                if (!fileManager) {
                    return fallback(this, filePathNode);
                }
                var useBase64 = false;
                // detect the mimetype if not given
                if (!mimetypeNode) {
                    mimetype = environment.mimeLookup(filePath);
                    if (mimetype === 'image/svg+xml') {
                        useBase64 = false;
                    }
                    else {
                        // use base 64 unless it's an ASCII or UTF-8 format
                        var charset = environment.charsetLookup(mimetype);
                        useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;
                    }
                    if (useBase64) {
                        mimetype += ';base64';
                    }
                }
                else {
                    useBase64 = /;base64$/.test(mimetype);
                }
                var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);
                if (!fileSync.contents) {
                    logger.warn("Skipped data-uri embedding of " + filePath + " because file not found");
                    return fallback(this, filePathNode || mimetypeNode);
                }
                var buf = fileSync.contents;
                if (useBase64 && !environment.encodeBase64) {
                    return fallback(this, filePathNode);
                }
                buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);
                var uri = "data:" + mimetype + "," + buf + fragment;
                return new URL(new Quoted("\"" + uri + "\"", uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
            } };
    });

    var getItemsFromNode = function (node) {
        // handle non-array values as an array of length 1
        // return 'undefined' if index is invalid
        var items = Array.isArray(node.value) ?
            node.value : Array(node);
        return items;
    };
    var list = {
        _SELF: function (n) {
            return n;
        },
        '~': function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i] = arguments[_i];
            }
            if (expr.length === 1) {
                return expr[0];
            }
            return new Value(expr);
        },
        extract: function (values, index) {
            // (1-based index)
            index = index.value - 1;
            return getItemsFromNode(values)[index];
        },
        length: function (values) {
            return new Dimension(getItemsFromNode(values).length);
        },
        /**
         * Creates a Less list of incremental values.
         * Modeled after Lodash's range function, also exists natively in PHP
         *
         * @param {Dimension} [start=1]
         * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output
         * @param {Dimension} [step=1]
         */
        range: function (start, end, step) {
            var from;
            var to;
            var stepValue = 1;
            var list = [];
            if (end) {
                to = end;
                from = start.value;
                if (step) {
                    stepValue = step.value;
                }
            }
            else {
                from = 1;
                to = start;
            }
            for (var i = from; i <= to.value; i += stepValue) {
                list.push(new Dimension(i, to.unit));
            }
            return new Expression(list);
        },
        each: function (list, rs) {
            var _this = this;
            var rules = [];
            var newRules;
            var iterator;
            var tryEval = function (val) {
                if (val instanceof Node) {
                    return val.eval(_this.context);
                }
                return val;
            };
            if (list.value && !(list instanceof Quoted)) {
                if (Array.isArray(list.value)) {
                    iterator = list.value.map(tryEval);
                }
                else {
                    iterator = [tryEval(list.value)];
                }
            }
            else if (list.ruleset) {
                iterator = tryEval(list.ruleset).rules;
            }
            else if (list.rules) {
                iterator = list.rules.map(tryEval);
            }
            else if (Array.isArray(list)) {
                iterator = list.map(tryEval);
            }
            else {
                iterator = [tryEval(list)];
            }
            var valueName = '@value';
            var keyName = '@key';
            var indexName = '@index';
            if (rs.params) {
                valueName = rs.params[0] && rs.params[0].name;
                keyName = rs.params[1] && rs.params[1].name;
                indexName = rs.params[2] && rs.params[2].name;
                rs = rs.rules;
            }
            else {
                rs = rs.ruleset;
            }
            for (var i = 0; i < iterator.length; i++) {
                var key = void 0;
                var value = void 0;
                var item = iterator[i];
                if (item instanceof Declaration) {
                    key = typeof item.name === 'string' ? item.name : item.name[0].value;
                    value = item.value;
                }
                else {
                    key = new Dimension(i + 1);
                    value = item;
                }
                if (item instanceof Comment) {
                    continue;
                }
                newRules = rs.rules.slice(0);
                if (valueName) {
                    newRules.push(new Declaration(valueName, value, false, false, this.index, this.currentFileInfo));
                }
                if (indexName) {
                    newRules.push(new Declaration(indexName, new Dimension(i + 1), false, false, this.index, this.currentFileInfo));
                }
                if (keyName) {
                    newRules.push(new Declaration(keyName, key, false, false, this.index, this.currentFileInfo));
                }
                rules.push(new Ruleset([new (Selector)([new Element("", '&')])], newRules, rs.strictImports, rs.visibilityInfo()));
            }
            return new Ruleset([new (Selector)([new Element("", '&')])], rules, rs.strictImports, rs.visibilityInfo()).eval(this.context);
        }
    };

    var MathHelper = function (fn, unit, n) {
        if (!(n instanceof Dimension)) {
            throw { type: 'Argument', message: 'argument must be a number' };
        }
        if (unit == null) {
            unit = n.unit;
        }
        else {
            n = n.unify();
        }
        return new Dimension(fn(parseFloat(n.value)), unit);
    };

    var mathFunctions = {
        // name,  unit
        ceil: null,
        floor: null,
        sqrt: null,
        abs: null,
        tan: '',
        sin: '',
        cos: '',
        atan: 'rad',
        asin: 'rad',
        acos: 'rad'
    };
    for (var f$1 in mathFunctions) {
        if (mathFunctions.hasOwnProperty(f$1)) {
            mathFunctions[f$1] = MathHelper.bind(null, Math[f$1], mathFunctions[f$1]);
        }
    }
    mathFunctions.round = function (n, f) {
        var fraction = typeof f === 'undefined' ? 0 : f.value;
        return MathHelper(function (num) { return num.toFixed(fraction); }, null, n);
    };

    var minMax = function (isMin, args) {
        args = Array.prototype.slice.call(args);
        switch (args.length) {
            case 0: throw { type: 'Argument', message: 'one or more arguments required' };
        }
        var i; // key is the unit.toString() for unified Dimension values,
        var j;
        var current;
        var currentUnified;
        var referenceUnified;
        var unit;
        var unitStatic;
        var unitClone;
        var // elems only contains original argument values.
        order = [];
        var values = {};
        // value is the index into the order array.
        for (i = 0; i < args.length; i++) {
            current = args[i];
            if (!(current instanceof Dimension)) {
                if (Array.isArray(args[i].value)) {
                    Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
                }
                continue;
            }
            currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();
            unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
            unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;
            unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;
            j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];
            if (j === undefined) {
                if (unitStatic !== undefined && unit !== unitStatic) {
                    throw { type: 'Argument', message: 'incompatible types' };
                }
                values[unit] = order.length;
                order.push(current);
                continue;
            }
            referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();
            if (isMin && currentUnified.value < referenceUnified.value ||
                !isMin && currentUnified.value > referenceUnified.value) {
                order[j] = current;
            }
        }
        if (order.length == 1) {
            return order[0];
        }
        args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');
        return new Anonymous((isMin ? 'min' : 'max') + "(" + args + ")");
    };
    var number$1 = {
        min: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return minMax(true, args);
            }
            catch (e) { }
        },
        max: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return minMax(false, args);
            }
            catch (e) { }
        },
        convert: function (val, unit) {
            return val.convertTo(unit.value);
        },
        pi: function () {
            return new Dimension(Math.PI);
        },
        mod: function (a, b) {
            return new Dimension(a.value % b.value, a.unit);
        },
        pow: function (x, y) {
            if (typeof x === 'number' && typeof y === 'number') {
                x = new Dimension(x);
                y = new Dimension(y);
            }
            else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {
                throw { type: 'Argument', message: 'arguments must be numbers' };
            }
            return new Dimension(Math.pow(x.value, y.value), x.unit);
        },
        percentage: function (n) {
            var result = MathHelper(function (num) { return num * 100; }, '%', n);
            return result;
        }
    };

    var string = {
        e: function (str) {
            return new Quoted('"', str instanceof JavaScript ? str.evaluated : str.value, true);
        },
        escape: function (str) {
            return new Anonymous(encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')
                .replace(/\(/g, '%28').replace(/\)/g, '%29'));
        },
        replace: function (string, pattern, replacement, flags) {
            var result = string.value;
            replacement = (replacement.type === 'Quoted') ?
                replacement.value : replacement.toCSS();
            result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);
            return new Quoted(string.quote || '', result, string.escaped);
        },
        '%': function (string /* arg, arg, ... */) {
            var args = Array.prototype.slice.call(arguments, 1);
            var result = string.value;
            var _loop_1 = function (i) {
                /* jshint loopfunc:true */
                result = result.replace(/%[sda]/i, function (token) {
                    var value = ((args[i].type === 'Quoted') &&
                        token.match(/s/i)) ? args[i].value : args[i].toCSS();
                    return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
                });
            };
            for (var i = 0; i < args.length; i++) {
                _loop_1(i);
            }
            result = result.replace(/%%/g, '%');
            return new Quoted(string.quote || '', result, string.escaped);
        }
    };

    var svg = (function (environment) {
        return { 'svg-gradient': function (direction) {
                var stops;
                var gradientDirectionSvg;
                var gradientType = 'linear';
                var rectangleDimension = 'x="0" y="0" width="1" height="1"';
                var renderEnv = { compress: false };
                var returner;
                var directionValue = direction.toCSS(renderEnv);
                var i;
                var color;
                var position;
                var positionValue;
                var alpha;
                function throwArgumentDescriptor() {
                    throw { type: 'Argument',
                        message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +
                            ' end_color [end_position] or direction, color list' };
                }
                if (arguments.length == 2) {
                    if (arguments[1].value.length < 2) {
                        throwArgumentDescriptor();
                    }
                    stops = arguments[1].value;
                }
                else if (arguments.length < 3) {
                    throwArgumentDescriptor();
                }
                else {
                    stops = Array.prototype.slice.call(arguments, 1);
                }
                switch (directionValue) {
                    case 'to bottom':
                        gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
                        break;
                    case 'to right':
                        gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
                        break;
                    case 'to bottom right':
                        gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
                        break;
                    case 'to top right':
                        gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
                        break;
                    case 'ellipse':
                    case 'ellipse at center':
                        gradientType = 'radial';
                        gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
                        rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
                        break;
                    default:
                        throw { type: 'Argument', message: 'svg-gradient direction must be \'to bottom\', \'to right\',' +
                                ' \'to bottom right\', \'to top right\' or \'ellipse at center\'' };
                }
                returner = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"><" + gradientType + "Gradient id=\"g\" " + gradientDirectionSvg + ">";
                for (i = 0; i < stops.length; i += 1) {
                    if (stops[i] instanceof Expression) {
                        color = stops[i].value[0];
                        position = stops[i].value[1];
                    }
                    else {
                        color = stops[i];
                        position = undefined;
                    }
                    if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {
                        throwArgumentDescriptor();
                    }
                    positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';
                    alpha = color.alpha;
                    returner += "<stop offset=\"" + positionValue + "\" stop-color=\"" + color.toRGB() + "\"" + (alpha < 1 ? " stop-opacity=\"" + alpha + "\"" : '') + "/>";
                }
                returner += "</" + gradientType + "Gradient><rect " + rectangleDimension + " fill=\"url(#g)\" /></svg>";
                returner = encodeURIComponent(returner);
                returner = "data:image/svg+xml," + returner;
                return new URL(new Quoted("'" + returner + "'", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
            } };
    });

    var isa = function (n, Type) { return (n instanceof Type) ? Keyword.True : Keyword.False; };
    var isunit = function (n, unit) {
        if (unit === undefined) {
            throw { type: 'Argument', message: 'missing the required second argument to isunit.' };
        }
        unit = typeof unit.value === 'string' ? unit.value : unit;
        if (typeof unit !== 'string') {
            throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };
        }
        return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;
    };
    var types = {
        isruleset: function (n) {
            return isa(n, DetachedRuleset);
        },
        iscolor: function (n) {
            return isa(n, Color);
        },
        isnumber: function (n) {
            return isa(n, Dimension);
        },
        isstring: function (n) {
            return isa(n, Quoted);
        },
        iskeyword: function (n) {
            return isa(n, Keyword);
        },
        isurl: function (n) {
            return isa(n, URL);
        },
        ispixel: function (n) {
            return isunit(n, 'px');
        },
        ispercentage: function (n) {
            return isunit(n, '%');
        },
        isem: function (n) {
            return isunit(n, 'em');
        },
        isunit: isunit,
        unit: function (val, unit) {
            if (!(val instanceof Dimension)) {
                throw { type: 'Argument', message: "the first argument to unit must be a number" + (val instanceof Operation ? '. Have you forgotten parenthesis?' : '') };
            }
            if (unit) {
                if (unit instanceof Keyword) {
                    unit = unit.value;
                }
                else {
                    unit = unit.toCSS();
                }
            }
            else {
                unit = '';
            }
            return new Dimension(val.value, unit);
        },
        'get-unit': function (n) {
            return new Anonymous(n.unit);
        }
    };

    var functions = (function (environment) {
        var functions = { functionRegistry: functionRegistry, functionCaller: functionCaller };
        // register functions
        functionRegistry.addMultiple(boolean$1);
        functionRegistry.add('default', defaultFunc.eval.bind(defaultFunc));
        functionRegistry.addMultiple(color);
        functionRegistry.addMultiple(colorBlend);
        functionRegistry.addMultiple(dataUri(environment));
        functionRegistry.addMultiple(list);
        functionRegistry.addMultiple(mathFunctions);
        functionRegistry.addMultiple(number$1);
        functionRegistry.addMultiple(string);
        functionRegistry.addMultiple(svg());
        functionRegistry.addMultiple(types);
        return functions;
    });

    function transformTree (root, options) {
        options = options || {};
        var evaldRoot;
        var variables = options.variables;
        var evalEnv = new contexts.Eval(options);
        //
        // Allows setting variables with a hash, so:
        //
        //   `{ color: new tree.Color('#f01') }` will become:
        //
        //   new tree.Declaration('@color',
        //     new tree.Value([
        //       new tree.Expression([
        //         new tree.Color('#f01')
        //       ])
        //     ])
        //   )
        //
        if (typeof variables === 'object' && !Array.isArray(variables)) {
            variables = Object.keys(variables).map(function (k) {
                var value = variables[k];
                if (!(value instanceof tree.Value)) {
                    if (!(value instanceof tree.Expression)) {
                        value = new tree.Expression([value]);
                    }
                    value = new tree.Value([value]);
                }
                return new tree.Declaration("@" + k, value, false, null, 0);
            });
            evalEnv.frames = [new tree.Ruleset(null, variables)];
        }
        var visitors$1 = [
            new visitors.JoinSelectorVisitor(),
            new visitors.MarkVisibleSelectorsVisitor(true),
            new visitors.ExtendVisitor(),
            new visitors.ToCSSVisitor({ compress: Boolean(options.compress) })
        ];
        var preEvalVisitors = [];
        var v;
        var visitorIterator;
        /**
         * first() / get() allows visitors to be added while visiting
         *
         * @todo Add scoping for visitors just like functions for @plugin; right now they're global
         */
        if (options.pluginManager) {
            visitorIterator = options.pluginManager.visitor();
            for (var i = 0; i < 2; i++) {
                visitorIterator.first();
                while ((v = visitorIterator.get())) {
                    if (v.isPreEvalVisitor) {
                        if (i === 0 || preEvalVisitors.indexOf(v) === -1) {
                            preEvalVisitors.push(v);
                            v.run(root);
                        }
                    }
                    else {
                        if (i === 0 || visitors$1.indexOf(v) === -1) {
                            if (v.isPreVisitor) {
                                visitors$1.unshift(v);
                            }
                            else {
                                visitors$1.push(v);
                            }
                        }
                    }
                }
            }
        }
        evaldRoot = root.eval(evalEnv);
        for (var i = 0; i < visitors$1.length; i++) {
            visitors$1[i].run(evaldRoot);
        }
        // Run any remaining visitors added after eval pass
        if (options.pluginManager) {
            visitorIterator.first();
            while ((v = visitorIterator.get())) {
                if (visitors$1.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {
                    v.run(evaldRoot);
                }
            }
        }
        return evaldRoot;
    }

    /**
     * Plugin Manager
     */
    var PluginManager = /** @class */ (function () {
        function PluginManager(less) {
            this.less = less;
            this.visitors = [];
            this.preProcessors = [];
            this.postProcessors = [];
            this.installedPlugins = [];
            this.fileManagers = [];
            this.iterator = -1;
            this.pluginCache = {};
            this.Loader = new less.PluginLoader(less);
        }
        /**
         * Adds all the plugins in the array
         * @param {Array} plugins
         */
        PluginManager.prototype.addPlugins = function (plugins) {
            if (plugins) {
                for (var i = 0; i < plugins.length; i++) {
                    this.addPlugin(plugins[i]);
                }
            }
        };
        /**
         *
         * @param plugin
         * @param {String} filename
         */
        PluginManager.prototype.addPlugin = function (plugin, filename, functionRegistry) {
            this.installedPlugins.push(plugin);
            if (filename) {
                this.pluginCache[filename] = plugin;
            }
            if (plugin.install) {
                plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);
            }
        };
        /**
         *
         * @param filename
         */
        PluginManager.prototype.get = function (filename) {
            return this.pluginCache[filename];
        };
        /**
         * Adds a visitor. The visitor object has options on itself to determine
         * when it should run.
         * @param visitor
         */
        PluginManager.prototype.addVisitor = function (visitor) {
            this.visitors.push(visitor);
        };
        /**
         * Adds a pre processor object
         * @param {object} preProcessor
         * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import
         */
        PluginManager.prototype.addPreProcessor = function (preProcessor, priority) {
            var indexToInsertAt;
            for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
                if (this.preProcessors[indexToInsertAt].priority >= priority) {
                    break;
                }
            }
            this.preProcessors.splice(indexToInsertAt, 0, { preProcessor: preProcessor, priority: priority });
        };
        /**
         * Adds a post processor object
         * @param {object} postProcessor
         * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression
         */
        PluginManager.prototype.addPostProcessor = function (postProcessor, priority) {
            var indexToInsertAt;
            for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
                if (this.postProcessors[indexToInsertAt].priority >= priority) {
                    break;
                }
            }
            this.postProcessors.splice(indexToInsertAt, 0, { postProcessor: postProcessor, priority: priority });
        };
        /**
         *
         * @param manager
         */
        PluginManager.prototype.addFileManager = function (manager) {
            this.fileManagers.push(manager);
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getPreProcessors = function () {
            var preProcessors = [];
            for (var i = 0; i < this.preProcessors.length; i++) {
                preProcessors.push(this.preProcessors[i].preProcessor);
            }
            return preProcessors;
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getPostProcessors = function () {
            var postProcessors = [];
            for (var i = 0; i < this.postProcessors.length; i++) {
                postProcessors.push(this.postProcessors[i].postProcessor);
            }
            return postProcessors;
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getVisitors = function () {
            return this.visitors;
        };
        PluginManager.prototype.visitor = function () {
            var self = this;
            return {
                first: function () {
                    self.iterator = -1;
                    return self.visitors[self.iterator];
                },
                get: function () {
                    self.iterator += 1;
                    return self.visitors[self.iterator];
                }
            };
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getFileManagers = function () {
            return this.fileManagers;
        };
        return PluginManager;
    }());
    var pm;
    var PluginManagerFactory = function (less, newFactory) {
        if (newFactory || !pm) {
            pm = new PluginManager(less);
        }
        return pm;
    };

    function SourceMapOutput (environment) {
        var SourceMapOutput = /** @class */ (function () {
            function SourceMapOutput(options) {
                this._css = [];
                this._rootNode = options.rootNode;
                this._contentsMap = options.contentsMap;
                this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;
                if (options.sourceMapFilename) {
                    this._sourceMapFilename = options.sourceMapFilename.replace(/\\/g, '/');
                }
                this._outputFilename = options.outputFilename;
                this.sourceMapURL = options.sourceMapURL;
                if (options.sourceMapBasepath) {
                    this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\/g, '/');
                }
                if (options.sourceMapRootpath) {
                    this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\/g, '/');
                    if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {
                        this._sourceMapRootpath += '/';
                    }
                }
                else {
                    this._sourceMapRootpath = '';
                }
                this._outputSourceFiles = options.outputSourceFiles;
                this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();
                this._lineNumber = 0;
                this._column = 0;
            }
            SourceMapOutput.prototype.removeBasepath = function (path) {
                if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {
                    path = path.substring(this._sourceMapBasepath.length);
                    if (path.charAt(0) === '\\' || path.charAt(0) === '/') {
                        path = path.substring(1);
                    }
                }
                return path;
            };
            SourceMapOutput.prototype.normalizeFilename = function (filename) {
                filename = filename.replace(/\\/g, '/');
                filename = this.removeBasepath(filename);
                return (this._sourceMapRootpath || '') + filename;
            };
            SourceMapOutput.prototype.add = function (chunk, fileInfo, index, mapLines) {
                // ignore adding empty strings
                if (!chunk) {
                    return;
                }
                var lines, sourceLines, columns, sourceColumns, i;
                if (fileInfo && fileInfo.filename) {
                    var inputSource = this._contentsMap[fileInfo.filename];
                    // remove vars/banner added to the top of the file
                    if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
                        // adjust the index
                        index -= this._contentsIgnoredCharsMap[fileInfo.filename];
                        if (index < 0) {
                            index = 0;
                        }
                        // adjust the source
                        inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
                    }
                    /**
                     * ignore empty content, or failsafe
                     * if contents map is incorrect
                     */
                    if (inputSource === undefined) {
                        this._css.push(chunk);
                        return;
                    }
                    inputSource = inputSource.substring(0, index);
                    sourceLines = inputSource.split('\n');
                    sourceColumns = sourceLines[sourceLines.length - 1];
                }
                lines = chunk.split('\n');
                columns = lines[lines.length - 1];
                if (fileInfo && fileInfo.filename) {
                    if (!mapLines) {
                        this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column },
                            original: { line: sourceLines.length, column: sourceColumns.length },
                            source: this.normalizeFilename(fileInfo.filename) });
                    }
                    else {
                        for (i = 0; i < lines.length; i++) {
                            this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0 },
                                original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0 },
                                source: this.normalizeFilename(fileInfo.filename) });
                        }
                    }
                }
                if (lines.length === 1) {
                    this._column += columns.length;
                }
                else {
                    this._lineNumber += lines.length - 1;
                    this._column = columns.length;
                }
                this._css.push(chunk);
            };
            SourceMapOutput.prototype.isEmpty = function () {
                return this._css.length === 0;
            };
            SourceMapOutput.prototype.toCSS = function (context) {
                this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });
                if (this._outputSourceFiles) {
                    for (var filename in this._contentsMap) {
                        if (this._contentsMap.hasOwnProperty(filename)) {
                            var source = this._contentsMap[filename];
                            if (this._contentsIgnoredCharsMap[filename]) {
                                source = source.slice(this._contentsIgnoredCharsMap[filename]);
                            }
                            this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
                        }
                    }
                }
                this._rootNode.genCSS(context, this);
                if (this._css.length > 0) {
                    var sourceMapURL = void 0;
                    var sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());
                    if (this.sourceMapURL) {
                        sourceMapURL = this.sourceMapURL;
                    }
                    else if (this._sourceMapFilename) {
                        sourceMapURL = this._sourceMapFilename;
                    }
                    this.sourceMapURL = sourceMapURL;
                    this.sourceMap = sourceMapContent;
                }
                return this._css.join('');
            };
            return SourceMapOutput;
        }());
        return SourceMapOutput;
    }

    function SourceMapBuilder (SourceMapOutput, environment) {
        var SourceMapBuilder = /** @class */ (function () {
            function SourceMapBuilder(options) {
                this.options = options;
            }
            SourceMapBuilder.prototype.toCSS = function (rootNode, options, imports) {
                var sourceMapOutput = new SourceMapOutput({
                    contentsIgnoredCharsMap: imports.contentsIgnoredChars,
                    rootNode: rootNode,
                    contentsMap: imports.contents,
                    sourceMapFilename: this.options.sourceMapFilename,
                    sourceMapURL: this.options.sourceMapURL,
                    outputFilename: this.options.sourceMapOutputFilename,
                    sourceMapBasepath: this.options.sourceMapBasepath,
                    sourceMapRootpath: this.options.sourceMapRootpath,
                    outputSourceFiles: this.options.outputSourceFiles,
                    sourceMapGenerator: this.options.sourceMapGenerator,
                    sourceMapFileInline: this.options.sourceMapFileInline,
                    disableSourcemapAnnotation: this.options.disableSourcemapAnnotation
                });
                var css = sourceMapOutput.toCSS(options);
                this.sourceMap = sourceMapOutput.sourceMap;
                this.sourceMapURL = sourceMapOutput.sourceMapURL;
                if (this.options.sourceMapInputFilename) {
                    this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
                }
                if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {
                    this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);
                }
                return css + this.getCSSAppendage();
            };
            SourceMapBuilder.prototype.getCSSAppendage = function () {
                var sourceMapURL = this.sourceMapURL;
                if (this.options.sourceMapFileInline) {
                    if (this.sourceMap === undefined) {
                        return '';
                    }
                    sourceMapURL = "data:application/json;base64," + environment.encodeBase64(this.sourceMap);
                }
                if (this.options.disableSourcemapAnnotation) {
                    return '';
                }
                if (sourceMapURL) {
                    return "/*# sourceMappingURL=" + sourceMapURL + " */";
                }
                return '';
            };
            SourceMapBuilder.prototype.getExternalSourceMap = function () {
                return this.sourceMap;
            };
            SourceMapBuilder.prototype.setExternalSourceMap = function (sourceMap) {
                this.sourceMap = sourceMap;
            };
            SourceMapBuilder.prototype.isInline = function () {
                return this.options.sourceMapFileInline;
            };
            SourceMapBuilder.prototype.getSourceMapURL = function () {
                return this.sourceMapURL;
            };
            SourceMapBuilder.prototype.getOutputFilename = function () {
                return this.options.sourceMapOutputFilename;
            };
            SourceMapBuilder.prototype.getInputFilename = function () {
                return this.sourceMapInputFilename;
            };
            return SourceMapBuilder;
        }());
        return SourceMapBuilder;
    }

    function ParseTree (SourceMapBuilder) {
        var ParseTree = /** @class */ (function () {
            function ParseTree(root, imports) {
                this.root = root;
                this.imports = imports;
            }
            ParseTree.prototype.toCSS = function (options) {
                var evaldRoot;
                var result = {};
                var sourceMapBuilder;
                try {
                    evaldRoot = transformTree(this.root, options);
                }
                catch (e) {
                    throw new LessError(e, this.imports);
                }
                try {
                    var compress = Boolean(options.compress);
                    if (compress) {
                        logger.warn('The compress option has been deprecated. ' +
                            'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');
                    }
                    var toCSSOptions = {
                        compress: compress,
                        dumpLineNumbers: options.dumpLineNumbers,
                        strictUnits: Boolean(options.strictUnits),
                        numPrecision: 8
                    };
                    if (options.sourceMap) {
                        sourceMapBuilder = new SourceMapBuilder(options.sourceMap);
                        result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
                    }
                    else {
                        result.css = evaldRoot.toCSS(toCSSOptions);
                    }
                }
                catch (e) {
                    throw new LessError(e, this.imports);
                }
                if (options.pluginManager) {
                    var postProcessors = options.pluginManager.getPostProcessors();
                    for (var i = 0; i < postProcessors.length; i++) {
                        result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });
                    }
                }
                if (options.sourceMap) {
                    result.map = sourceMapBuilder.getExternalSourceMap();
                }
                result.imports = [];
                for (var file in this.imports.files) {
                    if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {
                        result.imports.push(file);
                    }
                }
                return result;
            };
            return ParseTree;
        }());
        return ParseTree;
    }

    function ImportManager (environment) {
        // FileInfo = {
        //  'rewriteUrls' - option - whether to adjust URL's to be relative
        //  'filename' - full resolved filename of current file
        //  'rootpath' - path to append to normal URLs for this node
        //  'currentDirectory' - path to the current file, absolute
        //  'rootFilename' - filename of the base file
        //  'entryPath' - absolute path to the entry file
        //  'reference' - whether the file should not be output and only output parts that are referenced
        var ImportManager = /** @class */ (function () {
            function ImportManager(less, context, rootFileInfo) {
                this.less = less;
                this.rootFilename = rootFileInfo.filename;
                this.paths = context.paths || []; // Search paths, when importing
                this.contents = {}; // map - filename to contents of all the files
                this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore
                this.mime = context.mime;
                this.error = null;
                this.context = context;
                // Deprecated? Unused outside of here, could be useful.
                this.queue = []; // Files which haven't been imported yet
                this.files = {}; // Holds the imported parse trees.
            }
            /**
             * Add an import to be imported
             * @param path - the raw path
             * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)
             * @param currentFileInfo - the current file info (used for instance to work out relative paths)
             * @param importOptions - import options
             * @param callback - callback for when it is imported
             */
            ImportManager.prototype.push = function (path, tryAppendExtension, currentFileInfo, importOptions, callback) {
                var importManager = this, pluginLoader = this.context.pluginManager.Loader;
                this.queue.push(path);
                var fileParsedFunc = function (e, root, fullPath) {
                    importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue
                    var importedEqualsRoot = fullPath === importManager.rootFilename;
                    if (importOptions.optional && e) {
                        callback(null, { rules: [] }, false, null);
                        logger.info("The file " + fullPath + " was skipped because it was not found and the import was marked optional.");
                    }
                    else {
                        // Inline imports aren't cached here.
                        // If we start to cache them, please make sure they won't conflict with non-inline imports of the
                        // same name as they used to do before this comment and the condition below have been added.
                        if (!importManager.files[fullPath] && !importOptions.inline) {
                            importManager.files[fullPath] = { root: root, options: importOptions };
                        }
                        if (e && !importManager.error) {
                            importManager.error = e;
                        }
                        callback(e, root, importedEqualsRoot, fullPath);
                    }
                };
                var newFileInfo = {
                    rewriteUrls: this.context.rewriteUrls,
                    entryPath: currentFileInfo.entryPath,
                    rootpath: currentFileInfo.rootpath,
                    rootFilename: currentFileInfo.rootFilename
                };
                var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);
                if (!fileManager) {
                    fileParsedFunc({ message: "Could not find a file-manager for " + path });
                    return;
                }
                var loadFileCallback = function (loadedFile) {
                    var plugin;
                    var resolvedFilename = loadedFile.filename;
                    var contents = loadedFile.contents.replace(/^\uFEFF/, '');
                    // Pass on an updated rootpath if path of imported file is relative and file
                    // is in a (sub|sup) directory
                    //
                    // Examples:
                    // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',
                    //   then rootpath should become 'less/module/nav/'
                    // - If path of imported file is '../mixins.less' and rootpath is 'less/',
                    //   then rootpath should become 'less/../'
                    newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
                    if (newFileInfo.rewriteUrls) {
                        newFileInfo.rootpath = fileManager.join((importManager.context.rootpath || ''), fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));
                        if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
                            newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
                        }
                    }
                    newFileInfo.filename = resolvedFilename;
                    var newEnv = new contexts.Parse(importManager.context);
                    newEnv.processImports = false;
                    importManager.contents[resolvedFilename] = contents;
                    if (currentFileInfo.reference || importOptions.reference) {
                        newFileInfo.reference = true;
                    }
                    if (importOptions.isPlugin) {
                        plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);
                        if (plugin instanceof LessError) {
                            fileParsedFunc(plugin, null, resolvedFilename);
                        }
                        else {
                            fileParsedFunc(null, plugin, resolvedFilename);
                        }
                    }
                    else if (importOptions.inline) {
                        fileParsedFunc(null, contents, resolvedFilename);
                    }
                    else {
                        // import (multiple) parse trees apparently get altered and can't be cached.
                        // TODO: investigate why this is
                        if (importManager.files[resolvedFilename]
                            && !importManager.files[resolvedFilename].options.multiple
                            && !importOptions.multiple) {
                            fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);
                        }
                        else {
                            new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {
                                fileParsedFunc(e, root, resolvedFilename);
                            });
                        }
                    }
                };
                var loadedFile;
                var promise;
                var context = clone(this.context);
                if (tryAppendExtension) {
                    context.ext = importOptions.isPlugin ? '.js' : '.less';
                }
                if (importOptions.isPlugin) {
                    context.mime = 'application/javascript';
                    if (context.syncImport) {
                        loadedFile = pluginLoader.loadPluginSync(path, currentFileInfo.currentDirectory, context, environment, fileManager);
                    }
                    else {
                        promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);
                    }
                }
                else {
                    if (context.syncImport) {
                        loadedFile = fileManager.loadFileSync(path, currentFileInfo.currentDirectory, context, environment);
                    }
                    else {
                        promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment, function (err, loadedFile) {
                            if (err) {
                                fileParsedFunc(err);
                            }
                            else {
                                loadFileCallback(loadedFile);
                            }
                        });
                    }
                }
                if (loadedFile) {
                    if (!loadedFile.filename) {
                        fileParsedFunc(loadedFile);
                    }
                    else {
                        loadFileCallback(loadedFile);
                    }
                }
                else if (promise) {
                    promise.then(loadFileCallback, fileParsedFunc);
                }
            };
            return ImportManager;
        }());
        return ImportManager;
    }

    function Parse (environment, ParseTree, ImportManager) {
        var parse = function (input, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = copyOptions(this.options, {});
            }
            else {
                options = copyOptions(this.options, options || {});
            }
            if (!callback) {
                var self_1 = this;
                return new Promise(function (resolve, reject) {
                    parse.call(self_1, input, options, function (err, output) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(output);
                        }
                    });
                });
            }
            else {
                var context_1;
                var rootFileInfo = void 0;
                var pluginManager_1 = new PluginManagerFactory(this, !options.reUsePluginManager);
                options.pluginManager = pluginManager_1;
                context_1 = new contexts.Parse(options);
                if (options.rootFileInfo) {
                    rootFileInfo = options.rootFileInfo;
                }
                else {
                    var filename = options.filename || 'input';
                    var entryPath = filename.replace(/[^\/\\]*$/, '');
                    rootFileInfo = {
                        filename: filename,
                        rewriteUrls: context_1.rewriteUrls,
                        rootpath: context_1.rootpath || '',
                        currentDirectory: entryPath,
                        entryPath: entryPath,
                        rootFilename: filename
                    };
                    // add in a missing trailing slash
                    if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {
                        rootFileInfo.rootpath += '/';
                    }
                }
                var imports_1 = new ImportManager(this, context_1, rootFileInfo);
                this.importManager = imports_1;
                // TODO: allow the plugins to be just a list of paths or names
                // Do an async plugin queue like lessc
                if (options.plugins) {
                    options.plugins.forEach(function (plugin) {
                        var evalResult, contents;
                        if (plugin.fileContent) {
                            contents = plugin.fileContent.replace(/^\uFEFF/, '');
                            evalResult = pluginManager_1.Loader.evalPlugin(contents, context_1, imports_1, plugin.options, plugin.filename);
                            if (evalResult instanceof LessError) {
                                return callback(evalResult);
                            }
                        }
                        else {
                            pluginManager_1.addPlugin(plugin);
                        }
                    });
                }
                new Parser(context_1, imports_1, rootFileInfo)
                    .parse(input, function (e, root) {
                    if (e) {
                        return callback(e);
                    }
                    callback(null, root, imports_1, options);
                }, options);
            }
        };
        return parse;
    }

    function Render (environment, ParseTree, ImportManager) {
        var render = function (input, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = copyOptions(this.options, {});
            }
            else {
                options = copyOptions(this.options, options || {});
            }
            if (!callback) {
                var self_1 = this;
                return new Promise(function (resolve, reject) {
                    render.call(self_1, input, options, function (err, output) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(output);
                        }
                    });
                });
            }
            else {
                this.parse(input, options, function (err, root, imports, options) {
                    if (err) {
                        return callback(err);
                    }
                    var result;
                    try {
                        var parseTree = new ParseTree(root, imports);
                        result = parseTree.toCSS(options);
                    }
                    catch (err) {
                        return callback(err);
                    }
                    callback(null, result);
                });
            }
        };
        return render;
    }

    var version = "4.1.1";

    function parseNodeVersion(version) {
      var match = version.match(/^v(\d{1,2})\.(\d{1,2})\.(\d{1,2})(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$/); // eslint-disable-line max-len
      if (!match) {
        throw new Error('Unable to parse: ' + version);
      }

      var res = {
        major: parseInt(match[1], 10),
        minor: parseInt(match[2], 10),
        patch: parseInt(match[3], 10),
        pre: match[4] || '',
        build: match[5] || '',
      };

      return res;
    }

    var parseNodeVersion_1 = parseNodeVersion;

    function lessRoot (environment, fileManagers) {
        var sourceMapOutput, sourceMapBuilder, parseTree, importManager;
        environment = new Environment(environment, fileManagers);
        sourceMapOutput = SourceMapOutput(environment);
        sourceMapBuilder = SourceMapBuilder(sourceMapOutput, environment);
        parseTree = ParseTree(sourceMapBuilder);
        importManager = ImportManager(environment);
        var render = Render(environment, parseTree);
        var parse = Parse(environment, parseTree, importManager);
        var v = parseNodeVersion_1("v" + version);
        var initial = {
            version: [v.major, v.minor, v.patch],
            data: data,
            tree: tree,
            Environment: Environment,
            AbstractFileManager: AbstractFileManager,
            AbstractPluginLoader: AbstractPluginLoader,
            environment: environment,
            visitors: visitors,
            Parser: Parser,
            functions: functions(environment),
            contexts: contexts,
            SourceMapOutput: sourceMapOutput,
            SourceMapBuilder: sourceMapBuilder,
            ParseTree: parseTree,
            ImportManager: importManager,
            render: render,
            parse: parse,
            LessError: LessError,
            transformTree: transformTree,
            utils: utils,
            PluginManager: PluginManagerFactory,
            logger: logger
        };
        // Create a public API
        var ctor = function (t) {
            return function () {
                var obj = Object.create(t.prototype);
                t.apply(obj, Array.prototype.slice.call(arguments, 0));
                return obj;
            };
        };
        var t;
        var api = Object.create(initial);
        for (var n in initial.tree) {
            /* eslint guard-for-in: 0 */
            t = initial.tree[n];
            if (typeof t === 'function') {
                api[n.toLowerCase()] = ctor(t);
            }
            else {
                api[n] = Object.create(null);
                for (var o in t) {
                    /* eslint guard-for-in: 0 */
                    api[n][o.toLowerCase()] = ctor(t[o]);
                }
            }
        }
        /**
         * Some of the functions assume a `this` context of the API object,
         * which causes it to fail when wrapped for ES6 imports.
         *
         * An assumed `this` should be removed in the future.
         */
        initial.parse = initial.parse.bind(api);
        initial.render = initial.render.bind(api);
        return api;
    }

    /* global window, XMLHttpRequest */
    var options;
    var logger$1;
    var fileCache = {};
    // TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load
    var FileManager = function () { };
    FileManager.prototype = Object.assign(new AbstractFileManager(), {
        alwaysMakePathsAbsolute: function () {
            return true;
        },
        join: function (basePath, laterPath) {
            if (!basePath) {
                return laterPath;
            }
            return this.extractUrlParts(laterPath, basePath).path;
        },
        doXHR: function (url, type, callback, errback) {
            var xhr = new XMLHttpRequest();
            var async = options.isFileProtocol ? options.fileAsync : true;
            if (typeof xhr.overrideMimeType === 'function') {
                xhr.overrideMimeType('text/css');
            }
            logger$1.debug("XHR: Getting '" + url + "'");
            xhr.open('GET', url, async);
            xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
            xhr.send(null);
            function handleResponse(xhr, callback, errback) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    callback(xhr.responseText, xhr.getResponseHeader('Last-Modified'));
                }
                else if (typeof errback === 'function') {
                    errback(xhr.status, url);
                }
            }
            if (options.isFileProtocol && !options.fileAsync) {
                if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
                    callback(xhr.responseText);
                }
                else {
                    errback(xhr.status, url);
                }
            }
            else if (async) {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        handleResponse(xhr, callback, errback);
                    }
                };
            }
            else {
                handleResponse(xhr, callback, errback);
            }
        },
        supports: function () {
            return true;
        },
        clearFileCache: function () {
            fileCache = {};
        },
        loadFile: function (filename, currentDirectory, options, environment) {
            // TODO: Add prefix support like less-node?
            // What about multiple paths?
            if (currentDirectory && !this.isPathAbsolute(filename)) {
                filename = currentDirectory + filename;
            }
            filename = options.ext ? this.tryAppendExtension(filename, options.ext) : filename;
            options = options || {};
            // sheet may be set to the stylesheet for the initial load or a collection of properties including
            // some context variables for imports
            var hrefParts = this.extractUrlParts(filename, window.location.href);
            var href = hrefParts.url;
            var self = this;
            return new Promise(function (resolve, reject) {
                if (options.useFileCache && fileCache[href]) {
                    try {
                        var lessText = fileCache[href];
                        return resolve({ contents: lessText, filename: href, webInfo: { lastModified: new Date() } });
                    }
                    catch (e) {
                        return reject({ filename: href, message: "Error loading file " + href + " error was " + e.message });
                    }
                }
                self.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {
                    // per file cache
                    fileCache[href] = data;
                    // Use remote copy (re-parse)
                    resolve({ contents: data, filename: href, webInfo: { lastModified: lastModified } });
                }, function doXHRError(status, url) {
                    reject({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")", href: href });
                });
            });
        }
    });
    var FM = (function (opts, log) {
        options = opts;
        logger$1 = log;
        return FileManager;
    });

    // TODO: Add tests for browser @plugin
    /**
     * Browser Plugin Loader
     */
    var PluginLoader = function (less) {
        this.less = less;
        // Should we shim this.require for browser? Probably not?
    };
    PluginLoader.prototype = Object.assign(new AbstractPluginLoader(), {
        loadPlugin: function (filename, basePath, context, environment, fileManager) {
            return new Promise(function (fulfill, reject) {
                fileManager.loadFile(filename, basePath, context, environment)
                    .then(fulfill).catch(reject);
            });
        }
    });

    var LogListener = (function (less, options) {
        var logLevel_debug = 4;
        var logLevel_info = 3;
        var logLevel_warn = 2;
        var logLevel_error = 1;
        // The amount of logging in the javascript console.
        // 3 - Debug, information and errors
        // 2 - Information and errors
        // 1 - Errors
        // 0 - None
        // Defaults to 2
        options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ? logLevel_info : logLevel_error);
        if (!options.loggers) {
            options.loggers = [{
                    debug: function (msg) {
                        if (options.logLevel >= logLevel_debug) {
                            console.log(msg);
                        }
                    },
                    info: function (msg) {
                        if (options.logLevel >= logLevel_info) {
                            console.log(msg);
                        }
                    },
                    warn: function (msg) {
                        if (options.logLevel >= logLevel_warn) {
                            console.warn(msg);
                        }
                    },
                    error: function (msg) {
                        if (options.logLevel >= logLevel_error) {
                            console.error(msg);
                        }
                    }
                }];
        }
        for (var i = 0; i < options.loggers.length; i++) {
            less.logger.addListener(options.loggers[i]);
        }
    });

    var ErrorReporting = (function (window, less, options) {
        function errorHTML(e, rootHref) {
            var id = "less-error-message:" + extractId(rootHref || '');
            var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
            var elem = window.document.createElement('div');
            var timer;
            var content;
            var errors = [];
            var filename = e.filename || rootHref;
            var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];
            elem.id = id;
            elem.className = 'less-error-message';
            content = "<h3>" + (e.type || 'Syntax') + "Error: " + (e.message || 'There is an error in your .less file') +
                ("</h3><p>in <a href=\"" + filename + "\">" + filenameNoPath + "</a> ");
            var errorline = function (e, i, classname) {
                if (e.extract[i] !== undefined) {
                    errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                        .replace(/\{class\}/, classname)
                        .replace(/\{content\}/, e.extract[i]));
                }
            };
            if (e.line) {
                errorline(e, 0, '');
                errorline(e, 1, 'line');
                errorline(e, 2, '');
                content += "on line " + e.line + ", column " + (e.column + 1) + ":</p><ul>" + errors.join('') + "</ul>";
            }
            if (e.stack && (e.extract || options.logLevel >= 4)) {
                content += "<br/>Stack Trace</br />" + e.stack.split('\n').slice(1).join('<br/>');
            }
            elem.innerHTML = content;
            // CSS for error messages
            browser.createCSS(window.document, [
                '.less-error-message ul, .less-error-message li {',
                'list-style-type: none;',
                'margin-right: 15px;',
                'padding: 4px 0;',
                'margin: 0;',
                '}',
                '.less-error-message label {',
                'font-size: 12px;',
                'margin-right: 15px;',
                'padding: 4px 0;',
                'color: #cc7777;',
                '}',
                '.less-error-message pre {',
                'color: #dd6666;',
                'padding: 4px 0;',
                'margin: 0;',
                'display: inline-block;',
                '}',
                '.less-error-message pre.line {',
                'color: #ff0000;',
                '}',
                '.less-error-message h3 {',
                'font-size: 20px;',
                'font-weight: bold;',
                'padding: 15px 0 5px 0;',
                'margin: 0;',
                '}',
                '.less-error-message a {',
                'color: #10a',
                '}',
                '.less-error-message .error {',
                'color: red;',
                'font-weight: bold;',
                'padding-bottom: 2px;',
                'border-bottom: 1px dashed red;',
                '}'
            ].join('\n'), { title: 'error-message' });
            elem.style.cssText = [
                'font-family: Arial, sans-serif',
                'border: 1px solid #e00',
                'background-color: #eee',
                'border-radius: 5px',
                '-webkit-border-radius: 5px',
                '-moz-border-radius: 5px',
                'color: #e00',
                'padding: 15px',
                'margin-bottom: 15px'
            ].join(';');
            if (options.env === 'development') {
                timer = setInterval(function () {
                    var document = window.document;
                    var body = document.body;
                    if (body) {
                        if (document.getElementById(id)) {
                            body.replaceChild(elem, document.getElementById(id));
                        }
                        else {
                            body.insertBefore(elem, body.firstChild);
                        }
                        clearInterval(timer);
                    }
                }, 10);
            }
        }
        function removeErrorHTML(path) {
            var node = window.document.getElementById("less-error-message:" + extractId(path));
            if (node) {
                node.parentNode.removeChild(node);
            }
        }
        function removeError(path) {
            if (!options.errorReporting || options.errorReporting === 'html') {
                removeErrorHTML(path);
            }
            else if (options.errorReporting === 'console') ;
            else if (typeof options.errorReporting === 'function') {
                options.errorReporting('remove', path);
            }
        }
        function errorConsole(e, rootHref) {
            var template = '{line} {content}';
            var filename = e.filename || rootHref;
            var errors = [];
            var content = (e.type || 'Syntax') + "Error: " + (e.message || 'There is an error in your .less file') + " in " + filename;
            var errorline = function (e, i, classname) {
                if (e.extract[i] !== undefined) {
                    errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                        .replace(/\{class\}/, classname)
                        .replace(/\{content\}/, e.extract[i]));
                }
            };
            if (e.line) {
                errorline(e, 0, '');
                errorline(e, 1, 'line');
                errorline(e, 2, '');
                content += " on line " + e.line + ", column " + (e.column + 1) + ":\n" + errors.join('\n');
            }
            if (e.stack && (e.extract || options.logLevel >= 4)) {
                content += "\nStack Trace\n" + e.stack;
            }
            less.logger.error(content);
        }
        function error(e, rootHref) {
            if (!options.errorReporting || options.errorReporting === 'html') {
                errorHTML(e, rootHref);
            }
            else if (options.errorReporting === 'console') {
                errorConsole(e, rootHref);
            }
            else if (typeof options.errorReporting === 'function') {
                options.errorReporting('add', e, rootHref);
            }
        }
        return {
            add: error,
            remove: removeError
        };
    });

    // Cache system is a bit outdated and could do with work
    var Cache = (function (window, options, logger) {
        var cache = null;
        if (options.env !== 'development') {
            try {
                cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;
            }
            catch (_) { }
        }
        return {
            setCSS: function (path, lastModified, modifyVars, styles) {
                if (cache) {
                    logger.info("saving " + path + " to cache.");
                    try {
                        cache.setItem(path, styles);
                        cache.setItem(path + ":timestamp", lastModified);
                        if (modifyVars) {
                            cache.setItem(path + ":vars", JSON.stringify(modifyVars));
                        }
                    }
                    catch (e) {
                        // TODO - could do with adding more robust error handling
                        logger.error("failed to save \"" + path + "\" to local storage for caching.");
                    }
                }
            },
            getCSS: function (path, webInfo, modifyVars) {
                var css = cache && cache.getItem(path);
                var timestamp = cache && cache.getItem(path + ":timestamp");
                var vars = cache && cache.getItem(path + ":vars");
                modifyVars = modifyVars || {};
                vars = vars || "{}"; // if not set, treat as the JSON representation of an empty object
                if (timestamp && webInfo.lastModified &&
                    (new Date(webInfo.lastModified).valueOf() ===
                        new Date(timestamp).valueOf()) &&
                    JSON.stringify(modifyVars) === vars) {
                    // Use local copy
                    return css;
                }
            }
        };
    });

    var ImageSize = (function () {
        function imageSize() {
            throw {
                type: 'Runtime',
                message: 'Image size functions are not supported in browser version of less'
            };
        }
        var imageFunctions = {
            'image-size': function (filePathNode) {
                imageSize();
                return -1;
            },
            'image-width': function (filePathNode) {
                imageSize();
                return -1;
            },
            'image-height': function (filePathNode) {
                imageSize();
                return -1;
            }
        };
        functionRegistry.addMultiple(imageFunctions);
    });

    //
    var root = (function (window, options) {
        var document = window.document;
        var less = lessRoot();
        less.options = options;
        var environment = less.environment;
        var FileManager = FM(options, less.logger);
        var fileManager = new FileManager();
        environment.addFileManager(fileManager);
        less.FileManager = FileManager;
        less.PluginLoader = PluginLoader;
        LogListener(less, options);
        var errors = ErrorReporting(window, less, options);
        var cache = less.cache = options.cache || Cache(window, options, less.logger);
        ImageSize(less.environment);
        // Setup user functions - Deprecate?
        if (options.functions) {
            less.functions.functionRegistry.addMultiple(options.functions);
        }
        var typePattern = /^text\/(x-)?less$/;
        function clone(obj) {
            var cloned = {};
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    cloned[prop] = obj[prop];
                }
            }
            return cloned;
        }
        // only really needed for phantom
        function bind(func, thisArg) {
            var curryArgs = Array.prototype.slice.call(arguments, 2);
            return function () {
                var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));
                return func.apply(thisArg, args);
            };
        }
        function loadStyles(modifyVars) {
            var styles = document.getElementsByTagName('style');
            var style;
            for (var i = 0; i < styles.length; i++) {
                style = styles[i];
                if (style.type.match(typePattern)) {
                    var instanceOptions = clone(options);
                    instanceOptions.modifyVars = modifyVars;
                    var lessText = style.innerHTML || '';
                    instanceOptions.filename = document.location.href.replace(/#.*$/, '');
                    /* jshint loopfunc:true */
                    // use closure to store current style
                    less.render(lessText, instanceOptions, bind(function (style, e, result) {
                        if (e) {
                            errors.add(e, 'inline');
                        }
                        else {
                            style.type = 'text/css';
                            if (style.styleSheet) {
                                style.styleSheet.cssText = result.css;
                            }
                            else {
                                style.innerHTML = result.css;
                            }
                        }
                    }, null, style));
                }
            }
        }
        function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {
            var instanceOptions = clone(options);
            addDataAttr(instanceOptions, sheet);
            instanceOptions.mime = sheet.type;
            if (modifyVars) {
                instanceOptions.modifyVars = modifyVars;
            }
            function loadInitialFileCallback(loadedFile) {
                var data = loadedFile.contents;
                var path = loadedFile.filename;
                var webInfo = loadedFile.webInfo;
                var newFileInfo = {
                    currentDirectory: fileManager.getPath(path),
                    filename: path,
                    rootFilename: path,
                    rewriteUrls: instanceOptions.rewriteUrls
                };
                newFileInfo.entryPath = newFileInfo.currentDirectory;
                newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;
                if (webInfo) {
                    webInfo.remaining = remaining;
                    var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);
                    if (!reload && css) {
                        webInfo.local = true;
                        callback(null, css, data, sheet, webInfo, path);
                        return;
                    }
                }
                // TODO add tests around how this behaves when reloading
                errors.remove(path);
                instanceOptions.rootFileInfo = newFileInfo;
                less.render(data, instanceOptions, function (e, result) {
                    if (e) {
                        e.href = path;
                        callback(e);
                    }
                    else {
                        cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);
                        callback(null, result.css, data, sheet, webInfo, path);
                    }
                });
            }
            fileManager.loadFile(sheet.href, null, instanceOptions, environment)
                .then(function (loadedFile) {
                loadInitialFileCallback(loadedFile);
            }).catch(function (err) {
                console.log(err);
                callback(err);
            });
        }
        function loadStyleSheets(callback, reload, modifyVars) {
            for (var i = 0; i < less.sheets.length; i++) {
                loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);
            }
        }
        function initRunningMode() {
            if (less.env === 'development') {
                less.watchTimer = setInterval(function () {
                    if (less.watchMode) {
                        fileManager.clearFileCache();
                        loadStyleSheets(function (e, css, _, sheet, webInfo) {
                            if (e) {
                                errors.add(e, e.href || sheet.href);
                            }
                            else if (css) {
                                browser.createCSS(window.document, css, sheet);
                            }
                        });
                    }
                }, options.poll);
            }
        }
        //
        // Watch mode
        //
        less.watch = function () {
            if (!less.watchMode) {
                less.env = 'development';
                initRunningMode();
            }
            this.watchMode = true;
            return true;
        };
        less.unwatch = function () { clearInterval(less.watchTimer); this.watchMode = false; return false; };
        //
        // Synchronously get all <link> tags with the 'rel' attribute set to
        // "stylesheet/less".
        //
        less.registerStylesheetsImmediately = function () {
            var links = document.getElementsByTagName('link');
            less.sheets = [];
            for (var i = 0; i < links.length; i++) {
                if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&
                    (links[i].type.match(typePattern)))) {
                    less.sheets.push(links[i]);
                }
            }
        };
        //
        // Asynchronously get all <link> tags with the 'rel' attribute set to
        // "stylesheet/less", returning a Promise.
        //
        less.registerStylesheets = function () { return new Promise(function (resolve, reject) {
            less.registerStylesheetsImmediately();
            resolve();
        }); };
        //
        // With this function, it's possible to alter variables and re-render
        // CSS without reloading less-files
        //
        less.modifyVars = function (record) { return less.refresh(true, record, false); };
        less.refresh = function (reload, modifyVars, clearFileCache) {
            if ((reload || clearFileCache) && clearFileCache !== false) {
                fileManager.clearFileCache();
            }
            return new Promise(function (resolve, reject) {
                var startTime;
                var endTime;
                var totalMilliseconds;
                var remainingSheets;
                startTime = endTime = new Date();
                // Set counter for remaining unprocessed sheets
                remainingSheets = less.sheets.length;
                if (remainingSheets === 0) {
                    endTime = new Date();
                    totalMilliseconds = endTime - startTime;
                    less.logger.info('Less has finished and no sheets were loaded.');
                    resolve({
                        startTime: startTime,
                        endTime: endTime,
                        totalMilliseconds: totalMilliseconds,
                        sheets: less.sheets.length
                    });
                }
                else {
                    // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array
                    loadStyleSheets(function (e, css, _, sheet, webInfo) {
                        if (e) {
                            errors.add(e, e.href || sheet.href);
                            reject(e);
                            return;
                        }
                        if (webInfo.local) {
                            less.logger.info("Loading " + sheet.href + " from cache.");
                        }
                        else {
                            less.logger.info("Rendered " + sheet.href + " successfully.");
                        }
                        browser.createCSS(window.document, css, sheet);
                        less.logger.info("CSS for " + sheet.href + " generated in " + (new Date() - endTime) + "ms");
                        // Count completed sheet
                        remainingSheets--;
                        // Check if the last remaining sheet was processed and then call the promise
                        if (remainingSheets === 0) {
                            totalMilliseconds = new Date() - startTime;
                            less.logger.info("Less has finished. CSS generated in " + totalMilliseconds + "ms");
                            resolve({
                                startTime: startTime,
                                endTime: endTime,
                                totalMilliseconds: totalMilliseconds,
                                sheets: less.sheets.length
                            });
                        }
                        endTime = new Date();
                    }, reload, modifyVars);
                }
                loadStyles(modifyVars);
            });
        };
        less.refreshStyles = loadStyles;
        return less;
    });

    /**
     * Kicks off less and compiles any stylesheets
     * used in the browser distributed version of less
     * to kick-start less using the browser api
     */
    var options$1 = defaultOptions();
    if (window.less) {
        for (var key in window.less) {
            if (window.less.hasOwnProperty(key)) {
                options$1[key] = window.less[key];
            }
        }
    }
    addDefaultOptions(window, options$1);
    options$1.plugins = options$1.plugins || [];
    if (window.LESS_PLUGINS) {
        options$1.plugins = options$1.plugins.concat(window.LESS_PLUGINS);
    }
    var less = root(window, options$1);
    window.less = less;
    var css;
    var head;
    var style;
    // Always restore page visibility
    function resolveOrReject(data) {
        if (data.filename) {
            console.warn(data);
        }
        if (!options$1.async) {
            head.removeChild(style);
        }
    }
    if (options$1.onReady) {
        if (/!watch/.test(window.location.hash)) {
            less.watch();
        }
        // Simulate synchronous stylesheet loading by hiding page rendering
        if (!options$1.async) {
            css = 'body { display: none !important }';
            head = document.head || document.getElementsByTagName('head')[0];
            style = document.createElement('style');
            style.type = 'text/css';
            if (style.styleSheet) {
                style.styleSheet.cssText = css;
            }
            else {
                style.appendChild(document.createTextNode(css));
            }
            head.appendChild(style);
        }
        less.registerStylesheetsImmediately();
        less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);
    }

    return less;

})));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!********************************!*\
  !*** ./modules/boilerplate.js ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ boilerplate)
/* harmony export */ });
/* harmony import */ var _pageSetup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pageSetup.js */ "./modules/pageSetup.js");
/* harmony import */ var _replace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./replace.js */ "./modules/replace.js");
/* harmony import */ var _placeholder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./placeholder.js */ "./modules/placeholder.js");
/* harmony import */ var _textFit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./textFit.js */ "./modules/textFit.js");
/* harmony import */ var _mto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mto.js */ "./modules/mto.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utilities.js */ "./modules/utilities.js");
/* harmony import */ var _limiters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./limiters */ "./modules/limiters.js");







class boilerplate {
  constructor({
    fonts = [],
    ensureImagesLoad = true,
    allowLegacyRendering = false,
    exportReduceFont = 0,
    waitForImages = false,
    trimMarks = false,
    allowNoMetaData = false,
    cssVariables = "",
    runAddCrop = true,
    templateProps = '{}'
  } = {}) {
    this.fonts = fonts || "";
    this.waitForImages = waitForImages;
    this.ensureImagesLoad = ensureImagesLoad;
    this.allowLegacyRendering = allowLegacyRendering;
    this.exportReduceFont = exportReduceFont;
    this.trimMarks = trimMarks;
    this.allowNoMetaData = allowNoMetaData;
    this.overflows = false;
    this.state = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.setOutfitState)(trimMarks);
    this.browser = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.setBrowserType)();
    this.addStyle(":root{".concat(cssVariables, "}"));

    if (runAddCrop) {
      (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.addCrop)(trimMarks, allowLegacyRendering);
    }

    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.setSize)(trimMarks, exportReduceFont);
    this._events = {};
    console.clear();

    try {
      this.templateProps = JSON.parse(templateProps);
    } catch (e) {
      this.templateProps = {};
      console.log("templateProps is not a valid JSON object");
    }
  }

  start() {
    return new Promise((resolve, reject) => {
      // all these checks need to be done before the tempalte code can be run
      let checkList = [_utilities_js__WEBPACK_IMPORTED_MODULE_5__.domReady, (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.loadLESS)(), (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.fontsLoaded)(this.fonts)];

      if (this.waitForImages) {
        checkList.push((0,_pageSetup_js__WEBPACK_IMPORTED_MODULE_0__.ensureAllImagesLoaded)());
      }

      Promise.all(checkList).then(() => {
        this.emit("inputsChange", this.templateProps);

        if (typeof window.onTextChange === "function") {
          window.onTextChange();
        }

        window.addEventListener("resize", async e => {
          await (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.setSize)(this.trimMarks, this.exportReduceFont);

          if (state !== "preview") {
            this.emit("inputsChange");

            if (typeof window.onTextChange === "function") {
              window.onTextChange("resize", this.templateProps);
            }
          }
        }); // setInterval(() => {
        //   this.getOverflows();
        // }, 1000)

        if (state === "document") {
          (0,_pageSetup_js__WEBPACK_IMPORTED_MODULE_0__.imageCompression)();
        }

        resolve(this);
      }).catch(reject);
    });
  } // on creates a callback event


  on(name, listener) {
    if (!this._events[name]) {
      this._events[name] = [];
    }

    this._events[name].push(listener);
  } // removeListener(name, listenerToRemove) {
  //   if (!this._events[name]) {
  //     throw new Error(`Can't remove a listener. Event "${name}" doesn't exits.`);
  //   }
  //   const filterListeners = (listener) => listener !== listenerToRemove;
  //   this._events[name] = this._events[name].filter(filterListeners);
  // }
  // emit sends a message to a callback


  emit(name, data) {
    if (this._events[name]) {
      const fireCallbacks = callback => {
        callback(data);
      };

      this._events[name].forEach(fireCallbacks);
    }
  } // textValidation(callback)


  addStyle(styles = "") {
    var css = document.createElement("style");
    css.classList = "injectedStyle";

    if (css.styleSheet) {
      css.styleSheet.cssText = styles;
    } else {
      css.appendChild(document.createTextNode(styles));
    }

    document.getElementsByTagName("head")[0].appendChild(css);
  } // send a event to stop a render


  completeRender() {
    let checkList = [_utilities_js__WEBPACK_IMPORTED_MODULE_5__.winLoad];

    if (this.ensureImagesLoad) {
      checkList.push(_pageSetup_js__WEBPACK_IMPORTED_MODULE_0__.ensureAllImagesLoaded);
    }

    Promise.all(checkList).then(() => {
      if (this.getOverflows()) {
        console.log("%c This will export with overflow errors", 'background: #1F2A44; color: white');
      }

      let loadTime = Date.now() - window.performance.timing.navigationStart;
      console.info("Document has finished rendering in ".concat(loadTime, "ms"));
      document.dispatchEvent(new Event("printready"));

      if (state === "document" || state === "template") {
        // set timeout is used here to push this to the end of the heap which means it will load after everything else
        setTimeout(() => {
          if (!this.allowNoMetaData) {
            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.defaultsRemoved)();
          }
        }, 2000);
      }

      ;
    }).catch(err => {
      console.error(err);
      throw "⚠️ Render failed for logged reason ⤴️";
    });
  }

  hotReloadOnChange() {
    if ((this.state === "document" || state === "template") && typeof BroadcastChannel === "function") {
      let bc = new BroadcastChannel("fs-sync");

      bc.onmessage = ev => {
        if (!window.top.reloading) {
          window.top.reloading = true;
          window.top.location.reload();
        }
      };
    }
  }

  getOverflows() {
    let overflows = document.querySelectorAll(".overflow, [data-overflow]");

    if (overflows.length > 0) {
      this.overflows = overflows;
      this.emit("overflow", overflows);
    } else {
      this.overflows = false;
    }

    return this.overflows;
  }

  dynamicReplace() {
    return _replace_js__WEBPACK_IMPORTED_MODULE_1__.dynamicReplace.apply(this, arguments);
  }

  setupPlaceholder() {
    return _placeholder_js__WEBPACK_IMPORTED_MODULE_2__.default.apply(this, arguments);
  }

  textFit() {
    _textFit_js__WEBPACK_IMPORTED_MODULE_3__.default.apply(this, arguments);
    this.getOverflows();
  }

  maxLineCheck() {
    _limiters__WEBPACK_IMPORTED_MODULE_6__.maxLineCheck.apply(this, arguments);
    this.getOverflows();
  }

  minLineCheck() {
    _limiters__WEBPACK_IMPORTED_MODULE_6__.minLineCheck.apply(this, arguments);
    this.getOverflows();
  }

  maxHeightCheck() {
    _limiters__WEBPACK_IMPORTED_MODULE_6__.maxHeightCheck.apply(this, arguments);
    this.getOverflows();
  }

  charLimit() {
    _limiters__WEBPACK_IMPORTED_MODULE_6__.charLimit.apply(this, arguments);
    this.getOverflows();
  }

  highestZindex() {
    return (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.highestZ)();
  }

  ensureAllImagesLoaded() {
    return _pageSetup_js__WEBPACK_IMPORTED_MODULE_0__.ensureAllImagesLoaded.apply(this, arguments);
  }

  setupMTO() {
    return _mto_js__WEBPACK_IMPORTED_MODULE_4__.setupMTO.apply(this, arguments);
  }

  getWidth() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.getWidth.apply(this, arguments);
  }

  getHeight() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.getHeight.apply(this, arguments);
  }

  countLines() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.countLines.apply(this, arguments);
  }

  calculateTextMetrics() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.calculateTextMetrics.apply(this, arguments);
  }

  lineClamp() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.lineClamp.apply(this, arguments);
  }

}
})();

__webpack_exports__ = __webpack_exports__.default;
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL2ZvbnRmYWNlb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL2xpbWl0ZXJzLmpzIiwid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbW9kdWxlcy9saW5lQ2xhbXAuanMiLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL210by5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvcGFnZVNldHVwLmpzIiwid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbW9kdWxlcy9wbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvcmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvdGV4dEZpdC5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvdXRpbGl0aWVzLmpzIiwid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL2xlc3MvZGlzdC9sZXNzLmpzIiwid2VicGFjazovL2JvaWxlcnBsYXRlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2JvaWxlcnBsYXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2JvaWxlcnBsYXRlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL2JvaWxlcnBsYXRlLmpzIl0sIm5hbWVzIjpbImYiLCJnIiwibCIsImEiLCJwdXNoIiwibGVuZ3RoIiwibSIsInNoaWZ0Iiwic2V0VGltZW91dCIsIm4iLCJwIiwiYiIsInEiLCJyIiwiYyIsInQiLCJ1IiwiVHlwZUVycm9yIiwiZCIsInRoZW4iLCJjYWxsIiwiZSIsInYiLCJoIiwicHJvdG90eXBlIiwidyIsImsiLCJ4Iiwid2luZG93IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyYWNlIiwiYWxsIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJib2R5IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5U3RhdGUiLCJkZXRhY2hFdmVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwic3R5bGUiLCJjc3NUZXh0IiwieiIsIm9mZnNldFdpZHRoIiwid2lkdGgiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJBIiwicGFyZW50Tm9kZSIsIkIiLCJmYW1pbHkiLCJ3ZWlnaHQiLCJzdHJldGNoIiwibG9hZCIsIkgiLCJEYXRlIiwiZ2V0VGltZSIsIkoiLCJHIiwiTSIsIkVycm9yIiwiZm9udHMiLCJMIiwiTiIsImNsZWFyVGltZW91dCIsIkMiLCJleGVjIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicGFyc2VJbnQiLCJ5IiwicmVtb3ZlQ2hpbGQiLCJJIiwiaGlkZGVuIiwiZGlyIiwiRCIsIkUiLCJGIiwidGVzdCIsInZlbmRvciIsIksiLCJmb250Iiwiam9pbiIsImhhc0hlaWdodFZhbHVlIiwiZWwiLCJ0YXJnZXQiLCJpc1NhbWVOb2RlIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJpbmNsdWRlcyIsImdldENvbXB1dGVkU3R5bGUiLCJkaXNwbGF5IiwiaXNOYU4iLCJnZXRIZWlnaHQiLCJwYXJlbnRFbGVtZW50IiwidGV4dE5vZGVzVW5kZXIiLCJ3YWxrIiwiY3JlYXRlVHJlZVdhbGtlciIsIk5vZGVGaWx0ZXIiLCJTSE9XX1RFWFQiLCJuZXh0Tm9kZSIsInRleHRDb250ZW50IiwidHJpbSIsImNvbnNvbGUiLCJsb2ciLCJmaWx0ZXIiLCJpIiwiZmluZFRleHROb2RlIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ0YWdOYW1lIiwic2ltcGxlUm91bmRpbmciLCJudW0iLCJNYXRoIiwicm91bmQiLCJjb3VudExpbmVzIiwiZWxlbWVudHMiLCJhZHZhbmNlZCIsImVsVHlwZSIsIk9iamVjdCIsInRvU3RyaW5nIiwicmVzdWx0IiwibWFwIiwibXVpbHRDb3VudCIsInRleHROb2RlcyIsImZvckVhY2giLCJtZXRyaWNzIiwiY2FsY3VsYXRlVGV4dE1ldHJpY3MiLCJsaW5lIiwibGluZUNvdW50IiwiZGF0YXNldCIsInJhd0xpbmVzQ291bnQiLCJjYWxjdWxhdGVkTGluZXNDb3VudCIsImNsYW1wRGVmYXVsdHMiLCJtYXhMaW5lcyIsIm1pbkZvbnRTaXplIiwidXNlU29mdENsYW1wIiwiZWxsaXBzaXMiLCJsaW5lQ2xhbXAiLCJjb25maWciLCJlbGVtZW50IiwiY2xhbXAiLCJMaW5lQ2xhbXAiLCJhcHBseSIsIndhdGNoIiwiaGVpZ2h0IiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJib3hfc2l6aW5nIiwicGFkZGluZ190b3AiLCJwYWRkaW5nX2JvdHRvbSIsImJvcmRlcl90b3AiLCJib3JkZXJfYm90dG9tIiwiY2FsY3VsYXRlZEhlaWdodCIsImdldFdpZHRoIiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsImJvcmRlcl9sZWZ0IiwiYm9yZGVyX3JpZ2h0IiwiY2FsY3VsYXRlZFdpZHRoIiwibWF4TGluZUNoZWNrIiwiaXNFeHBvcnRNb2RlIiwibG9jYXRpb24iLCJocmVmIiwiaW5kZXhPZiIsImlzTG9jYWxEZXYiLCJwcmV2ZW50RXhwb3J0T3ZlcmZsb3ciLCJpc1Byb2plY3RLaXQiLCJ1bmRlZmluZWQiLCJwYXJlbnQiLCJxdWVyeVNlbGVjdG9yIiwiYmxvY2tzIiwicXVlcnlTZWxlY3RvckFsbCIsImJsb2NrIiwibWF4TGluZSIsIm1heExpbmVBbHQiLCJhZGQiLCJyZW1vdmUiLCJtaW5MaW5lQ2hlY2siLCJtaW5MaW5lIiwibWluTGluZUFsdCIsIm1heEhlaWdodENoZWNrIiwibWF4SGVpZ2h0IiwibWF4SGVpZ2h0RHluYW1pYyIsImR5bmFtaWNBc3NpZ24iLCJibG9ja0hlaWdodCIsImNvbXB1dGVkQmxvY2tTdHlsZSIsImNzc01heEhlaWdodCIsImVycm9yIiwibWF4SGVpZ2h0VW5pdCIsImZvbnRTaXplIiwiY29udGFpbmVyIiwib3ZlcmZsb3ciLCJjb250YWluZXJIZWlnaHQiLCJzdWJ0cmFoZW5kcyIsInN1YnRyYWhlbmRzSGVpZ2h0IiwicmVkdWNlIiwidG90YWxIZWlnaHQiLCJzdWJ0cmFoZW5kIiwic3VidHJhaGVuZE1hcmdpbnMiLCJ0b3AiLCJtYXJnaW5Ub3AiLCJib3R0b20iLCJtYXJnaW5Cb3R0b20iLCJvZmZzZXRIZWlnaHQiLCJkeW5hbWljSGVpZ2h0IiwiY2hhckxpbWl0IiwibGltaXQiLCJ0b2tlblZhbHVlIiwiaXRlbSIsImNvZGUiLCJpbm5lclRleHQiLCJjYWxjdWxhdGVkQ2hhckNvdW50IiwiY29uc3RydWN0b3IiLCJoYXJkQ2xhbXBBc0ZhbGxiYWNrIiwibWF4Rm9udFNpemUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwidmFsdWUiLCJtYXRjaCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJ1cGRhdGVIYW5kbGVyIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJyZXBsYWNlV2l0aCIsIm5hdHVyYWxIZWlnaHQiLCJuYXR1cmFsSGVpZ2h0V2l0aG91dFRleHQiLCJ0ZXh0SGVpZ2h0IiwibmF0dXJhbEhlaWdodFdpdGhPbmVMaW5lIiwiZmlyc3RMaW5lSGVpZ2h0IiwiYWRkaXRpb25hbExpbmVIZWlnaHQiLCJfd2F0Y2hpbmciLCJvYnNlcnZlciIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwic3VidHJlZSIsImNoaWxkTGlzdCIsImF0dHJpYnV0ZXMiLCJ1bndhdGNoIiwiZGlzY29ubmVjdCIsInByZXZpb3VzbHlXYXRjaGluZyIsIm9yaWdpbmFsV29yZHMiLCJzb2Z0Q2xhbXAiLCJoYXJkQ2xhbXAiLCJza2lwQ2hlY2siLCJzaG91bGRDbGFtcCIsImN1cnJlbnRUZXh0IiwiZmluZEJvdW5kYXJ5IiwidmFsIiwic2xpY2UiLCJtaW4iLCJtYXgiLCJlbWl0Iiwic3RhcnRTaXplIiwiZG9uZSIsImNoYW5nZWQiLCJjdXJzb3IiLCJmbG9vciIsImluc3RhbmNlIiwidHlwZSIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImdldFNpZGViYXIiLCJzaWRlYmFyIiwicG9wIiwiaGlkZUlucHV0IiwiaW5wdXRWYWx1ZSIsImlucHV0Iiwic2V0dXBNVE8iLCJ0ZWFtTWV0YWRhdGEiLCJ0ZWFtc0FsbG93ZWQiLCJpbnB1dE5hbWUiLCJzdGF0ZSIsIm10b05vdFN1cHBvcnRlZCIsImZpcnN0Q2hpbGQiLCJsYXN0Q2hpbGQiLCJpbm5lckhUTUwiLCJzZXRJbnRlcnZhbCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJoaWRlVGVhbXNUaGF0QXJlTm90QWxsb3dlZCIsImlucHV0T3B0aW9uIiwic3BhbiIsInN1YnN0cmluZyIsImhhbmRsZU1UT0RhdGEiLCJpbWFnZUNvbXByZXNzaW9uIiwiaW1hZ2VDb21wcmVzc0VsIiwiZWRpdG9yU3RyaW5nIiwiY2hlY2tVUkwiLCJ1cmwiLCJpbWdTcmMiLCJnZXRBdHRyaWJ1dGUiLCJpbWdFbCIsImltZ1VSTCIsImJrZ0ltZ0VsIiwiYmtnVXJsIiwiYmFja2dyb3VuZEltYWdlIiwicmVwbGFjZSIsImVuc3VyZUFsbEltYWdlc0xvYWRlZCIsImRvYyIsInRpbWVvdXQiLCJsb2FkQWxsSW1hZ2VzIiwiQXJyYXkiLCJmcm9tIiwic2VhcmNoRE9NIiwic3JjQ2hlY2tlciIsImNvbGxlY3Rpb24iLCJub2RlIiwicHJvcCIsInNyYyIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJpbWciLCJTZXQiLCJsb2FkSW1hZ2UiLCJpbWdQcm9taXNlIiwiSW1hZ2UiLCJvbmxvYWQiLCJuYXR1cmFsV2lkdGgiLCJvbmVycm9yIiwidGltZXIiLCJpbWdMaXN0IiwiY2F0Y2giLCJyZXN1bHRzIiwic2V0dXBQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyVmlzaWJpbGl0eSIsInBsYWNlaG9sZGVySW1hZ2VzIiwicGFnZXMiLCJwYWdlIiwiaW5kZXgiLCJwbGFjZWhvbGRlckltYWdlIiwicGxhY2Vob2xkZXJTdHJ1Y3R1cmUiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJTdHJpbmciLCJyZXBsYWNlQWxsIiwic3RyIiwibmV3U3RyIiwiZHluYW1pY1JlcGxhY2UiLCJzZWxlY3RvciIsImRhdGEiLCJkeW5hbWljUmVwbGFjZU11bHRpIiwiZHluYW1pY1JlcGxhY2VTaW5nbGUiLCJ0YXJnZXRzIiwibG9va3VwIiwibG9va3VwU3BhbiIsInRlbXAiLCJ0ZXh0IiwiaHRtbCIsInJlcGxhY2VGcm9tIiwicmVwbGFjZVRvIiwic2VhcmNoIiwiZGVmYXVsdFNldHRpbmdzIiwiYWxpZ25WZXJ0IiwiYWxpZ25Ib3JpeiIsIm11bHRpTGluZSIsInN0b3BPdmVyZmxvdyIsImZvbnRVbml0IiwiZm9udENoYW5nZVNpemUiLCJyZVByb2Nlc3MiLCJ3aWR0aE9ubHkiLCJhbGlnblZlcnRXaXRoRmxleGJveCIsInRleHRGaXQiLCJlbHMiLCJvcHRpb25zIiwic2V0dGluZ3MiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInRvQXJyYXkiLCJwcm9jZXNzSXRlbSIsImlzRWxlbWVudCIsImlubmVyU3BhbiIsIm9yaWdpbmFsSGVpZ2h0Iiwib3JpZ2luYWxIVE1MIiwib3JpZ2luYWxXaWR0aCIsImxvdyIsIm1pZCIsImhpZ2giLCJvdXRlckhUTUwiLCJ0ZXh0Rml0dGVkU3BhbiIsImNsYXNzTmFtZSIsInN0YXJ0aW5nU2l6ZSIsInNpemUiLCJ0b0ZpeGVkIiwic2Nyb2xsSGVpZ2h0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiY3VzdG9tT3ZlcmZsb3dNZXNzYWdlIiwibyIsIkhUTUxFbGVtZW50Iiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImRlZmF1bHRzUmVtb3ZlZCIsInRpdGxlIiwiYnVpbHRCeSIsInNjb3BlQ2FyZCIsImJ1aWx0Q2FyZCIsImhlYWQiLCJjaGlsZE5vZGVzIiwic29tZSIsInNldE91dGZpdFN0YXRlIiwidHJpbU1hcmtzIiwibW9kZSIsImJsb2NrUmVuZGVyIiwiaGlnaGVzdFoiLCJwYWdlSGVpZ2h0U2V0dXAiLCJhbGxvd0xlZ2FjeVJlbmRlcmluZyIsImFnZW50IiwiaW5mbyIsImFkZENyb3AiLCJjcm9wU1ZHIiwicGFnZUhlaWdodCIsImJsZWVkIiwibGVmdCIsInJpZ2h0IiwiZm9udHNMb2FkZWQiLCJmb250c0xpc3RlZCIsImlzQXJyYXkiLCJGb250RmFjZU9ic2VydmVyIiwic2V0U2l6ZSIsImV4cG9ydFJlZHVjZUZvbnQiLCJ2dyIsImlubmVyV2lkdGgiLCJ2aCIsImlubmVySGVpZ2h0Iiwidm1pbiIsInZtYXgiLCJwcmVsaW1pbmFyeUNhbGMiLCJmaW5hbENhbGMiLCJkb2N1bWVudEVsZW1lbnQiLCJzZXRCcm93c2VyVHlwZSIsImJyb3dzZXIiLCJpc09wZXJhIiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwic2FmYXJpIiwicHVzaE5vdGlmaWNhdGlvbiIsImlzSUUiLCJkb2N1bWVudE1vZGUiLCJpc0Nocm9tZSIsImNocm9tZSIsIndlYnN0b3JlIiwicnVudGltZSIsImlzTWFjIiwiYXBwVmVyc2lvbiIsIlN0eWxlTWVkaWEiLCJDU1MiLCJrZXlzIiwiekluZGV4Iiwic29ydCIsImRvbVJlYWR5Iiwid2luTG9hZCIsImxvYWRMRVNTIiwidmFyaWFibGVzIiwicmVxdWlyZSIsImJvaWxlcnBsYXRlIiwiZW5zdXJlSW1hZ2VzTG9hZCIsIndhaXRGb3JJbWFnZXMiLCJhbGxvd05vTWV0YURhdGEiLCJjc3NWYXJpYWJsZXMiLCJydW5BZGRDcm9wIiwidGVtcGxhdGVQcm9wcyIsIm92ZXJmbG93cyIsImFkZFN0eWxlIiwiX2V2ZW50cyIsImNsZWFyIiwiSlNPTiIsInBhcnNlIiwic3RhcnQiLCJjaGVja0xpc3QiLCJvblRleHRDaGFuZ2UiLCJvbiIsIm5hbWUiLCJsaXN0ZW5lciIsImZpcmVDYWxsYmFja3MiLCJjYWxsYmFjayIsInN0eWxlcyIsImNzcyIsInN0eWxlU2hlZXQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNvbXBsZXRlUmVuZGVyIiwiZ2V0T3ZlcmZsb3dzIiwibG9hZFRpbWUiLCJub3ciLCJwZXJmb3JtYW5jZSIsInRpbWluZyIsIm5hdmlnYXRpb25TdGFydCIsIkV2ZW50IiwiZXJyIiwiaG90UmVsb2FkT25DaGFuZ2UiLCJCcm9hZGNhc3RDaGFubmVsIiwiYmMiLCJvbm1lc3NhZ2UiLCJldiIsInJlbG9hZGluZyIsInJlbG9hZCIsImFyZ3VtZW50cyIsImhpZ2hlc3RaaW5kZXgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQXNFLENBQUMsWUFBWTtBQUNqRjs7QUFDQSxNQUFJQSxDQUFKO0FBQUEsTUFDRUMsQ0FBQyxHQUFHLEVBRE47O0FBRUEsV0FBU0MsQ0FBVCxDQUFXQyxDQUFYLEVBQWM7QUFDWkYsS0FBQyxDQUFDRyxJQUFGLENBQU9ELENBQVA7QUFDQSxTQUFLRixDQUFDLENBQUNJLE1BQVAsSUFBaUJMLENBQUMsRUFBbEI7QUFDRDs7QUFDRCxXQUFTTSxDQUFULEdBQWE7QUFDWCxXQUFPTCxDQUFDLENBQUNJLE1BQVQsR0FBbUJKLENBQUMsQ0FBQyxDQUFELENBQUQsSUFBUUEsQ0FBQyxDQUFDTSxLQUFGLEVBQVI7QUFDcEI7O0FBQ0RQLEdBQUMsR0FBRyxZQUFZO0FBQ2RRLGNBQVUsQ0FBQ0YsQ0FBRCxDQUFWO0FBQ0QsR0FGRDs7QUFHQSxXQUFTRyxDQUFULENBQVdOLENBQVgsRUFBYztBQUNaLFNBQUtBLENBQUwsR0FBU08sQ0FBVDtBQUNBLFNBQUtDLENBQUwsR0FBUyxLQUFLLENBQWQ7QUFDQSxTQUFLWCxDQUFMLEdB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxh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QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLDRDQUE0QztBQUMvRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELGtCQUFrQixFQUFFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrREFBK0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwrQkFBK0IsRUFBRTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsMEJBQTBCLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Z0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixVQUFVO0FBQ3pHO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpRUFBaUUsUUFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csVUFBVTtBQUMxRztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEVBQUUsYUFBYSxFQUFFLGFBQWEsSUFBSTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUE2RixJQUFJO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWEsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQXdEO0FBQ3BHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELG9FQUFvRTtBQUNwRTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFFBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsWUFBWTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx1QkFBdUIsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNDQUFzQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQXVEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QyxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksa0RBQWtEO0FBQ25IO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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U0FBekI7QUFDQSxTQUFLZixZQUFMO0FBQ0Q7O0FBQ0RsVCxjQUFZLEdBQUc7QUFDYkEsNkRBQUEsQ0FBbUIsSUFBbkIsRUFBeUJpVSxTQUF6QjtBQUNBLFNBQUtmLFlBQUw7QUFDRDs7QUFDRC9TLGdCQUFjLEdBQUc7QUFDZkEsK0RBQUEsQ0FBcUIsSUFBckIsRUFBMkI4VCxTQUEzQjtBQUNBLFNBQUtmLFlBQUw7QUFDRDs7QUFDRHRSLFdBQVMsR0FBRztBQUNWQSwwREFBQSxDQUFnQixJQUFoQixFQUFzQnFTLFNBQXRCO0FBQ0EsU0FBS2YsWUFBTDtBQUNEOztBQUNEZ0IsZUFBYSxHQUFHO0FBQ2QsV0FBT2pHLHVEQUFRLEVBQWY7QUFDRDs7QUFDRHpHLHVCQUFxQixHQUFHO0FBQ3RCLFdBQU9BLHNFQUFBLENBQTRCLElBQTVCLEVBQWtDeU0sU0FBbEMsQ0FBUDtBQUNEOztBQUNEdk8sVUFBUSxHQUFHO0FBQ1QsV0FBT0EsbURBQUEsQ0FBZSxJQUFmLEVBQXFCdU8sU0FBckIsQ0FBUDtBQUNEOztBQUNEelYsVUFBUSxHQUFHO0FBQ1QsV0FBT0EscURBQUEsQ0FBZSxJQUFmLEVBQXFCeVYsU0FBckIsQ0FBUDtBQUNEOztBQUNEclosV0FBUyxHQUFHO0FBQ1YsV0FBT0Esc0RBQUEsQ0FBZ0IsSUFBaEIsRUFBc0JxWixTQUF0QixDQUFQO0FBQ0Q7O0FBQ0RoWSxZQUFVLEdBQUc7QUFDWCxXQUFPQSx1REFBQSxDQUFpQixJQUFqQixFQUF1QmdZLFNBQXZCLENBQVA7QUFDRDs7QUFDRHBYLHNCQUFvQixHQUFHO0FBQ3JCLFdBQU9BLGlFQUFBLENBQTJCLElBQTNCLEVBQWlDb1gsU0FBakMsQ0FBUDtBQUNEOztBQUNEelcsV0FBUyxHQUFHO0FBQ1YsV0FBT0Esc0RBQUEsQ0FBZ0IsSUFBaEIsRUFBc0J5VyxTQUF0QixDQUFQO0FBQ0Q7O0FBN044QixDIiwiZmlsZSI6ImJvaWxlcnBsYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYm9pbGVycGxhdGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiYm9pbGVycGxhdGVcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIvKiBGb250IEZhY2UgT2JzZXJ2ZXIgdjIuMS4wIC0gwqkgQnJhbSBTdGVpbi4gTGljZW5zZTogQlNELTMtQ2xhdXNlICovIChmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgZixcbiAgICBnID0gW107XG4gIGZ1bmN0aW9uIGwoYSkge1xuICAgIGcucHVzaChhKTtcbiAgICAxID09IGcubGVuZ3RoICYmIGYoKTtcbiAgfVxuICBmdW5jdGlvbiBtKCkge1xuICAgIGZvciAoOyBnLmxlbmd0aDsgKSBnWzBdKCksIGcuc2hpZnQoKTtcbiAgfVxuICBmID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQobSk7XG4gIH07XG4gIGZ1bmN0aW9uIG4oYSkge1xuICAgIHRoaXMuYSA9IHA7XG4gICAgdGhpcy5iID0gdm9pZCAwO1xuICAgIHRoaXMuZiA9IFtdO1xuICAgIHZhciBiID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgYShcbiAgICAgICAgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBxKGIsIGEpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHIoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgcihiLCBjKTtcbiAgICB9XG4gIH1cbiAgdmFyIHAgPSAyO1xuICBmdW5jdGlvbiB0KGEpIHtcbiAgICByZXR1cm4gbmV3IG4oZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgIGMoYSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdShhKSB7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChiKSB7XG4gICAgICBiKGEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHEoYSwgYikge1xuICAgIGlmIChhLmEgPT0gcCkge1xuICAgICAgaWYgKGIgPT0gYSkgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgdmFyIGMgPSAhMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBkID0gYiAmJiBiLnRoZW47XG4gICAgICAgIGlmIChudWxsICE9IGIgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgYiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGQpIHtcbiAgICAgICAgICBkLmNhbGwoXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgYyB8fCBxKGEsIGIpO1xuICAgICAgICAgICAgICBjID0gITA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgYyB8fCByKGEsIGIpO1xuICAgICAgICAgICAgICBjID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYyB8fCByKGEsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhLmEgPSAwO1xuICAgICAgYS5iID0gYjtcbiAgICAgIHYoYSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHIoYSwgYikge1xuICAgIGlmIChhLmEgPT0gcCkge1xuICAgICAgaWYgKGIgPT0gYSkgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgYS5hID0gMTtcbiAgICAgIGEuYiA9IGI7XG4gICAgICB2KGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB2KGEpIHtcbiAgICBsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhLmEgIT0gcClcbiAgICAgICAgZm9yICg7IGEuZi5sZW5ndGg7ICkge1xuICAgICAgICAgIHZhciBiID0gYS5mLnNoaWZ0KCksXG4gICAgICAgICAgICBjID0gYlswXSxcbiAgICAgICAgICAgIGQgPSBiWzFdLFxuICAgICAgICAgICAgZSA9IGJbMl0sXG4gICAgICAgICAgICBiID0gYlszXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgMCA9PSBhLmFcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGNcbiAgICAgICAgICAgICAgICA/IGUoYy5jYWxsKHZvaWQgMCwgYS5iKSlcbiAgICAgICAgICAgICAgICA6IGUoYS5iKVxuICAgICAgICAgICAgICA6IDEgPT0gYS5hICYmXG4gICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZCA/IGUoZC5jYWxsKHZvaWQgMCwgYS5iKSkgOiBiKGEuYikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgIGIoaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbi5wcm90b3R5cGUuZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuYyh2b2lkIDAsIGEpO1xuICB9O1xuICBuLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChkLCBlKSB7XG4gICAgICBjLmYucHVzaChbYSwgYiwgZCwgZV0pO1xuICAgICAgdihjKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gdyhhKSB7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICBmdW5jdGlvbiBkKGMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaFtjXSA9IGQ7XG4gICAgICAgICAgZSArPSAxO1xuICAgICAgICAgIGUgPT0gYS5sZW5ndGggJiYgYihoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBlID0gMCxcbiAgICAgICAgaCA9IFtdO1xuICAgICAgMCA9PSBhLmxlbmd0aCAmJiBiKGgpO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhLmxlbmd0aDsgayArPSAxKSB1KGFba10pLmMoZChrKSwgYyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24geChhKSB7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGEubGVuZ3RoOyBkICs9IDEpIHUoYVtkXSkuYyhiLCBjKTtcbiAgICB9KTtcbiAgfVxuICB3aW5kb3cuUHJvbWlzZSB8fFxuICAgICgod2luZG93LlByb21pc2UgPSBuKSxcbiAgICAod2luZG93LlByb21pc2UucmVzb2x2ZSA9IHUpLFxuICAgICh3aW5kb3cuUHJvbWlzZS5yZWplY3QgPSB0KSxcbiAgICAod2luZG93LlByb21pc2UucmFjZSA9IHgpLFxuICAgICh3aW5kb3cuUHJvbWlzZS5hbGwgPSB3KSxcbiAgICAod2luZG93LlByb21pc2UucHJvdG90eXBlLnRoZW4gPSBuLnByb3RvdHlwZS5jKSxcbiAgICAod2luZG93LlByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBuLnByb3RvdHlwZS5nKSk7XG59KSgpO1xuXG4gIGZ1bmN0aW9uIGwoYSwgYikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAgICAgID8gYS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGIsICExKVxuICAgICAgOiBhLmF0dGFjaEV2ZW50KFwic2Nyb2xsXCIsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIG0oYSkge1xuICAgIGRvY3VtZW50LmJvZHlcbiAgICAgID8gYSgpXG4gICAgICA6IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAgICAgID8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjKTtcbiAgICAgICAgICBhKCk7XG4gICAgICAgIH0pXG4gICAgICA6IGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uIGsoKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJpbnRlcmFjdGl2ZVwiID09IGRvY3VtZW50LnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY29tcGxldGVcIiA9PSBkb2N1bWVudC5yZWFkeVN0YXRlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgayksIGEoKTtcbiAgICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdChhKSB7XG4gICAgdGhpcy5hID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmEuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIHRoaXMuYS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7XG4gICAgdGhpcy5iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5oID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5mID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5nID0gLTE7XG4gICAgdGhpcy5iLnN0eWxlLmNzc1RleHQgPVxuICAgICAgXCJtYXgtd2lkdGg6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO292ZXJmbG93OnNjcm9sbDtmb250LXNpemU6MTZweDtcIjtcbiAgICB0aGlzLmMuc3R5bGUuY3NzVGV4dCA9XG4gICAgICBcIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO1xuICAgIHRoaXMuZi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgIFwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7XG4gICAgdGhpcy5oLnN0eWxlLmNzc1RleHQgPVxuICAgICAgXCJkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoyMDAlO2hlaWdodDoyMDAlO2ZvbnQtc2l6ZToxNnB4O21heC13aWR0aDpub25lO1wiO1xuICAgIHRoaXMuYi5hcHBlbmRDaGlsZCh0aGlzLmgpO1xuICAgIHRoaXMuYy5hcHBlbmRDaGlsZCh0aGlzLmYpO1xuICAgIHRoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmIpO1xuICAgIHRoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmMpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYSwgYikge1xuICAgIGEuYS5zdHlsZS5jc3NUZXh0ID1cbiAgICAgIFwibWF4LXdpZHRoOm5vbmU7bWluLXdpZHRoOjIwcHg7bWluLWhlaWdodDoyMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDphdXRvO21hcmdpbjowO3BhZGRpbmc6MDt0b3A6LTk5OXB4O3doaXRlLXNwYWNlOm5vd3JhcDtmb250LXN5bnRoZXNpczpub25lO2ZvbnQ6XCIgK1xuICAgICAgYiArXG4gICAgICBcIjtcIjtcbiAgfVxuICBmdW5jdGlvbiB6KGEpIHtcbiAgICB2YXIgYiA9IGEuYS5vZmZzZXRXaWR0aCxcbiAgICAgIGMgPSBiICsgMTAwO1xuICAgIGEuZi5zdHlsZS53aWR0aCA9IGMgKyBcInB4XCI7XG4gICAgYS5jLnNjcm9sbExlZnQgPSBjO1xuICAgIGEuYi5zY3JvbGxMZWZ0ID0gYS5iLnNjcm9sbFdpZHRoICsgMTAwO1xuICAgIHJldHVybiBhLmcgIT09IGIgPyAoKGEuZyA9IGIpLCAhMCkgOiAhMTtcbiAgfVxuICBmdW5jdGlvbiBBKGEsIGIpIHtcbiAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgdmFyIGEgPSBrO1xuICAgICAgeihhKSAmJiBhLmEucGFyZW50Tm9kZSAmJiBiKGEuZyk7XG4gICAgfVxuICAgIHZhciBrID0gYTtcbiAgICBsKGEuYiwgYyk7XG4gICAgbChhLmMsIGMpO1xuICAgIHooYSk7XG4gIH1cbiAgZnVuY3Rpb24gQihhLCBiKSB7XG4gICAgdmFyIGMgPSBiIHx8IHt9O1xuICAgIHRoaXMuZmFtaWx5ID0gYTtcbiAgICB0aGlzLnN0eWxlID0gYy5zdHlsZSB8fCBcIm5vcm1hbFwiO1xuICAgIHRoaXMud2VpZ2h0ID0gYy53ZWlnaHQgfHwgXCJub3JtYWxcIjtcbiAgICB0aGlzLnN0cmV0Y2ggPSBjLnN0cmV0Y2ggfHwgXCJub3JtYWxcIjtcbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgayA9IGEgfHwgXCJCRVNic3d5XCIsXG4gICAgICAgICAgciA9IDAsXG4gICAgICAgICAgbiA9IGIgfHwgM2UzLFxuICAgICAgICAgIEggPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKEooKSAmJiAhRygpKSB7XG4gICAgICAgICAgICB2YXIgTSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gSCA+PSBuXG4gICAgICAgICAgICAgICAgICAgID8gYihFcnJvcihcIlwiICsgbiArIFwibXMgdGltZW91dCBleGNlZWRlZCBsb2FkaW5nIGZvbnRzXCIpKVxuICAgICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmZvbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAubG9hZChMKGMsICdcIicgKyBjLmZhbWlseSArICdcIicpLCBrKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMSA8PSBjLmxlbmd0aCA/IGEoKSA6IHNldFRpbWVvdXQoZSwgMjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUoKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIE4gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgICAgIHIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGMoRXJyb3IoXCJcIiArIG4gKyBcIm1zIHRpbWVvdXQgZXhjZWVkZWQgbG9hZGluZyBmb250c1wiKSk7XG4gICAgICAgICAgICAgICAgfSwgbik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgUHJvbWlzZS5yYWNlKFtOLCBNXSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChyKTtcbiAgICAgICAgICAgICAgYShjKTtcbiAgICAgICAgICAgIH0sIGIpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgbShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGI7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGIgPVxuICAgICAgICAgICAgICAgICAgICAoLTEgIT0gZiAmJiAtMSAhPSBnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoLTEgIT0gZiAmJiAtMSAhPSBoKSB8fFxuICAgICAgICAgICAgICAgICAgICAoLTEgIT0gZyAmJiAtMSAhPSBoKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoYiA9IGYgIT0gZyAmJiBmICE9IGggJiYgZyAhPSBoKSB8fFxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gQyAmJlxuICAgICAgICAgICAgICAgICAgICAgICgoYiA9IC9BcHBsZVdlYktpdFxcLyhbMC05XSspKD86XFwuKFswLTldKykpLy5leGVjKFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAoQyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhIWIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICg1MzYgPiBwYXJzZUludChiWzFdLCAxMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDUzNiA9PT0gcGFyc2VJbnQoYlsxXSwgMTApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTEgPj0gcGFyc2VJbnQoYlsyXSwgMTApKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgKGIgPVxuICAgICAgICAgICAgICAgICAgICAgIEMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKGYgPT0gdyAmJiBnID09IHcgJiYgaCA9PSB3KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGYgPT0geCAmJiBnID09IHggJiYgaCA9PSB4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGYgPT0geSAmJiBnID09IHkgJiYgaCA9PSB5KSkpKSxcbiAgICAgICAgICAgICAgICAgICAgKGIgPSAhYik7XG4gICAgICAgICAgICAgICAgYiAmJlxuICAgICAgICAgICAgICAgICAgKGQucGFyZW50Tm9kZSAmJiBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksXG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQociksXG4gICAgICAgICAgICAgICAgICBhKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBJKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIEggPj0gbilcbiAgICAgICAgICAgICAgICAgIGQucGFyZW50Tm9kZSAmJiBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksXG4gICAgICAgICAgICAgICAgICAgIGIoRXJyb3IoXCJcIiArIG4gKyBcIm1zIHRpbWVvdXQgZXhjZWVkZWQgbG9hZGluZyBmb250c1wiKSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gYSB8fCB2b2lkIDAgPT09IGEpXG4gICAgICAgICAgICAgICAgICAgIChmID0gZS5hLm9mZnNldFdpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAoZyA9IHAuYS5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgKGggPSBxLmEub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgICAgIHIgPSBzZXRUaW1lb3V0KEksIDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgdChrKSxcbiAgICAgICAgICAgICAgICBwID0gbmV3IHQoayksXG4gICAgICAgICAgICAgICAgcSA9IG5ldyB0KGspLFxuICAgICAgICAgICAgICAgIGYgPSAtMSxcbiAgICAgICAgICAgICAgICBnID0gLTEsXG4gICAgICAgICAgICAgICAgaCA9IC0xLFxuICAgICAgICAgICAgICAgIHcgPSAtMSxcbiAgICAgICAgICAgICAgICB4ID0gLTEsXG4gICAgICAgICAgICAgICAgeSA9IC0xLFxuICAgICAgICAgICAgICAgIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICBkLmRpciA9IFwibHRyXCI7XG4gICAgICAgICAgICAgIHUoZSwgTChjLCBcInNhbnMtc2VyaWZcIikpO1xuICAgICAgICAgICAgICB1KHAsIEwoYywgXCJzZXJpZlwiKSk7XG4gICAgICAgICAgICAgIHUocSwgTChjLCBcIm1vbm9zcGFjZVwiKSk7XG4gICAgICAgICAgICAgIGQuYXBwZW5kQ2hpbGQoZS5hKTtcbiAgICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChwLmEpO1xuICAgICAgICAgICAgICBkLmFwcGVuZENoaWxkKHEuYSk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZCk7XG4gICAgICAgICAgICAgIHcgPSBlLmEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIHggPSBwLmEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIHkgPSBxLmEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIEkoKTtcbiAgICAgICAgICAgICAgQShlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGYgPSBhO1xuICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHUoZSwgTChjLCAnXCInICsgYy5mYW1pbHkgKyAnXCIsc2Fucy1zZXJpZicpKTtcbiAgICAgICAgICAgICAgQShwLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGcgPSBhO1xuICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHUocCwgTChjLCAnXCInICsgYy5mYW1pbHkgKyAnXCIsc2VyaWYnKSk7XG4gICAgICAgICAgICAgIEEocSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBoID0gYTtcbiAgICAgICAgICAgICAgICB2KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB1KHEsIEwoYywgJ1wiJyArIGMuZmFtaWx5ICsgJ1wiLG1vbm9zcGFjZScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gIH1cbiAgdmFyIEMgPSBudWxsLFxuICAgIEQgPSBudWxsLFxuICAgIEUgPSBudWxsLFxuICAgIEYgPSBudWxsO1xuICBmdW5jdGlvbiBHKCkge1xuICAgIGlmIChudWxsID09PSBEKVxuICAgICAgaWYgKEooKSAmJiAvQXBwbGUvLnRlc3Qod2luZG93Lm5hdmlnYXRvci52ZW5kb3IpKSB7XG4gICAgICAgIHZhciBhID0gL0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkoPzpcXC4oWzAtOV0rKSkvLmV4ZWMoXG4gICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgKTtcbiAgICAgICAgRCA9ICEhYSAmJiA2MDMgPiBwYXJzZUludChhWzFdLCAxMCk7XG4gICAgICB9IGVsc2UgRCA9ICExO1xuICAgIHJldHVybiBEO1xuICB9XG4gIGZ1bmN0aW9uIEooKSB7XG4gICAgbnVsbCA9PT0gRiAmJiAoRiA9ICEhZG9jdW1lbnQuZm9udHMpO1xuICAgIHJldHVybiBGO1xuICB9XG4gIGZ1bmN0aW9uIEsoKSB7XG4gICAgaWYgKG51bGwgPT09IEUpIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGEuc3R5bGUuZm9udCA9IFwiY29uZGVuc2VkIDEwMHB4IHNhbnMtc2VyaWZcIjtcbiAgICAgIH0gY2F0Y2ggKGIpIHt9XG4gICAgICBFID0gXCJcIiAhPT0gYS5zdHlsZS5mb250O1xuICAgIH1cbiAgICByZXR1cm4gRTtcbiAgfVxuICBmdW5jdGlvbiBMKGEsIGIpIHtcbiAgICByZXR1cm4gW2Euc3R5bGUsIGEud2VpZ2h0LCBLKCkgPyBhLnN0cmV0Y2ggOiBcIlwiLCBcIjEwMHB4XCIsIGJdLmpvaW4oXCIgXCIpO1xuICB9XG4gXG5leHBvcnQgZGVmYXVsdCBCO1xuIiwiaW1wb3J0IExpbmVDbGFtcCBmcm9tIFwiLi9saW5lQ2xhbXAuanNcIlxyXG5cclxuZnVuY3Rpb24gaGFzSGVpZ2h0VmFsdWUoZWwsIHRhcmdldCkge1xyXG4gIGlmIChlbC5pc1NhbWVOb2RlKHRhcmdldCkpIHtcclxuICAgIHJldHVybiBlbDtcclxuICB9XHJcbiAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygndGV4dEZpdHRlZCcpKSB7XHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfVxyXG4gIGlmIChbJ2lubGluZScsJ2lubGluZS1ibG9jayddLmluY2x1ZGVzKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXNwbGF5KSB8fCBpc05hTihnZXRIZWlnaHQoZWwpKSkge1xyXG4gICAgcmV0dXJuIGhhc0hlaWdodFZhbHVlKGVsLnBhcmVudEVsZW1lbnQsIHRhcmdldClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGVsXHJcbiAgfVxyXG59XHJcbi8vIGZpbmQgYWxsIHRleHQgbm9kZXMgdW5kZXIgYSBnaXZlbiBlbGVtZW50XHJcbmZ1bmN0aW9uIHRleHROb2Rlc1VuZGVyKGVsKSB7XHJcbiAgdmFyIG4gPSBudWxsLCBhPVtdLCB3YWxrPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWwsTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCxmYWxzZSk7XHJcbiAgd2hpbGUobiA9IHdhbGsubmV4dE5vZGUoKSkge1xyXG4gICAgaWYgKG4udGV4dENvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgIGxldCB7IHBhcmVudEVsZW1lbnQgfSA9IG5cclxuICAgICAgLy8gaWYgKHBhcmVudEVsZW1lbnQuaXNTYW1lTm9kZShlbCkpIHtcclxuICAgICAgLy8gICByZXR1cm4gW2VsXTtcclxuICAgICAgLy8gfVxyXG4gICAgICBsZXQgZSA9IGhhc0hlaWdodFZhbHVlKHBhcmVudEVsZW1lbnQsIGVsKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhlKVxyXG5cclxuICAgICAgLy8gaWYgKGUpIGV4aXRzIGFuZCBpbnMndCBhbHJlYWR5IHJldHVybmVkIHRoZW4gYWRkIGl0IHRvIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIGxpbmUgY2hlY2tcclxuICAgICAgaWYgKGUgJiYgIWEuaW5jbHVkZXMoZSkpICB7XHJcbiAgICAgICAgLy8gaWYgKGUpIGhhcyBnb3QgYSBjaGlsZCBpbiAoYSkgdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGF0IGNoaWxkIHRvIHByZXZlbnQgZG91YmxlIHVwIG9mIGNvdW50aW5nXHJcbiAgICAgICAgY29uc29sZS5sb2coJ2JlZm9yZScsIGEpXHJcbiAgICAgICAgYSA9IGEuZmlsdGVyKGkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coZS5jb250YWlucyhpKSk7XHJcbiAgICAgICAgICByZXR1cm4gIWUuY29udGFpbnMoaSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdhZnRlcicsIGEpO1xyXG4gICAgICAgIGEucHVzaChlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYTtcclxufVxyXG5cclxuLy8gc29tZSBlbGVtZW50cyBkb24ndCBoYXZlIGhlaWdodCB2YWx1ZXMgc2V0IGNvcnJlY3RseSBzbyB3ZSBuZWVkIHRvIGRyaWxsIGRvd24gXHJcbmZ1bmN0aW9uIGZpbmRUZXh0Tm9kZSh0YXJnZXQpIHtcclxuICAvLyBpZiAoY2hpbGQgJiYgWydTUEFOJywnVE9LRU4tVkFMVUUnLCdTVFJPTkcnLCdQJywnRU0nLCcnXS5pbmNsdWRlcyhjaGlsZC50YWdOYW1lKSkge1xyXG4gIGlmICh0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQgJiYgIVsnQlInXS5pbmNsdWRlcyh0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQudGFnTmFtZSkpIHtcclxuICAgIHRhcmdldCA9IGZpbmRUZXh0Tm9kZSh0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpO1xyXG4gIH1cclxuICByZXR1cm4gdGFyZ2V0XHJcbn1cclxuLy8gbm90IHNvIHNpbXBsZSByb3VuZGluZyBmb3IgbGluZSBjb3VudGluZyBwdXJwb3Nlc1xyXG5mdW5jdGlvbiBzaW1wbGVSb3VuZGluZyhudW0pIHtcclxuICBpZiAobnVtID4gMTApIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSk7XHJcbiAgICAvLyByZXR1cm4gbnVtLnRvRml4ZWQoMCkucmVwbGFjZSgvKFxcLjArfDArKSQvLCAnJyk7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSkvLy5yZXBsYWNlKC8oXFwuMCt8MCspJC8sICcnKTtcclxufVxyXG4vLyBjb3VudCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluc2lkZSBvZiB0aGUgY3VycmVudCBkaXJlY3QgZWxlbWVudFxyXG5mdW5jdGlvbiBjb3VudExpbmVzKGVsZW1lbnRzLCBhZHZhbmNlZCkge1xyXG4gIHZhciBlbFR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpO1xyXG4gIGlmIChcclxuICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICYmXHJcbiAgICBlbFR5cGUgIT09IFwiW29iamVjdCBOb2RlTGlzdF1cIiAmJlxyXG4gICAgZWxUeXBlICE9PSBcIltvYmplY3QgSFRNTENvbGxlY3Rpb25dXCJcclxuICApIHtcclxuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuICB9XHJcbiAgbGV0IHJlc3VsdCA9IFsuLi5lbGVtZW50c10ubWFwKHRhcmdldCA9PiB7XHJcbiAgICBpZiAodHJ1ZSkge1xyXG4gICAgICBsZXQgbXVpbHRDb3VudCA9IDA7XHJcbiAgICAgIGxldCB0ZXh0Tm9kZXMgPSB0ZXh0Tm9kZXNVbmRlcih0YXJnZXQpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyh0ZXh0Tm9kZXMsICd0ZXh0Tm9kZXMgdGhhdCBoYXZlIGhlaWdodCcpXHJcbiAgICAgIHRleHROb2Rlcy5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICBsZXQgbWV0cmljcyA9IGNhbGN1bGF0ZVRleHRNZXRyaWNzKGVsKTtcclxuICAgICAgICBsZXQgbGluZSA9IHNpbXBsZVJvdW5kaW5nKG1ldHJpY3MubGluZUNvdW50KVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGVsLCBtZXRyaWNzKVxyXG4gICAgICAgIGlmIChsaW5lKSB7XHJcbiAgICAgICAgICBlbC5kYXRhc2V0LnJhd0xpbmVzQ291bnQgPSBsaW5lO1xyXG4gICAgICAgICAgbXVpbHRDb3VudCArPSBsaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgbXVpbHRDb3VudCA9IHNpbXBsZVJvdW5kaW5nKG11aWx0Q291bnQpXHJcbiAgICAgIHRhcmdldC5kYXRhc2V0LmNhbGN1bGF0ZWRMaW5lc0NvdW50ID0gbXVpbHRDb3VudCAvLyBhZGRzIHByb3BlcnR5IGZvciBDU1MgdGFyZ2V0aW5nXHJcbiAgICAgIHJldHVybiBtdWlsdENvdW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZmFsc2UpIHtcclxuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKCdjb3VudGluZ0xpbmVzJyk7XHJcbiAgICAgICAgICBsZXQgdGVzdEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICBsZXQgY291bnRlclRhcmdldCA9IGZpbmRUZXh0Tm9kZSh0YXJnZXQpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjb3VudGVyVGFyZ2V0KVxyXG4gICAgICAgICAgLy8gbGV0IHRhcmdldEZpeCA9IHRhcmdldC5maXJzdENoaWxkID8gdGFyZ2V0LmZpcnN0Q2hpbGQuY2xhc3NMaXN0ID09PSBcInRleHRGaXR0ZWRcIiA/IHRhcmdldC5maXJzdENoaWxkIDogdGFyZ2V0IDogdGFyZ2V0OyBcclxuICAgICAgICAgIHRlc3RCb3guY2xhc3NMaXN0ID0gXCJsaW5lQ291bnRlclwiO1xyXG4gICAgICAgICAgLy8gdGVzdEJveC5zdHlsZS5mb250RmFtaWx5ID0gXCItd2Via2l0LXBpY3RvZ3JhcGhcIjtcclxuICAgICAgICAgIC8vIHRlc3RCb3guc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgIC8vIHRlc3RCb3guc3R5bGUuZm9udFNpemUgPSB0YXJnZXRGaXguc3R5bGUuZm9udFNpemU7XHJcbiAgICAgICAgICB0ZXN0Qm94LmlubmVyVGV4dCA9IFwi4oCLXCI7XHJcbiAgICAgICAgICBjb3VudGVyVGFyZ2V0Lmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJiZWdpbicsIHRlc3RCb3gpIFxyXG4gICAgICAgICAgbGV0IG9uZUxpbmVIZWlnaHQgPSBnZXRIZWlnaHQodGVzdEJveCk7XHJcbiAgICAgICAgICB0ZXN0Qm94LnJlbW92ZSgpO1xyXG4gICAgICAgICAgbGV0IGxpbmVDb3VudCA9IGdldEhlaWdodCh0YXJnZXQpIC8gb25lTGluZUhlaWdodDtcclxuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdjb3VudGluZ0xpbmVzJyk7XHJcbiAgICAgICAgICBpZiAobGluZUNvdW50KSB7XHJcbiAgICAgICAgICAgIGxldCBsaW5lQ291bnRSb3VuZGVkID0gc2ltcGxlUm91bmRpbmcobGluZUNvdW50KTtcclxuICAgICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuY2FsY3VsYXRlZExpbmVzQ291bnQgPSBsaW5lQ291bnRSb3VuZGVkOyAvLyBhZGRzIHByb3BlcnR5IGZvciBDU1MgdGFyZ2V0aW5nXHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lQ291bnRSb3VuZGVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IG1ldHJpY3MgPSBjYWxjdWxhdGVUZXh0TWV0cmljcyh0YXJnZXQpO1xyXG4gICAgICAgIGxldCB7IGxpbmVDb3VudCB9ID0gbWV0cmljcztcclxuICAgICAgICB0YXJnZXQuZGF0YXNldC5yYXdMaW5lc0NvdW50ID0gbGluZUNvdW50OyAvLyBhZGRzIHByb3BlcnR5IGZvciBDU1MgdGFyZ2V0aW5nXHJcbiAgICAgICAgaWYgKGxpbmVDb3VudCkge1xyXG4gICAgICAgICAgbGV0IGxpbmVDb3VudFJvdW5kZWQgPSBzaW1wbGVSb3VuZGluZyhsaW5lQ291bnQpO1xyXG4gICAgICAgICAgdGFyZ2V0LmRhdGFzZXQuY2FsY3VsYXRlZExpbmVzQ291bnQgPSBsaW5lQ291bnRSb3VuZGVkOyAvLyBhZGRzIHByb3BlcnR5IGZvciBDU1MgdGFyZ2V0aW5nXHJcbiAgICAgICAgICByZXR1cm4gbGluZUNvdW50Um91bmRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB9IGVsc2Uge1xyXG4gXHJcbiAgICAgIC8vIGxldCBtZXRyaWNzID0gY2FsY3VsYXRlVGV4dE1ldHJpY3ModGFyZ2V0KTtcclxuICAgICAgLy8gaWYgKG1ldHJpY3MubGluZUNvdW50KSB7XHJcbiAgICAgIC8vICAgbGV0IGxpbmVDb3VudFJvdW5kZWQgPSBzaW1wbGVSb3VuZGluZyhtZXRyaWNzLmxpbmVDb3VudClcclxuICAgICAgLy8gICB0YXJnZXQuZGF0YXNldC5jYWxjdWxhdGVkTGluZXNDb3VudCA9IGxpbmVDb3VudFJvdW5kZWQgLy8gYWRkcyBwcm9wZXJ0eSBmb3IgQ1NTIHRhcmdldGluZ1xyXG4gICAgICAvLyAgIHRhcmdldC5kYXRhc2V0LnJhd0xpbmVzQ291bnQgPSBtZXRyaWNzLmxpbmVDb3VudDsgLy8gYWRkcyBwcm9wZXJ0eSBmb3IgQ1NTIHRhcmdldGluZ1xyXG4gICAgICAvLyAgIHJldHVybiBsaW5lQ291bnRSb3VuZGVkXHJcbiAgICAgIC8vIH1cclxuICAgICAgLy8gcmV0dXJuIG51bGxcclxuICAgIC8vIH1cclxuICB9KTtcclxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICByZXR1cm4gcmVzdWx0WzBdO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5sZXQgY2xhbXBEZWZhdWx0cyA9IHsgbWF4TGluZXM6IDEsIG1pbkZvbnRTaXplOiAxOCwgdXNlU29mdENsYW1wOiB0cnVlLCBlbGxpcHNpczogJy4uLicgfVxyXG5mdW5jdGlvbiBsaW5lQ2xhbXAoZWxlbWVudHMsIGNvbmZpZykgIHtcclxuICBjb25maWcgPSB7IC4uLmNsYW1wRGVmYXVsdHMsIC4uLmNvbmZpZyB9XHJcbiAgdmFyIGVsVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50cyk7XHJcbiAgaWYgKFxyXG4gICAgZWxUeXBlICE9PSBcIltvYmplY3QgQXJyYXldXCIgJiZcclxuICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiICYmXHJcbiAgICBlbFR5cGUgIT09IFwiW29iamVjdCBIVE1MQ29sbGVjdGlvbl1cIlxyXG4gICkge1xyXG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG4gIH1cclxuICByZXR1cm4gWy4uLmVsZW1lbnRzXS5tYXAoZWxlbWVudCA9PiB7XHJcbiAgICBjb25zdCBjbGFtcCA9IG5ldyBMaW5lQ2xhbXAoZWxlbWVudCwgY29uZmlnKVxyXG4gICAgY2xhbXAuYXBwbHkoKVxyXG4gICAgY2xhbXAud2F0Y2goKVxyXG4gICBcclxuICAgIHJldHVybiBjbGFtcDtcclxuICB9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBsaW5lQ291bnQgYW5kIGxpbmUgaGllZ2h0IGluZm8gZnJvbSB0aGlzIGxpYmFyYXkgaHR0cHM6Ly9naXRodWIuY29tL3R2YW5jL2xpbmVjbGFtcFxyXG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0TWV0cmljcyhlbGVtZW50cywgY29uZmlnKSB7XHJcbiAgdmFyIGVsVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50cyk7XHJcbiAgaWYgKFxyXG4gICAgZWxUeXBlICE9PSBcIltvYmplY3QgQXJyYXldXCIgJiZcclxuICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiICYmXHJcbiAgICBlbFR5cGUgIT09IFwiW29iamVjdCBIVE1MQ29sbGVjdGlvbl1cIlxyXG4gICkge1xyXG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG4gIH1cclxuICBsZXQgcmVzdWx0ID0gWy4uLmVsZW1lbnRzXS5tYXAoZWxlbWVudCA9PiB7XHJcbiAgICByZXR1cm4gbmV3IExpbmVDbGFtcChlbGVtZW50LCBjb25maWcpLmNhbGN1bGF0ZVRleHRNZXRyaWNzKCk7XHJcbiAgfSk7XHJcbiAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMSkge1xyXG4gICAgcmV0dXJuIHJlc3VsdFswXTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLy8gQ2FsY3VsYXRlIGhlaWdodCB3aXRob3V0IHBhZGRpbmcuXHJcbmZ1bmN0aW9uIGdldEhlaWdodChlbCkge1xyXG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpKTtcclxuICB2YXIgYm94X3NpemluZyA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJib3gtc2l6aW5nXCIpO1xyXG4gIGlmIChib3hfc2l6aW5nID09PSBcImJvcmRlci1ib3hcIikge1xyXG4gICAgdmFyIHBhZGRpbmdfdG9wID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy10b3BcIikpO1xyXG4gICAgdmFyIHBhZGRpbmdfYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1ib3R0b21cIikpO1xyXG4gICAgdmFyIGJvcmRlcl90b3AgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItdG9wLXdpZHRoXCIpKTtcclxuICAgIHZhciBib3JkZXJfYm90dG9tID0gcGFyc2VGbG9hdChcclxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1ib3R0b20td2lkdGhcIilcclxuICAgICk7XHJcbiAgICBoZWlnaHQgPSBoZWlnaHQgLSBwYWRkaW5nX3RvcCAtIHBhZGRpbmdfYm90dG9tIC0gYm9yZGVyX3RvcCAtIGJvcmRlcl9ib3R0b207XHJcbiAgfVxyXG4gIGVsLmRhdGFzZXQuY2FsY3VsYXRlZEhlaWdodCA9IGhlaWdodDsgLy8gYWRkcyBwcm9wZXJ0eSBmb3IgZGVidWdpbmdcclxuICByZXR1cm4gaGVpZ2h0O1xyXG59XHJcblxyXG4vLyBDYWxjdWxhdGUgd2lkdGggd2l0aG91dCBwYWRkaW5nLlxyXG5mdW5jdGlvbiBnZXRXaWR0aChlbCkge1xyXG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ3aWR0aFwiKSk7XHJcbiAgdmFyIGJveF9zaXppbmcgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTtcclxuICBpZiAoYm94X3NpemluZyA9PT0gXCJib3JkZXItYm94XCIpIHtcclxuICAgIHZhciBwYWRkaW5nX2xlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWxlZnRcIikpO1xyXG4gICAgdmFyIHBhZGRpbmdfcmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLXJpZ2h0XCIpKTtcclxuICAgIHZhciBib3JkZXJfbGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1sZWZ0LXdpZHRoXCIpKTtcclxuICAgIHZhciBib3JkZXJfcmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItcmlnaHQtd2lkdGhcIikpO1xyXG4gICAgd2lkdGggPSB3aWR0aCAtIHBhZGRpbmdfbGVmdCAtIHBhZGRpbmdfcmlnaHQgLSBib3JkZXJfbGVmdCAtIGJvcmRlcl9yaWdodDtcclxuICB9XHJcbiAgZWwuZGF0YXNldC5jYWxjdWxhdGVkV2lkdGggPSB3aWR0aDsgLy8gYWRkcyBwcm9wZXJ0eSBmb3IgZGVidWdpbmdcclxuICByZXR1cm4gd2lkdGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1heExpbmVDaGVjayhlbGVtZW50ID0gbnVsbCkge1xyXG4gIGNvbnN0IGlzRXhwb3J0TW9kZSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJleHBvcnRzXCIpID4gLTE7XHJcbiAgY29uc3QgaXNMb2NhbERldiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJsb2NhbGhvc3RcIikgPiAtMTtcclxuICBjb25zdCBwcmV2ZW50RXhwb3J0T3ZlcmZsb3cgPVxyXG4gICAgZG9jdW1lbnQuYm9keS5kYXRhc2V0LnByZXZlbnRFeHBvcnRPdmVyZmxvdyA9PT0gXCJ0cnVlXCI7XHJcbiAgY29uc3QgaXNQcm9qZWN0S2l0ID0gaXNMb2NhbERldlxyXG4gICAgPyB1bmRlZmluZWRcclxuICAgIDogd2luZG93LnBhcmVudC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnByZXZpZXctZnJhbWVcIik7XHJcblxyXG4gIGlmICgoaXNFeHBvcnRNb2RlICYmIHByZXZlbnRFeHBvcnRPdmVyZmxvdykgfHwgaXNQcm9qZWN0S2l0KSByZXR1cm47XHJcblxyXG4gIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1tYXgtbGluZV1cIik7XHJcbiAgYmxvY2tzLmZvckVhY2goKGJsb2NrKSA9PiB7XHJcbiAgICBjb25zdCBsaW5lQ291bnQgPSBjb3VudExpbmVzKGJsb2NrKTtcclxuICAgIC8vIEdldHRpbmcgdGhlIGRhdGEtbWF4LWxpbmUgYXR0cmlidXRlIHZhbHVlIChtYXggbnVtYmVyIG9mIGxpbmVzIGFsbG93ZWQpIFxyXG4gICAgY29uc3QgbWF4TGluZSA9IGJsb2NrLmRhdGFzZXQubWF4TGluZUFsdCB8fCBibG9jay5kYXRhc2V0Lm1heExpbmU7XHJcblxyXG4gICAgbGluZUNvdW50ID4gbWF4TGluZVxyXG4gICAgICA/IGJsb2NrLmNsYXNzTGlzdC5hZGQoXCJvdmVyZmxvd1wiKVxyXG4gICAgICA6IGJsb2NrLmNsYXNzTGlzdC5yZW1vdmUoXCJvdmVyZmxvd1wiKTtcclxuICB9KTtcclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWluTGluZUNoZWNrKGVsZW1lbnQgPSBudWxsKSB7XHJcbiAgY29uc3QgaXNFeHBvcnRNb2RlID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImV4cG9ydHNcIikgPiAtMTtcclxuICBjb25zdCBpc0xvY2FsRGV2ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImxvY2FsaG9zdFwiKSA+IC0xO1xyXG4gIGNvbnN0IHByZXZlbnRFeHBvcnRPdmVyZmxvdyA9XHJcbiAgICBkb2N1bWVudC5ib2R5LmRhdGFzZXQucHJldmVudEV4cG9ydE92ZXJmbG93ID09PSBcInRydWVcIjtcclxuICBjb25zdCBpc1Byb2plY3RLaXQgPSBpc0xvY2FsRGV2XHJcbiAgICA/IHVuZGVmaW5lZFxyXG4gICAgOiB3aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucHJldmlldy1mcmFtZVwiKTtcclxuXHJcbiAgaWYgKChpc0V4cG9ydE1vZGUgJiYgcHJldmVudEV4cG9ydE92ZXJmbG93KSB8fCBpc1Byb2plY3RLaXQpIHJldHVybjtcclxuXHJcbiAgY29uc3QgYmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLW1pbi1saW5lXVwiKTtcclxuICBibG9ja3MuZm9yRWFjaCgoYmxvY2spID0+IHtcclxuICAgIGNvbnN0IGxpbmVDb3VudCA9IGNvdW50TGluZXMoYmxvY2spO1xyXG4gICAgLy8gR2V0dGluZyB0aGUgZGF0YS1tYXgtbGluZSBhdHRyaWJ1dGUgdmFsdWUgKG1heCBudW1iZXIgb2YgbGluZXMgYWxsb3dlZCkgXHJcbiAgICBjb25zdCBtaW5MaW5lID0gYmxvY2suZGF0YXNldC5taW5MaW5lQWx0IHx8IGJsb2NrLmRhdGFzZXQubWF4TGluZTtcclxuXHJcbiAgICBsaW5lQ291bnQgPD0gbWluTGluZVxyXG4gICAgICA/IGJsb2NrLmNsYXNzTGlzdC5hZGQoXCJvdmVyZmxvd1wiKVxyXG4gICAgICA6IGJsb2NrLmNsYXNzTGlzdC5yZW1vdmUoXCJvdmVyZmxvd1wiKTtcclxuICB9KTtcclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbipEZXRhaWxlZCBpbnN0cnVjdGlvbiBjYW4gYmUgZm91bmQgaGVyZTpcclxuIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGVrcy1mcm9udGVuZC9tYXgtaGVpZ2h0LWNoZWNrXHJcbiovXHJcbmZ1bmN0aW9uIG1heEhlaWdodENoZWNrKGVsZW1lbnQgPSBudWxsKSB7XHJcbiAgY29uc3QgaXNFeHBvcnRNb2RlID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImV4cG9ydHNcIikgPiAtMTtcclxuICBjb25zdCBpc0xvY2FsRGV2ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImxvY2FsaG9zdFwiKSA+IC0xO1xyXG4gIGNvbnN0IHByZXZlbnRFeHBvcnRPdmVyZmxvdyA9XHJcbiAgICBkb2N1bWVudC5ib2R5LmRhdGFzZXQucHJldmVudEV4cG9ydE92ZXJmbG93ID09PSBcInRydWVcIjtcclxuICBjb25zdCBpc1Byb2plY3RLaXQgPSBpc0xvY2FsRGV2XHJcbiAgICA/IHVuZGVmaW5lZFxyXG4gICAgOiB3aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucHJldmlldy1mcmFtZVwiKTtcclxuXHJcbiAgaWYgKChpc0V4cG9ydE1vZGUgJiYgcHJldmVudEV4cG9ydE92ZXJmbG93KSB8fCBpc1Byb2plY3RLaXQpIHJldHVybjtcclxuXHJcbiAgY29uc3QgYmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLW1heC1oZWlnaHRdXCIpO1xyXG4gIGJsb2Nrcy5mb3JFYWNoKChibG9jaykgPT4ge1xyXG4gICAgaWYgKGJsb2NrLmRhdGFzZXQubWF4SGVpZ2h0ID09PSBcImR5bmFtaWNcIiB8fCBibG9jay5kYXRhc2V0Lm1heEhlaWdodCA9PT0gXCJwYXJlbnRcIiB8fCBibG9jay5kYXRhc2V0Lm1heEhlaWdodER5bmFtaWMgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgIGR5bmFtaWNBc3NpZ24oYmxvY2spO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmxvY2tIZWlnaHQgPSBnZXRIZWlnaHQoYmxvY2spO1xyXG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gYmxvY2suZGF0YXNldC5tYXhIZWlnaHQ7XHJcblxyXG4gICAgLy8gVE9ETyBpbXByb3ZlIHRoaXMgXHJcbiAgICBpZiAoYmxvY2suZGF0YXNldC5tYXhIZWlnaHQgPT09IFwiY3NzXCIpIHtcclxuICAgICAgY29uc3QgY29tcHV0ZWRCbG9ja1N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYmxvY2spO1xyXG4gICAgICBjb25zdCBjc3NNYXhIZWlnaHQgPSBwYXJzZUZsb2F0KGNvbXB1dGVkQmxvY2tTdHlsZS5tYXhIZWlnaHQpO1xyXG4gICAgICBpZiAoIWNzc01heEhlaWdodCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZXJlIG5lZWRzIHRvIGJlIGEgbWF4IGhlaWdodCBzZXQgb24gdGhlIGVsZW1lbnQgaWYgeW91IHdhbnQgdG8gdXNlIGRhdGEtbWF4LWhlaWdodD1cImNzc1wiJylcclxuICAgICAgfVxyXG4gICAgICBtYXhIZWlnaHQgPSBjc3NNYXhIZWlnaHRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNldHRpbmcgdGhlIGVsZW1lbnQncyBtYXgtaGVpZ2h0XHJcbiAgICAgIGJsb2NrLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIGJsb2NrLmRhdGFzZXQubWF4SGVpZ2h0VW5pdCB8fCBcInB4XCI7XHJcblxyXG4gICAgICAvLyBSZWNhbGN1bGF0aW5nIG1heEhlaWdodCBpbiBjYXNlICdyZW0nIGlzIHNldCBhcyBhIHVuaXRcclxuICAgICAgaWYgKGJsb2NrLmRhdGFzZXQubWF4SGVpZ2h0VW5pdCA9PT0gXCJyZW1cIikge1xyXG4gICAgICAgIG1heEhlaWdodCA9IG1heEhlaWdodCAqIHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZm9udFNpemUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkaW5nIGFuICdvdmVyZmxvdycgY2xhc3MgdG8gYW4gZWxlbWVudCBpZiBpdCdzIG9mZnNldCBoZWlnaHQgZXhjZWVkZXMgdGhlIG1heC1saW5lLWhlaWdodFxyXG4gICAgYmxvY2tIZWlnaHQgPiBtYXhIZWlnaHRcclxuICAgICAgPyBibG9jay5jbGFzc0xpc3QuYWRkKFwib3ZlcmZsb3dcIilcclxuICAgICAgOiBibG9jay5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNBc3NpZ24oZWxlbWVudCA9IG51bGwpIHtcclxuICBjb25zdCBjb250YWluZXIgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAvLyBjb25zdCBjb250YWluZXJDb21wdXRlZCA9IHtcclxuICAvLyAgIGhlaWdodDogcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLmhlaWdodCksXHJcbiAgLy8gICB0b3A6IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wYWRkaW5nVG9wKSxcclxuICAvLyAgIGJvdHRvbTogcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLnBhZGRpbmdCb3R0b20pLFxyXG4gIC8vIH07XHJcbiAgLy8gY29uc3QgY29udGFpbmVySGVpZ2h0ID0gTWF0aC5mbG9vcihcclxuICAvLyAgIGNvbnRhaW5lckNvbXB1dGVkLmhlaWdodCAtIGNvbnRhaW5lckNvbXB1dGVkLnRvcCAtIGNvbnRhaW5lckNvbXB1dGVkLmJvdHRvbVxyXG4gIC8vICk7XHJcbiAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gZ2V0SGVpZ2h0KGNvbnRhaW5lcilcclxuICAvLyBUT0RPIHdvcmsgb3V0IHdoYXQgc3VidHJhaGVuZCBpcyBcclxuICBjb25zdCBzdWJ0cmFoZW5kcyA9IFsuLi5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5qcy1zdWJ0cmFoZW5kXCIpXTtcclxuXHJcbiAgY29uc3Qgc3VidHJhaGVuZHNIZWlnaHQgPSBzdWJ0cmFoZW5kcy5yZWR1Y2UoKHRvdGFsSGVpZ2h0LCBzdWJ0cmFoZW5kKSA9PiB7XHJcbiAgICBjb25zdCBzdWJ0cmFoZW5kTWFyZ2lucyA9IHtcclxuICAgICAgdG9wOiBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHN1YnRyYWhlbmQpLm1hcmdpblRvcCksXHJcbiAgICAgIGJvdHRvbTogcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdWJ0cmFoZW5kKS5tYXJnaW5Cb3R0b20pLFxyXG4gICAgfTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRvdGFsSGVpZ2h0ICtcclxuICAgICAgc3VidHJhaGVuZC5vZmZzZXRIZWlnaHQgK1xyXG4gICAgICBzdWJ0cmFoZW5kTWFyZ2lucy50b3AgK1xyXG4gICAgICBzdWJ0cmFoZW5kTWFyZ2lucy5ib3R0b21cclxuICAgICk7XHJcbiAgfSwgMCk7XHJcblxyXG4gIGNvbnN0IGR5bmFtaWNIZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSBzdWJ0cmFoZW5kc0hlaWdodDtcclxuXHJcbiAgZWxlbWVudC5kYXRhc2V0Lm1heEhlaWdodER5bmFtaWMgPSBcInRydWVcIjtcclxuICBlbGVtZW50LmRhdGFzZXQubWF4SGVpZ2h0ID0gZHluYW1pY0hlaWdodDtcclxuICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcclxuICByZXR1cm4gZHluYW1pY0hlaWdodDtcclxufVxyXG5cclxuLy8gQWRkaW5nIGxpbWl0IGZvciB0aGUgd29yZCBsZW5ndGhcclxuZnVuY3Rpb24gY2hhckxpbWl0KGVsZW1lbnQgPSBudWxsKSB7XHJcbiAgY29uc3QgYmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNoYXItbGltaXRdXCIpO1xyXG4gIGJsb2Nrcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICBjb25zdCBsaW1pdCA9IGVsZW1lbnQuZGF0YXNldC5jaGFyTGltaXQ7XHJcblxyXG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHRva2VuVmFsdWUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudG9rZW4tdmFsdWVcIik7XHJcblxyXG4gICAgaWYgKHRva2VuVmFsdWUubGVuZ3RoICE9IDApIHtcclxuICAgICAgZWxlbWVudCA9IHRva2VuVmFsdWUuaXRlbSgwKTtcclxuICAgIH1cclxuICAgIHZhciBjb2RlID0gZWxlbWVudC5pbm5lclRleHQ7XHJcbiAgICBlbGVtZW50LmRhdGFzZXQuY2FsY3VsYXRlZENoYXJDb3VudCA9IGNvZGUubGVuZ3RoO1xyXG4gICAgaWYgKGNvZGUubGVuZ3RoID4gbGltaXQpIHtcclxuICAgICAgLy8gQ2hlY2sgVG9rZW4gQWdhaW5cclxuICAgICAgaWYgKHRva2VuVmFsdWUubGVuZ3RoICE9IDApIHtcclxuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBDaGVjayBUb2tlbiBBZ2FpblxyXG4gICAgICBpZiAodG9rZW5WYWx1ZS5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IHsgY2hhckxpbWl0LCBkeW5hbWljQXNzaWduLCBtYXhIZWlnaHRDaGVjaywgbWF4TGluZUNoZWNrLCBnZXRXaWR0aCwgZ2V0SGVpZ2h0LCBjb3VudExpbmVzLCBjYWxjdWxhdGVUZXh0TWV0cmljcywgbGluZUNsYW1wLCBtaW5MaW5lQ2hlY2sgfSIsImltcG9ydCB7IGdldEhlaWdodCB9IGZyb20gJy4vbGltaXRlcnMuanMnXG5cbi8qKlxuICogUmVkdWNlcyBmb250IHNpemUgb3IgdHJpbXMgdGV4dCB0byBtYWtlIGl0IGZpdCB3aXRoaW4gc3BlY2lmaWVkIGJvdW5kcy5cbiAqXG4gKiBTdXBwb3J0cyBjbGFtcGluZyBieSBudW1iZXIgb2YgbGluZXMgb3IgdGV4dCBoZWlnaHQuXG4gKlxuICogS25vd24gbGltaXRhdGlvbnM6XG4gKiAxLiBDaGFyYWN0ZXJzIHRoYXQgZGlzdG9ydCBsaW5lIGhlaWdodHMgKGVtb2ppcywgemFsZ28pIG1heSBjYXVzZVxuICogdW5leHBlY3RlZCByZXN1bHRzLlxuICogMi4gQ2FsbGluZyB7QHNlZSBoYXJkQ2xhbXAoKX0gd2lwZXMgY2hpbGQgZWxlbWVudHMuIEZ1dHVyZSB1cGRhdGVzIG1heSBhbGxvd1xuICogaW5saW5lIGNoaWxkIGVsZW1lbnRzIHRvIGJlIHByZXNlcnZlZC5cbiAqXG4gKiBAdG9kbyBTcGxpdCB0ZXh0IG1ldHJpY3MgaW50byBvd24gbGlicmFyeVxuICogQHRvZG8gVGVzdCBub24tTFRSIHRleHRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNsYW1wIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogVGhlIGVsZW1lbnQgdG8gY2xhbXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogT3B0aW9ucyB0byBnb3Zlcm4gY2xhbXBpbmcgYmVoYXZpb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhMaW5lc11cbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGxpbmVzIHRvIGFsbG93LiBEZWZhdWx0cyB0byAxLlxuICAgKiBUbyBzZXQgYSBtYXhpbXVtIGhlaWdodCBpbnN0ZWFkLCB1c2Uge0BzZWUgb3B0aW9ucy5tYXhIZWlnaHR9XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhIZWlnaHRdXG4gICAqIFRoZSBtYXhpbXVtIGhlaWdodCAoaW4gcGl4ZWxzKSBvZiB0ZXh0IGluIGFuIGVsZW1lbnQuXG4gICAqIFRoaXMgb3B0aW9uIGlzIHVuZGVmaW5lZCBieSBkZWZhdWx0LiBPbmNlIHNldCwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyXG4gICAqIHtAc2VlIG9wdGlvbnMubWF4TGluZXN9LiBOb3RlIHRoYXQgdGhpcyBhcHBsaWVzIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRleHQsIG5vdFxuICAgKiB0aGUgZWxlbWVudCBpdHNlbGYuIFJlc3RyaWN0aW5nIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIGFjaGlldmVkXG4gICAqIHdpdGggQ1NTIDxjb2RlPm1heC1oZWlnaHQ8L2NvZGU+LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZVNvZnRDbGFtcF1cbiAgICogSWYgdHJ1ZSwgcmVkdWNlIGZvbnQgc2l6ZSAoc29mdCBjbGFtcCkgdG8gYXQgbGVhc3Qge0BzZWUgb3B0aW9ucy5taW5Gb250U2l6ZX1cbiAgICogYmVmb3JlIHJlc29ydGluZyB0byB0cmltbWluZyB0ZXh0LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5oYXJkQ2xhbXBBc0ZhbGxiYWNrXVxuICAgKiBJZiB0cnVlLCByZXNvcnQgdG8gaGFyZCBjbGFtcGluZyBpZiBzb2Z0IGNsYW1waW5nIHJlYWNoZXMgdGhlIG1pbmltdW0gZm9udCBzaXplXG4gICAqIGFuZCBzdGlsbCBkb2Vzbid0IGZpdCB3aXRoaW4gdGhlIG1heCBoZWlnaHQgb3IgbnVtYmVyIG9mIGxpbmVzLlxuICAgKiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZWxsaXBzaXNdXG4gICAqIFRoZSBjaGFyYWN0ZXIgd2l0aCB3aGljaCB0byByZXByZXNlbnQgY2xpcHBlZCB0cmFpbGluZyB0ZXh0LlxuICAgKiBUaGlzIG9wdGlvbiB0YWtlcyBlZmZlY3Qgd2hlbiBcImhhcmRcIiBjbGFtcGluZyBpcyB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluRm9udFNpemVdXG4gICAqIFRoZSBsb3dlc3QgZm9udCBzaXplLCBpbiBwaXhlbHMsIHRvIHRyeSBiZWZvcmUgcmVzb3J0aW5nIHRvIHJlbW92aW5nXG4gICAqIHRyYWlsaW5nIHRleHQgKGhhcmQgY2xhbXBpbmcpLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9udFNpemVdXG4gICAqIFRoZSBtYXhpbXVtIGZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlJ2xsIHN0YXJ0IHdpdGggdGhpcyBmb250IHNpemUgdGhlblxuICAgKiByZWR1Y2UgdW50aWwgdGV4dCBmaXRzIGNvbnN0cmFpbnRzLCBvciBmb250IHNpemUgaXMgZXF1YWwgdG9cbiAgICoge0BzZWUgb3B0aW9ucy5taW5Gb250U2l6ZX0uIERlZmF1bHRzIHRvIHRoZSBlbGVtZW50J3MgaW5pdGlhbCBjb21wdXRlZCBmb250IHNpemUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBlbGVtZW50LFxuICAgIHtcbiAgICAgIG1heExpbmVzID0gdW5kZWZpbmVkLFxuICAgICAgbWF4SGVpZ2h0ID0gdW5kZWZpbmVkLFxuICAgICAgdXNlU29mdENsYW1wID0gZmFsc2UsXG4gICAgICBoYXJkQ2xhbXBBc0ZhbGxiYWNrID0gdHJ1ZSxcbiAgICAgIG1pbkZvbnRTaXplID0gMSxcbiAgICAgIG1heEZvbnRTaXplID0gdW5kZWZpbmVkLFxuICAgICAgZWxsaXBzaXMgPSBcIuKAplwiLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbFdvcmRzXCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBlbGVtZW50LnRleHRDb250ZW50Lm1hdGNoKC9cXFMrXFxzKi9nKSB8fCBbXSxcbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXBkYXRlSGFuZGxlclwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogKCkgPT4gdGhpcy5hcHBseSgpLFxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYnNlcnZlclwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy51cGRhdGVIYW5kbGVyKSxcbiAgICB9KVxuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWF4Rm9udFNpemUpIHtcbiAgICAgIG1heEZvbnRTaXplID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZm9udFNpemUsIDEwKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLm1heExpbmVzID0gbWF4TGluZXNcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodFxuICAgIHRoaXMudXNlU29mdENsYW1wID0gdXNlU29mdENsYW1wXG4gICAgdGhpcy5oYXJkQ2xhbXBBc0ZhbGxiYWNrID0gaGFyZENsYW1wQXNGYWxsYmFja1xuICAgIHRoaXMubWluRm9udFNpemUgPSBtaW5Gb250U2l6ZVxuICAgIHRoaXMubWF4Rm9udFNpemUgPSBtYXhGb250U2l6ZVxuICAgIHRoaXMuZWxsaXBzaXMgPSBlbGxpcHNpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdhdGhlciBtZXRyaWNzIGFib3V0IHRoZSBsYXlvdXQgb2YgdGhlIGVsZW1lbnQncyB0ZXh0LlxuICAgKiBUaGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiAtIGNhbGwgd2l0aCBjYXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VGV4dE1ldHJpY3N9XG4gICAqIExheW91dCBtZXRyaWNzIGZvciB0aGUgY2xhbXBlZCBlbGVtZW50J3MgdGV4dC5cbiAgICovXG4gIGNhbGN1bGF0ZVRleHRNZXRyaWNzKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRcbiAgICBjb25zdCBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpXG4gICAgY29uc3Qgc3R5bGUgPSBjbG9uZS5zdHlsZVxuXG4gICAgLy8gQXBwZW5kLCBkb24ndCByZXBsYWNlXG4gICAgc3R5bGUuY3NzVGV4dCArPSBcIjttaW4taGVpZ2h0OjAhaW1wb3J0YW50O21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnRcIlxuICAgIGVsZW1lbnQucmVwbGFjZVdpdGgoY2xvbmUpXG5cbiAgICBjb25zdCBuYXR1cmFsSGVpZ2h0ID0gZ2V0SGVpZ2h0KGNsb25lKSAvLyBjbG9uZS5vZmZzZXRIZWlnaHRcblxuICAgIC8vIENsZWFyIHRvIG1lYXN1cmUgZW1wdHkgaGVpZ2h0LiB0ZXh0Q29udGVudCBmYXN0ZXIgdGhhbiBpbm5lckhUTUxcbiAgICBjbG9uZS50ZXh0Q29udGVudCA9IFwiXCJcblxuICAgIGNvbnN0IG5hdHVyYWxIZWlnaHRXaXRob3V0VGV4dCA9IGdldEhlaWdodChjbG9uZSkgLy8gY2xvbmUub2Zmc2V0SGVpZ2h0XG4gICAgY29uc3QgdGV4dEhlaWdodCA9IG5hdHVyYWxIZWlnaHQgLSBuYXR1cmFsSGVpZ2h0V2l0aG91dFRleHRcblxuICAgIC8vIEZpbGwgZWxlbWVudCB3aXRoIHNpbmdsZSBub24tYnJlYWtpbmcgc3BhY2UgdG8gZmluZCBoZWlnaHQgb2Ygb25lIGxpbmVcbiAgICBjbG9uZS50ZXh0Q29udGVudCA9IFwiXFx4YTBcIlxuXG4gICAgLy8gR2V0IGhlaWdodCBvZiBlbGVtZW50IHdpdGggb25seSBvbmUgbGluZSBvZiB0ZXh0XG4gICAgY29uc3QgbmF0dXJhbEhlaWdodFdpdGhPbmVMaW5lID0gZ2V0SGVpZ2h0KGNsb25lKSAvLyBjbG9uZS5vZmZzZXRIZWlnaHRcbiAgICBjb25zdCBmaXJzdExpbmVIZWlnaHQgPSBuYXR1cmFsSGVpZ2h0V2l0aE9uZUxpbmUgLSBuYXR1cmFsSGVpZ2h0V2l0aG91dFRleHRcblxuICAgIC8vIEFkZCBsaW5lICg8YnI+ICsgbmJzcCkuIGFwcGVuZENoaWxkKCkgZmFzdGVyIHRoYW4gaW5uZXJIVE1MXG4gICAgY2xvbmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKVxuICAgIGNsb25lLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFx4YTBcIikpXG5cbiAgICBjb25zdCBhZGRpdGlvbmFsTGluZUhlaWdodCA9IGdldEhlaWdodChjbG9uZSkgLSBuYXR1cmFsSGVpZ2h0V2l0aE9uZUxpbmUgLy8gY2xvbmUub2Zmc2V0SGVpZ2h0IC0gbmF0dXJhbEhlaWdodFdpdGhPbmVMaW5lXG4gICAgY29uc3QgbGluZUNvdW50ID1cbiAgICAgIDEgKyAobmF0dXJhbEhlaWdodCAtIG5hdHVyYWxIZWlnaHRXaXRoT25lTGluZSkgLyBhZGRpdGlvbmFsTGluZUhlaWdodFxuXG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb250ZW50XG4gICAgY2xvbmUucmVwbGFjZVdpdGgoZWxlbWVudClcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRNZXRyaWNzXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge3RleHRIZWlnaHR9XG4gICAgICogVGhlIHZlcnRpY2FsIHNwYWNlIHJlcXVpcmVkIHRvIGRpc3BsYXkgdGhlIGVsZW1lbnQncyBjdXJyZW50IHRleHQuXG4gICAgICogVGhpcyBpcyA8ZW0+bm90PC9lbT4gbmVjZXNzYXJpbHkgdGhlIHNhbWUgYXMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGlzIG51bWJlciBtYXkgZXZlbiBiZSBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQncyBoZWlnaHQgaW4gY2FzZXNcbiAgICAgKiB3aGVyZSB0aGUgdGV4dCBvdmVyZmxvd3MgdGhlIGVsZW1lbnQncyBibG9jayBheGlzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtuYXR1cmFsSGVpZ2h0V2l0aE9uZUxpbmV9XG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCB3aXRoIG9ubHkgb25lIGxpbmUgb2YgdGV4dCBhbmQgd2l0aG91dFxuICAgICAqIG1pbmltdW0gb3IgbWF4aW11bSBoZWlnaHRzLiBUaGlzIGluZm9ybWF0aW9uIG1heSBiZSBoZWxwZnVsIHdoZW5cbiAgICAgKiBkZWFsaW5nIHdpdGggaW5saW5lIGVsZW1lbnRzIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgc2NlbmFyaW9zKSwgd2hlcmVcbiAgICAgKiB0aGUgZmlyc3QgbGluZSBvZiB0ZXh0IGRvZXMgbm90IGluY3JlYXNlIHRoZSBlbGVtZW50J3MgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtmaXJzdExpbmVIZWlnaHR9XG4gICAgICogVGhlIGhlaWdodCB0aGF0IHRoZSBmaXJzdCBsaW5lIG9mIHRleHQgYWRkcyB0byB0aGUgZWxlbWVudCwgaS5lLiwgdGhlXG4gICAgICogZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgd2hpbGUgZW1wdHkgYW5kIHRoZSBoZWlnaHRcbiAgICAgKiBvZiB0aGUgZWxlbWVudCB3aGlsZSBpdCBjb250YWlucyBvbmUgbGluZSBvZiB0ZXh0LiBUaGlzIG51bWJlciBtYXkgYmVcbiAgICAgKiB6ZXJvIGZvciBpbmxpbmUgZWxlbWVudHMgYmVjYXVzZSB0aGUgZmlyc3QgbGluZSBvZiB0ZXh0IGRvZXMgbm90XG4gICAgICogaW5jcmVhc2UgdGhlIGhlaWdodCBvZiBpbmxpbmUgZWxlbWVudHMuXG5cbiAgICAgKiBAcHJvcGVydHkge2FkZGl0aW9uYWxMaW5lSGVpZ2h0fVxuICAgICAqIFRoZSBoZWlnaHQgdGhhdCBlYWNoIGxpbmUgb2YgdGV4dCBhZnRlciB0aGUgZmlyc3QgYWRkcyB0byB0aGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bGluZUNvdW50fVxuICAgICAqIFRoZSBudW1iZXIgb2YgbGluZXMgb2YgdGV4dCB0aGUgZWxlbWVudCBjb250YWlucy5cbiAgICAgKi9cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dEhlaWdodCxcbiAgICAgIG5hdHVyYWxIZWlnaHRXaXRoT25lTGluZSxcbiAgICAgIGZpcnN0TGluZUhlaWdodCxcbiAgICAgIGFkZGl0aW9uYWxMaW5lSGVpZ2h0LFxuICAgICAgbGluZUNvdW50LFxuICAgICAgbmF0dXJhbEhlaWdodFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYXRjaCBmb3IgY2hhbmdlcyB0aGF0IG1heSBhZmZlY3QgbGF5b3V0LiBSZXNwb25kIGJ5IHJlY2xhbXBpbmcgaWZcbiAgICogbmVjZXNzYXJ5LlxuICAgKi9cbiAgd2F0Y2goKSB7XG4gICAgaWYgKCF0aGlzLl93YXRjaGluZykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy51cGRhdGVIYW5kbGVyKVxuXG4gICAgICAvLyBNaW5pbXVtIHJlcXVpcmVkIHRvIGRldGVjdCBjaGFuZ2VzIHRvIHRleHQgbm9kZXMsXG4gICAgICAvLyBhbmQgd2hvbGVzYWxlIHJlcGxhY2VtZW50IHZpYSBpbm5lckhUTUxcbiAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgfSlcblxuICAgICAgdGhpcy5fd2F0Y2hpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHdhdGNoaW5nIGZvciBsYXlvdXQgY2hhbmdlcy5cbiAgICpcbiAgICogQHJldHVybnMge0xpbmVDbGFtcH1cbiAgICovXG4gIHVud2F0Y2goKSB7XG4gICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnVwZGF0ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl93YXRjaGluZyA9IGZhbHNlXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmR1Y3QgZWl0aGVyIHNvZnQgY2xhbXBpbmcgb3IgaGFyZCBjbGFtcGluZywgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZSBvZlxuICAgKiBwcm9wZXJ0eSB7QHNlZSBMaW5lQ2xhbXAudXNlU29mdENsYW1wfS5cbiAgICovXG4gIGFwcGx5KCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICBjb25zdCBwcmV2aW91c2x5V2F0Y2hpbmcgPSB0aGlzLl93YXRjaGluZ1xuXG4gICAgICAvLyBJZ25vcmUgaW50ZXJuYWxseSBzdGFydGVkIG11dGF0aW9ucywgbGVzdCB3ZSByZWN1cnNlIGludG8gb2JsaXZpb25cbiAgICAgIHRoaXMudW53YXRjaCgpXG5cbiAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMub3JpZ2luYWxXb3Jkcy5qb2luKFwiXCIpXG5cbiAgICAgIGlmICh0aGlzLnVzZVNvZnRDbGFtcCkge1xuICAgICAgICB0aGlzLnNvZnRDbGFtcCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhcmRDbGFtcCgpXG4gICAgICB9XG5cbiAgICAgIC8vIFJlc3VtZSBvYnNlcnZhdGlvbiBpZiBwcmV2aW91c2x5IHdhdGNoaW5nXG4gICAgICBpZiAocHJldmlvdXNseVdhdGNoaW5nKSB7XG4gICAgICAgIHRoaXMud2F0Y2goZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmltcyB0ZXh0IHVudGlsIGl0IGZpdHMgd2l0aGluIGNvbnN0cmFpbnRzXG4gICAqIChtYXhpbXVtIGhlaWdodCBvciBudW1iZXIgb2YgbGluZXMpLlxuICAgKlxuICAgKiBAc2VlIHtMaW5lQ2xhbXAubWF4TGluZXN9XG4gICAqIEBzZWUge0xpbmVDbGFtcC5tYXhIZWlnaHR9XG4gICAqL1xuICBoYXJkQ2xhbXAoc2tpcENoZWNrID0gdHJ1ZSkge1xuICAgIGlmIChza2lwQ2hlY2sgfHwgdGhpcy5zaG91bGRDbGFtcCgpKSB7XG4gICAgICBsZXQgY3VycmVudFRleHRcblxuICAgICAgZmluZEJvdW5kYXJ5KFxuICAgICAgICAxLFxuICAgICAgICB0aGlzLm9yaWdpbmFsV29yZHMubGVuZ3RoLFxuICAgICAgICAodmFsKSA9PiB7XG4gICAgICAgICAgY3VycmVudFRleHQgPSB0aGlzLm9yaWdpbmFsV29yZHMuc2xpY2UoMCwgdmFsKS5qb2luKFwiIFwiKVxuICAgICAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IGN1cnJlbnRUZXh0XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5zaG91bGRDbGFtcCgpXG4gICAgICAgIH0sXG4gICAgICAgICh2YWwsIG1pbiwgbWF4KSA9PiB7XG4gICAgICAgICAgLy8gQWRkIG9uZSBtb3JlIHdvcmQgaWYgbm90IG9uIG1heFxuICAgICAgICAgIGlmICh2YWwgPiBtaW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gdGhpcy5vcmlnaW5hbFdvcmRzLnNsaWNlKDAsIG1heCkuam9pbihcIiBcIilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGVuIHRyaW0gbGV0dGVycyB1bnRpbCBpdCBmaXRzXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudFRleHQgPSBjdXJyZW50VGV4dC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IGN1cnJlbnRUZXh0ICsgdGhpcy5lbGxpcHNpc1xuICAgICAgICAgIH0gd2hpbGUgKHRoaXMuc2hvdWxkQ2xhbXAoKSlcblxuICAgICAgICAgIC8vIEJyb2FkY2FzdCBtb3JlIHNwZWNpZmljIGhhcmRDbGFtcCBldmVudCBmaXJzdFxuICAgICAgICAgIGVtaXQodGhpcywgXCJsaW5lY2xhbXAuaGFyZGNsYW1wXCIpXG4gICAgICAgICAgZW1pdCh0aGlzLCBcImxpbmVjbGFtcC5jbGFtcFwiKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWR1Y2VzIGZvbnQgc2l6ZSB1bnRpbCB0ZXh0IGZpdHMgd2l0aGluIHRoZSBzcGVjaWZpZWQgaGVpZ2h0IG9yIG51bWJlciBvZlxuICAgKiBsaW5lcy4gUmVzb3J0cyB0byB1c2luZyB7QHNlZSBoYXJkQ2xhbXAoKX0gaWYgdGV4dCBzdGlsbCBleGNlZWRzIGNsYW1wXG4gICAqIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzb2Z0Q2xhbXAoKSB7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGVcbiAgICBjb25zdCBzdGFydFNpemUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQpLmZvbnRTaXplXG4gICAgc3R5bGUuZm9udFNpemUgPSBcIlwiXG5cbiAgICBsZXQgZG9uZSA9IGZhbHNlXG4gICAgbGV0IHNob3VsZENsYW1wXG5cbiAgICBmaW5kQm91bmRhcnkoXG4gICAgICB0aGlzLm1pbkZvbnRTaXplLFxuICAgICAgdGhpcy5tYXhGb250U2l6ZSxcbiAgICAgICh2YWwpID0+IHtcbiAgICAgICAgc3R5bGUuZm9udFNpemUgPSB2YWwgKyBcInB4XCJcbiAgICAgICAgc2hvdWxkQ2xhbXAgPSB0aGlzLnNob3VsZENsYW1wKClcbiAgICAgICAgcmV0dXJuIHNob3VsZENsYW1wXG4gICAgICB9LFxuICAgICAgKHZhbCwgbWluKSA9PiB7XG4gICAgICAgIGlmICh2YWwgPiBtaW4pIHtcbiAgICAgICAgICBzdHlsZS5mb250U2l6ZSA9IG1pbiArIFwicHhcIlxuICAgICAgICAgIHNob3VsZENsYW1wID0gdGhpcy5zaG91bGRDbGFtcCgpXG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA9ICFzaG91bGRDbGFtcFxuICAgICAgfVxuICAgIClcblxuICAgIGNvbnN0IGNoYW5nZWQgPSBzdHlsZS5mb250U2l6ZSAhPT0gc3RhcnRTaXplXG5cbiAgICAvLyBFbWl0IHNwZWNpZmljIHNvZnRDbGFtcCBldmVudCBmaXJzdFxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICBlbWl0KHRoaXMsIFwibGluZWNsYW1wLnNvZnRjbGFtcFwiKVxuICAgIH1cblxuICAgIC8vIERvbid0IGVtaXQgYGxpbmVjbGFtcC5jbGFtcGAgZXZlbnQgdHdpY2UuXG4gICAgaWYgKCFkb25lICYmIHRoaXMuaGFyZENsYW1wQXNGYWxsYmFjaykge1xuICAgICAgdGhpcy5oYXJkQ2xhbXAoZmFsc2UpXG4gICAgfSBlbHNlIGlmIChjaGFuZ2VkKSB7XG4gICAgICAvLyBoYXJkQ2xhbXAgZW1pdHMgYGxpbmVjbGFtcC5jbGFtcGAgdG9vLiBPbmx5IGVtaXQgZnJvbSBoZXJlIGlmIHdlJ3JlXG4gICAgICAvLyBub3QgYWxzbyBoYXJkIGNsYW1waW5nLlxuICAgICAgZW1pdCh0aGlzLCBcImxpbmVjbGFtcC5jbGFtcFwiKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIFdoZXRoZXIgaGVpZ2h0IG9mIHRleHQgb3IgbnVtYmVyIG9mIGxpbmVzIGV4Y2VlZCBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQHNlZSBMaW5lQ2xhbXAubWF4SGVpZ2h0XG4gICAqIEBzZWUgTGluZUNsYW1wLm1heExpbmVzXG4gICAqL1xuICBzaG91bGRDbGFtcCgpIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudCwgdGV4dEhlaWdodCB9ID0gdGhpcy5jYWxjdWxhdGVUZXh0TWV0cmljcygpXG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB0aGlzLm1heEhlaWdodCAmJiB1bmRlZmluZWQgIT09IHRoaXMubWF4TGluZXMpIHtcbiAgICAgIHJldHVybiB0ZXh0SGVpZ2h0ID4gdGhpcy5tYXhIZWlnaHQgfHwgbGluZUNvdW50ID4gdGhpcy5tYXhMaW5lc1xuICAgIH1cblxuICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMubWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGV4dEhlaWdodCA+IHRoaXMubWF4SGVpZ2h0XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gdGhpcy5tYXhMaW5lcykge1xuICAgICAgcmV0dXJuIGxpbmVDb3VudCA+IHRoaXMubWF4TGluZXNcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIm1heExpbmVzIG9yIG1heEhlaWdodCBtdXN0IGJlIHNldCBiZWZvcmUgY2FsbGluZyBzaG91bGRDbGFtcCgpLlwiXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgcG9pbnQgaW4gYSBjb250aWdvdXMgcmFuZ2Ugd2hlcmUgYSBnaXZlblxuICogdGVzdCBjYWxsYmFjayB3aWxsIGdvIGZyb20gcmV0dXJuaW5nIHRydWUgdG8gcmV0dXJuaW5nIGZhbHNlLlxuICpcbiAqIFNpbmNlIHRoaXMgdXNlcyBhIGJpbmFyeS1zZWFyY2ggYWxnb3JpdGhtIHRoaXMgaXMgYW4gTyhsb2cgbikgZnVuY3Rpb24sXG4gKiB3aGVyZSBuID0gbWF4IC0gbWluLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAqIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICogVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdGVzdFxuICogQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBjdXJyZW50IHZhbHVlIGluIHRoZSByYW5nZSBhbmQgcmV0dXJucyBhIHRydXRoeSBvciBmYWxzeSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZG9uZVxuICogQSBmdW5jdGlvbiB0byBwZXJmb3JtIHdoZW4gY29tcGxldGUuIFJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyc1xuICogLSBjdXJzb3JcbiAqIC0gbWF4UGFzc2luZ1ZhbHVlXG4gKiAtIG1pbkZhaWxpbmdWYWx1ZVxuICovXG5mdW5jdGlvbiBmaW5kQm91bmRhcnkobWluLCBtYXgsIHRlc3QsIGRvbmUpIHtcbiAgLy8gc3RhcnQgaGFsZndheSB0aHJvdWdoIHRoZSByYW5nZVxuICBsZXQgY3Vyc29yID0gKG1pbiArIG1heCkgLyAyXG5cbiAgd2hpbGUgKG1heCA+IG1pbikge1xuICAgIGlmICh0ZXN0KGN1cnNvcikpIHtcbiAgICAgIG1heCA9IGN1cnNvclxuICAgIH0gZWxzZSB7XG4gICAgICBtaW4gPSBjdXJzb3JcbiAgICB9XG5cbiAgICBpZiAobWF4IC0gbWluID09PSAxKSB7XG4gICAgICBkb25lKGN1cnNvciwgbWluLCBtYXgpXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGN1cnNvciA9IE1hdGguZmxvb3IoKG1pbiArIG1heCkgLyAyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaW5zdGFuY2UuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlKSlcbn1cbiIsIiAgLy8gZ2V0IHNpZGViYXIgZWxlbWVudCBvbiB0aGUgY3VycmVudCBwYWdlXG4gIGNvbnN0IGdldFNpZGViYXIgPSAoKSA9PiB7XG4gICAgbGV0IHNpZGViYXIgPSB3aW5kb3cudG9wLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2lkZWJhciAuY3VycmVudC1saXN0XCIpO1xuICAgIGlmIChzaWRlYmFyLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBbLi4uc2lkZWJhcl0ucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhpZGVJbnB1dCA9IChpbnB1dFZhbHVlKSA9PiB7XG4gICAgZ2V0U2lkZWJhcigpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2lkZWJhci1pdGVtc1wiKVxuICAgIC5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0LnF1ZXJ5U2VsZWN0b3IoXCIuZmllbGQtdmFyaWFibGUtdGFnXCIpLmlubmVyVGV4dCA9PT0gaW5wdXRWYWx1ZSkge1xuICAgICAgICBpbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBzZXR1cE1UTyA9ICh0ZWFtTWV0YWRhdGEsIHRlYW1zQWxsb3dlZCA9ICcnLCBpbnB1dE5hbWUgPSAnVGVhbSBtZXRhZGF0YScpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gY29uc3Qgc2lkZWJhciA9IGdldFNpZGViYXIoKTtcbiAgICAgICAgLy8gc3RhdGUgaXNuJ3QgZ2xvYmFsIGluIHYyIHNvIHRoaXMgbGluZSBpcyBuZWVkZWQgZm9yIHRoYXQgdmVyc2lvbiBidXQgc2hvdWxkbid0IGJlIGluY2x1ZGVkIGluIHYzXG4gICAgICAgIC8vIGNvbnN0IHN0YXRlID0gZG9jdW1lbnQuYm9keS5nZXRBdHRyaWJ1dGUoXCJkb2N1bWVudC1zdGF0ZVwiKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIHJlamVjdCgncGxlYXNlIHNldCB0aGUgc3RhdGUgYXR0cmlidXRlJylcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBhcmUgb24gYW55IG90aGVyIHBhZ2UgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIHRvIHRoZSBzaWRlYmFyIGFuZCB3ZSBjYW4gc2tpcCBldmVyeXRoaW5nXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgICAgbGV0IG10b05vdFN1cHBvcnRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRTaWRlYmFyKCkuZmlyc3RDaGlsZC5maXJzdENoaWxkLmxhc3RDaGlsZC5pbm5lclRleHQgPT0gaW5wdXROYW1lKSB7XG4gICAgICAgICAgICAgICAgZ2V0U2lkZWJhcigpLnF1ZXJ5U2VsZWN0b3IoJy5jaG9pY2UtdmFyaWFibGUnKS5pbm5lckhUTUwgPSBgPHA+JHtpbnB1dE5hbWV9IGZ1bmN0aW9uYWxpdHkgaXMgbm90IGF2YWlsYWJsZSBvbiBhIHRlbXBsYXRlIGxldmVsLjwvcD5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiBtdG9Ob3RTdXBwb3J0ZWQoKSwgNTAwKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIC8vIHR1cm4gdGVhbXNBbGxvd2VkIGZyb20gc3RyaW5nIGludG8gYXJyYXlcbiAgICAgICAgICB0ZWFtc0FsbG93ZWQgPSB0ZWFtc0FsbG93ZWQudG9Mb3dlckNhc2UoKS5zcGxpdChcIl9cIikuam9pbihcIiBcIikuc3BsaXQoJywnKS5maWx0ZXIobiA9PiBuKVxuICAgICAgICAgICAgbGV0IGhpZGVUZWFtc1RoYXRBcmVOb3RBbGxvd2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGVhbXNBbGxvd2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgb25seSBhbGxvd2luZyB0aGUgdXNlciB0byBzZWxlY3Qgc29tZSBvZiB0aGUgdGVhbXMgdGhlbiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBvbmVzIHRoYXQgdGhlIHVzZXIgaGFzbid0IGdvdCBhY2Nlc3MgdG8uIFxuICAgICAgICAgICAgICAgIGlmIChnZXRTaWRlYmFyKCkuZmlyc3RDaGlsZC5maXJzdENoaWxkLmxhc3RDaGlsZC5pbm5lclRleHQgPT0gaW5wdXROYW1lKSB7XG4gICAgICAgICAgICAgICAgICBnZXRTaWRlYmFyKCkucXVlcnlTZWxlY3RvckFsbCgnLnNlYXJjaC1iYXItd3JhcHBlcicpLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpXG4gICAgICAgICAgICAgICAgICBnZXRTaWRlYmFyKCkucXVlcnlTZWxlY3RvckFsbCgnLmFjdGlvbi1idXR0b25zJykuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSlcbiAgICAgICAgICAgICAgICAgIGdldFNpZGViYXIoKS5xdWVyeVNlbGVjdG9yQWxsKCcuY2hvaWNlLXZhcmlhYmxlIC5tdWx0aWNob2ljZS1lZGl0LXJvdycpLmZvckVhY2goKGlucHV0T3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGVhbXNBbGxvd2VkLmluY2x1ZGVzKGlucHV0T3B0aW9uLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dE9wdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGlucHV0T3B0aW9uLnF1ZXJ5U2VsZWN0b3IoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA0IGRpZ2l0IG51bWJlciBmcm9tIHN0YXJ0IG9mIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uaW5uZXJUZXh0Lm1hdGNoKC9eWzAtOV17NH0vZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uaW5uZXJUZXh0ID0gc3Bhbi5pbm5lclRleHQuc3Vic3RyaW5nKDcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2UgYXJlIG5vdCBvbiB0aGUgTVRPIHNpZGViYXIgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldFNpZGViYXIoKS5xdWVyeVNlbGVjdG9yKCcuY2hvaWNlLXZhcmlhYmxlJykuaW5uZXJIVE1MID0gYDxwPiR7aW5wdXROYW1lfSBpcyBub3QgYXZhaWxhYmxlIGZvciB5b3VyIHRlYW0uIFBsZWFzZSBjbGljayBiYWNrIHRvIGNvbnRpbnVlIGVkaXRpbmcgeW91ciBkb2N1bWVudC48L3A+YDtcbiAgICAgICAgICAgICAgICBoaWRlSW5wdXQoaW5wdXROYW1lKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiBoaWRlVGVhbXNUaGF0QXJlTm90QWxsb3dlZCgpLCA1MDApXG4gICAgICAgICAgICBoaWRlVGVhbXNUaGF0QXJlTm90QWxsb3dlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IFwidGVtcGxhdGVcIikge1xuICAgICAgICAgICAgZ2V0U2lkZWJhcigpLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaG9pY2UtdmFyaWFibGUnKS5pbm5lckhUTUwgPSBgPHA+JHtpbnB1dE5hbWV9IGlzIG9ubHkgYXZhaWxhYmxlIG9uIHRoZSBlZGl0IHBhZ2UuPC9wPmA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChbJ2RvY3VtZW50JywgJ2V4cG9ydCcsICdwcmV2aWV3J10uaW5jbHVkZXMoc3RhdGUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oYW5kbGVNVE9EYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5oYW5kbGVNVE9EYXRhKHRlYW1NZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHRlYW1NZXRhZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkFuIE1UTyBlcnJvciBoYXMgb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuIElmIHRoZSBpc3N1ZSBzdGlsbCBwZXJzaXN0cyBwbGVhc2UgY29udGFjdCBPdXRmaXQgU3VwcG9ydFwiKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cblxuZXhwb3J0IHsgc2V0dXBNVE8sIGdldFNpZGViYXIgfTtcbiIsImNvbnN0IGltYWdlQ29tcHJlc3Npb24gPSAoKSA9PiB7XG4gIHZhciBpbWFnZUNvbXByZXNzRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtY3VzdG9tLWNvbXByZXNzaW9uXVwiKTtcbiAgdmFyIGVkaXRvclN0cmluZyA9IFwiP3F1YWw9ZWRpdG9yXCI7XG5cbiAgZnVuY3Rpb24gY2hlY2tVUkwoZWRpdG9yU3RyaW5nLCB1cmwpIHtcbiAgICBpZiAodXJsLmluY2x1ZGVzKGVkaXRvclN0cmluZykgfHwgdXJsLmluY2x1ZGVzKFwiLnN2Z1wiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaW1hZ2VDb21wcmVzc0VsLmZvckVhY2goKGVsKSA9PiB7XG4gICAgLy9Ob24gUmVwbyBJbWFnZXMgd2l0aCBkYXRhLWN1c3RvbS1jb21wcmVzc2lvbiBvbiBpbWcgZWxlbWVudCBpdHNlbGZcbiAgICB2YXIgaW1nU3JjID0gZWwuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICAgIGNvbnNvbGUubG9nKGltZ1NyYyk7XG4gICAgaWYgKGltZ1NyYykge1xuICAgICAgLy9zcmMgYXR0cmlidXRlIGV4aXN0cyBhc3N1bWUgdGhhdCB0aGlzIGlzIGFuIDxpbWc+IGVsZW1lbnRcbiAgICAgIGlmICghY2hlY2tVUkwoZWRpdG9yU3RyaW5nLCBpbWdTcmMpKSByZXR1cm47XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgaW1nU3JjICsgZWRpdG9yU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGltZ0VsID0gZWwucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICAgIGlmICghaW1nRWwpIHJldHVybjtcbiAgICAgIHZhciBpbWdVUkwgPSBpbWdFbC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICBpZiAoIWNoZWNrVVJMKGVkaXRvclN0cmluZywgaW1nVVJMKSkgcmV0dXJuO1xuICAgICAgaW1nRWwuc2V0QXR0cmlidXRlKFwic3JjXCIsIGltZ1VSTCArIGVkaXRvclN0cmluZyk7XG5cbiAgICAgIHZhciBia2dJbWdFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoXCIub3V0Zml0LXJlc2l6YWJsZS1iYWNrZ3JvdW5kXCIpO1xuICAgICAgaWYgKCFia2dJbWdFbCkgcmV0dXJuO1xuICAgICAgdmFyIGJrZ1VybCA9IGJrZ0ltZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZVxuICAgICAgICAuc2xpY2UoNCwgLTEpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIlwiKTtcbiAgICAgIGlmICghY2hlY2tVUkwoZWRpdG9yU3RyaW5nLCBia2dVcmwpKSByZXR1cm47XG4gICAgICBia2dJbWdFbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKFwiJHtia2dVcmx9JHtlZGl0b3JTdHJpbmd9XCIpYDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBodHRwczovL2Jsb2cuY3JpbXguY29tLzIwMTcvMDMvMDkvZ2V0LWFsbC1pbWFnZXMtaW4tZG9tLWluY2x1ZGluZy1iYWNrZ3JvdW5kLWVuL1xuLy8gdGltZSBvdXQgaXMgc2V0IHRvIDYwIHNlY29uZHMgYXMgdGhhdCBpcyBhcyBsb25nIGFzIHRoZSBwbGF0Zm9ybSB0aW1lb3V0XG5jb25zdCBlbnN1cmVBbGxJbWFnZXNMb2FkZWQgPSAoZG9jID0gZG9jdW1lbnQsIHRpbWVvdXQgPSA2ZTQpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsb2FkQWxsSW1hZ2VzKEFycmF5LmZyb20oc2VhcmNoRE9NKGRvYykpLCB0aW1lb3V0KVxuICAgICAgLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuICB9KVxufVxuXG5jb25zdCBzZWFyY2hET00gPSAoZG9jKSA9PiB7XG4gIGNvbnN0IHNyY0NoZWNrZXIgPSAvdXJsXFwoXFxzKj9bJ1wiXT9cXHMqPyhcXFMrPylcXHMqP1tcIiddP1xccyo/XFwpL2lcbiAgcmV0dXJuIEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcbiAgICAucmVkdWNlKChjb2xsZWN0aW9uLCBub2RlKSA9PiB7XG4gICAgICAvLyBiZyBzcmNcbiAgICAgIGxldCBwcm9wID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbClcbiAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtaW1hZ2UnKVxuICAgICAgLy8gbWF0Y2ggYHVybCguLi4pYFxuICAgICAgbGV0IG1hdGNoID0gc3JjQ2hlY2tlci5leGVjKHByb3ApXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29sbGVjdGlvbi5hZGQobWF0Y2hbMV0pXG4gICAgICB9XG4gICAgICBpZiAoL15pbWckL2kudGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgICAgIC8vIHNyYyBmcm9tIGltZyB0YWdcbiAgICAgICAgY29sbGVjdGlvbi5hZGQobm9kZS5zcmMpXG4gICAgICB9IGVsc2UgaWYgKC9eZnJhbWUkL2kudGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgICAgIC8vIGlmcmFtZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlYXJjaERPTShub2RlLmNvbnRlbnREb2N1bWVudCB8fCBub2RlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpXG4gICAgICAgICAgICAuZm9yRWFjaChpbWcgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW1nKSB7IGNvbGxlY3Rpb24uYWRkKGltZykgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uXG4gICAgfSwgbmV3IFNldCgpKVxufVxuXG5jb25zdCBsb2FkSW1hZ2UgPSAoc3JjLCB0aW1lb3V0ID0gNTAwMCkgPT4ge1xuICB2YXIgaW1nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgaW1nID0gbmV3IEltYWdlKClcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICB3aWR0aDogaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbWcubmF0dXJhbEhlaWdodFxuICAgICAgfSlcbiAgICB9XG4gICAgaW1nLm9uZXJyb3IgPSByZWplY3RcbiAgICBpbWcuc3JjID0gc3JjXG4gIH0pXG4gIHZhciB0aW1lciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlamVjdCwgdGltZW91dClcbiAgfSlcbiAgcmV0dXJuIFByb21pc2UucmFjZShbaW1nUHJvbWlzZSwgdGltZXJdKVxufVxuXG5jb25zdCBsb2FkQWxsSW1hZ2VzID0gKGltZ0xpc3QsIHRpbWVvdXQgPSA1MDAwKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICBpbWdMaXN0XG4gICAgICAgIC5tYXAoc3JjID0+IGxvYWRJbWFnZShzcmMsIHRpbWVvdXQpKVxuICAgICAgICAubWFwKHAgPT4gcC5jYXRjaChlID0+IGZhbHNlKSlcbiAgICApLnRoZW4ocmVzdWx0cyA9PiByZXNvbHZlKHJlc3VsdHMuZmlsdGVyKHIgPT4gcikpKVxuICB9KVxufVxuXG5leHBvcnQgeyBpbWFnZUNvbXByZXNzaW9uLCBlbnN1cmVBbGxJbWFnZXNMb2FkZWQgfTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJWaXNpYmlsaXR5LCBwbGFjZWhvbGRlckltYWdlcykge1xuICAgIC8vIElmIGFycmF5IGxlbmd0aCA8IDEgb3IgdGhlIGZpcnN0IGl0ZW0gaXMgXCJcIiBvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgIGlmIChcbiAgICAgIHBsYWNlaG9sZGVySW1hZ2VzLmxlbmd0aCA8IDEgfHxcbiAgICAgIHBsYWNlaG9sZGVySW1hZ2VzWzBdID09IFwiXCIgfHxcbiAgICAgIHBsYWNlaG9sZGVySW1hZ2VzWzBdID09IG51bGwgfHxcbiAgICAgIHBsYWNlaG9sZGVySW1hZ2VzWzBdID09IHVuZGVmaW5lZCB8fFxuICAgICAgcGxhY2Vob2xkZXJWaXNpYmlsaXR5ID09IFwiaGlkZVwiXG4gICAgKVxuICAgICAgcmV0dXJuO1xuICBcbiAgICB2YXIgcGFnZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnBhZ2UgLmNvbnRhaW5lclwiKTtcbiAgICBwYWdlcy5mb3JFYWNoKChwYWdlLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IHBsYWNlaG9sZGVySW1hZ2UgPSBwbGFjZWhvbGRlckltYWdlc1tpbmRleF07XG4gICAgICBpZiAoXG4gICAgICAgIHBsYWNlaG9sZGVySW1hZ2UgPT0gXCJcIiB8fFxuICAgICAgICBwbGFjZWhvbGRlckltYWdlID09IG51bGwgfHxcbiAgICAgICAgcGxhY2Vob2xkZXJJbWFnZSA9PSB1bmRlZmluZWRcbiAgICAgIClcbiAgICAgICAgcGxhY2Vob2xkZXJJbWFnZSA9IHBsYWNlaG9sZGVySW1hZ2VzWzBdO1xuICBcbiAgICAgIGxldCBwbGFjZWhvbGRlclN0cnVjdHVyZSA9IGA8ZGl2IGNsYXNzPVwicGxhY2Vob2xkZXJJbWFnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTogdXJsKCcke3BsYWNlaG9sZGVySW1hZ2V9JylcIj48L2Rpdj5gO1xuICAgICAgcGFnZS5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmJlZ2luXCIsIHBsYWNlaG9sZGVyU3RydWN0dXJlKTtcbiAgICB9KTtcbiAgfSIsIi8vIHJlbmRlciBoYXMgYW4gaXNzdWUgd2l0aCByZXBsYWNlQWxsIGNhdXNpbmcgZXJyb3JzIHRvIGJlIHRocm93biB3aGljaCBzdG9wcyB0aGUgcmVuZGVyLiBUaGlzIGlzIGEgcG9sbHlmaWwgZm9yIGFsbCByZW5kZXJzXHJcblN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzdHIsIG5ld1N0cikge1xyXG4gIC8vIElmIGEgcmVnZXggcGF0dGVyblxyXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKS50b0xvd2VyQ2FzZSgpID09PSBcIltvYmplY3QgcmVnZXhwXVwiKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHN0ciwgbmV3U3RyKTtcclxuICB9XHJcbiAgLy8gSWYgYSBzdHJpbmdcclxuICByZXR1cm4gdGhpcy5zcGxpdChzdHIpLmpvaW4obmV3U3RyKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNSZXBsYWNlKHNlbGVjdG9yID0gbnVsbCwgZGF0YSA9IG51bGwpIHtcclxuICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiBkYXRhICE9IG51bGwpIFxyXG4gIHsgXHJcbiAgICBkeW5hbWljUmVwbGFjZU11bHRpKHNlbGVjdG9yLCBkYXRhKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZHluYW1pY1JlcGxhY2VTaW5nbGUoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNSZXBsYWNlTXVsdGkodGFyZ2V0LCBkYXRhKSB7XHJcbiAgY29uc3QgdGFyZ2V0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KTtcclxuICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICBjb25zdCBpbnB1dFZhbHVlID0gaXRlbVswXTtcclxuICAgICAgY29uc3QgbG9va3VwID0gaXRlbVsxXTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0YXJnZXQuaW5uZXJUZXh0LmluY2x1ZGVzKGxvb2t1cCkgIT0gLTEgJiZcclxuICAgICAgICAoaW5wdXRWYWx1ZSAhPSBcIlwiIHx8IGlucHV0VmFsdWUubGVuZ3RoICE9IDApXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRhcmdldC5pbm5lckhUTUwgPSB0YXJnZXQuaW5uZXJIVE1MLnJlcGxhY2VBbGwobG9va3VwLCBpbnB1dFZhbHVlKTsgLy9JZiBmb3VuZCByZXBsYWNlXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGxvb2t1cFNwYW4gPSBgPHNwYW4gY2xhc3M9J2xvb2t1cC12YWx1ZSc+JHtsb29rdXB9PC9zcGFuPmA7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGFyZ2V0LmlubmVySFRNTCk7XHJcbiAgICAgICAgbGV0IHRlbXAgPSB0YXJnZXQuaW5uZXJIVE1MLnNwbGl0KGxvb2t1cFNwYW4pO1xyXG4gICAgICAgIHRlbXAgPSB0ZW1wLm1hcCgoeCkgPT4geC5yZXBsYWNlQWxsKGxvb2t1cCwgbG9va3VwU3BhbikpO1xyXG4gICAgICAgIHRhcmdldC5pbm5lckhUTUwgPSB0ZW1wLmpvaW4obG9va3VwU3Bhbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljUmVwbGFjZVNpbmdsZSgpIHtcclxuICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yZXBsYWNlLWZyb21dXCIpO1xyXG4gIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgIGNvbnN0IHRleHQgPSBlbC5pbm5lclRleHQ7XHJcbiAgICBjb25zdCBodG1sID0gZWwuaW5uZXJIVE1MO1xyXG4gICAgY29uc3QgbG9va3VwID0gZWwuZGF0YXNldC5yZXBsYWNlRnJvbTtcclxuICAgIGNvbnN0IHJlcGxhY2UgPSBlbC5kYXRhc2V0LnJlcGxhY2VUbztcclxuXHJcbiAgICBpZiAodGV4dC5zZWFyY2gobG9va3VwKSAhPSAtMSAmJiAocmVwbGFjZSAhPSBcIlwiIHx8IHJlcGxhY2UubGVuZ3RoICE9IDApKSB7XHJcbiAgICAgIGVsLmlubmVySFRNTCA9IGh0bWwucmVwbGFjZUFsbChsb29rdXAsIHJlcGxhY2UpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgeyBkeW5hbWljUmVwbGFjZSwgZHluYW1pY1JlcGxhY2VTaW5nbGUsIGR5bmFtaWNSZXBsYWNlTXVsdGkgfSIsImltcG9ydCB7IGdldFdpZHRoLCBnZXRIZWlnaHQsIGNvdW50TGluZXMgfSBmcm9tICcuL2xpbWl0ZXJzLmpzJ1xuLyoqXG4gKiB0ZXh0Rml0IHYzLjEuMFxuICogUHJldmlvdXNseSBrbm93biBhcyBqUXVlcnkudGV4dEZpdFxuICogMTEvMjAxNCBieSBTVFJNTCAoc3RybWwuZ2l0aHViLmNvbSlcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogVG8gdXNlOiB0ZXh0Rml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YXJnZXQtZGl2JyksIG9wdGlvbnMpO1xuICpcbiAqIFdpbGwgbWFrZSB0aGUgKnRleHQqIGNvbnRlbnQgaW5zaWRlIGEgY29udGFpbmVyIHNjYWxlIHRvIGZpdCB0aGUgY29udGFpbmVyXG4gKiBUaGUgY29udGFpbmVyIGlzIHJlcXVpcmVkIHRvIGhhdmUgYSBzZXQgd2lkdGggYW5kIGhlaWdodFxuICogVXNlcyBiaW5hcnkgc2VhcmNoIHRvIGZpdCB0ZXh0IHdpdGggbWluaW1hbCBsYXlvdXQgY2FsbHMuXG4gKiBWZXJzaW9uIDIuMCBkb2VzIG5vdCB1c2UgalF1ZXJ5LlxuICovXG4vKiBnbG9iYWwgZGVmaW5lOnRydWUsIGRvY3VtZW50OnRydWUsIHdpbmRvdzp0cnVlLCBIVE1MRWxlbWVudDp0cnVlKi9cblxuLy8gKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4vLyAgIFwidXNlIHN0cmljdFwiO1xuXG4vLyAgIC8vIFVNRCBzaGltXG4vLyAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuLy8gICAgIC8vIEFNRFxuLy8gICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4vLyAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbi8vICAgICAvLyBOb2RlL0NvbW1vbkpTXG4vLyAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgLy8gQnJvd3NlclxuLy8gICAgIHJvb3QudGV4dEZpdCA9IGZhY3RvcnkoKTtcbi8vICAgfVxuLy8gfSkodHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHRoaXMsIGZ1bmN0aW9uICgpIHtcbi8vICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGRlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICBhbGlnblZlcnQ6IGZhbHNlLCAvLyBpZiB0cnVlLCB0ZXh0Rml0IHdpbGwgYWxpZ24gdmVydGljYWxseSB1c2luZyBjc3MgdGFibGVzXG4gICAgYWxpZ25Ib3JpejogZmFsc2UsIC8vIGlmIHRydWUsIHRleHRGaXQgd2lsbCBzZXQgdGV4dC1hbGlnbjogY2VudGVyXG4gICAgbXVsdGlMaW5lOiBmYWxzZSwgLy8gaWYgdHJ1ZSwgdGV4dEZpdCB3aWxsIG5vdCBzZXQgd2hpdGUtc3BhY2U6IG5vLXdyYXBcbiAgICBzdG9wT3ZlcmZsb3c6IGZhbHNlLCAvLyBpZiB0cnVlLCBhIGVycm9yIHdlIGJlIHRocm93biBpZiB0aGUgY29udGVudCBpcyBvdmVyZmxvd2luZ1xuICAgIGZvbnRVbml0OiBcInJlbVwiLCAvLyB3aGF0IHVuaXQgc2hvdWxkIHRoZSBmaW5hbCBmb250IGJlLiB1c2luZyByZW1zIG9yIG1tIGlzIHNvbWV0aW1lcyB1c2VmdWxcbiAgICBmb250Q2hhbmdlU2l6ZTogMC4xLCAvLyBob3cgbXVjaCBzaG91bGQgdGhlIGZvbnQgc2l6ZSBieSBhanVzdGVkIGJ5IGVhY2ggdGltZS4gMC4xIGFuZCAwLjAxIGlzIHVzZWZ1bCBmb3Igd2hlbiB1c2luZyBhIHJlbSBmb250IHVuaXRcbiAgICBtaW5Gb250U2l6ZTogMC4zLFxuICAgIG1heEZvbnRTaXplOiAxLFxuICAgIG1heExpbmU6IGZhbHNlLFxuICAgIHJlUHJvY2VzczogdHJ1ZSwgLy8gaWYgdHJ1ZSwgdGV4dEZpdCB3aWxsIHJlLXByb2Nlc3MgYWxyZWFkeS1maXQgbm9kZXMuIFNldCB0byAnZmFsc2UnIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICB3aWR0aE9ubHk6IGZhbHNlLCAvLyBpZiB0cnVlLCB0ZXh0Rml0IHdpbGwgZml0IHRleHQgdG8gZWxlbWVudCB3aWR0aCwgcmVnYXJkbGVzcyBvZiB0ZXh0IGhlaWdodFxuICAgIGFsaWduVmVydFdpdGhGbGV4Ym94OiBmYWxzZSwgLy8gaWYgdHJ1ZSwgdGV4dEZpdCB3aWxsIHVzZSBmbGV4Ym94IGZvciB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLCAvLyBpbiBjYXNlIHlvdSBuZWVkIHRvIGNoYW5nZSB0aGlzXG4gIH07XG5cbiAgZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGV4dEZpdChlbHMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIC8vIEV4dGVuZCBvcHRpb25zLlxuICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0U2V0dGluZ3MpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgc2V0dGluZ3Nba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzW2tleV0gPSBkZWZhdWx0U2V0dGluZ3Nba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGpRdWVyeSBvYmplY3RzIGludG8gYXJyYXlzXG4gICAgaWYgKHR5cGVvZiBlbHMudG9BcnJheSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBlbHMgPSBlbHMudG9BcnJheSgpO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgcGFzc2luZyBhIHNpbmdsZSBlbFxuICAgIHZhciBlbFR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxzKTtcbiAgICBpZiAoXG4gICAgICBlbFR5cGUgIT09IFwiW29iamVjdCBBcnJheV1cIiAmJlxuICAgICAgZWxUeXBlICE9PSBcIltvYmplY3QgTm9kZUxpc3RdXCIgJiZcbiAgICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXVwiXG4gICAgKSB7XG4gICAgICBlbHMgPSBbZWxzXTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGVhY2ggZWwgd2UndmUgcGFzc2VkLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm9jZXNzSXRlbShlbHNbaV0sIHNldHRpbmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBtZWF0LiBHaXZlbiBhbiBlbCwgbWFrZSB0aGUgdGV4dCBpbnNpZGUgaXQgZml0IGl0cyBwYXJlbnQuXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGVsICAgICAgIENoaWxkIGVsLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzICAgICBPcHRpb25zIGZvciBmaXQuXG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzSXRlbShlbCwgc2V0dGluZ3MpIHtcbiAgICBpZiAoIWlzRWxlbWVudChlbCkgfHwgKCFzZXR0aW5ncy5yZVByb2Nlc3MgJiYgZWwuZ2V0QXR0cmlidXRlKFwidGV4dEZpdHRlZFwiKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGV4dEZpdHRlZCBhdHRyaWJ1dGUgc28gd2Uga25vdyB0aGlzIHdhcyBwcm9jZXNzZWQuXG4gICAgaWYgKCFzZXR0aW5ncy5yZVByb2Nlc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInRleHRGaXR0ZWRcIiwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGlubmVyU3Bhbiwgb3JpZ2luYWxIZWlnaHQsIG9yaWdpbmFsSFRNTCwgb3JpZ2luYWxXaWR0aDtcbiAgICB2YXIgbG93LCBtaWQsIGhpZ2g7XG5cbiAgICAvLyBHZXQgZWxlbWVudCBkYXRhLlxuICAgIG9yaWdpbmFsSFRNTCA9IGVsLmlubmVySFRNTDtcbiAgICBvcmlnaW5hbFdpZHRoID0gZ2V0V2lkdGgoZWwpO1xuICAgIG9yaWdpbmFsSGVpZ2h0ID0gZ2V0SGVpZ2h0KGVsKTtcblxuICAgIC8vIERvbid0IHByb2Nlc3MgaWYgd2UgY2FuJ3QgZmluZCBib3ggZGltZW5zaW9uc1xuICAgIGlmICghb3JpZ2luYWxXaWR0aCB8fCAoIXNldHRpbmdzLndpZHRoT25seSAmJiAhb3JpZ2luYWxIZWlnaHQpKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLndpZHRoT25seSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiU2V0IGEgaGVpZ2h0IGFuZCB3aWR0aCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQgXCIgK1xuICAgICAgICAgICAgZWwub3V0ZXJIVE1MICtcbiAgICAgICAgICAgIFwiIGJlZm9yZSB1c2luZyB0ZXh0Rml0IVwiXG4gICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlNldCBhIHdpZHRoIG9uIHRoZSB0YXJnZXQgZWxlbWVudCBcIiArXG4gICAgICAgICAgICBlbC5vdXRlckhUTUwgK1xuICAgICAgICAgICAgXCIgYmVmb3JlIHVzaW5nIHRleHRGaXQhXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHRleHRGaXR0ZWRTcGFuID0gZWwucXVlcnlTZWxlY3RvcihcInNwYW4udGV4dEZpdHRlZFwiKVxuICAgIC8vIEFkZCB0ZXh0Rml0dGVkIHNwYW4gaW5zaWRlIHRoaXMgY29udGFpbmVyLlxuICAgIGlmICghdGV4dEZpdHRlZFNwYW4pIHtcbiAgICAgIGlubmVyU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgaW5uZXJTcGFuLmNsYXNzTmFtZSA9IFwidGV4dEZpdHRlZFwiO1xuICAgICAgLy8gSW5saW5lIGJsb2NrIGVuc3VyZSBpdCB0YWtlcyBvbiB0aGUgc2l6ZSBvZiBpdHMgY29udGVudHMsIGV2ZW4gaWYgdGhleSBhcmUgZW5jbG9zZWRcbiAgICAgIC8vIGluIG90aGVyIHRhZ3MgbGlrZSA8cD5cbiAgICAgIGlubmVyU3Bhbi5zdHlsZVtcImRpc3BsYXlcIl0gPSBzZXR0aW5ncy5kaXNwbGF5O1xuICAgICAgaW5uZXJTcGFuLmlubmVySFRNTCA9IG9yaWdpbmFsSFRNTDtcbiAgICAgIGVsLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBlbC5hcHBlbmRDaGlsZChpbm5lclNwYW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXByb2Nlc3NpbmcuXG4gICAgICBpbm5lclNwYW4gPSB0ZXh0Rml0dGVkU3BhbjtcbiAgICAgIC8vIFJlbW92ZSB2ZXJ0aWNhbCBhbGlnbiBpZiB3ZSdyZSByZXByb2Nlc3NpbmcuXG4gICAgICBpZiAoaW5uZXJTcGFuLmNsYXNzTGlzdC5jb250YWlucyhcInRleHRGaXRBbGlnblZlcnRcIikpIHtcbiAgICAgICAgaW5uZXJTcGFuLmNsYXNzTmFtZSA9IGlubmVyU3Bhbi5jbGFzc05hbWUucmVwbGFjZShcbiAgICAgICAgICBcInRleHRGaXRBbGlnblZlcnRcIixcbiAgICAgICAgICBcIlwiXG4gICAgICAgICk7XG4gICAgICAgIGlubmVyU3Bhbi5zdHlsZVtcImhlaWdodFwiXSA9IFwiXCI7XG4gICAgICAgIGVsLmNsYXNzTmFtZS5yZXBsYWNlKFwidGV4dEZpdEFsaWduVmVydEZsZXhcIiwgXCJcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSAmIHNldCBhbGlnbm1lbnRcbiAgICBpZiAoc2V0dGluZ3MuYWxpZ25Ib3Jpeikge1xuICAgICAgZWwuc3R5bGVbXCJ0ZXh0LWFsaWduXCJdID0gXCJjZW50ZXJcIjtcbiAgICAgIGlubmVyU3Bhbi5zdHlsZVtcInRleHQtYWxpZ25cIl0gPSBcImNlbnRlclwiO1xuICAgIH1cblxuICAgIHZhciBtYXhMaW5lID0gcGFyc2VJbnQoZWwuZGF0YXNldC5tYXhMaW5lIHx8IHNldHRpbmdzLm1heExpbmUpO1xuICAgIGNvbnNvbGUubG9nKG1heExpbmUsICdtYXhsaW5lJylcbiAgICB2YXIgc3RhcnRpbmdTaXplID0gaW5uZXJTcGFuLnN0eWxlLmZvbnRTaXplO1xuXG4gICAgbG93ID0gc2V0dGluZ3MubWluRm9udFNpemU7XG4gICAgaGlnaCA9IHNldHRpbmdzLm1heEZvbnRTaXplO1xuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGhpZ2hlc3QgYmVzdCBmaXRcbiAgICB2YXIgc2l6ZSA9IGxvdztcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIG1pZCA9IHBhcnNlRmxvYXQoKChoaWdoICsgbG93KSAvIDIpLnRvRml4ZWQoMikpO1xuICAgICAgaW5uZXJTcGFuLnN0eWxlLmZvbnRTaXplID0gbWlkICsgc2V0dGluZ3MuZm9udFVuaXQ7XG5cbiAgICAgIHZhciBzY3JvbGxXaWR0aCA9IGdldFdpZHRoKGlubmVyU3BhbikgPD0gb3JpZ2luYWxXaWR0aDtcbiAgICAgIHZhciBzY3JvbGxIZWlnaHQgPVxuICAgICAgICBzZXR0aW5ncy53aWR0aE9ubHkgfHwgZ2V0SGVpZ2h0KGlubmVyU3BhbikgPD0gb3JpZ2luYWxIZWlnaHQ7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRvbyBtYW55IGxpbmVzIGFuZCBpZiBpdCBpcyB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBmb250IHNpemUgYWNjb3JkaW5nbHlcbiAgICAgIHZhciBtYXhMaW5lcyA9IGZhbHNlO1xuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWF4TGluZSkpIHtcbiAgICAgICAgdmFyIGxpbmVDb3VudCA9IGNvdW50TGluZXMoaW5uZXJTcGFuKTtcbiAgICAgICAgbWF4TGluZXMgPSBsaW5lQ291bnQgPiBtYXhMaW5lO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Nyb2xsV2lkdGggJiYgc2Nyb2xsSGVpZ2h0ICYmICFtYXhMaW5lcykge1xuICAgICAgICBzaXplID0gbWlkO1xuICAgICAgICBsb3cgPSBtaWQgKyBzZXR0aW5ncy5mb250Q2hhbmdlU2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZ2ggPSBtaWQgLSBzZXR0aW5ncy5mb250Q2hhbmdlU2l6ZTtcbiAgICAgIH1cbiAgICAgIC8vIGF3YWl0IGluamVjdGlvbiBwb2ludFxuICAgIH1cbiAgICBpZiAoc3RhcnRpbmdTaXplICE9PSBzaXplICsgc2V0dGluZ3MuZm9udFVuaXQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidGV4dEZpdCBmb250IGNoYW5nZWQgdG86XCIsIHNpemUgKyBzZXR0aW5ncy5mb250VW5pdCk7XG4gICAgfVxuICAgIC8vIHVwZGF0aW5nIGZvbnQgaWYgZGlmZmVyczpcbiAgICBpZiAoaW5uZXJTcGFuLnN0eWxlLmZvbnRTaXplICE9IHNpemUgKyBzZXR0aW5ncy5mb250VW5pdClcbiAgICAgIGlubmVyU3Bhbi5zdHlsZS5mb250U2l6ZSA9IHNpemUgKyBzZXR0aW5ncy5mb250VW5pdDtcblxuICAgIC8vIGFkZCB0aGUgcmVxdWlyZWQgQ1NTIGluIG9yZGVyIHRvIHN0b3Agb3ZlcmZsb3dzXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIobWF4TGluZSkgfHwgc2V0dGluZ3Muc3RvcE92ZXJmbG93KSB7XG4gICAgICAvLyBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3ZlcmZsb3dTdHlsZVNoZWV0XCIpKSB7XG4gICAgICAvLyAgIHZhciBzdHlsZSA9IFtcIi5vdmVyZmxvdyA+IHNwYW4ge1wiLCBcIm92ZXJmbG93OiBoaWRkZW47XCIsIFwifVwiXS5qb2luKFwiXCIpO1xuICAgICAgLy8gICB2YXIgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgLy8gICBjc3MudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICAgIC8vICAgY3NzLmlkID0gXCJvdmVyZmxvd1N0eWxlU2hlZXRcIjtcbiAgICAgIC8vICAgY3NzLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgLy8gICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNzcyk7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGRldGVjdCBpZiBkYXRhIG1heCBsaW5lcyBoYXMgYmVlbiBleGNlZWRlZFxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWF4TGluZSkpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcIm92ZXJmbG93XCIpO1xuICAgICAgICBkZWxldGUgZWwuZGF0YXNldC5jdXN0b21PdmVyZmxvd01lc3NhZ2U7XG4gICAgICAgIHZhciBsaW5lQ291bnQgPSBjb3VudExpbmVzKGlubmVyU3Bhbik7XG4gICAgICAgIGVsLmRhdGFzZXQubGluZUNvdW50ID0gbGluZUNvdW50O1xuICAgICAgICBpZiAobGluZUNvdW50ID4gbWF4TGluZSkge1xuICAgICAgICAgIC8vIGVsLmRhdGFzZXQuY3VzdG9tT3ZlcmZsb3dNZXNzYWdlID0gXCJUb28gbXVjaCBjb250ZW50IGhhcyBiZWVuIGFkZGVkIGZvciB0aGUgYWxsb3dlZCBzcGFjZVwiO1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZGV0ZWN0IGlmIHRoZSBjb250ZW50IGlzIGxhcmdlciB0aGFuIGl0J3MgcGFyZW50XG4gICAgICBpZiAoc2V0dGluZ3Muc3RvcE92ZXJmbG93KSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGdldEhlaWdodChlbCkgPCBnZXRIZWlnaHQoaW5uZXJTcGFuKTtcbiAgICAgICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE91ciBoZWlnaHQgaXMgZmluYWxpemVkLiBJZiB3ZSBhcmUgYWxpZ25pbmcgdmVydGljYWxseSwgc2V0IHRoYXQgdXAuXG4gICAgaWYgKHNldHRpbmdzLmFsaWduVmVydCkge1xuICAgICAgLy8gYWRkU3R5bGVTaGVldCgpO1xuICAgICAgdmFyIGhlaWdodCA9IGdldEhlaWdodChpbm5lclNwYW4pO1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKVtcInBvc2l0aW9uXCJdID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgIGVsLnN0eWxlW1wicG9zaXRpb25cIl0gPSBcInJlbGF0aXZlXCI7XG4gICAgICB9XG4gICAgICBpZiAoIWlubmVyU3Bhbi5jbGFzc0xpc3QuY29udGFpbnMoXCJ0ZXh0Rml0QWxpZ25WZXJ0XCIpKSB7XG4gICAgICAgIGlubmVyU3Bhbi5jbGFzc05hbWUgPSBpbm5lclNwYW4uY2xhc3NOYW1lICsgXCIgdGV4dEZpdEFsaWduVmVydFwiO1xuICAgICAgfVxuICAgICAgaW5uZXJTcGFuLnN0eWxlW1wiaGVpZ2h0XCJdID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgaWYgKFxuICAgICAgICBzZXR0aW5ncy5hbGlnblZlcnRXaXRoRmxleGJveCAmJlxuICAgICAgICAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwidGV4dEZpdEFsaWduVmVydEZsZXhcIilcbiAgICAgICkge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUgKyBcIiB0ZXh0Rml0QWxpZ25WZXJ0RmxleFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyBhIERPTSBlbGVtZW50XG4gIGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIlxuICAgICAgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgLy9ET00yXG4gICAgICA6IG8gJiZcbiAgICAgICAgICB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgIG8gIT09IG51bGwgJiZcbiAgICAgICAgICBvLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCI7XG4gIH0iLCJpbXBvcnQgRm9udEZhY2VPYnNlcnZlciBmcm9tIFwiLi9mb250ZmFjZW9ic2VydmVyLmpzXCI7XG5cbmNvbnN0IGRlZmF1bHRzUmVtb3ZlZCA9ICgpID0+IHtcbiAgLy8gZW5zdXJlIHRoYXQgdGhlIHVzZXIgaGFzIGNoYW5nZWQgaW1wb3J0YW50IHRlbXBhbHRlIG1ldGFkYXRhXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWYkPVwibWFpbi5jc3NcIl0nKSkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiJWMgUGxlYXNlIGluY2x1ZGUgbWFpbi5jc3MgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgZXhwb3J0IGlzIGNvcnJlY3RcIiwgJ2JhY2tncm91bmQ6ICNFNDFFNDY7IGNvbG9yOiB3aGl0ZSdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGU6bm90KFtkYXRhLWhyZWZdKTpub3QoLmluamVjdGVkU3R5bGUpOm5vdCgjbWNlRGVmYXVsdFN0eWxlcyk6bm90KCNtY2VTdHlsZXMpOm5vdChbaWRePWxlc3NdKVwiKSkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiJWMgSXQgaXMgYmVzdCBwcmFjdGljZSBub3QgdXNlIHN0eWxlcyBpbiB0aGUgaHRtbCBkb2N1bWVudC4gUGxlYXNlIG1vdmUgYWxsIHRoZSBzdHlsZXMgdG8gYW4gZXh0ZW5hbCBzdHlsZXMuY3NzIG9yIHN0eWxlcy5sZXNzIGZpbGUgZm9yIGNvbnN0YW5jeVwiLCAnYmFja2dyb3VuZDogI0U0MUU0NjsgY29sb3I6IHdoaXRlJ1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHRpdGxlID0gZG9jdW1lbnQudGl0bGU7XG4gICAgaWYgKHRpdGxlID09PSBcIlwiIHx8IHRpdGxlID09PSBcIlBVVF9URU1QTEFURV9OQU1FX0hFUkVcIikge1xuICAgICAgcmVqZWN0KFxuICAgICAgICBcIlBsZWFzZSBwdXQgdGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIGluIHRoZSB0aXRsZSBvZiB0aGUgZG9jdW1lbnRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGJ1aWx0QnkgPSBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInRlbXBsYXRlLWJ1aWx0LWJ5XCJdJylcbiAgICAgIC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpO1xuICAgIGlmIChidWlsdEJ5ID09PSBcIlwiIHx8IGJ1aWx0QnkgPT09IFwiUFVUX1lPVVJfTkFNRV9IRVJFXCIpIHtcbiAgICAgIHJlamVjdChcIlBsZWFzZSBhZGQgeW91ciBuYW1lIGluIHRoZSBkb2N1bWVudCBtZXRhIHRhZ3NcIik7XG4gICAgfVxuICAgIGxldCBzY29wZUNhcmQgPSBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInNjb3BlXCJdJylcbiAgICAgIC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpO1xuICAgIGlmIChzY29wZUNhcmQgPT09IFwiXCIgfHwgc2NvcGVDYXJkID09PSBcIkRUQi1QVVRfSklSQV9OVU1CRVJfSEVSRVwiKSB7XG4gICAgICByZWplY3QoXCJQbGVhc2UgYWRkIHRoZSBzY29wZSBjYXJkIElEIGluIHRoZSBkb2N1bWVudCBtZXRhIHRhZ3NcIik7XG4gICAgfVxuICAgIGxldCBidWlsdENhcmQgPSBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImJ1aWxkXCJdJylcbiAgICAgIC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpO1xuICAgIGlmIChidWlsdENhcmQgPT09IFwiXCIgfHwgYnVpbHRDYXJkID09PSBcIkRUQi1QVVRfSklSQV9OVU1CRVJfSEVSRVwiKSB7XG4gICAgICByZWplY3QoXCJQbGVhc2UgYWRkIHRoZSBidWlsZCBjYXJkIElEIGluIHRoZSBkb2N1bWVudCBtZXRhIHRhZ3NcIik7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgWy4uLmRvY3VtZW50LmhlYWQuY2hpbGROb2Rlc10uc29tZSgobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmRhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgIHJldHVybiBub2RlLmRhdGEuaW5jbHVkZXMoXCJUZW1wbGF0ZSBBZG1pbiBCdWlsZCBJbnN0cnVjdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICByZWplY3QoXG4gICAgICAgICdQbGVhc2UgcmVtb3ZlIHRoZSBcIlRlbXBsYXRlIEFkbWluIEJ1aWxkIEluc3RydWN0aW9uc1wiIGNvbW1lbnQgZnJvbSB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCdcbiAgICAgICk7XG4gICAgfVxuICAgIHJlc29sdmUoKTtcbiAgfSk7XG59O1xuXG5jb25zdCBzZXRPdXRmaXRTdGF0ZSA9ICh0cmltTWFya3MpID0+IHtcbiAgdmFyIG1vZGUgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZXhwb3J0c1wiKSA+IC0xID8gXCJleHBvcnRcIiA6IGZhbHNlO1xuICBtb2RlID1cbiAgICAhbW9kZSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwidGVtcGxhdGVzXCIpID4gLTEgPyBcInRlbXBsYXRlXCIgOiBtb2RlO1xuICBtb2RlID1cbiAgICAhbW9kZSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwicHJvamVjdHNcIikgPiAtMSA/IFwiZG9jdW1lbnRcIiA6IG1vZGU7XG4gIG1vZGUgPVxuICAgICFtb2RlICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJwcmV2aWV3XCIpID4gLTEgPyBcInByZXZpZXdcIiA6IG1vZGU7XG4gIG1vZGUgPVxuICAgICFtb2RlICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJsb2NhbGhvc3RcIikgPiAtMSA/IFwibG9jYWxcIiA6IG1vZGU7XG4gIGlmICghbW9kZSkge1xuICAgIG1vZGUgPSBcImVycm9yXCI7XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJkb2N1bWVudC1zdGF0ZVwiLCBtb2RlKTtcbiAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRyaW1cIiwgdHJpbU1hcmtzKTtcbiAgd2luZG93LnN0YXRlID0gbW9kZTtcbiAgcmV0dXJuIG1vZGU7XG59O1xuXG5cbi8vIGRpc3BsYXkgYSBtZXNzYWdlIHRvIGJsb2NrIHJlbmRlcmluZyBmb3IgbWFqb3IgaXNzdWVzXG5jb25zdCBibG9ja1JlbmRlciA9ICh2KSA9PiB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpLmlubmVySFRNTCA9IGBcbiAgICA8c3R5bGU+LnVqbWp1IHsgcG9zaXRpb246IGFic29sdXRlOyBiYWNrZ3JvdW5kOiAjMTExODIwOyBjb2xvcjogd2hpdGU7IGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmOyBmb250LXNpemU6IDAuNXJlbTsgei1pbmRleDogJHtoaWdoZXN0WigpfTsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTt9ICAucnNkaWUgeyBtYXJnaW46IDFyZW07IHdpZHRoOiA4MCUhaW1wb3J0YW50OyB9IC5yc2RpZSBwIHsgZm9udC1zaXplOiAwLjRyZW07IH0gPC9zdHlsZT5cbiAgICA8ZGl2IGNsYXNzPVwidWptanVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJyc2RpZVwiPlxuICAgICAgICA8aDI+4pqg77iPIFJlbmRlcmluZyBlcnJvciBkZXRlY3RlZDwvaDI+XG4gICAgICAgIDxoND7imqBQbGVhc2UgZW5hYmxlIDxjb2RlPnsgYWxsb3dMZWdhY3lSZW5kZXJpbmc6IHRydWUgfTwvY29kZT5cbiAgICAgICAgaW4gdGhlIGJvaWxlcnBsYXRlIG9yIHVwZGF0ZSB0aGlzIHRlbXBsYXRlIHRvIHZlcnNpb24gMS4xIG9yIDIuMTwvaDQ+XG4gICAgICAgIDxwPlRoaXMgdGVtcGxhdGUgaXMgdXNpbmcgcmVuZGVyZXIgJHt2fTwvcD5cbiAgICAgICAgPHA+UGxlYXNlIGNvbnRhY3Qgc3VwcG9ydCBpZiB5b3Ugc2VlIHRoaXMgbWVzc2FnZS48L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gO1xufTtcblxuLy8gVGhlcmUgaXMgYW4gZXJyb3Igb24gcmVuZGVyIDIgd2hlcmUgYW4gZXh0cmEgcGl4ZWwgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiBhIHRlbXBsYXRlXG4vLyB0aGlzIGNhc3VlcyBhIG5ldyBwYWdlIHRvIGJlIG1hZGUuIFRoaXMgZnVjdGlvbiByZW1vdmVzIHRoYXQgZXh0cmEgcGl4ZWxcbmNvbnN0IHBhZ2VIZWlnaHRTZXR1cCA9ICh0cmltTWFya3MsIGFsbG93TGVnYWN5UmVuZGVyaW5nKSA9PiB7XG4gIGxldCBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmIChhZ2VudC5pbmNsdWRlcyhcIk9QVElPTiAyLjFcIikpIHtcbiAgICBjb25zb2xlLmluZm8oXCJSZW5kZXJlciAyLjEgU2V0XCIpO1xuICAgIGlmICghdHJpbU1hcmtzKSB7XG4gICAgICByZXR1cm4gXCJjYWxjKDEwMHZoIC0gMXB4KVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIxMDB2aFwiO1xuICB9IGVsc2UgaWYgKGFnZW50LmluY2x1ZGVzKFwiT1BUSU9OIDEuMVwiKSkge1xuICAgIGNvbnNvbGUuaW5mbyhcIlJlbmRlcmVyIDEuMSBTZXRcIik7XG4gICAgcmV0dXJuIFwiMTAwdmhcIjtcbiAgfSBlbHNlIGlmIChhZ2VudC5pbmNsdWRlcyhcIk9QVElPTiAxLjBcIikpIHtcbiAgICBpZiAoIWFsbG93TGVnYWN5UmVuZGVyaW5nKSB7XG4gICAgICBibG9ja1JlbmRlcihcIjEuMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMTAwdmhcIjtcbiAgfSBlbHNlIGlmIChhZ2VudC5pbmNsdWRlcyhcIk9QVElPTiAyLjBcIikpIHtcbiAgICBpZiAoIWFsbG93TGVnYWN5UmVuZGVyaW5nKSB7XG4gICAgICBibG9ja1JlbmRlcihcIjIuMFwiKTtcbiAgICB9XG4gICAgaWYgKCF0cmltTWFya3MpIHtcbiAgICAgIHJldHVybiBcImNhbGMoMTAwdmggLSAxcHgpXCI7XG4gICAgfVxuICAgIHJldHVybiBcIjEwMHZoXCI7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5lcnJvcihcIlJlbmRlcmVyIE5vdCBTZXRcIik7XG4gICAgcmV0dXJuIFwiMTAwdmhcIjtcbiAgfVxufTtcblxuLy8gRml4IGZvciB0aGUgcmVzaXphYmxlIGJhY2tncm91bmQgaW1hZ2VzIC0gZnVsbHNjcmVlbiBhbmQgZGlnaXRhbCB2YWlyYWl0b25zIG9ubHlcbmNvbnN0IGFkZENyb3AgPSAodHJpbU1hcmtzLCBhbGxvd0xlZ2FjeVJlbmRlcmluZykgPT4ge1xuICAvLyBjcm9wIGFuZCBibGVlZFxuICB2YXIgY3JvcFNWRyA9IGA8c3ZnIGNsYXNzPVwiY3JvcC1tYXJrXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjEuNiAyMS42XCIgeG1sbnM6dj1cImh0dHBzOi8vdmVjdGEuaW8vbmFub1wiPjxwYXRoIGQ9XCJNMjEgMTVWMG0tNiAyMUgwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMC4yNVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTAuMDEzMVwiLz48L3N2Zz5gO1xuXG4gIGxldCBwYWdlSGVpZ2h0ID0gcGFnZUhlaWdodFNldHVwKHRyaW1NYXJrcywgYWxsb3dMZWdhY3lSZW5kZXJpbmcpO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnBhZ2VcIikuZm9yRWFjaCgocGFnZSkgPT4ge1xuICAgIHBhZ2Uuc3R5bGUuaGVpZ2h0ID0gcGFnZUhlaWdodDtcbiAgICBpZiAodHJpbU1hcmtzKSB7XG4gICAgICBwYWdlLmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgXCJhZnRlcmJlZ2luXCIsXG4gICAgICAgIGA8ZGl2IGNsYXNzPVwiY3JvcC1tYXJrc1wiPlxuICA8ZGl2IGNsYXNzPVwiY3JvcC1tYXJrIHRvcC1sZWZ0XCI+JHtjcm9wU1ZHfTwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY3JvcC1tYXJrIHRvcC1yaWdodFwiPiR7Y3JvcFNWR308L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImNyb3AtbWFyayBib3R0b20tbGVmdFwiPiR7Y3JvcFNWR308L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImNyb3AtbWFyayBib3R0b20tcmlnaHRcIj4ke2Nyb3BTVkd9PC9kaXY+XG4gIDwvZGl2PmBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmJsZWVkXCIpKVxuICAgIC5mb3JFYWNoKChibGVlZCkgPT4ge1xuICAgICAgYmxlZWQuc3R5bGUuY3NzVGV4dCA9IHRyaW1NYXJrc1xuICAgICAgICA/IFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDQuNDFtbTsgcmlnaHQ6IDQuNDFtbTsgYm90dG9tOiA0LjQxbW07IGxlZnQ6IDQuNDFtbTtcIlxuICAgICAgICA6IFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IC0zbW07IHJpZ2h0OiAtM21tOyBib3R0b206IC0zbW07IGxlZnQ6IC0zbW1cIjtcbiAgICB9KTtcbiAgaWYgKCF0cmltTWFya3MpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm91dGZpdC1yZXNpemFibGUtYmFja2dyb3VuZFwiKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwucGFyZW50Tm9kZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICBlbC5wYXJlbnROb2RlLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgICBlbC5wYXJlbnROb2RlLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgZWwucGFyZW50Tm9kZS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgICAgIGVsLnBhcmVudE5vZGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIGVsLnBhcmVudE5vZGUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhZ2VIZWlnaHQ7XG59O1xuXG5jb25zdCBmb250c0xvYWRlZCA9IChmb250c0xpc3RlZCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmb250c0xpc3RlZCkpIHtcbiAgICAgIGZvbnRzTGlzdGVkID0gW2ZvbnRzTGlzdGVkXTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWZvbnRzTGlzdGVkIHx8XG4gICAgICAoZm9udHNMaXN0ZWQgJiYgZm9udHNMaXN0ZWQubGVuZ3RoIDwgMSkgfHxcbiAgICAgIGZvbnRzTGlzdGVkWzBdID09PSBcIlBVVF9BTExfRk9OVF9OQU1FU19IRVJFXCJcbiAgICApIHtcbiAgICAgIHJlamVjdChcbiAgICAgICAgXCJObyBmb250cyB3ZXJlIHB1dCBpbiB0aGUgYm9pbGVycGxhdGUgY29uZmlnLiBGb3IgZXhhbXBsZSB7IGZvbnRzOiBbJ0lCTSBQbGV4IFNhbnMnXSB9XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICBmb250c0xpc3RlZC5tYXAoKGZvbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZvbnRGYWNlT2JzZXJ2ZXIoZm9udCkubG9hZCgpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgICAudGhlbigoZWwpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGVsKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IHNldFNpemUgPSAodHJpbU1hcmtzLCBleHBvcnRSZWR1Y2VGb250KSA9PiB7XG4gIGNvbnN0IHZ3ID0gKHRyaW1NYXJrcyA/IHdpbmRvdy5pbm5lcldpZHRoIDogd2luZG93LmlubmVyV2lkdGggKyA1Ny42MikgLyAxMDA7XG4gIGNvbnN0IHZoID1cbiAgICAodHJpbU1hcmtzID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0ICsgNTcuNjIpIC8gMTAwO1xuICBjb25zdCB2bWluID0gTWF0aC5taW4odncsIHZoKTtcbiAgY29uc3Qgdm1heCA9IE1hdGgubWF4KHZ3LCB2aCk7XG5cbiAgLy8gU2F2aW5nIHRoZSBwcmVsaW1pbmFyeSBmb250IHNpemUgY2FsY3VsYXRpb25cbiAgY29uc3QgcHJlbGltaW5hcnlDYWxjID0gdm1pbiAqIDIgKyB2bWF4ICogMS40ICsgdmggKiAyO1xuXG4gIC8vIFJlZHVjaW5nIHRoZSBwcmVsaW1pbmFyeUNhbGMgdmFsdWUgYnkgcmVkdWNlVmFsIGluIGV4cG9ydCBtb2RlIGFuZCBpbiBGaXJlZm94IHByZXZpZXcgbW9kZVxuICBjb25zdCBmaW5hbENhbGMgPSAod2luZG93LnN0YXRlID09PSBcImV4cG9ydHNcIilcbiAgICA/IHByZWxpbWluYXJ5Q2FsYyAtIChleHBvcnRSZWR1Y2VGb250IC8gMTAwKSAqIHByZWxpbWluYXJ5Q2FsY1xuICAgIDogcHJlbGltaW5hcnlDYWxjO1xuXG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IGAke2ZpbmFsQ2FsY31weGA7XG4gIHJldHVybiBmaW5hbENhbGM7XG59O1xuXG5jb25zdCBzZXRCcm93c2VyVHlwZSA9ICgpID0+IHtcbiAgbGV0IGJyb3dzZXIgPSB7XG4gICAgLy8gT3BlcmEgOC4wK1xuICAgIGlzT3BlcmE6XG4gICAgICAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHxcbiAgICAgICEhd2luZG93Lm9wZXJhIHx8XG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCIgT1BSL1wiKSA+PSAwLFxuICAgIC8vIEZpcmVmb3ggMS4wK1xuICAgIGlzRmlyZWZveDogdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIC8vIFNhZmFyaSAzLjArIFwiW29iamVjdCBIVE1MRWxlbWVudENvbnN0cnVjdG9yXVwiXG4gICAgaXNTYWZhcmk6XG4gICAgICAvY29uc3RydWN0b3IvaS50ZXN0KHdpbmRvdy5IVE1MRWxlbWVudCkgfHxcbiAgICAgIChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC50b1N0cmluZygpID09PSBcIltvYmplY3QgU2FmYXJpUmVtb3RlTm90aWZpY2F0aW9uXVwiO1xuICAgICAgfSkoXG4gICAgICAgICF3aW5kb3dbXCJzYWZhcmlcIl0gfHxcbiAgICAgICAgICAodHlwZW9mIHNhZmFyaSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dbXCJzYWZhcmlcIl0ucHVzaE5vdGlmaWNhdGlvbilcbiAgICAgICksXG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgNi0xMVxuICAgIGlzSUU6IC8qQGNjX29uIUAqLyBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZSxcbiAgICAvLyBDaHJvbWUgMSAtIDc5XG4gICAgaXNDaHJvbWU6XG4gICAgICAhIXdpbmRvdy5jaHJvbWUgJiYgKCEhd2luZG93LmNocm9tZS53ZWJzdG9yZSB8fCAhIXdpbmRvdy5jaHJvbWUucnVudGltZSksXG4gICAgLy8gbWFjIGRldGVjdGlvblxuICAgIGlzTWFjOiB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24uaW5jbHVkZXMoXCJNYWNcIiksXG4gIH07XG4gIC8vICBFZGdlIDIwK1xuICBicm93c2VyW1wiaXNFZGdlXCJdID0gIWJyb3dzZXIuaXNJRSAmJiAhIXdpbmRvdy5TdHlsZU1lZGlhO1xuICAvLyBFZGdlIChiYXNlZCBvbiBjaHJvbWl1bSkgZGV0ZWN0aW9uXG4gIGJyb3dzZXJbXCJpc0VkZ2VDaHJvbWl1bVwiXSA9XG4gICAgYnJvd3Nlci5pc0Nocm9tZSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJFZGdcIikgIT0gLTE7XG4gIC8vIEJsaW5rIGVuZ2luZSBkZXRlY3Rpb25cbiAgYnJvd3NlcltcImlzQmxpbmtcIl0gPSAoYnJvd3Nlci5pc0Nocm9tZSB8fCBicm93c2VyLmlzT3BlcmEpICYmICEhd2luZG93LkNTUztcblxuICBPYmplY3Qua2V5cyhicm93c2VyKVxuICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICByZXR1cm4gYnJvd3NlcltrZXldO1xuICB9KS5mb3JFYWNoKGVsID0+ICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoZWwpKVxuXG4gIHdpbmRvdy5icm93c2VyID0gYnJvd3NlclxuICByZXR1cm4gYnJvd3Nlcjtcbn07XG5cbmNvbnN0IGhpZ2hlc3RaID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJvZHkgKlwiKSlcbiAgICAgIC5tYXAoKGEpID0+IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoYSkuekluZGV4KSlcbiAgICAgIC5maWx0ZXIoKGEpID0+ICFpc05hTihhKSlcbiAgICAgIC5zb3J0KClcbiAgICAgIC5wb3AoKSArIDFcbiAgKTtcbn07XG5cbi8vIHdhaXQgZm9yIHRoZSBkb20gdG8gbGFvZCBvciBjb250aW51ZSBpZiBpdCBoYXMgYWxyZWFkeSBsb2FkZWRcbmNvbnN0IGRvbVJlYWR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBpZiAoXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkZWRcIiB8fFxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIlxuICApIHtcbiAgICByZXNvbHZlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHJlc29sdmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgfVxufSk7XG4vLyB3YWl0IGZvciB0aGUgd2luZG93IHRvIGxhb2Qgb3IgY29udGludWUgaWYgaXQgaGFzIGFscmVhZHkgbG9hZGVkXG5jb25zdCB3aW5Mb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgcmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZXNvbHZlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gIH1cbn0pO1xuXG5jb25zdCBsb2FkTEVTUyA9ICh2YXJpYWJsZXMgPSB7fSkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3R5cGU9XCJ0ZXh0L2xlc3NcIl0nKSAhPT0gbnVsbCkge1xuICAgICAgICByZXF1aXJlKFwibGVzc1wiKTtcbiAgICAgICAgZG9jdW1lbnRcbiAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbbWVkaWE9XCJcIl1bZGF0YS1ocmVmJD1cIi5sZXNzXCJdOm5vdChbaHJlZl0pJylcbiAgICAgICAgICAuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZWplY3QoZSk7XG4gICAgfVxuICB9KTtcbn07XG5cblxuZXhwb3J0IHtcbiAgZGVmYXVsdHNSZW1vdmVkLFxuICBsb2FkTEVTUyxcbiAgd2luTG9hZCxcbiAgZG9tUmVhZHksXG4gIGhpZ2hlc3RaLFxuICBzZXRCcm93c2VyVHlwZSxcbiAgc2V0U2l6ZSxcbiAgZm9udHNMb2FkZWQsXG4gIGFkZENyb3AsXG4gIHNldE91dGZpdFN0YXRlXG59O1xuIiwiLyoqXG4gKiBMZXNzIC0gTGVhbmVyIENTUyB2NC4xLjFcbiAqIGh0dHA6Ly9sZXNzY3NzLm9yZ1xuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAyMSwgQWxleGlzIFNlbGxpZXIgPHNlbGZAY2xvdWRoZWFkLm5ldD5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIExpY2Vuc2UuXG4gKlxuICogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmxlc3MgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBFeHBvcnQgYSBuZXcgZGVmYXVsdCBlYWNoIHRpbWVcclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKiBJbmxpbmUgSmF2YXNjcmlwdCAtIEBwbHVnaW4gc3RpbGwgYWxsb3dlZCAqL1xyXG4gICAgICAgICAgICBqYXZhc2NyaXB0RW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIC8qIE91dHB1dHMgYSBtYWtlZmlsZSBpbXBvcnQgZGVwZW5kZW5jeSBsaXN0IHRvIHN0ZG91dC4gKi9cclxuICAgICAgICAgICAgZGVwZW5kczogZmFsc2UsXHJcbiAgICAgICAgICAgIC8qIChERVBSRUNBVEVEKSBDb21wcmVzcyB1c2luZyBsZXNzIGJ1aWx0LWluIGNvbXByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKiBUaGlzIGRvZXMgYW4gb2theSBqb2IgYnV0IGRvZXMgbm90IHV0aWxpc2UgYWxsIHRoZSB0cmlja3Mgb2ZcclxuICAgICAgICAgICAgICogZGVkaWNhdGVkIGNzcyBjb21wcmVzc2lvbi4gKi9cclxuICAgICAgICAgICAgY29tcHJlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiBSdW5zIHRoZSBsZXNzIHBhcnNlciBhbmQganVzdCByZXBvcnRzIGVycm9ycyB3aXRob3V0IGFueSBvdXRwdXQuICovXHJcbiAgICAgICAgICAgIGxpbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiBTZXRzIGF2YWlsYWJsZSBpbmNsdWRlIHBhdGhzLlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgZmlsZSBpbiBhbiBAaW1wb3J0IHJ1bGUgZG9lcyBub3QgZXhpc3QgYXQgdGhhdCBleGFjdCBsb2NhdGlvbixcclxuICAgICAgICAgICAgICogbGVzcyB3aWxsIGxvb2sgZm9yIGl0IGF0IHRoZSBsb2NhdGlvbihzKSBwYXNzZWQgdG8gdGhpcyBvcHRpb24uXHJcbiAgICAgICAgICAgICAqIFlvdSBtaWdodCB1c2UgdGhpcyBmb3IgaW5zdGFuY2UgdG8gc3BlY2lmeSBhIHBhdGggdG8gYSBsaWJyYXJ5IHdoaWNoXHJcbiAgICAgICAgICAgICAqIHlvdSB3YW50IHRvIGJlIHJlZmVyZW5jZWQgc2ltcGx5IGFuZCByZWxhdGl2ZWx5IGluIHRoZSBsZXNzIGZpbGVzLiAqL1xyXG4gICAgICAgICAgICBwYXRoczogW10sXHJcbiAgICAgICAgICAgIC8qIGNvbG9yIG91dHB1dCBpbiB0aGUgdGVybWluYWwgKi9cclxuICAgICAgICAgICAgY29sb3I6IHRydWUsXHJcbiAgICAgICAgICAgIC8qIFRoZSBzdHJpY3RJbXBvcnRzIGNvbnRyb2xzIHdoZXRoZXIgdGhlIGNvbXBpbGVyIHdpbGwgYWxsb3cgYW4gQGltcG9ydCBpbnNpZGUgb2YgZWl0aGVyXHJcbiAgICAgICAgICAgICAqIEBtZWRpYSBibG9ja3Mgb3IgKGEgbGF0ZXIgYWRkaXRpb24pIG90aGVyIHNlbGVjdG9yIGJsb2Nrcy5cclxuICAgICAgICAgICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbGVzcy9sZXNzLmpzL2lzc3Vlcy82NTYgKi9cclxuICAgICAgICAgICAgc3RyaWN0SW1wb3J0czogZmFsc2UsXHJcbiAgICAgICAgICAgIC8qIEFsbG93IEltcG9ydHMgZnJvbSBJbnNlY3VyZSBIVFRQUyBIb3N0cyAqL1xyXG4gICAgICAgICAgICBpbnNlY3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIC8qIEFsbG93cyB5b3UgdG8gYWRkIGEgcGF0aCB0byBldmVyeSBnZW5lcmF0ZWQgaW1wb3J0IGFuZCB1cmwgaW4geW91ciBjc3MuXHJcbiAgICAgICAgICAgICAqIFRoaXMgZG9lcyBub3QgYWZmZWN0IGxlc3MgaW1wb3J0IHN0YXRlbWVudHMgdGhhdCBhcmUgcHJvY2Vzc2VkLCBqdXN0IG9uZXNcclxuICAgICAgICAgICAgICogdGhhdCBhcmUgbGVmdCBpbiB0aGUgb3V0cHV0IGNzcy4gKi9cclxuICAgICAgICAgICAgcm9vdHBhdGg6ICcnLFxyXG4gICAgICAgICAgICAvKiBCeSBkZWZhdWx0IFVSTHMgYXJlIGtlcHQgYXMtaXMsIHNvIGlmIHlvdSBpbXBvcnQgYSBmaWxlIGluIGEgc3ViLWRpcmVjdG9yeVxyXG4gICAgICAgICAgICAgKiB0aGF0IHJlZmVyZW5jZXMgYW4gaW1hZ2UsIGV4YWN0bHkgdGhlIHNhbWUgVVJMIHdpbGwgYmUgb3V0cHV0IGluIHRoZSBjc3MuXHJcbiAgICAgICAgICAgICAqIFRoaXMgb3B0aW9uIGFsbG93cyB5b3UgdG8gcmUtd3JpdGUgVVJMJ3MgaW4gaW1wb3J0ZWQgZmlsZXMgc28gdGhhdCB0aGVcclxuICAgICAgICAgICAgICogVVJMIGlzIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgYmFzZSBpbXBvcnRlZCBmaWxlICovXHJcbiAgICAgICAgICAgIHJld3JpdGVVcmxzOiBmYWxzZSxcclxuICAgICAgICAgICAgLyogSG93IHRvIHByb2Nlc3MgbWF0aFxyXG4gICAgICAgICAgICAgKiAgIDAgYWx3YXlzICAgICAgICAgICAtIGVhZ2VybHkgdHJ5IHRvIHNvbHZlIGFsbCBvcGVyYXRpb25zXHJcbiAgICAgICAgICAgICAqICAgMSBwYXJlbnMtZGl2aXNpb24gIC0gcmVxdWlyZSBwYXJlbnMgZm9yIGRpdmlzaW9uIFwiL1wiXHJcbiAgICAgICAgICAgICAqICAgMiBwYXJlbnMgfCBzdHJpY3QgIC0gcmVxdWlyZSBwYXJlbnMgZm9yIGFsbCBvcGVyYXRpb25zXHJcbiAgICAgICAgICAgICAqICAgMyBzdHJpY3QtbGVnYWN5ICAgIC0gbGVnYWN5IHN0cmljdCBiZWhhdmlvciAoc3VwZXItc3RyaWN0KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbWF0aDogMSxcclxuICAgICAgICAgICAgLyogV2l0aG91dCB0aGlzIG9wdGlvbiwgbGVzcyBhdHRlbXB0cyB0byBndWVzcyBhdCB0aGUgb3V0cHV0IHVuaXQgd2hlbiBpdCBkb2VzIG1hdGhzLiAqL1xyXG4gICAgICAgICAgICBzdHJpY3RVbml0czogZmFsc2UsXHJcbiAgICAgICAgICAgIC8qIEVmZmVjdGl2ZWx5IHRoZSBkZWNsYXJhdGlvbiBpcyBwdXQgYXQgdGhlIHRvcCBvZiB5b3VyIGJhc2UgTGVzcyBmaWxlLFxyXG4gICAgICAgICAgICAgKiBtZWFuaW5nIGl0IGNhbiBiZSB1c2VkIGJ1dCBpdCBhbHNvIGNhbiBiZSBvdmVycmlkZGVuIGlmIHRoaXMgdmFyaWFibGVcclxuICAgICAgICAgICAgICogaXMgZGVmaW5lZCBpbiB0aGUgZmlsZS4gKi9cclxuICAgICAgICAgICAgZ2xvYmFsVmFyczogbnVsbCxcclxuICAgICAgICAgICAgLyogQXMgb3Bwb3NlZCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlIG9wdGlvbiwgdGhpcyBwdXRzIHRoZSBkZWNsYXJhdGlvbiBhdCB0aGVcclxuICAgICAgICAgICAgICogZW5kIG9mIHlvdXIgYmFzZSBmaWxlLCBtZWFuaW5nIGl0IHdpbGwgb3ZlcnJpZGUgYW55dGhpbmcgZGVmaW5lZCBpbiB5b3VyIExlc3MgZmlsZS4gKi9cclxuICAgICAgICAgICAgbW9kaWZ5VmFyczogbnVsbCxcclxuICAgICAgICAgICAgLyogVGhpcyBvcHRpb24gYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGEgYXJndW1lbnQgdG8gZ28gb24gdG8gZXZlcnkgVVJMLiAgKi9cclxuICAgICAgICAgICAgdXJsQXJnczogJydcclxuICAgICAgICB9O1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdElkKGhyZWYpIHtcclxuICAgICAgICByZXR1cm4gaHJlZi5yZXBsYWNlKC9eW2Etei1dKzpcXC8rP1teXFwvXSsvLCAnJykgLy8gUmVtb3ZlIHByb3RvY29sICYgZG9tYWluXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFw/XFwmXWxpdmVyZWxvYWQ9XFx3Ky8sICcnKSAvLyBSZW1vdmUgTGl2ZVJlbG9hZCBjYWNoZWJ1c3RlclxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcLy8sICcnKSAvLyBSZW1vdmUgcm9vdCAvXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC5bYS16QS1aXSskLywgJycpIC8vIFJlbW92ZSBzaW1wbGUgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcLlxcdy1dKy9nLCAnLScpIC8vIFJlcGxhY2UgaWxsZWdhbCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC4vZywgJzonKTsgLy8gUmVwbGFjZSBkb3RzIHdpdGggY29sb25zKGZvciB2YWxpZCBpZClcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZERhdGFBdHRyKG9wdGlvbnMsIHRhZykge1xyXG4gICAgICAgIGZvciAodmFyIG9wdCBpbiB0YWcuZGF0YXNldCkge1xyXG4gICAgICAgICAgICBpZiAodGFnLmRhdGFzZXQuaGFzT3duUHJvcGVydHkob3B0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdCA9PT0gJ2VudicgfHwgb3B0ID09PSAnZHVtcExpbmVOdW1iZXJzJyB8fCBvcHQgPT09ICdyb290cGF0aCcgfHwgb3B0ID09PSAnZXJyb3JSZXBvcnRpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRdID0gdGFnLmRhdGFzZXRbb3B0XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IEpTT04ucGFyc2UodGFnLmRhdGFzZXRbb3B0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cblxuICAgIHZhciBicm93c2VyID0ge1xyXG4gICAgICAgIGNyZWF0ZUNTUzogZnVuY3Rpb24gKGRvY3VtZW50LCBzdHlsZXMsIHNoZWV0KSB7XHJcbiAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBxdWVyeS1zdHJpbmdcclxuICAgICAgICAgICAgdmFyIGhyZWYgPSBzaGVldC5ocmVmIHx8ICcnO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyB0aXRsZSBzZXQsIHVzZSB0aGUgZmlsZW5hbWUsIG1pbnVzIHRoZSBleHRlbnNpb25cclxuICAgICAgICAgICAgdmFyIGlkID0gXCJsZXNzOlwiICsgKHNoZWV0LnRpdGxlIHx8IGV4dHJhY3RJZChocmVmKSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaGFzIGFscmVhZHkgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00sIHdlIG1heSBuZWVkIHRvIHJlcGxhY2UgaXRcclxuICAgICAgICAgICAgdmFyIG9sZFN0eWxlTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgICAgICAgICAgdmFyIGtlZXBPbGRTdHlsZU5vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0eWxlc2hlZXQgbm9kZSBmb3IgaW5zZXJ0aW9uIG9yIChpZiBuZWNlc3NhcnkpIHJlcGxhY2VtZW50XHJcbiAgICAgICAgICAgIHZhciBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XHJcbiAgICAgICAgICAgIGlmIChzaGVldC5tZWRpYSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBzaGVldC5tZWRpYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGVOb2RlLmlkID0gaWQ7XHJcbiAgICAgICAgICAgIGlmICghc3R5bGVOb2RlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50cyBtYXRjaCBjb250ZW50cyBvZiBvbGRTdHlsZU5vZGUsIGRvbid0IHJlcGxhY2Ugb2xkU3R5bGVOb2RlXHJcbiAgICAgICAgICAgICAgICBrZWVwT2xkU3R5bGVOb2RlID0gKG9sZFN0eWxlTm9kZSAhPT0gbnVsbCAmJiBvbGRTdHlsZU5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIHN0eWxlTm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBvbGRTdHlsZU5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPT09IHN0eWxlTm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvbGRTdHlsZU5vZGUsIGp1c3QgYXBwZW5kOyBvdGhlcndpc2UsIG9ubHkgYXBwZW5kIGlmIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gcmVwbGFjZSBvbGRTdHlsZU5vZGUgd2l0aCBhbiB1cGRhdGVkIHN0eWxlc2hlZXRcclxuICAgICAgICAgICAgaWYgKG9sZFN0eWxlTm9kZSA9PT0gbnVsbCB8fCBrZWVwT2xkU3R5bGVOb2RlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRFbCA9IHNoZWV0ICYmIHNoZWV0Lm5leHRTaWJsaW5nIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlTm9kZSwgbmV4dEVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkU3R5bGVOb2RlICYmIGtlZXBPbGRTdHlsZU5vZGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRTdHlsZU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvbGRTdHlsZU5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZvciBJRS5cclxuICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBoYXBwZW4gKmFmdGVyKiB0aGUgc3R5bGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgRE9NLCBvdGhlcndpc2UgSUUgNyBhbmQgOCBtYXkgY3Jhc2guXHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvN2UwODFiNjUtODc4YS00YzIyLThlNjgtYzEwZDM5YzJlZDMyL2ludGVybmV0LWV4cGxvcmVyLWNyYXNoZXMtYXBwZW5kaW5nLXN0eWxlLWVsZW1lbnQtdG8taGVhZFxyXG4gICAgICAgICAgICBpZiAoc3R5bGVOb2RlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVOb2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHN0eWxlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZG5cXCd0IHJlYXNzaWduIHN0eWxlU2hlZXQuY3NzVGV4dC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3VycmVudFNjcmlwdDogZnVuY3Rpb24gKHdpbmRvdykge1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcblxuICAgIHZhciBhZGREZWZhdWx0T3B0aW9ucyA9IChmdW5jdGlvbiAod2luZG93LCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gdXNlIG9wdGlvbnMgZnJvbSB0aGUgY3VycmVudCBzY3JpcHQgdGFnIGRhdGEgYXR0cmlidWVzXHJcbiAgICAgICAgYWRkRGF0YUF0dHIob3B0aW9ucywgYnJvd3Nlci5jdXJyZW50U2NyaXB0KHdpbmRvdykpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmlzRmlsZVByb3RvY29sID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA9IC9eKGZpbGV8KGNocm9tZXxzYWZhcmkpKC1leHRlbnNpb24pP3xyZXNvdXJjZXxxcmN8YXBwKTovLnRlc3Qod2luZG93LmxvY2F0aW9uLnByb3RvY29sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTG9hZCBzdHlsZXMgYXN5bmNocm9ub3VzbHkgKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhpcyBpcyBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LCBzbyB0aGF0IHRoZSBib2R5XHJcbiAgICAgICAgLy8gZG9lc24ndCBzdGFydCBsb2FkaW5nIGJlZm9yZSB0aGUgc3R5bGVzaGVldHMgYXJlIHBhcnNlZC5cclxuICAgICAgICAvLyBTZXR0aW5nIHRoaXMgdG8gYHRydWVgIGNhbiByZXN1bHQgaW4gZmxpY2tlcmluZy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIG9wdGlvbnMuYXN5bmMgPSBvcHRpb25zLmFzeW5jIHx8IGZhbHNlO1xyXG4gICAgICAgIG9wdGlvbnMuZmlsZUFzeW5jID0gb3B0aW9ucy5maWxlQXN5bmMgfHwgZmFsc2U7XHJcbiAgICAgICAgLy8gSW50ZXJ2YWwgYmV0d2VlbiB3YXRjaCBwb2xsc1xyXG4gICAgICAgIG9wdGlvbnMucG9sbCA9IG9wdGlvbnMucG9sbCB8fCAob3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA/IDEwMDAgOiAxNTAwKTtcclxuICAgICAgICBvcHRpb25zLmVudiA9IG9wdGlvbnMuZW52IHx8ICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT0gJzEyNy4wLjAuMScgfHxcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09ICcwLjAuMC4wJyB8fFxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT0gJ2xvY2FsaG9zdCcgfHxcclxuICAgICAgICAgICAgKHdpbmRvdy5sb2NhdGlvbi5wb3J0ICYmXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucG9ydC5sZW5ndGggPiAwKSB8fFxyXG4gICAgICAgICAgICBvcHRpb25zLmlzRmlsZVByb3RvY29sID8gJ2RldmVsb3BtZW50J1xyXG4gICAgICAgICAgICA6ICdwcm9kdWN0aW9uJyk7XHJcbiAgICAgICAgdmFyIGR1bXBMaW5lTnVtYmVycyA9IC8hZHVtcExpbmVOdW1iZXJzOihjb21tZW50c3xtZWRpYXF1ZXJ5fGFsbCkvLmV4ZWMod2luZG93LmxvY2F0aW9uLmhhc2gpO1xyXG4gICAgICAgIGlmIChkdW1wTGluZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5kdW1wTGluZU51bWJlcnMgPSBkdW1wTGluZU51bWJlcnNbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnVzZUZpbGVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudXNlRmlsZUNhY2hlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMub25SZWFkeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMub25SZWFkeSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlVXJscykge1xyXG4gICAgICAgICAgICBvcHRpb25zLnJld3JpdGVVcmxzID0gJ2FsbCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgbG9nZ2VyID0ge1xyXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZXJyb3InLCBtc2cpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3dhcm4nLCBtc2cpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5mbzogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2luZm8nLCBtc2cpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVidWc6IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdkZWJ1ZycsIG1zZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9maXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBtc2cpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb2dGdW5jdGlvbiA9IHRoaXMuX2xpc3RlbmVyc1tpXVt0eXBlXTtcclxuICAgICAgICAgICAgICAgIGlmIChsb2dGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKG1zZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9saXN0ZW5lcnM6IFtdXHJcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBAdG9kbyBEb2N1bWVudCB3aHkgdGhpcyBhYnN0cmFjdGlvbiBleGlzdHMsIGFuZCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW5cclxuICAgICAqICAgICAgIGVudmlyb25tZW50LCBmaWxlIG1hbmFnZXJzLCBhbmQgcGx1Z2luIG1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEVudmlyb25tZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEVudmlyb25tZW50KGV4dGVybmFsRW52aXJvbm1lbnQsIGZpbGVNYW5hZ2Vycykge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IGZpbGVNYW5hZ2VycyB8fCBbXTtcclxuICAgICAgICAgICAgZXh0ZXJuYWxFbnZpcm9ubWVudCA9IGV4dGVybmFsRW52aXJvbm1lbnQgfHwge307XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25hbEZ1bmN0aW9ucyA9IFsnZW5jb2RlQmFzZTY0JywgJ21pbWVMb29rdXAnLCAnY2hhcnNldExvb2t1cCcsICdnZXRTb3VyY2VNYXBHZW5lcmF0b3InXTtcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVkRnVuY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbnMgPSByZXF1aXJlZEZ1bmN0aW9ucy5jb25jYXQob3B0aW9uYWxGdW5jdGlvbnMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gZnVuY3Rpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudmlyb25tZW50RnVuYyA9IGV4dGVybmFsRW52aXJvbm1lbnRbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50RnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gZW52aXJvbm1lbnRGdW5jLmJpbmQoZXh0ZXJuYWxFbnZpcm9ubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgcmVxdWlyZWRGdW5jdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXJuKFwibWlzc2luZyByZXF1aXJlZCBmdW5jdGlvbiBpbiBlbnZpcm9ubWVudCAtIFwiICsgcHJvcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5nZXRGaWxlTWFuYWdlciA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY3VycmVudERpcmVjdG9yeSwgb3B0aW9ucywgZW52aXJvbm1lbnQsIGlzU3luYykge1xyXG4gICAgICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybignZ2V0RmlsZU1hbmFnZXIgY2FsbGVkIHdpdGggbm8gZmlsZW5hbWUuLiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUuIGNvbnRpbnVpbmcuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXJlY3RvcnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2dldEZpbGVNYW5hZ2VyIGNhbGxlZCB3aXRoIG51bGwgZGlyZWN0b3J5Li4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlLiBjb250aW51aW5nLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmaWxlTWFuYWdlcnMgPSB0aGlzLmZpbGVNYW5hZ2VycztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGx1Z2luTWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgZmlsZU1hbmFnZXJzID0gW10uY29uY2F0KGZpbGVNYW5hZ2VycykuY29uY2F0KG9wdGlvbnMucGx1Z2luTWFuYWdlci5nZXRGaWxlTWFuYWdlcnMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZpbGVNYW5hZ2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVNYW5hZ2VyID0gZmlsZU1hbmFnZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVNYW5hZ2VyW2lzU3luYyA/ICdzdXBwb3J0c1N5bmMnIDogJ3N1cHBvcnRzJ10oZmlsZW5hbWUsIGN1cnJlbnREaXJlY3RvcnksIG9wdGlvbnMsIGVudmlyb25tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlTWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5hZGRGaWxlTWFuYWdlciA9IGZ1bmN0aW9uIChmaWxlTWFuYWdlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2Vycy5wdXNoKGZpbGVNYW5hZ2VyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5jbGVhckZpbGVNYW5hZ2VycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlTWFuYWdlcnMgPSBbXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBFbnZpcm9ubWVudDtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgY29sb3JzID0ge1xyXG4gICAgICAgICdhbGljZWJsdWUnOiAnI2YwZjhmZicsXHJcbiAgICAgICAgJ2FudGlxdWV3aGl0ZSc6ICcjZmFlYmQ3JyxcclxuICAgICAgICAnYXF1YSc6ICcjMDBmZmZmJyxcclxuICAgICAgICAnYXF1YW1hcmluZSc6ICcjN2ZmZmQ0JyxcclxuICAgICAgICAnYXp1cmUnOiAnI2YwZmZmZicsXHJcbiAgICAgICAgJ2JlaWdlJzogJyNmNWY1ZGMnLFxyXG4gICAgICAgICdiaXNxdWUnOiAnI2ZmZTRjNCcsXHJcbiAgICAgICAgJ2JsYWNrJzogJyMwMDAwMDAnLFxyXG4gICAgICAgICdibGFuY2hlZGFsbW9uZCc6ICcjZmZlYmNkJyxcclxuICAgICAgICAnYmx1ZSc6ICcjMDAwMGZmJyxcclxuICAgICAgICAnYmx1ZXZpb2xldCc6ICcjOGEyYmUyJyxcclxuICAgICAgICAnYnJvd24nOiAnI2E1MmEyYScsXHJcbiAgICAgICAgJ2J1cmx5d29vZCc6ICcjZGViODg3JyxcclxuICAgICAgICAnY2FkZXRibHVlJzogJyM1ZjllYTAnLFxyXG4gICAgICAgICdjaGFydHJldXNlJzogJyM3ZmZmMDAnLFxyXG4gICAgICAgICdjaG9jb2xhdGUnOiAnI2QyNjkxZScsXHJcbiAgICAgICAgJ2NvcmFsJzogJyNmZjdmNTAnLFxyXG4gICAgICAgICdjb3JuZmxvd2VyYmx1ZSc6ICcjNjQ5NWVkJyxcclxuICAgICAgICAnY29ybnNpbGsnOiAnI2ZmZjhkYycsXHJcbiAgICAgICAgJ2NyaW1zb24nOiAnI2RjMTQzYycsXHJcbiAgICAgICAgJ2N5YW4nOiAnIzAwZmZmZicsXHJcbiAgICAgICAgJ2RhcmtibHVlJzogJyMwMDAwOGInLFxyXG4gICAgICAgICdkYXJrY3lhbic6ICcjMDA4YjhiJyxcclxuICAgICAgICAnZGFya2dvbGRlbnJvZCc6ICcjYjg4NjBiJyxcclxuICAgICAgICAnZGFya2dyYXknOiAnI2E5YTlhOScsXHJcbiAgICAgICAgJ2RhcmtncmV5JzogJyNhOWE5YTknLFxyXG4gICAgICAgICdkYXJrZ3JlZW4nOiAnIzAwNjQwMCcsXHJcbiAgICAgICAgJ2RhcmtraGFraSc6ICcjYmRiNzZiJyxcclxuICAgICAgICAnZGFya21hZ2VudGEnOiAnIzhiMDA4YicsXHJcbiAgICAgICAgJ2RhcmtvbGl2ZWdyZWVuJzogJyM1NTZiMmYnLFxyXG4gICAgICAgICdkYXJrb3JhbmdlJzogJyNmZjhjMDAnLFxyXG4gICAgICAgICdkYXJrb3JjaGlkJzogJyM5OTMyY2MnLFxyXG4gICAgICAgICdkYXJrcmVkJzogJyM4YjAwMDAnLFxyXG4gICAgICAgICdkYXJrc2FsbW9uJzogJyNlOTk2N2EnLFxyXG4gICAgICAgICdkYXJrc2VhZ3JlZW4nOiAnIzhmYmM4ZicsXHJcbiAgICAgICAgJ2RhcmtzbGF0ZWJsdWUnOiAnIzQ4M2Q4YicsXHJcbiAgICAgICAgJ2RhcmtzbGF0ZWdyYXknOiAnIzJmNGY0ZicsXHJcbiAgICAgICAgJ2RhcmtzbGF0ZWdyZXknOiAnIzJmNGY0ZicsXHJcbiAgICAgICAgJ2Rhcmt0dXJxdW9pc2UnOiAnIzAwY2VkMScsXHJcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOiAnIzk0MDBkMycsXHJcbiAgICAgICAgJ2RlZXBwaW5rJzogJyNmZjE0OTMnLFxyXG4gICAgICAgICdkZWVwc2t5Ymx1ZSc6ICcjMDBiZmZmJyxcclxuICAgICAgICAnZGltZ3JheSc6ICcjNjk2OTY5JyxcclxuICAgICAgICAnZGltZ3JleSc6ICcjNjk2OTY5JyxcclxuICAgICAgICAnZG9kZ2VyYmx1ZSc6ICcjMWU5MGZmJyxcclxuICAgICAgICAnZmlyZWJyaWNrJzogJyNiMjIyMjInLFxyXG4gICAgICAgICdmbG9yYWx3aGl0ZSc6ICcjZmZmYWYwJyxcclxuICAgICAgICAnZm9yZXN0Z3JlZW4nOiAnIzIyOGIyMicsXHJcbiAgICAgICAgJ2Z1Y2hzaWEnOiAnI2ZmMDBmZicsXHJcbiAgICAgICAgJ2dhaW5zYm9ybyc6ICcjZGNkY2RjJyxcclxuICAgICAgICAnZ2hvc3R3aGl0ZSc6ICcjZjhmOGZmJyxcclxuICAgICAgICAnZ29sZCc6ICcjZmZkNzAwJyxcclxuICAgICAgICAnZ29sZGVucm9kJzogJyNkYWE1MjAnLFxyXG4gICAgICAgICdncmF5JzogJyM4MDgwODAnLFxyXG4gICAgICAgICdncmV5JzogJyM4MDgwODAnLFxyXG4gICAgICAgICdncmVlbic6ICcjMDA4MDAwJyxcclxuICAgICAgICAnZ3JlZW55ZWxsb3cnOiAnI2FkZmYyZicsXHJcbiAgICAgICAgJ2hvbmV5ZGV3JzogJyNmMGZmZjAnLFxyXG4gICAgICAgICdob3RwaW5rJzogJyNmZjY5YjQnLFxyXG4gICAgICAgICdpbmRpYW5yZWQnOiAnI2NkNWM1YycsXHJcbiAgICAgICAgJ2luZGlnbyc6ICcjNGIwMDgyJyxcclxuICAgICAgICAnaXZvcnknOiAnI2ZmZmZmMCcsXHJcbiAgICAgICAgJ2toYWtpJzogJyNmMGU2OGMnLFxyXG4gICAgICAgICdsYXZlbmRlcic6ICcjZTZlNmZhJyxcclxuICAgICAgICAnbGF2ZW5kZXJibHVzaCc6ICcjZmZmMGY1JyxcclxuICAgICAgICAnbGF3bmdyZWVuJzogJyM3Y2ZjMDAnLFxyXG4gICAgICAgICdsZW1vbmNoaWZmb24nOiAnI2ZmZmFjZCcsXHJcbiAgICAgICAgJ2xpZ2h0Ymx1ZSc6ICcjYWRkOGU2JyxcclxuICAgICAgICAnbGlnaHRjb3JhbCc6ICcjZjA4MDgwJyxcclxuICAgICAgICAnbGlnaHRjeWFuJzogJyNlMGZmZmYnLFxyXG4gICAgICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6ICcjZmFmYWQyJyxcclxuICAgICAgICAnbGlnaHRncmF5JzogJyNkM2QzZDMnLFxyXG4gICAgICAgICdsaWdodGdyZXknOiAnI2QzZDNkMycsXHJcbiAgICAgICAgJ2xpZ2h0Z3JlZW4nOiAnIzkwZWU5MCcsXHJcbiAgICAgICAgJ2xpZ2h0cGluayc6ICcjZmZiNmMxJyxcclxuICAgICAgICAnbGlnaHRzYWxtb24nOiAnI2ZmYTA3YScsXHJcbiAgICAgICAgJ2xpZ2h0c2VhZ3JlZW4nOiAnIzIwYjJhYScsXHJcbiAgICAgICAgJ2xpZ2h0c2t5Ymx1ZSc6ICcjODdjZWZhJyxcclxuICAgICAgICAnbGlnaHRzbGF0ZWdyYXknOiAnIzc3ODg5OScsXHJcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmV5JzogJyM3Nzg4OTknLFxyXG4gICAgICAgICdsaWdodHN0ZWVsYmx1ZSc6ICcjYjBjNGRlJyxcclxuICAgICAgICAnbGlnaHR5ZWxsb3cnOiAnI2ZmZmZlMCcsXHJcbiAgICAgICAgJ2xpbWUnOiAnIzAwZmYwMCcsXHJcbiAgICAgICAgJ2xpbWVncmVlbic6ICcjMzJjZDMyJyxcclxuICAgICAgICAnbGluZW4nOiAnI2ZhZjBlNicsXHJcbiAgICAgICAgJ21hZ2VudGEnOiAnI2ZmMDBmZicsXHJcbiAgICAgICAgJ21hcm9vbic6ICcjODAwMDAwJyxcclxuICAgICAgICAnbWVkaXVtYXF1YW1hcmluZSc6ICcjNjZjZGFhJyxcclxuICAgICAgICAnbWVkaXVtYmx1ZSc6ICcjMDAwMGNkJyxcclxuICAgICAgICAnbWVkaXVtb3JjaGlkJzogJyNiYTU1ZDMnLFxyXG4gICAgICAgICdtZWRpdW1wdXJwbGUnOiAnIzkzNzBkOCcsXHJcbiAgICAgICAgJ21lZGl1bXNlYWdyZWVuJzogJyMzY2IzNzEnLFxyXG4gICAgICAgICdtZWRpdW1zbGF0ZWJsdWUnOiAnIzdiNjhlZScsXHJcbiAgICAgICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogJyMwMGZhOWEnLFxyXG4gICAgICAgICdtZWRpdW10dXJxdW9pc2UnOiAnIzQ4ZDFjYycsXHJcbiAgICAgICAgJ21lZGl1bXZpb2xldHJlZCc6ICcjYzcxNTg1JyxcclxuICAgICAgICAnbWlkbmlnaHRibHVlJzogJyMxOTE5NzAnLFxyXG4gICAgICAgICdtaW50Y3JlYW0nOiAnI2Y1ZmZmYScsXHJcbiAgICAgICAgJ21pc3R5cm9zZSc6ICcjZmZlNGUxJyxcclxuICAgICAgICAnbW9jY2FzaW4nOiAnI2ZmZTRiNScsXHJcbiAgICAgICAgJ25hdmFqb3doaXRlJzogJyNmZmRlYWQnLFxyXG4gICAgICAgICduYXZ5JzogJyMwMDAwODAnLFxyXG4gICAgICAgICdvbGRsYWNlJzogJyNmZGY1ZTYnLFxyXG4gICAgICAgICdvbGl2ZSc6ICcjODA4MDAwJyxcclxuICAgICAgICAnb2xpdmVkcmFiJzogJyM2YjhlMjMnLFxyXG4gICAgICAgICdvcmFuZ2UnOiAnI2ZmYTUwMCcsXHJcbiAgICAgICAgJ29yYW5nZXJlZCc6ICcjZmY0NTAwJyxcclxuICAgICAgICAnb3JjaGlkJzogJyNkYTcwZDYnLFxyXG4gICAgICAgICdwYWxlZ29sZGVucm9kJzogJyNlZWU4YWEnLFxyXG4gICAgICAgICdwYWxlZ3JlZW4nOiAnIzk4ZmI5OCcsXHJcbiAgICAgICAgJ3BhbGV0dXJxdW9pc2UnOiAnI2FmZWVlZScsXHJcbiAgICAgICAgJ3BhbGV2aW9sZXRyZWQnOiAnI2Q4NzA5MycsXHJcbiAgICAgICAgJ3BhcGF5YXdoaXAnOiAnI2ZmZWZkNScsXHJcbiAgICAgICAgJ3BlYWNocHVmZic6ICcjZmZkYWI5JyxcclxuICAgICAgICAncGVydSc6ICcjY2Q4NTNmJyxcclxuICAgICAgICAncGluayc6ICcjZmZjMGNiJyxcclxuICAgICAgICAncGx1bSc6ICcjZGRhMGRkJyxcclxuICAgICAgICAncG93ZGVyYmx1ZSc6ICcjYjBlMGU2JyxcclxuICAgICAgICAncHVycGxlJzogJyM4MDAwODAnLFxyXG4gICAgICAgICdyZWJlY2NhcHVycGxlJzogJyM2NjMzOTknLFxyXG4gICAgICAgICdyZWQnOiAnI2ZmMDAwMCcsXHJcbiAgICAgICAgJ3Jvc3licm93bic6ICcjYmM4ZjhmJyxcclxuICAgICAgICAncm95YWxibHVlJzogJyM0MTY5ZTEnLFxyXG4gICAgICAgICdzYWRkbGVicm93bic6ICcjOGI0NTEzJyxcclxuICAgICAgICAnc2FsbW9uJzogJyNmYTgwNzInLFxyXG4gICAgICAgICdzYW5keWJyb3duJzogJyNmNGE0NjAnLFxyXG4gICAgICAgICdzZWFncmVlbic6ICcjMmU4YjU3JyxcclxuICAgICAgICAnc2Vhc2hlbGwnOiAnI2ZmZjVlZScsXHJcbiAgICAgICAgJ3NpZW5uYSc6ICcjYTA1MjJkJyxcclxuICAgICAgICAnc2lsdmVyJzogJyNjMGMwYzAnLFxyXG4gICAgICAgICdza3libHVlJzogJyM4N2NlZWInLFxyXG4gICAgICAgICdzbGF0ZWJsdWUnOiAnIzZhNWFjZCcsXHJcbiAgICAgICAgJ3NsYXRlZ3JheSc6ICcjNzA4MDkwJyxcclxuICAgICAgICAnc2xhdGVncmV5JzogJyM3MDgwOTAnLFxyXG4gICAgICAgICdzbm93JzogJyNmZmZhZmEnLFxyXG4gICAgICAgICdzcHJpbmdncmVlbic6ICcjMDBmZjdmJyxcclxuICAgICAgICAnc3RlZWxibHVlJzogJyM0NjgyYjQnLFxyXG4gICAgICAgICd0YW4nOiAnI2QyYjQ4YycsXHJcbiAgICAgICAgJ3RlYWwnOiAnIzAwODA4MCcsXHJcbiAgICAgICAgJ3RoaXN0bGUnOiAnI2Q4YmZkOCcsXHJcbiAgICAgICAgJ3RvbWF0byc6ICcjZmY2MzQ3JyxcclxuICAgICAgICAndHVycXVvaXNlJzogJyM0MGUwZDAnLFxyXG4gICAgICAgICd2aW9sZXQnOiAnI2VlODJlZScsXHJcbiAgICAgICAgJ3doZWF0JzogJyNmNWRlYjMnLFxyXG4gICAgICAgICd3aGl0ZSc6ICcjZmZmZmZmJyxcclxuICAgICAgICAnd2hpdGVzbW9rZSc6ICcjZjVmNWY1JyxcclxuICAgICAgICAneWVsbG93JzogJyNmZmZmMDAnLFxyXG4gICAgICAgICd5ZWxsb3dncmVlbic6ICcjOWFjZDMyJ1xyXG4gICAgfTtcblxuICAgIHZhciB1bml0Q29udmVyc2lvbnMgPSB7XHJcbiAgICAgICAgbGVuZ3RoOiB7XHJcbiAgICAgICAgICAgICdtJzogMSxcclxuICAgICAgICAgICAgJ2NtJzogMC4wMSxcclxuICAgICAgICAgICAgJ21tJzogMC4wMDEsXHJcbiAgICAgICAgICAgICdpbic6IDAuMDI1NCxcclxuICAgICAgICAgICAgJ3B4JzogMC4wMjU0IC8gOTYsXHJcbiAgICAgICAgICAgICdwdCc6IDAuMDI1NCAvIDcyLFxyXG4gICAgICAgICAgICAncGMnOiAwLjAyNTQgLyA3MiAqIDEyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkdXJhdGlvbjoge1xyXG4gICAgICAgICAgICAncyc6IDEsXHJcbiAgICAgICAgICAgICdtcyc6IDAuMDAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbmdsZToge1xyXG4gICAgICAgICAgICAncmFkJzogMSAvICgyICogTWF0aC5QSSksXHJcbiAgICAgICAgICAgICdkZWcnOiAxIC8gMzYwLFxyXG4gICAgICAgICAgICAnZ3JhZCc6IDEgLyA0MDAsXHJcbiAgICAgICAgICAgICd0dXJuJzogMVxyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgZGF0YSA9IHsgY29sb3JzOiBjb2xvcnMsIHVuaXRDb252ZXJzaW9uczogdW5pdENvbnZlcnNpb25zIH07XG5cbiAgICAvKipcclxuICAgICAqIFRoZSByZWFzb24gd2h5IE5vZGUgaXMgYSBjbGFzcyBhbmQgb3RoZXIgbm9kZXMgc2ltcGx5IGRvIG5vdCBleHRlbmRcclxuICAgICAqIGZyb20gTm9kZSAoc2luY2Ugd2UncmUgdHJhbnNwaWxpbmcpIGlzIGR1ZSB0byB0aGlzIGlzc3VlOlxyXG4gICAgICpcclxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNzL2xlc3MuanMvaXNzdWVzLzM0MzRcclxuICAgICAqL1xyXG4gICAgdmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gTm9kZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZVZpc2libGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjdXJyZW50RmlsZUluZm8nLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuZmlsZUluZm8oKTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpbmRleCcsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5nZXRJbmRleCgpOyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAobm9kZXMsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXQobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZSBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldChub2Rlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXggfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmdldEluZGV4KCkpIHx8IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5maWxlSW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVJbmZvIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5maWxlSW5mbygpKSB8fCB7fTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmlzUnVsZXNldExpa2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZ2VuQ1NTKGNvbnRleHQsIHtcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGNodW5rLCBmaWxlSW5mbywgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Rycy5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc3Rycy5qb2luKCcnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmdlbkNTUyA9IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuX29wZXJhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgb3AsIGEsIGIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6IHJldHVybiBhICsgYjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOiByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcqJzogcmV0dXJuIGEgKiBiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6IHJldHVybiBhIC8gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuZnJvdW5kID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBjb250ZXh0ICYmIGNvbnRleHQubnVtUHJlY2lzaW9uO1xyXG4gICAgICAgICAgICAvLyBhZGQgXCJlcHNpbG9uXCIgdG8gZW5zdXJlIG51bWJlcnMgbGlrZSAxLjAwMDAwMDAwNSAocmVwcmVzZW50ZWQgYXMgMS4wMDAwMDAwMDQ5OTkuLi4pIGFyZSBwcm9wZXJseSByb3VuZGVkOlxyXG4gICAgICAgICAgICByZXR1cm4gKHByZWNpc2lvbikgPyBOdW1iZXIoKHZhbHVlICsgMmUtMTYpLnRvRml4ZWQocHJlY2lzaW9uKSkgOiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIC8qIHJldHVybnM6XHJcbiAgICAgICAgICAgICAtMTogYSA8IGJcclxuICAgICAgICAgICAgIDA6IGEgPSBiXHJcbiAgICAgICAgICAgICAxOiBhID4gYlxyXG4gICAgICAgICAgICAgYW5kICphbnkqIG90aGVyIHZhbHVlIGZvciBhICE9IGIgKGUuZy4gdW5kZWZpbmVkLCBOYU4sIC0yIGV0Yy4pICovXHJcbiAgICAgICAgICAgIGlmICgoYS5jb21wYXJlKSAmJlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIFwic3ltbWV0cmljIHJlc3VsdHNcIiBmb3JjZSB0b0NTUy1iYXNlZCBjb21wYXJpc29uXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBRdW90ZWQgb3IgQW5vbnltb3VzIGlmIGVpdGhlciB2YWx1ZSBpcyBvbmUgb2YgdGhvc2VcclxuICAgICAgICAgICAgICAgICEoYi50eXBlID09PSAnUXVvdGVkJyB8fCBiLnR5cGUgPT09ICdBbm9ueW1vdXMnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuY29tcGFyZShiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChiLmNvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtYi5jb21wYXJlKGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEgPSBhLnZhbHVlO1xyXG4gICAgICAgICAgICBiID0gYi52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChOb2RlLmNvbXBhcmUoYVtpXSwgYltpXSkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTm9kZS5udW1lcmljQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xXHJcbiAgICAgICAgICAgICAgICA6IGEgPT09IGIgPyAwXHJcbiAgICAgICAgICAgICAgICAgICAgOiBhID4gYiA/IDEgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIHJlcHJlc2VudHMgcm9vdCBvZiBhc3QgaW1wb3J0ZWQgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuYmxvY2tzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2liaWxpdHlCbG9ja3MgIT09IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5hZGRWaXNpYmlsaXR5QmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2liaWxpdHlCbG9ja3MgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSB0aGlzLnZpc2liaWxpdHlCbG9ja3MgKyAxO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUucmVtb3ZlVmlzaWJpbGl0eUJsb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52aXNpYmlsaXR5QmxvY2tzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gdGhpcy52aXNpYmlsaXR5QmxvY2tzIC0gMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFR1cm5zIG9uIG5vZGUgdmlzaWJpbGl0eSAtIGlmIGNhbGxlZCBub2RlIHdpbGwgYmUgc2hvd24gaW4gb3V0cHV0IHJlZ2FyZGxlc3NcclxuICAgICAgICAvLyBvZiB3aGV0aGVyIGl0IGNvbWVzIGZyb20gaW1wb3J0IGJ5IHJlZmVyZW5jZSBvciBub3RcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5lbnN1cmVWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFR1cm5zIG9mZiBub2RlIHZpc2liaWxpdHkgLSBpZiBjYWxsZWQgbm9kZSB3aWxsIE5PVCBiZSBzaG93biBpbiBvdXRwdXQgcmVnYXJkbGVzc1xyXG4gICAgICAgIC8vIG9mIHdoZXRoZXIgaXQgY29tZXMgZnJvbSBpbXBvcnQgYnkgcmVmZXJlbmNlIG9yIG5vdFxyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmVuc3VyZUludmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlczpcclxuICAgICAgICAvLyBmYWxzZSAtIHRoZSBub2RlIG11c3Qgbm90IGJlIHZpc2libGVcclxuICAgICAgICAvLyB0cnVlIC0gdGhlIG5vZGUgbXVzdCBiZSB2aXNpYmxlXHJcbiAgICAgICAgLy8gdW5kZWZpbmVkIG9yIG51bGwgLSB0aGUgbm9kZSBoYXMgdGhlIHNhbWUgdmlzaWJpbGl0eSBhcyBpdHMgcGFyZW50XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlVmlzaWJsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnZpc2liaWxpdHlJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUJsb2NrczogdGhpcy52aXNpYmlsaXR5QmxvY2tzLFxyXG4gICAgICAgICAgICAgICAgbm9kZVZpc2libGU6IHRoaXMubm9kZVZpc2libGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmNvcHlWaXNpYmlsaXR5SW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IGluZm8udmlzaWJpbGl0eUJsb2NrcztcclxuICAgICAgICAgICAgdGhpcy5ub2RlVmlzaWJsZSA9IGluZm8ubm9kZVZpc2libGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTm9kZTtcclxuICAgIH0oKSk7XG5cbiAgICAvL1xyXG4gICAgLy8gUkdCIENvbG9ycyAtICNmZjAwMTQsICNlZWVcclxuICAgIC8vXHJcbiAgICB2YXIgQ29sb3IgPSBmdW5jdGlvbiAocmdiLCBhLCBvcmlnaW5hbEZvcm0pIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGUgZW5kIGdvYWwgaGVyZSwgaXMgdG8gcGFyc2UgdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgIC8vIGludG8gYW4gaW50ZWdlciB0cmlwbGV0LCBzdWNoIGFzIGAxMjgsIDI1NSwgMGBcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoaXMgZmFjaWxpdGF0ZXMgb3BlcmF0aW9ucyBhbmQgY29udmVyc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZ2IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmdiID0gcmdiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZ2IubGVuZ3RoID49IDYpIHtcclxuICAgICAgICAgICAgdGhpcy5yZ2IgPSBbXTtcclxuICAgICAgICAgICAgcmdiLm1hdGNoKC8uezJ9L2cpLm1hcChmdW5jdGlvbiAoYywgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZ2IucHVzaChwYXJzZUludChjLCAxNikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHBoYSA9IChwYXJzZUludChjLCAxNikpIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmdiID0gW107XHJcbiAgICAgICAgICAgIHJnYi5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJnYi5wdXNoKHBhcnNlSW50KGMgKyBjLCAxNikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHBoYSA9IChwYXJzZUludChjICsgYywgMTYpKSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWxwaGEgPSB0aGlzLmFscGhhIHx8ICh0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogMSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbEZvcm0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvcmlnaW5hbEZvcm07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbG9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdDb2xvcicsXHJcbiAgICAgICAgbHVtYTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LCBnID0gdGhpcy5yZ2JbMV0gLyAyNTUsIGIgPSB0aGlzLnJnYlsyXSAvIDI1NTtcclxuICAgICAgICAgICAgciA9IChyIDw9IDAuMDM5MjgpID8gciAvIDEyLjkyIDogTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xyXG4gICAgICAgICAgICBnID0gKGcgPD0gMC4wMzkyOCkgPyBnIC8gMTIuOTIgOiBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XHJcbiAgICAgICAgICAgIGIgPSAoYiA8PSAwLjAzOTI4KSA/IGIgLyAxMi45MiA6IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcclxuICAgICAgICAgICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMudG9DU1MoY29udGV4dCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBkb05vdENvbXByZXNzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wcmVzcyA9IGNvbnRleHQgJiYgY29udGV4dC5jb21wcmVzcyAmJiAhZG9Ob3RDb21wcmVzcztcclxuICAgICAgICAgICAgdmFyIGNvbG9yO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGE7XHJcbiAgICAgICAgICAgIHZhciBjb2xvckZ1bmN0aW9uO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBgdmFsdWVgIGlzIHNldCBpZiB0aGlzIGNvbG9yIHdhcyBvcmlnaW5hbGx5XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnRlZCBmcm9tIGEgbmFtZWQgY29sb3Igc3RyaW5nIHNvIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gcmVzcGVjdCB0aGlzIGFuZCB0cnkgdG8gb3V0cHV0IG5hbWVkIGNvbG9yIHRvby5cclxuICAgICAgICAgICAgYWxwaGEgPSB0aGlzLmZyb3VuZChjb250ZXh0LCB0aGlzLmFscGhhKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmluZGV4T2YoJ3JnYicpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckZ1bmN0aW9uID0gJ3JnYmEnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWUuaW5kZXhPZignaHNsJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRnVuY3Rpb24gPSAnaHNsYSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckZ1bmN0aW9uID0gJ2hzbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JGdW5jdGlvbiA9ICdyZ2JhJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvbG9yRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLnJnYi5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGgucm91bmQoYyksIDI1NSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY29uY2F0KGNsYW1wKGFscGhhLCAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2xhbXAoYWxwaGEsIDEpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRvSFNMKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm91bmQoY29udGV4dCwgY29sb3IuaCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvdW5kKGNvbnRleHQsIGNvbG9yLnMgKiAxMDApICsgXCIlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvdW5kKGNvbnRleHQsIGNvbG9yLmwgKiAxMDApICsgXCIlXCJcclxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29sb3JGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gVmFsdWVzIGFyZSBjYXBwZWQgYmV0d2VlbiBgMGAgYW5kIGAyNTVgLCByb3VuZGVkIGFuZCB6ZXJvLXBhZGRlZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9uICsgXCIoXCIgKyBhcmdzLmpvaW4oXCIsXCIgKyAoY29tcHJlc3MgPyAnJyA6ICcgJykpICsgXCIpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRvUkdCKCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wcmVzcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0Y29sb3IgPSBjb2xvci5zcGxpdCgnJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGNvbG9yIHRvIHNob3J0IGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0Y29sb3JbMV0gPT09IHNwbGl0Y29sb3JbMl0gJiYgc3BsaXRjb2xvclszXSA9PT0gc3BsaXRjb2xvcls0XSAmJiBzcGxpdGNvbG9yWzVdID09PSBzcGxpdGNvbG9yWzZdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBcIiNcIiArIHNwbGl0Y29sb3JbMV0gKyBzcGxpdGNvbG9yWzNdICsgc3BsaXRjb2xvcls1XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaGF2ZSB0byBiZSBkb25lIHBlci1jaGFubmVsLCBpZiBub3QsXHJcbiAgICAgICAgLy8gY2hhbm5lbHMgd2lsbCBzcGlsbCBvbnRvIGVhY2ggb3RoZXIuIE9uY2Ugd2UgaGF2ZVxyXG4gICAgICAgIC8vIG91ciByZXN1bHQsIGluIHRoZSBmb3JtIG9mIGFuIGludGVnZXIgdHJpcGxldCxcclxuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBuZXcgQ29sb3Igbm9kZSB0byBob2xkIHRoZSByZXN1bHQuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBvcGVyYXRlOiBmdW5jdGlvbiAoY29udGV4dCwgb3AsIG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZ2IgPSBuZXcgQXJyYXkoMyk7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHRoaXMuYWxwaGEgKiAoMSAtIG90aGVyLmFscGhhKSArIG90aGVyLmFscGhhO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDM7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgcmdiW2NdID0gdGhpcy5fb3BlcmF0ZShjb250ZXh0LCBvcCwgdGhpcy5yZ2JbY10sIG90aGVyLnJnYltjXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IsIGFscGhhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvUkdCOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b0hleCh0aGlzLnJnYik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0hTTDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LCBnID0gdGhpcy5yZ2JbMV0gLyAyNTUsIGIgPSB0aGlzLnJnYlsyXSAvIDI1NSwgYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICAgICAgICAgIHZhciBoO1xyXG4gICAgICAgICAgICB2YXIgcztcclxuICAgICAgICAgICAgdmFyIGwgPSAobWF4ICsgbWluKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcclxuICAgICAgICAgICAgICAgIGggPSBzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGggLz0gNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBoOiBoICogMzYwLCBzOiBzLCBsOiBsLCBhOiBhIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBBZGFwdGVkIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxyXG4gICAgICAgIHRvSFNWOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5yZ2JbMF0gLyAyNTUsIGcgPSB0aGlzLnJnYlsxXSAvIDI1NSwgYiA9IHRoaXMucmdiWzJdIC8gMjU1LCBhID0gdGhpcy5hbHBoYTtcclxuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciBzO1xyXG4gICAgICAgICAgICB2YXIgdiA9IG1heDtcclxuICAgICAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHMgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcyA9IGQgLyBtYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGggLz0gNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBoOiBoICogMzYwLCBzOiBzLCB2OiB2LCBhOiBhIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0FSR0I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvSGV4KFt0aGlzLmFscGhhICogMjU1XS5jb25jYXQodGhpcy5yZ2IpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoeC5yZ2IgJiZcclxuICAgICAgICAgICAgICAgIHgucmdiWzBdID09PSB0aGlzLnJnYlswXSAmJlxyXG4gICAgICAgICAgICAgICAgeC5yZ2JbMV0gPT09IHRoaXMucmdiWzFdICYmXHJcbiAgICAgICAgICAgICAgICB4LnJnYlsyXSA9PT0gdGhpcy5yZ2JbMl0gJiZcclxuICAgICAgICAgICAgICAgIHguYWxwaGEgPT09IHRoaXMuYWxwaGEpID8gMCA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIENvbG9yLmZyb21LZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICB2YXIga2V5ID0ga2V5d29yZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBjID0gbmV3IENvbG9yKGNvbG9yc1trZXldLnNsaWNlKDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAndHJhbnNwYXJlbnQnKSB7XHJcbiAgICAgICAgICAgIGMgPSBuZXcgQ29sb3IoWzAsIDAsIDBdLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGMpIHtcclxuICAgICAgICAgICAgYy52YWx1ZSA9IGtleXdvcmQ7XHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBjbGFtcCh2LCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodiwgMCksIG1heCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0b0hleCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgdi5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgYyA9IGNsYW1wKE1hdGgucm91bmQoYyksIDI1NSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYyA8IDE2ID8gJzAnIDogJycpICsgYy50b1N0cmluZygxNik7XHJcbiAgICAgICAgfSkuam9pbignJyk7XHJcbiAgICB9XG5cbiAgICB2YXIgUGFyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBub2RlO1xyXG4gICAgfTtcclxuICAgIFBhcmVuLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdQYXJlbicsXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoJygnKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCgnKScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJlbih0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIF9ub1NwYWNlQ29tYmluYXRvcnMgPSB7XHJcbiAgICAgICAgJyc6IHRydWUsXHJcbiAgICAgICAgJyAnOiB0cnVlLFxyXG4gICAgICAgICd8JzogdHJ1ZVxyXG4gICAgfTtcclxuICAgIHZhciBDb21iaW5hdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAnICcpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcgJztcclxuICAgICAgICAgICAgdGhpcy5lbXB0eU9yV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUgPyB2YWx1ZS50cmltKCkgOiAnJztcclxuICAgICAgICAgICAgdGhpcy5lbXB0eU9yV2hpdGVzcGFjZSA9IHRoaXMudmFsdWUgPT09ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb21iaW5hdG9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdDb21iaW5hdG9yJyxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIHNwYWNlT3JFbXB0eSA9IChjb250ZXh0LmNvbXByZXNzIHx8IF9ub1NwYWNlQ29tYmluYXRvcnNbdGhpcy52YWx1ZV0pID8gJycgOiAnICc7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoc3BhY2VPckVtcHR5ICsgdGhpcy52YWx1ZSArIHNwYWNlT3JFbXB0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChjb21iaW5hdG9yLCB2YWx1ZSwgaXNWYXJpYWJsZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLmNvbWJpbmF0b3IgPSBjb21iaW5hdG9yIGluc3RhbmNlb2YgQ29tYmluYXRvciA/XHJcbiAgICAgICAgICAgIGNvbWJpbmF0b3IgOiBuZXcgQ29tYmluYXRvcihjb21iaW5hdG9yKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUudHJpbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNWYXJpYWJsZSA9IGlzVmFyaWFibGU7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5jb21iaW5hdG9yLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdFbGVtZW50JyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29tYmluYXRvciA9IHZpc2l0b3IudmlzaXQodGhpcy5jb21iaW5hdG9yKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KHRoaXMuY29tYmluYXRvciwgdGhpcy52YWx1ZS5ldmFsID8gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpIDogdGhpcy52YWx1ZSwgdGhpcy5pc1ZhcmlhYmxlLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzLmNvbWJpbmF0b3IsIHRoaXMudmFsdWUsIHRoaXMuaXNWYXJpYWJsZSwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnRvQ1NTKGNvbnRleHQpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0NTUzogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwge307XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFNlbGVjdG9yID0gY29udGV4dC5maXJzdFNlbGVjdG9yO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQYXJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0b3IgaW4gcGFyZW5zIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgb3V0ZXIgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIC8vIGZsYWdzIChicmVha3Mgb25seSBpbnRlcnBvbGF0ZWQgc2VsZWN0b3JzIC0gc2VlICMxOTczKVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maXJzdFNlbGVjdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQ1NTID8gdmFsdWUudG9DU1MoY29udGV4dCkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgY29udGV4dC5maXJzdFNlbGVjdG9yID0gZmlyc3RTZWxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiB0aGlzLmNvbWJpbmF0b3IudmFsdWUuY2hhckF0KDApID09PSAnJicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbWJpbmF0b3IudG9DU1MoY29udGV4dCkgKyB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIE1hdGgkMSA9IHtcclxuICAgICAgICBBTFdBWVM6IDAsXHJcbiAgICAgICAgUEFSRU5TX0RJVklTSU9OOiAxLFxyXG4gICAgICAgIFBBUkVOUzogMlxyXG4gICAgICAgIC8vIHJlbW92ZWQgLSBTVFJJQ1RfTEVHQUNZOiAzXHJcbiAgICB9O1xyXG4gICAgdmFyIFJld3JpdGVVcmxzID0ge1xyXG4gICAgICAgIE9GRjogMCxcclxuICAgICAgICBMT0NBTDogMSxcclxuICAgICAgICBBTEw6IDJcclxuICAgIH07XG5cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCB0eXBlIG9mIHRoZSBnaXZlbiBwYXlsb2FkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRUeXBlKHBheWxvYWQpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBheWxvYWQpLnNsaWNlKDgsIC0xKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgKGV4Y2x1ZGluZyBzcGVjaWFsIGNsYXNzZXMgb3Igb2JqZWN0cyB3aXRoIG90aGVyIHByb3RvdHlwZXMpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBwYXlsb2FkXHJcbiAgICAgKiBAcmV0dXJucyB7cGF5bG9hZCBpcyBSZWNvcmQ8c3RyaW5nLCBhbnk+fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHBheWxvYWQpIHtcclxuICAgICAgICBpZiAoZ2V0VHlwZShwYXlsb2FkKSAhPT0gJ09iamVjdCcpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXlsb2FkKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IHBheWxvYWRcclxuICAgICAqIEByZXR1cm5zIHtwYXlsb2FkIGlzIGFueVtdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KHBheWxvYWQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0VHlwZShwYXlsb2FkKSA9PT0gJ0FycmF5JztcclxuICAgIH1cblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgICBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICAgIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICAgIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICAgIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbiAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NpZ25Qcm9wKGNhcnJ5LCBrZXksIG5ld1ZhbCwgb3JpZ2luYWxPYmplY3QsIGluY2x1ZGVOb25lbnVtZXJhYmxlKSB7XHJcbiAgICAgICAgdmFyIHByb3BUeXBlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvcmlnaW5hbE9iamVjdCwga2V5KVxyXG4gICAgICAgICAgICA/ICdlbnVtZXJhYmxlJ1xyXG4gICAgICAgICAgICA6ICdub25lbnVtZXJhYmxlJztcclxuICAgICAgICBpZiAocHJvcFR5cGUgPT09ICdlbnVtZXJhYmxlJylcclxuICAgICAgICAgICAgY2Fycnlba2V5XSA9IG5ld1ZhbDtcclxuICAgICAgICBpZiAoaW5jbHVkZU5vbmVudW1lcmFibGUgJiYgcHJvcFR5cGUgPT09ICdub25lbnVtZXJhYmxlJykge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FycnksIGtleSwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbCxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29weSAoY2xvbmUpIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wcyByZWN1cnNpdmVseSB0byBnZXQgcmlkIG9mIGFueSBwcm9wIHJlZmVyZW5jZWQgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gQXJyYXlzIGFyZSBhbHNvIGNsb25lZCwgaG93ZXZlciBvYmplY3RzIGluc2lkZSBhcnJheXMgYXJlIHN0aWxsIGxpbmtlZC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhwb3J0XHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtUfSB0YXJnZXQgVGFyZ2V0IGNhbiBiZSBhbnl0aGluZ1xyXG4gICAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBjYW4gYmUgYHByb3BzYCBvciBgbm9uZW51bWVyYWJsZWBcclxuICAgICAqIEByZXR1cm5zIHtUfSB0aGUgdGFyZ2V0IHdpdGggcmVwbGFjZWQgdmFsdWVzXHJcbiAgICAgKiBAZXhwb3J0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gY29weShpLCBvcHRpb25zKTsgfSk7XHJcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcclxuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KTtcclxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheXMocHJvcHMsIHN5bWJvbHMpLnJlZHVjZShmdW5jdGlvbiAoY2FycnksIGtleSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zLnByb3BzKSAmJiAhb3B0aW9ucy5wcm9wcy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICB2YXIgbmV3VmFsID0gY29weSh2YWwsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBhc3NpZ25Qcm9wKGNhcnJ5LCBrZXksIG5ld1ZhbCwgdGFyZ2V0LCBvcHRpb25zLm5vbmVudW1lcmFibGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2Fycnk7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfVxuXG4gICAgLyoganNoaW50IHByb3RvOiB0cnVlICovXHJcbiAgICBmdW5jdGlvbiBnZXRMb2NhdGlvbihpbmRleCwgaW5wdXRTdHJlYW0pIHtcclxuICAgICAgICB2YXIgbiA9IGluZGV4ICsgMTtcclxuICAgICAgICB2YXIgbGluZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGNvbHVtbiA9IC0xO1xyXG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCAmJiBpbnB1dFN0cmVhbS5jaGFyQXQobikgIT09ICdcXG4nKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBsaW5lID0gKGlucHV0U3RyZWFtLnNsaWNlKDAsIGluZGV4KS5tYXRjaCgvXFxuL2cpIHx8ICcnKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXHJcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShhcnIpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3B5W2ldID0gYXJyW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gICAgICAgIHZhciBjbG9uZWQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKG9iajEsIG9iajIpIHtcclxuICAgICAgICB2YXIgbmV3T2JqID0gb2JqMiB8fCB7fTtcclxuICAgICAgICBpZiAoIW9iajIuX2RlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIG5ld09iaiA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHNfMSA9IGNvcHkob2JqMSk7XHJcbiAgICAgICAgICAgIG5ld09iai5fZGVmYXVsdHMgPSBkZWZhdWx0c18xO1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVkID0gb2JqMiA/IGNvcHkob2JqMikgOiB7fTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdPYmosIGRlZmF1bHRzXzEsIGNsb25lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb3B5T3B0aW9ucyhvYmoxLCBvYmoyKSB7XHJcbiAgICAgICAgaWYgKG9iajIgJiYgb2JqMi5fZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRzID0gZGVmYXVsdHMob2JqMSwgb2JqMik7XHJcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0TWF0aCkge1xyXG4gICAgICAgICAgICBvcHRzLm1hdGggPSBNYXRoJDEuUEFSRU5TO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCYWNrIGNvbXBhdCB3aXRoIGNoYW5nZWQgcmVsYXRpdmVVcmxzIG9wdGlvblxyXG4gICAgICAgIGlmIChvcHRzLnJlbGF0aXZlVXJscykge1xyXG4gICAgICAgICAgICBvcHRzLnJld3JpdGVVcmxzID0gUmV3cml0ZVVybHMuQUxMO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChvcHRzLm1hdGgudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLm1hdGggPSBNYXRoJDEuQUxXQVlTO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncGFyZW5zLWRpdmlzaW9uJzpcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLm1hdGggPSBNYXRoJDEuUEFSRU5TX0RJVklTSU9OO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaWN0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmVucyc6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5tYXRoID0gTWF0aCQxLlBBUkVOUztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5tYXRoID0gTWF0aCQxLlBBUkVOUztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9wdHMucmV3cml0ZVVybHMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3B0cy5yZXdyaXRlVXJscy50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdvZmYnOlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMucmV3cml0ZVVybHMgPSBSZXdyaXRlVXJscy5PRkY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb2NhbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5yZXdyaXRlVXJscyA9IFJld3JpdGVVcmxzLkxPQ0FMO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYWxsJzpcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLnJld3JpdGVVcmxzID0gUmV3cml0ZVVybHMuQUxMO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqMSwgb2JqMikge1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqMikge1xyXG4gICAgICAgICAgICBpZiAob2JqMi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqMVtwcm9wXSA9IG9iajJbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmbGF0dGVuQXJyYXkoYXJyLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gW107IH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBhcnIubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KHZhbHVlLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cblxuICAgIHZhciB1dGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBnZXRMb2NhdGlvbjogZ2V0TG9jYXRpb24sXG4gICAgICAgIGNvcHlBcnJheTogY29weUFycmF5LFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgY29weU9wdGlvbnM6IGNvcHlPcHRpb25zLFxuICAgICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICAgIGZsYXR0ZW5BcnJheTogZmxhdHRlbkFycmF5XG4gICAgfSk7XG5cbiAgICB2YXIgYW5vbnltb3VzRnVuYyA9IC8oPGFub255bW91cz58RnVuY3Rpb24pOihcXGQrKTooXFxkKykvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGEgY2VudHJhbGl6ZWQgY2xhc3Mgb2YgYW55IGVycm9yIHRoYXQgY291bGQgYmUgdGhyb3duIGludGVybmFsbHkgKG1vc3RseSBieSB0aGUgcGFyc2VyKS5cclxuICAgICAqIEJlc2lkZXMgc3RhbmRhcmQgLm1lc3NhZ2UgaXQga2VlcHMgc29tZSBhZGRpdGlvbmFsIGRhdGEgbGlrZSBhIHBhdGggdG8gdGhlIGZpbGUgd2hlcmUgdGhlIGVycm9yXHJcbiAgICAgKiBvY2N1cnJlZCBhbG9uZyB3aXRoIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICogQGV4dGVuZHMgRXJyb3JcclxuICAgICAqIEB0eXBlIHttb2R1bGUuTGVzc0Vycm9yfVxyXG4gICAgICpcclxuICAgICAqIEBwcm9wIHtzdHJpbmd9IHR5cGVcclxuICAgICAqIEBwcm9wIHtzdHJpbmd9IGZpbGVuYW1lXHJcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBpbmRleFxyXG4gICAgICogQHByb3Age251bWJlcn0gbGluZVxyXG4gICAgICogQHByb3Age251bWJlcn0gY29sdW1uXHJcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBjYWxsTGluZVxyXG4gICAgICogQHByb3Age251bWJlcn0gY2FsbEV4dHJhY3RcclxuICAgICAqIEBwcm9wIHtzdHJpbmdbXX0gZXh0cmFjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlICAgICAgICAgICAgICAtIEFuIGVycm9yIG9iamVjdCB0byB3cmFwIGFyb3VuZCBvciBqdXN0IGEgZGVzY3JpcHRpdmUgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZUNvbnRlbnRNYXAgLSBBbiBvYmplY3Qgd2l0aCBmaWxlIGNvbnRlbnRzIGluICdjb250ZW50cycgcHJvcGVydHkgKGxpa2UgaW1wb3J0TWFuYWdlcikgQHRvZG8gLSBtb3ZlIHRvIGZpbGVNYW5hZ2VyP1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJyZW50RmlsZW5hbWVdXHJcbiAgICAgKi9cclxuICAgIHZhciBMZXNzRXJyb3IgPSBmdW5jdGlvbiAoZSwgZmlsZUNvbnRlbnRNYXAsIGN1cnJlbnRGaWxlbmFtZSkge1xyXG4gICAgICAgIEVycm9yLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZS5maWxlbmFtZSB8fCBjdXJyZW50RmlsZW5hbWU7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZS5tZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xyXG4gICAgICAgIGlmIChmaWxlQ29udGVudE1hcCAmJiBmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlQ29udGVudE1hcC5jb250ZW50c1tmaWxlbmFtZV07XHJcbiAgICAgICAgICAgIHZhciBsb2MgPSBnZXRMb2NhdGlvbihlLmluZGV4LCBpbnB1dCk7XHJcbiAgICAgICAgICAgIHZhciBsaW5lID0gbG9jLmxpbmU7XHJcbiAgICAgICAgICAgIHZhciBjb2wgPSBsb2MuY29sdW1uO1xyXG4gICAgICAgICAgICB2YXIgY2FsbExpbmUgPSBlLmNhbGwgJiYgZ2V0TG9jYXRpb24oZS5jYWxsLCBpbnB1dCkubGluZTtcclxuICAgICAgICAgICAgdmFyIGxpbmVzID0gaW5wdXQgPyBpbnB1dC5zcGxpdCgnXFxuJykgOiAnJztcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gZS50eXBlIHx8ICdTeW50YXgnO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBlLmluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUgPSB0eXBlb2YgbGluZSA9PT0gJ251bWJlcicgPyBsaW5lICsgMSA6IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1uID0gY29sO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubGluZSAmJiB0aGlzLnN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSB0aGlzLnN0YWNrLm1hdGNoKGFub255bW91c0Z1bmMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93IHRoaXMgZW52aXJvbm1lbnQgc3RyaW5naWZpZXMgYW5vbnltb3VzIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogc28gd2UgY2FuIGNvcnJlY3RseSBtYXAgcGx1Z2luIGVycm9ycy5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlLCBpbiBOb2RlIDgsIHRoZSBvdXRwdXQgb2YgYW5vbnltb3VzIGZ1bmNzIHZhcmllZCBiYXNlZCBvbiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICAgKiBiZWluZyBwcmVzZW50IG9yIG5vdCwgc28gd2UgaW5qZWN0IGR1bW15IHBhcmFtcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb24oJ2EnLCAndGhyb3cgbmV3IEVycm9yKCknKTtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lQWRqdXN0ID0gMDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBlLnN0YWNrLm1hdGNoKGFub255bW91c0Z1bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVBZGp1c3QgPSAxIC0gbGluZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFsyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgPSBwYXJzZUludChmb3VuZFsyXSkgKyBsaW5lQWRqdXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRbM10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gPSBwYXJzZUludChmb3VuZFszXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbExpbmUgPSBjYWxsTGluZSArIDE7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbEV4dHJhY3QgPSBsaW5lc1tjYWxsTGluZV07XHJcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdCA9IFtcclxuICAgICAgICAgICAgICAgIGxpbmVzW3RoaXMubGluZSAtIDJdLFxyXG4gICAgICAgICAgICAgICAgbGluZXNbdGhpcy5saW5lIC0gMV0sXHJcbiAgICAgICAgICAgICAgICBsaW5lc1t0aGlzLmxpbmVdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICBGLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcclxuICAgICAgICBMZXNzRXJyb3IucHJvdG90eXBlID0gbmV3IEYoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIExlc3NFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbiAgICBMZXNzRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVzc0Vycm9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvdmVycmlkZGVuIHZlcnNpb24gb2YgdGhlIGRlZmF1bHQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xyXG4gICAgICogd2hpY2ggdXNlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSBhIGhlbHBmdWwgbWVzc2FnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgTGVzc0Vycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcclxuICAgICAgICB2YXIgZXh0cmFjdCA9IHRoaXMuZXh0cmFjdCB8fCBbXTtcclxuICAgICAgICB2YXIgZXJyb3IgPSBbXTtcclxuICAgICAgICB2YXIgc3R5bGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0cjsgfTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsaXplKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9wdGlvbnMuc3R5bGl6ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwib3B0aW9ucy5zdHlsaXplIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBnb3QgYSBcIiArIHR5cGUgKyBcIiFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGl6ZSA9IG9wdGlvbnMuc3R5bGl6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubGluZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhY3RbMF0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvci5wdXNoKHN0eWxpemUodGhpcy5saW5lIC0gMSArIFwiIFwiICsgZXh0cmFjdFswXSwgJ2dyZXknKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYWN0WzFdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yVHh0ID0gdGhpcy5saW5lICsgXCIgXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFjdFsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVHh0ICs9IGV4dHJhY3RbMV0uc2xpY2UoMCwgdGhpcy5jb2x1bW4pICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGl6ZShzdHlsaXplKHN0eWxpemUoZXh0cmFjdFsxXS5zdWJzdHIodGhpcy5jb2x1bW4sIDEpLCAnYm9sZCcpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RbMV0uc2xpY2UodGhpcy5jb2x1bW4gKyAxKSwgJ3JlZCcpLCAnaW52ZXJzZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXJyb3IucHVzaChlcnJvclR4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYWN0WzJdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IucHVzaChzdHlsaXplKHRoaXMubGluZSArIDEgKyBcIiBcIiArIGV4dHJhY3RbMl0sICdncmV5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yID0gZXJyb3Iuam9pbignXFxuJykgKyBzdHlsaXplKCcnLCAncmVzZXQnKSArIFwiXFxuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc3NhZ2UgKz0gc3R5bGl6ZSh0aGlzLnR5cGUgKyBcIkVycm9yOiBcIiArIHRoaXMubWVzc2FnZSwgJ3JlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gc3R5bGl6ZSgnIGluICcsICdyZWQnKSArIHRoaXMuZmlsZW5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxpbmUpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBzdHlsaXplKFwiIG9uIGxpbmUgXCIgKyB0aGlzLmxpbmUgKyBcIiwgY29sdW1uIFwiICsgKHRoaXMuY29sdW1uICsgMSkgKyBcIjpcIiwgJ2dyZXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVzc2FnZSArPSBcIlxcblwiICsgZXJyb3I7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbExpbmUpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBzdHlsaXplKCdmcm9tICcsICdyZWQnKSArICh0aGlzLmZpbGVuYW1lIHx8ICcnKSArIFwiL25cIjtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBzdHlsaXplKHRoaXMuY2FsbExpbmUsICdncmV5JykgKyBcIiBcIiArIHRoaXMuY2FsbEV4dHJhY3QgKyBcIi9uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfTtcblxuICAgIHZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50cywgZXh0ZW5kTGlzdCwgY29uZGl0aW9uLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCB2aXNpYmlsaXR5SW5mbykge1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3Q7XHJcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy5ldmFsZENvbmRpdGlvbiA9ICFjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5nZXRFbGVtZW50cyhlbGVtZW50cyk7XHJcbiAgICAgICAgdGhpcy5taXhpbkVsZW1lbnRzXyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5lbGVtZW50cywgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1NlbGVjdG9yJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMuZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV4dGVuZExpc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kTGlzdCA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmV4dGVuZExpc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25kaXRpb24gPSB2aXNpdG9yLnZpc2l0KHRoaXMuY29uZGl0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlRGVyaXZlZDogZnVuY3Rpb24gKGVsZW1lbnRzLCBleHRlbmRMaXN0LCBldmFsZENvbmRpdGlvbikge1xyXG4gICAgICAgICAgICBlbGVtZW50cyA9IHRoaXMuZ2V0RWxlbWVudHMoZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoZWxlbWVudHMsIGV4dGVuZExpc3QgfHwgdGhpcy5leHRlbmRMaXN0LCBudWxsLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICAgICAgbmV3U2VsZWN0b3IuZXZhbGRDb25kaXRpb24gPSAoZXZhbGRDb25kaXRpb24gIT0gbnVsbCkgPyBldmFsZENvbmRpdGlvbiA6IHRoaXMuZXZhbGRDb25kaXRpb247XHJcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yLm1lZGlhRW1wdHkgPSB0aGlzLm1lZGlhRW1wdHk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTZWxlY3RvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEVsZW1lbnRzOiBmdW5jdGlvbiAoZWxzKSB7XHJcbiAgICAgICAgICAgIGlmICghZWxzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBFbGVtZW50KCcnLCAnJicsIGZhbHNlLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVscyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UucGFyc2VOb2RlKGVscywgWydzZWxlY3RvciddLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZXJyLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5wYXJzZS5pbXBvcnRzLCB0aGlzLl9maWxlSW5mby5maWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVscyA9IHJlc3VsdFswXS5lbGVtZW50cztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVFbXB0eVNlbGVjdG9yczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCgnJywgJyYnLCBmYWxzZSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvKSwgc2VscyA9IFtuZXcgU2VsZWN0b3IoW2VsXSwgbnVsbCwgbnVsbCwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvKV07XHJcbiAgICAgICAgICAgIHNlbHNbMF0ubWVkaWFFbXB0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgb2xlbjtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIG90aGVyID0gb3RoZXIubWl4aW5FbGVtZW50cygpO1xyXG4gICAgICAgICAgICBvbGVuID0gb3RoZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAob2xlbiA9PT0gMCB8fCBsZW4gPCBvbGVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0udmFsdWUgIT09IG90aGVyW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2xlbjsgLy8gcmV0dXJuIG51bWJlciBvZiBtYXRjaGVkIGVsZW1lbnRzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbkVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1peGluRWxlbWVudHNfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXhpbkVsZW1lbnRzXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuY29tYmluYXRvci52YWx1ZSArICh2LnZhbHVlLnZhbHVlIHx8IHYudmFsdWUpO1xyXG4gICAgICAgICAgICB9KS5qb2luKCcnKS5tYXRjaCgvWywmI1xcKlxcLlxcdy1dKFtcXHctXXwoXFxcXC4pKSovZyk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzWzBdID09PSAnJicpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubWl4aW5FbGVtZW50c18gPSBlbGVtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0p1c3RQYXJlbnRTZWxlY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMubWVkaWFFbXB0eSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0udmFsdWUgPT09ICcmJyAmJlxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJyAnIHx8IHRoaXMuZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJycpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGV2YWxkQ29uZGl0aW9uID0gdGhpcy5jb25kaXRpb24gJiYgdGhpcy5jb25kaXRpb24uZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgdmFyIGV4dGVuZExpc3QgPSB0aGlzLmV4dGVuZExpc3Q7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMgJiYgZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmV2YWwoY29udGV4dCk7IH0pO1xyXG4gICAgICAgICAgICBleHRlbmRMaXN0ID0gZXh0ZW5kTGlzdCAmJiBleHRlbmRMaXN0Lm1hcChmdW5jdGlvbiAoZXh0ZW5kKSB7IHJldHVybiBleHRlbmQuZXZhbChjb250ZXh0KTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURlcml2ZWQoZWxlbWVudHMsIGV4dGVuZExpc3QsIGV2YWxkQ29uZGl0aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICB2YXIgaSwgZWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKCghY29udGV4dCB8fCAhY29udGV4dC5maXJzdFNlbGVjdG9yKSAmJiB0aGlzLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCcgJywgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldElzT3V0cHV0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWxkQ29uZGl0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJlcXVpcmVzIGFuIGFycmF5IGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZhbHVlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdWYWx1ZScsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVswXS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh0aGlzLnZhbHVlLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCB0aGlzLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoKGNvbnRleHQgJiYgY29udGV4dC5jb21wcmVzcykgPyAnLCcgOiAnLCAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIEtleXdvcmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgS2V5d29yZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnS2V5d29yZCcsXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJScpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1N5bnRheCcsIG1lc3NhZ2U6ICdJbnZhbGlkICUgd2l0aG91dCBudW1iZXInIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIEtleXdvcmQuVHJ1ZSA9IG5ldyBLZXl3b3JkKCd0cnVlJyk7XHJcbiAgICBLZXl3b3JkLkZhbHNlID0gbmV3IEtleXdvcmQoJ2ZhbHNlJyk7XG5cbiAgICB2YXIgQW5vbnltb3VzID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBtYXBMaW5lcywgcnVsZXNldExpa2UsIHZpc2liaWxpdHlJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5tYXBMaW5lcyA9IG1hcExpbmVzO1xyXG4gICAgICAgIHRoaXMucnVsZXNldExpa2UgPSAodHlwZW9mIHJ1bGVzZXRMaWtlID09PSAndW5kZWZpbmVkJykgPyBmYWxzZSA6IHJ1bGVzZXRMaWtlO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICB9O1xyXG4gICAgQW5vbnltb3VzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdBbm9ueW1vdXMnLFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXModGhpcy52YWx1ZSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLm1hcExpbmVzLCB0aGlzLnJ1bGVzZXRMaWtlLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGFyZTogZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci50b0NTUyAmJiB0aGlzLnRvQ1NTKCkgPT09IG90aGVyLnRvQ1NTKCkgPyAwIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNSdWxlc2V0TGlrZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlc2V0TGlrZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVWaXNpYmxlID0gQm9vbGVhbih0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZVZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSwgdGhpcy5fZmlsZUluZm8sIHRoaXMuX2luZGV4LCB0aGlzLm1hcExpbmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIE1BVEggPSBNYXRoJDE7XHJcbiAgICBmdW5jdGlvbiBldmFsTmFtZShjb250ZXh0LCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIG4gPSBuYW1lLmxlbmd0aDtcclxuICAgICAgICB2YXIgb3V0cHV0ID0geyBhZGQ6IGZ1bmN0aW9uIChzKSB7IHZhbHVlICs9IHM7IH0gfTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5hbWVbaV0uZXZhbChjb250ZXh0KS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBpbXBvcnRhbnQsIG1lcmdlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbmxpbmUsIHZhcmlhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkgPyB2YWx1ZSA6IG5ldyBWYWx1ZShbdmFsdWUgPyBuZXcgQW5vbnltb3VzKHZhbHVlKSA6IG51bGxdKTtcclxuICAgICAgICB0aGlzLmltcG9ydGFudCA9IGltcG9ydGFudCA/IFwiIFwiICsgaW1wb3J0YW50LnRyaW0oKSA6ICcnO1xyXG4gICAgICAgIHRoaXMubWVyZ2UgPSBtZXJnZTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMuaW5saW5lID0gaW5saW5lIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGUgPSAodmFyaWFibGUgIT09IHVuZGVmaW5lZCkgPyB2YXJpYWJsZVxyXG4gICAgICAgICAgICA6IChuYW1lLmNoYXJBdCAmJiAobmFtZS5jaGFyQXQoMCkgPT09ICdAJykpO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnZhbHVlLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBEZWNsYXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnRGVjbGFyYXRpb24nLFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMubmFtZSArIChjb250ZXh0LmNvbXByZXNzID8gJzonIDogJzogJyksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5nZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuaW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgIGUuZmlsZW5hbWUgPSB0aGlzLl9maWxlSW5mby5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLmltcG9ydGFudCArICgodGhpcy5pbmxpbmUgfHwgKGNvbnRleHQubGFzdFJ1bGUgJiYgY29udGV4dC5jb21wcmVzcykpID8gJycgOiAnOycpLCB0aGlzLl9maWxlSW5mbywgdGhpcy5faW5kZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGhCeXBhc3MgPSBmYWxzZSwgcHJldk1hdGgsIG5hbWUgPSB0aGlzLm5hbWUsIGV2YWxkVmFsdWUsIHZhcmlhYmxlID0gdGhpcy52YXJpYWJsZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwYW5kICdwcmltaXRpdmUnIG5hbWUgZGlyZWN0bHkgdG8gZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGluZ3MgZmFzdGVyICh+MTAlIGZvciBiZW5jaG1hcmsubGVzcyk6XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gKG5hbWUubGVuZ3RoID09PSAxKSAmJiAobmFtZVswXSBpbnN0YW5jZW9mIEtleXdvcmQpID9cclxuICAgICAgICAgICAgICAgICAgICBuYW1lWzBdLnZhbHVlIDogZXZhbE5hbWUoY29udGV4dCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IGZhbHNlOyAvLyBuZXZlciB0cmVhdCBleHBhbmRlZCBpbnRlcnBvbGF0aW9uIGFzIG5ldyB2YXJpYWJsZSBuYW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQHRvZG8gcmVtb3ZlIHdoZW4gcGFyZW5zLWRpdmlzaW9uIGlzIGRlZmF1bHRcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdmb250JyAmJiBjb250ZXh0Lm1hdGggPT09IE1BVEguQUxXQVlTKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRoQnlwYXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByZXZNYXRoID0gY29udGV4dC5tYXRoO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5tYXRoID0gTUFUSC5QQVJFTlNfRElWSVNJT047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuaW1wb3J0YW50U2NvcGUucHVzaCh7fSk7XHJcbiAgICAgICAgICAgICAgICBldmFsZFZhbHVlID0gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhcmlhYmxlICYmIGV2YWxkVmFsdWUudHlwZSA9PT0gJ0RldGFjaGVkUnVsZXNldCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdSdWxlc2V0cyBjYW5ub3QgYmUgZXZhbHVhdGVkIG9uIGEgcHJvcGVydHkuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSwgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudCA9IHRoaXMuaW1wb3J0YW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudFJlc3VsdCA9IGNvbnRleHQuaW1wb3J0YW50U2NvcGUucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydGFudCAmJiBpbXBvcnRhbnRSZXN1bHQuaW1wb3J0YW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gaW1wb3J0YW50UmVzdWx0LmltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24obmFtZSwgZXZhbGRWYWx1ZSwgaW1wb3J0YW50LCB0aGlzLm1lcmdlLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5pbmxpbmUsIHZhcmlhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmluZGV4ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5maWxlbmFtZSA9IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0aEJ5cGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWF0aCA9IHByZXZNYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYWtlSW1wb3J0YW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24odGhpcy5uYW1lLCB0aGlzLnZhbHVlLCAnIWltcG9ydGFudCcsIHRoaXMubWVyZ2UsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmlubGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgZGVidWdJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlYnVnSW5mbyhjb250ZXh0LCBjdHgsIGxpbmVTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMgJiYgIWNvbnRleHQuY29tcHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc0NvbW1lbnQoY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWVkaWFxdWVyeSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc01lZGlhUXVlcnkoY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVidWdJbmZvLmFzQ29tbWVudChjdHgpICsgKGxpbmVTZXBhcmF0b3IgfHwgJycpICsgZGVidWdJbmZvLmFzTWVkaWFRdWVyeShjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWJ1Z0luZm8uYXNDb21tZW50ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIvKiBsaW5lIFwiICsgY3R4LmRlYnVnSW5mby5saW5lTnVtYmVyICsgXCIsIFwiICsgY3R4LmRlYnVnSW5mby5maWxlTmFtZSArIFwiICovXFxuXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBkZWJ1Z0luZm8uYXNNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWVXaXRoUHJvdG9jb2wgPSBjdHguZGVidWdJbmZvLmZpbGVOYW1lO1xyXG4gICAgICAgICAgICBpZiAoIS9eW2Etel0rOlxcL1xcLy9pLnRlc3QoZmlsZW5hbWVXaXRoUHJvdG9jb2wpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZVdpdGhQcm90b2NvbCA9IFwiZmlsZTovL1wiICsgZmlsZW5hbWVXaXRoUHJvdG9jb2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiQG1lZGlhIC1zYXNzLWRlYnVnLWluZm97ZmlsZW5hbWV7Zm9udC1mYW1pbHk6XCIgKyBmaWxlbmFtZVdpdGhQcm90b2NvbC5yZXBsYWNlKC8oWy46XFwvXFxcXF0pL2csIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gJ1xcLyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBhO1xyXG4gICAgICAgICAgICB9KSArIFwifWxpbmV7Zm9udC1mYW1pbHk6XFxcXDAwMDAzXCIgKyBjdHguZGVidWdJbmZvLmxpbmVOdW1iZXIgKyBcIn19XFxuXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZGVidWdJbmZvO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBDb21tZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0xpbmVDb21tZW50LCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaXNMaW5lQ29tbWVudCA9IGlzTGluZUNvbW1lbnQ7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ29tbWVudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQ29tbWVudCcsXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZChkZWJ1Z0luZm8oY29udGV4dCwgdGhpcyksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5nZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0NvbXByZXNzZWQgPSBjb250ZXh0LmNvbXByZXNzICYmIHRoaXMudmFsdWVbMl0gIT09ICchJztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNMaW5lQ29tbWVudCB8fCBpc0NvbXByZXNzZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgY29udGV4dHMgPSB7fTtcclxuICAgIHZhciBjb3B5RnJvbU9yaWdpbmFsID0gZnVuY3Rpb24gY29weUZyb21PcmlnaW5hbChvcmlnaW5hbCwgZGVzdGluYXRpb24sIHByb3BlcnRpZXNUb0NvcHkpIHtcclxuICAgICAgICBpZiAoIW9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzVG9Db3B5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0aWVzVG9Db3B5W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydGllc1RvQ29weVtpXV0gPSBvcmlnaW5hbFtwcm9wZXJ0aWVzVG9Db3B5W2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgIHBhcnNlIGlzIHVzZWQgd2hpbHN0IHBhcnNpbmdcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnNlQ29weVByb3BlcnRpZXMgPSBbXHJcbiAgICAgICAgLy8gb3B0aW9uc1xyXG4gICAgICAgICdwYXRocycsXHJcbiAgICAgICAgJ3Jld3JpdGVVcmxzJyxcclxuICAgICAgICAncm9vdHBhdGgnLFxyXG4gICAgICAgICdzdHJpY3RJbXBvcnRzJyxcclxuICAgICAgICAnaW5zZWN1cmUnLFxyXG4gICAgICAgICdkdW1wTGluZU51bWJlcnMnLFxyXG4gICAgICAgICdjb21wcmVzcycsXHJcbiAgICAgICAgJ3N5bmNJbXBvcnQnLFxyXG4gICAgICAgICdjaHVua0lucHV0JyxcclxuICAgICAgICAnbWltZScsXHJcbiAgICAgICAgJ3VzZUZpbGVDYWNoZScsXHJcbiAgICAgICAgLy8gY29udGV4dFxyXG4gICAgICAgICdwcm9jZXNzSW1wb3J0cycsXHJcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgaW1wb3J0IG1hbmFnZXIgdG8gc3RvcCBtdWx0aXBsZSBpbXBvcnQgdmlzaXRvcnMgYmVpbmcgY3JlYXRlZC5cclxuICAgICAgICAncGx1Z2luTWFuYWdlcicgLy8gVXNlZCBhcyB0aGUgcGx1Z2luIG1hbmFnZXIgZm9yIHRoZSBzZXNzaW9uXHJcbiAgICBdO1xyXG4gICAgY29udGV4dHMuUGFyc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGNvcHlGcm9tT3JpZ2luYWwob3B0aW9ucywgdGhpcywgcGFyc2VDb3B5UHJvcGVydGllcyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhdGhzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhzID0gW3RoaXMucGF0aHNdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgZXZhbENvcHlQcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgICdwYXRocycsXHJcbiAgICAgICAgJ2NvbXByZXNzJyxcclxuICAgICAgICAnbWF0aCcsXHJcbiAgICAgICAgJ3N0cmljdFVuaXRzJyxcclxuICAgICAgICAnc291cmNlTWFwJyxcclxuICAgICAgICAnaW1wb3J0TXVsdGlwbGUnLFxyXG4gICAgICAgICd1cmxBcmdzJyxcclxuICAgICAgICAnamF2YXNjcmlwdEVuYWJsZWQnLFxyXG4gICAgICAgICdwbHVnaW5NYW5hZ2VyJyxcclxuICAgICAgICAnaW1wb3J0YW50U2NvcGUnLFxyXG4gICAgICAgICdyZXdyaXRlVXJscycgLy8gb3B0aW9uIC0gd2hldGhlciB0byBhZGp1c3QgVVJMJ3MgdG8gYmUgcmVsYXRpdmVcclxuICAgIF07XHJcbiAgICBjb250ZXh0cy5FdmFsID0gZnVuY3Rpb24gKG9wdGlvbnMsIGZyYW1lcykge1xyXG4gICAgICAgIGNvcHlGcm9tT3JpZ2luYWwob3B0aW9ucywgdGhpcywgZXZhbENvcHlQcm9wZXJ0aWVzKTtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucGF0aHMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aHMgPSBbdGhpcy5wYXRoc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuaW1wb3J0YW50U2NvcGUgPSB0aGlzLmltcG9ydGFudFNjb3BlIHx8IFtdO1xyXG4gICAgfTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLmVudGVyQ2FsYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2FsY1N0YWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1N0YWNrID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsY1N0YWNrLnB1c2godHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5pbkNhbGMgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLmV4aXRDYWxjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsY1N0YWNrLnBvcCgpO1xyXG4gICAgICAgIGlmICghdGhpcy5jYWxjU3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5DYWxjID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLmluUGFyZW50aGVzaXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVuc1N0YWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW5zU3RhY2sgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJlbnNTdGFjay5wdXNoKHRydWUpO1xyXG4gICAgfTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLm91dE9mUGFyZW50aGVzaXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnNTdGFjay5wb3AoKTtcclxuICAgIH07XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5pbkNhbGMgPSBmYWxzZTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLm1hdGhPbiA9IHRydWU7XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5pc01hdGhPbiA9IGZ1bmN0aW9uIChvcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tYXRoT24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3AgPT09ICcvJyAmJiB0aGlzLm1hdGggIT09IE1hdGgkMS5BTFdBWVMgJiYgKCF0aGlzLnBhcmVuc1N0YWNrIHx8ICF0aGlzLnBhcmVuc1N0YWNrLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYXRoID4gTWF0aCQxLlBBUkVOU19ESVZJU0lPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnNTdGFjayAmJiB0aGlzLnBhcmVuc1N0YWNrLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgY29udGV4dHMuRXZhbC5wcm90b3R5cGUucGF0aFJlcXVpcmVzUmV3cml0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgdmFyIGlzUmVsYXRpdmUgPSB0aGlzLnJld3JpdGVVcmxzID09PSBSZXdyaXRlVXJscy5MT0NBTCA/IGlzUGF0aExvY2FsUmVsYXRpdmUgOiBpc1BhdGhSZWxhdGl2ZTtcclxuICAgICAgICByZXR1cm4gaXNSZWxhdGl2ZShwYXRoKTtcclxuICAgIH07XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5yZXdyaXRlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByb290cGF0aCkge1xyXG4gICAgICAgIHZhciBuZXdQYXRoO1xyXG4gICAgICAgIHJvb3RwYXRoID0gcm9vdHBhdGggfHwgJyc7XHJcbiAgICAgICAgbmV3UGF0aCA9IHRoaXMubm9ybWFsaXplUGF0aChyb290cGF0aCArIHBhdGgpO1xyXG4gICAgICAgIC8vIElmIGEgcGF0aCB3YXMgZXhwbGljaXQgcmVsYXRpdmUgYW5kIHRoZSByb290cGF0aCB3YXMgbm90IGFuIGFic29sdXRlIHBhdGhcclxuICAgICAgICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHRoZSBuZXcgcGF0aCBpcyBhbHNvIGV4cGxpY2l0IHJlbGF0aXZlLlxyXG4gICAgICAgIGlmIChpc1BhdGhMb2NhbFJlbGF0aXZlKHBhdGgpICYmXHJcbiAgICAgICAgICAgIGlzUGF0aFJlbGF0aXZlKHJvb3RwYXRoKSAmJlxyXG4gICAgICAgICAgICBpc1BhdGhMb2NhbFJlbGF0aXZlKG5ld1BhdGgpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBuZXdQYXRoID0gXCIuL1wiICsgbmV3UGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BhdGg7XHJcbiAgICB9O1xyXG4gICAgY29udGV4dHMuRXZhbC5wcm90b3R5cGUubm9ybWFsaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpLnJldmVyc2UoKTtcclxuICAgICAgICB2YXIgc2VnbWVudDtcclxuICAgICAgICBwYXRoID0gW107XHJcbiAgICAgICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHMucG9wKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcuLic6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwYXRoLmxlbmd0aCA9PT0gMCkgfHwgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy4uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChzZWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gaXNQYXRoUmVsYXRpdmUocGF0aCkge1xyXG4gICAgICAgIHJldHVybiAhL14oPzpbYS16LV0rOnxcXC98IykvaS50ZXN0KHBhdGgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNQYXRoTG9jYWxSZWxhdGl2ZShwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLic7XHJcbiAgICB9XHJcbiAgICAvLyB0b2RvIC0gZG8gdGhlIHNhbWUgZm9yIHRoZSB0b0NTUyA/XG5cbiAgICBmdW5jdGlvbiBtYWtlUmVnaXN0cnkoYmFzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIF9kYXRhOiB7fSxcclxuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlY2F1dGlvbmFyeSBjYXNlIGNvbnZlcnNpb24sIGFzIGxhdGVyIHF1ZXJ5aW5nIG9mXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVnaXN0cnkgYnkgZnVuY3Rpb24tY2FsbGVyIHVzZXMgbG93ZXIgY2FzZSBhcyB3ZWxsLlxyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW25hbWVdID0gZnVuYztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWRkTXVsdGlwbGU6IGZ1bmN0aW9uIChmdW5jdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGQobmFtZSwgZnVuY3Rpb25zW25hbWVdKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXSB8fCAoYmFzZSAmJiBiYXNlLmdldChuYW1lKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldExvY2FsRnVuY3Rpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW5oZXJpdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSZWdpc3RyeSh0aGlzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSZWdpc3RyeShiYXNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgZnVuY3Rpb25SZWdpc3RyeSA9IG1ha2VSZWdpc3RyeShudWxsKTtcblxuICAgIHZhciBkZWZhdWx0RnVuYyA9IHtcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy52YWx1ZV87XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5lcnJvcl87XHJcbiAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gS2V5d29yZC5UcnVlIDogS2V5d29yZC5GYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVfID0gdjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yXyA9IGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMuZXJyb3JfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIFJ1bGVzZXQgPSBmdW5jdGlvbiAoc2VsZWN0b3JzLCBydWxlcywgc3RyaWN0SW1wb3J0cywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcclxuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XHJcbiAgICAgICAgdGhpcy5fbG9va3VwcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdHJpY3RJbXBvcnRzID0gc3RyaWN0SW1wb3J0cztcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuc2VsZWN0b3JzLCB0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnJ1bGVzLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBSdWxlc2V0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdSdWxlc2V0JyxcclxuICAgICAgICBpc1J1bGVzZXQ6IHRydWUsXHJcbiAgICAgICAgaXNSdWxlc2V0TGlrZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucGF0aHMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnNlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMgJiYgdGhpcy5ydWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5ydWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnM7XHJcbiAgICAgICAgICAgIHZhciBzZWxDbnQ7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcjtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBoYXNWYXJpYWJsZTtcclxuICAgICAgICAgICAgdmFyIGhhc09uZVBhc3NpbmdTZWxlY3RvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RvcnMgJiYgKHNlbENudCA9IHRoaXMuc2VsZWN0b3JzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IG5ldyBBcnJheShzZWxDbnQpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdEZ1bmMuZXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTeW50YXgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpdCBpcyBjdXJyZW50bHkgb25seSBhbGxvd2VkIGluIHBhcmFtZXRyaWMgbWl4aW4gZ3VhcmRzLCdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yc1tpXS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmVsZW1lbnRzW2pdLmlzVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1ZhcmlhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc1tpXSA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5ldmFsZENvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPbmVQYXNzaW5nU2VsZWN0b3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoYXNWYXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b1BhcnNlU2VsZWN0b3JzID0gbmV3IEFycmF5KHNlbENudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1BhcnNlU2VsZWN0b3JzW2ldID0gc2VsZWN0b3IudG9DU1MoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UucGFyc2VOb2RlKHRvUGFyc2VTZWxlY3RvcnMuam9pbignLCcpLCBbXCJzZWxlY3RvcnNcIl0sIHNlbGVjdG9yc1swXS5nZXRJbmRleCgpLCBzZWxlY3RvcnNbMF0uZmlsZUluZm8oKSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IGZsYXR0ZW5BcnJheShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0RnVuYy5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFzT25lUGFzc2luZ1NlbGVjdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzID8gY29weUFycmF5KHRoaXMucnVsZXMpIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzZXQgPSBuZXcgUnVsZXNldChzZWxlY3RvcnMsIHJ1bGVzLCB0aGlzLnN0cmljdEltcG9ydHMsIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICB2YXIgc3ViUnVsZTtcclxuICAgICAgICAgICAgcnVsZXNldC5vcmlnaW5hbFJ1bGVzZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBydWxlc2V0LnJvb3QgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgIHJ1bGVzZXQuZmlyc3RSb290ID0gdGhpcy5maXJzdFJvb3Q7XHJcbiAgICAgICAgICAgIHJ1bGVzZXQuYWxsb3dJbXBvcnRzID0gdGhpcy5hbGxvd0ltcG9ydHM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldC5kZWJ1Z0luZm8gPSB0aGlzLmRlYnVnSW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWhhc09uZVBhc3NpbmdTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcnVsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmhlcml0IGEgZnVuY3Rpb24gcmVnaXN0cnkgZnJvbSB0aGUgZnJhbWVzIHN0YWNrIHdoZW4gcG9zc2libGU7XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmcm9tIHRoZSBnbG9iYWwgcmVnaXN0cnlcclxuICAgICAgICAgICAgcnVsZXNldC5mdW5jdGlvblJlZ2lzdHJ5ID0gKGZ1bmN0aW9uIChmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpICE9PSBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZyYW1lc1tpXS5mdW5jdGlvblJlZ2lzdHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uUmVnaXN0cnk7XHJcbiAgICAgICAgICAgIH0oY29udGV4dC5mcmFtZXMpKS5pbmhlcml0KCk7XHJcbiAgICAgICAgICAgIC8vIHB1c2ggdGhlIGN1cnJlbnQgcnVsZXNldCB0byB0aGUgZnJhbWVzIHN0YWNrXHJcbiAgICAgICAgICAgIHZhciBjdHhGcmFtZXMgPSBjb250ZXh0LmZyYW1lcztcclxuICAgICAgICAgICAgY3R4RnJhbWVzLnVuc2hpZnQocnVsZXNldCk7XHJcbiAgICAgICAgICAgIC8vIGN1cnJyZW50IHNlbGVjdG9yc1xyXG4gICAgICAgICAgICB2YXIgY3R4U2VsZWN0b3JzID0gY29udGV4dC5zZWxlY3RvcnM7XHJcbiAgICAgICAgICAgIGlmICghY3R4U2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNlbGVjdG9ycyA9IGN0eFNlbGVjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eFNlbGVjdG9ycy51bnNoaWZ0KHRoaXMuc2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgaW1wb3J0c1xyXG4gICAgICAgICAgICBpZiAocnVsZXNldC5yb290IHx8IHJ1bGVzZXQuYWxsb3dJbXBvcnRzIHx8ICFydWxlc2V0LnN0cmljdEltcG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXQuZXZhbEltcG9ydHMoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGZyYW1lcyBhcm91bmQgbWl4aW4gZGVmaW5pdGlvbnMsXHJcbiAgICAgICAgICAgIC8vIHNvIHRoZXkgY2FuIGJlIGV2YWx1YXRlZCBsaWtlIGNsb3N1cmVzIHdoZW4gdGhlIHRpbWUgY29tZXMuXHJcbiAgICAgICAgICAgIHZhciByc1J1bGVzID0gcnVsZXNldC5ydWxlcztcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgKHJ1bGUgPSByc1J1bGVzW2ldKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5ldmFsRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByc1J1bGVzW2ldID0gcnVsZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZWRpYUJsb2NrQ291bnQgPSAoY29udGV4dC5tZWRpYUJsb2NrcyAmJiBjb250ZXh0Lm1lZGlhQmxvY2tzLmxlbmd0aCkgfHwgMDtcclxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgbWl4aW4gY2FsbHMuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChydWxlID0gcnNSdWxlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ01peGluQ2FsbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZS5ldmFsKGNvbnRleHQpLmZpbHRlcihmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHIgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbikgJiYgci52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHBvbGx1dGUgdGhlIHNjb3BlIGlmIHRoZSB2YXJpYWJsZSBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSB0aGVyZS4gY29uc2lkZXIgcmV0dXJuaW5nIGZhbHNlIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBuZWVkIGEgd2F5IHRvIFwicmV0dXJuXCIgdmFyaWFibGUgZnJvbSBtaXhpbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHJ1bGVzZXQudmFyaWFibGUoci5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UuYXBwbHkocnNSdWxlcywgW2ksIDFdLmNvbmNhdChydWxlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gcnVsZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0LnJlc2V0Q2FjaGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUudHlwZSA9PT0gJ1ZhcmlhYmxlQ2FsbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZS5ldmFsKGNvbnRleHQpLnJ1bGVzLmZpbHRlcihmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHIgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbikgJiYgci52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHBvbGx1dGUgdGhlIHNjb3BlIGF0IGFsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzUnVsZXMuc3BsaWNlLmFwcGx5KHJzUnVsZXMsIFtpLCAxXS5jb25jYXQocnVsZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpICs9IHJ1bGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldC5yZXNldENhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChydWxlID0gcnNSdWxlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFydWxlLmV2YWxGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJzUnVsZXNbaV0gPSBydWxlID0gcnVsZS5ldmFsID8gcnVsZS5ldmFsKGNvbnRleHQpIDogcnVsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgKHJ1bGUgPSByc1J1bGVzW2ldKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgcnVsZXNldHMsIGNoZWNrIGlmIGl0IGlzIGEgY3NzIGd1YXJkIGFuZCBjYW4gYmUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBSdWxlc2V0ICYmIHJ1bGUuc2VsZWN0b3JzICYmIHJ1bGUuc2VsZWN0b3JzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0IGNhbiBiZSBmb2xkZWQgaW4gKGUuZy4gJiB3aGVyZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvcnNbMF0gJiYgcnVsZS5zZWxlY3RvcnNbMF0uaXNKdXN0UGFyZW50U2VsZWN0b3IoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByc1J1bGVzLnNwbGljZShpLS0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKHN1YlJ1bGUgPSBydWxlLnJ1bGVzW2pdKTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViUnVsZSBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJSdWxlLmNvcHlWaXNpYmlsaXR5SW5mbyhydWxlLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN1YlJ1bGUgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbikgfHwgIXN1YlJ1bGUudmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UoKytpLCAwLCBzdWJSdWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG9wIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBjdHhGcmFtZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgY3R4U2VsZWN0b3JzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm1lZGlhQmxvY2tzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBtZWRpYUJsb2NrQ291bnQ7IGkgPCBjb250ZXh0Lm1lZGlhQmxvY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tZWRpYUJsb2Nrc1tpXS5idWJibGVTZWxlY3RvcnMoc2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcnVsZXNldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWxJbXBvcnRzOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGltcG9ydFJ1bGVzO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZXNbaV0udHlwZSA9PT0gJ0ltcG9ydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRSdWxlcyA9IHJ1bGVzW2ldLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydFJ1bGVzICYmIChpbXBvcnRSdWxlcy5sZW5ndGggfHwgaW1wb3J0UnVsZXMubGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5zcGxpY2UuYXBwbHkocnVsZXMsIFtpLCAxXS5jb25jYXQoaW1wb3J0UnVsZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBpbXBvcnRSdWxlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKGksIDEsIGltcG9ydFJ1bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1ha2VJbXBvcnRhbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBSdWxlc2V0KHRoaXMuc2VsZWN0b3JzLCB0aGlzLnJ1bGVzLm1hcChmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIubWFrZUltcG9ydGFudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByLm1ha2VJbXBvcnRhbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSwgdGhpcy5zdHJpY3RJbXBvcnRzLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF0Y2hBcmdzOiBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBsZXRzIHlvdSBjYWxsIGEgY3NzIHNlbGVjdG9yIHdpdGggYSBndWFyZFxyXG4gICAgICAgIG1hdGNoQ29uZGl0aW9uOiBmdW5jdGlvbiAoYXJncywgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvcnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmICghbGFzdFNlbGVjdG9yLmV2YWxkQ29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhc3RTZWxlY3Rvci5jb25kaXRpb24gJiZcclxuICAgICAgICAgICAgICAgICFsYXN0U2VsZWN0b3IuY29uZGl0aW9uLmV2YWwobmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCwgY29udGV4dC5mcmFtZXMpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzZXRDYWNoZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ydWxlc2V0cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9sb29rdXBzID0ge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2YXJpYWJsZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl92YXJpYWJsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlcyA9ICF0aGlzLnJ1bGVzID8ge30gOiB0aGlzLnJ1bGVzLnJlZHVjZShmdW5jdGlvbiAoaGFzaCwgcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgRGVjbGFyYXRpb24gJiYgci52YXJpYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoW3IubmFtZV0gPSByO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGV2YWx1YXRpbmcgdmFyaWFibGVzIGluIGFuIGltcG9ydCBzdGF0ZW1lbnQsIGltcG9ydHMgaGF2ZSBub3QgYmVlbiBldmFsJ2RcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGdvIGluc2lkZSBpbXBvcnQgc3RhdGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHJvb3QgYmVpbmcgYSBzdHJpbmcgKGluIHRoZSBjYXNlIG9mIGlubGluZWQgbGVzcylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoci50eXBlID09PSAnSW1wb3J0JyAmJiByLnJvb3QgJiYgci5yb290LnZhcmlhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFycyA9IHIucm9vdC52YXJpYWJsZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHZhcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJzLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoW25hbWVfMV0gPSByLnJvb3QudmFyaWFibGUobmFtZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgICAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvcGVydGllczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSAhdGhpcy5ydWxlcyA/IHt9IDogdGhpcy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2gsIHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIERlY2xhcmF0aW9uICYmIHIudmFyaWFibGUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IChyLm5hbWUubGVuZ3RoID09PSAxKSAmJiAoci5uYW1lWzBdIGluc3RhbmNlb2YgS2V5d29yZCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5uYW1lWzBdLnZhbHVlIDogci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIGRvbid0IG92ZXJ3cml0ZSBhcyB0aGV5IGNhbiBtZXJnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc2hbXCIkXCIgKyBuYW1lXzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoW1wiJFwiICsgbmFtZV8yXSA9IFtyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hbXCIkXCIgKyBuYW1lXzJdLnB1c2gocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2YXJpYWJsZTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGRlY2wgPSB0aGlzLnZhcmlhYmxlcygpW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZGVjbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZShkZWNsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNsID0gdGhpcy5wcm9wZXJ0aWVzKClbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChkZWNsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlKGRlY2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGVjbGFyYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucnVsZXMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjbCA9IHRoaXMucnVsZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2wgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWUoZGVjbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uICh0b1BhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGVjbGFyYXRpb24oZGVjbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2wudmFsdWUgaW5zdGFuY2VvZiBBbm9ueW1vdXMgJiYgIWRlY2wucGFyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWNsLnZhbHVlLnZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnBhcnNlTm9kZShkZWNsLnZhbHVlLnZhbHVlLCBbJ3ZhbHVlJywgJ2ltcG9ydGFudCddLCBkZWNsLnZhbHVlLmdldEluZGV4KCksIGRlY2wuZmlsZUluZm8oKSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbC5wYXJzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wudmFsdWUgPSByZXN1bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbC5pbXBvcnRhbnQgPSByZXN1bHRbMV0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbC5wYXJzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wucGFyc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9QYXJzZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1EZWNsYXJhdGlvbi5jYWxsKHNlbGYsIHRvUGFyc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzXzEgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRvUGFyc2UuZm9yRWFjaChmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzXzEucHVzaCh0cmFuc2Zvcm1EZWNsYXJhdGlvbi5jYWxsKHNlbGYsIG4pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzXzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJ1bGVzZXRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmaWx0UnVsZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcztcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHJ1bGVzW2ldKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pc1J1bGVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0UnVsZXMucHVzaChydWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdFJ1bGVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJlcGVuZFJ1bGU6IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXM7XHJcbiAgICAgICAgICAgIGlmIChydWxlcykge1xyXG4gICAgICAgICAgICAgICAgcnVsZXMudW5zaGlmdChydWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXMgPSBbcnVsZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQocnVsZSwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHNlbGYsIGZpbHRlcikge1xyXG4gICAgICAgICAgICBzZWxmID0gc2VsZiB8fCB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG1hdGNoO1xyXG4gICAgICAgICAgICB2YXIgZm91bmRNaXhpbnM7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBzZWxlY3Rvci50b0NTUygpO1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2xvb2t1cHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ydWxlc2V0cygpLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlICE9PSBzZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBydWxlLnNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKHJ1bGUuc2VsZWN0b3JzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoID4gbWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIocnVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNaXhpbnMgPSBydWxlLmZpbmQobmV3IFNlbGVjdG9yKHNlbGVjdG9yLmVsZW1lbnRzLnNsaWNlKG1hdGNoKSksIHNlbGYsIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm91bmRNaXhpbnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWl4aW5zW2ldLnBhdGgucHVzaChydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgZm91bmRNaXhpbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2goeyBydWxlOiBydWxlLCBwYXRoOiBbXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fbG9va3Vwc1trZXldID0gcnVsZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgICAgIHZhciBjaGFyc2V0UnVsZU5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBydWxlTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIC8vIExpbmUgbnVtYmVyIGRlYnVnZ2luZ1xyXG4gICAgICAgICAgICBkZWJ1Z0luZm8kMTtcclxuICAgICAgICAgICAgdmFyIHJ1bGU7XHJcbiAgICAgICAgICAgIHZhciBwYXRoO1xyXG4gICAgICAgICAgICBjb250ZXh0LnRhYkxldmVsID0gKGNvbnRleHQudGFiTGV2ZWwgfHwgMCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRhYkxldmVsKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhYlJ1bGVTdHIgPSBjb250ZXh0LmNvbXByZXNzID8gJycgOiBBcnJheShjb250ZXh0LnRhYkxldmVsICsgMSkuam9pbignICAnKTtcclxuICAgICAgICAgICAgdmFyIHRhYlNldFN0ciA9IGNvbnRleHQuY29tcHJlc3MgPyAnJyA6IEFycmF5KGNvbnRleHQudGFiTGV2ZWwpLmpvaW4oJyAgJyk7XHJcbiAgICAgICAgICAgIHZhciBzZXA7XHJcbiAgICAgICAgICAgIHZhciBjaGFyc2V0Tm9kZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGltcG9ydE5vZGVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChydWxlID0gdGhpcy5ydWxlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydE5vZGVJbmRleCA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5vZGVzLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLmlzQ2hhcnNldCAmJiBydWxlLmlzQ2hhcnNldCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5vZGVzLnNwbGljZShjaGFyc2V0Tm9kZUluZGV4LCAwLCBydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0Tm9kZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnR5cGUgPT09ICdJbXBvcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5vZGVzLnNwbGljZShpbXBvcnROb2RlSW5kZXgsIDAsIHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydE5vZGVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5vZGVzLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcnVsZU5vZGVzID0gY2hhcnNldFJ1bGVOb2Rlcy5jb25jYXQocnVsZU5vZGVzKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBub2RlLCB3ZSBkb24ndCByZW5kZXJcclxuICAgICAgICAgICAgLy8gYSBzZWxlY3Rvciwgb3Ige30uXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm8kMSA9IGRlYnVnSW5mbyhjb250ZXh0LCB0aGlzLCB0YWJTZXRTdHIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnSW5mbyQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZChkZWJ1Z0luZm8kMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZCh0YWJTZXRTdHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5wYXRocztcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoQ250ID0gcGF0aHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhTdWJDbnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBzZXAgPSBjb250ZXh0LmNvbXByZXNzID8gJywnIDogKFwiLFxcblwiICsgdGFiU2V0U3RyKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoQ250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGF0aFN1YkNudCA9IHBhdGgubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoc2VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maXJzdFNlbGVjdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBwYXRoU3ViQ250OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFtqXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKChjb250ZXh0LmNvbXByZXNzID8gJ3snIDogJyB7XFxuJykgKyB0YWJSdWxlU3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb21waWxlIHJ1bGVzIGFuZCBydWxlc2V0c1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHJ1bGVOb2Rlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBydWxlTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudExhc3RSdWxlID0gY29udGV4dC5sYXN0UnVsZTtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlLmlzUnVsZXNldExpa2UocnVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5nZW5DU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQocnVsZS52YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQubGFzdFJ1bGUgPSBjdXJyZW50TGFzdFJ1bGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQubGFzdFJ1bGUgJiYgcnVsZS5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoY29udGV4dC5jb21wcmVzcyA/ICcnIDogKFwiXFxuXCIgKyB0YWJSdWxlU3RyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoKGNvbnRleHQuY29tcHJlc3MgPyAnfScgOiBcIlxcblwiICsgdGFiU2V0U3RyICsgXCJ9XCIpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQudGFiTGV2ZWwtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW91dHB1dC5pc0VtcHR5KCkgJiYgIWNvbnRleHQuY29tcHJlc3MgJiYgdGhpcy5maXJzdFJvb3QpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJ1xcbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBqb2luU2VsZWN0b3JzOiBmdW5jdGlvbiAocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9ycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNlbGVjdG9ycy5sZW5ndGg7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5qb2luU2VsZWN0b3IocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9yc1tzXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGpvaW5TZWxlY3RvcjogZnVuY3Rpb24gKHBhdGhzLCBjb250ZXh0LCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVQYXJlbnRoZXNpcyhlbGVtZW50c1RvUGFrLCBvcmlnaW5hbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudFBhcmVuLCBqO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzVG9QYWsubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRQYXJlbiA9IG5ldyBQYXJlbihlbGVtZW50c1RvUGFrWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNpZGVQYXJlbnQgPSBuZXcgQXJyYXkoZWxlbWVudHNUb1Bhay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBlbGVtZW50c1RvUGFrLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVBhcmVudFtqXSA9IG5ldyBFbGVtZW50KG51bGwsIGVsZW1lbnRzVG9QYWtbal0sIG9yaWdpbmFsRWxlbWVudC5pc1ZhcmlhYmxlLCBvcmlnaW5hbEVsZW1lbnQuX2luZGV4LCBvcmlnaW5hbEVsZW1lbnQuX2ZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRQYXJlbiA9IG5ldyBQYXJlbihuZXcgU2VsZWN0b3IoaW5zaWRlUGFyZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRQYXJlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rvcihjb250YWluZWRFbGVtZW50LCBvcmlnaW5hbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50LCBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChudWxsLCBjb250YWluZWRFbGVtZW50LCBvcmlnaW5hbEVsZW1lbnQuaXNWYXJpYWJsZSwgb3JpZ2luYWxFbGVtZW50Ll9pbmRleCwgb3JpZ2luYWxFbGVtZW50Ll9maWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IG5ldyBTZWxlY3RvcihbZWxlbWVudF0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGpvaW5zIHNlbGVjdG9yIHBhdGggZnJvbSBgYmVnaW5uaW5nUGF0aGAgd2l0aCBzZWxlY3RvciBwYXRoIGluIGBhZGRQYXRoYFxyXG4gICAgICAgICAgICAvLyBgcmVwbGFjZWRFbGVtZW50YCBjb250YWlucyBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcmVwbGFjZWQgYnkgYGFkZFBhdGhgXHJcbiAgICAgICAgICAgIC8vIHJldHVybnMgY29uY2F0ZW5hdGVkIHBhdGhcclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkUmVwbGFjZW1lbnRJbnRvUGF0aChiZWdpbm5pbmdQYXRoLCBhZGRQYXRoLCByZXBsYWNlZEVsZW1lbnQsIG9yaWdpbmFsU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdTZWxlY3RvclBhdGgsIGxhc3RTZWxlY3RvciwgbmV3Sm9pbmVkU2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAvLyBvdXIgbmV3IHNlbGVjdG9yIHBhdGhcclxuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3RydWN0IHRoZSBqb2luZWQgc2VsZWN0b3IgLSBpZiAmIGlzIHRoZSBmaXJzdCB0aGluZyB0aGlzIHdpbGwgYmUgZW1wdHksXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgbmV3Sm9pbmVkU2VsZWN0b3Igd2lsbCBiZSB0aGUgbGFzdCBzZXQgb2YgZWxlbWVudHMgaW4gdGhlIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW5uaW5nUGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JQYXRoID0gY29weUFycmF5KGJlZ2lubmluZ1BhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RvciA9IG5ld1NlbGVjdG9yUGF0aC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdKb2luZWRTZWxlY3RvciA9IG9yaWdpbmFsU2VsZWN0b3IuY3JlYXRlRGVyaXZlZChjb3B5QXJyYXkobGFzdFNlbGVjdG9yLmVsZW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdKb2luZWRTZWxlY3RvciA9IG9yaWdpbmFsU2VsZWN0b3IuY3JlYXRlRGVyaXZlZChbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYWRkUGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gL2RlZXAvIGlzIGEgQ1NTNCBzZWxlY3RvciAtIChyZW1vdmVkLCBzbyBzaG91bGQgZGVwcmVjYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgdmFsaWQgd2l0aG91dCBhbnl0aGluZyBpbiBmcm9udCBvZiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGlmIHRoZSAmIGRvZXMgbm90IGhhdmUgYSBjb21iaW5hdG9yIHRoYXQgaXMgXCJcIiBvciBcIiBcIiB0aGVuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZXJlIGlzIGEgY29tYmluYXRvciBvbiB0aGUgcGFyZW50LCB0aGVuIGdyYWIgdGhhdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGFsc28gYWxsb3dzICsgYSB7ICYgLmIgeyAuYSAmIHsgLi4uIHRob3VnaCBub3Qgc3VyZSB3aHkgeW91IHdvdWxkIHdhbnQgdG8gZG8gdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21iaW5hdG9yID0gcmVwbGFjZWRFbGVtZW50LmNvbWJpbmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gYWRkUGF0aFswXS5lbGVtZW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tYmluYXRvci5lbXB0eU9yV2hpdGVzcGFjZSAmJiAhcGFyZW50RWwuY29tYmluYXRvci5lbXB0eU9yV2hpdGVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5hdG9yID0gcGFyZW50RWwuY29tYmluYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gam9pbiB0aGUgZWxlbWVudHMgc28gZmFyIHdpdGggdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0pvaW5lZFNlbGVjdG9yLmVsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnQoY29tYmluYXRvciwgcGFyZW50RWwudmFsdWUsIHJlcGxhY2VkRWxlbWVudC5pc1ZhcmlhYmxlLCByZXBsYWNlZEVsZW1lbnQuX2luZGV4LCByZXBsYWNlZEVsZW1lbnQuX2ZpbGVJbmZvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Sm9pbmVkU2VsZWN0b3IuZWxlbWVudHMgPSBuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5jb25jYXQoYWRkUGF0aFswXS5lbGVtZW50cy5zbGljZSgxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBub3cgYWRkIHRoZSBqb2luZWQgc2VsZWN0b3IgLSBidXQgb25seSBpZiBpdCBpcyBub3QgZW1wdHlcclxuICAgICAgICAgICAgICAgIGlmIChuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvclBhdGgucHVzaChuZXdKb2luZWRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwdXQgdG9nZXRoZXIgdGhlIHBhcmVudCBzZWxlY3RvcnMgYWZ0ZXIgdGhlIGpvaW4gKGUuZy4gdGhlIHJlc3Qgb2YgdGhlIHBhcmVudClcclxuICAgICAgICAgICAgICAgIGlmIChhZGRQYXRoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdE9mUGF0aCA9IGFkZFBhdGguc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdE9mUGF0aCA9IHJlc3RPZlBhdGgubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IuY3JlYXRlRGVyaXZlZChzZWxlY3Rvci5lbGVtZW50cywgW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aCA9IG5ld1NlbGVjdG9yUGF0aC5jb25jYXQocmVzdE9mUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2VsZWN0b3JQYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGpvaW5zIHNlbGVjdG9yIHBhdGggZnJvbSBgYmVnaW5uaW5nUGF0aGAgd2l0aCBldmVyeSBzZWxlY3RvciBwYXRoIGluIGBhZGRQYXRoc2AgYXJyYXlcclxuICAgICAgICAgICAgLy8gYHJlcGxhY2VkRWxlbWVudGAgY29udGFpbnMgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHJlcGxhY2VkIGJ5IGBhZGRQYXRoYFxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIGFycmF5IHdpdGggYWxsIGNvbmNhdGVuYXRlZCBwYXRoc1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRBbGxSZXBsYWNlbWVudHNJbnRvUGF0aChiZWdpbm5pbmdQYXRoLCBhZGRQYXRocywgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJlZ2lubmluZ1BhdGgubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3JQYXRoID0gYWRkUmVwbGFjZW1lbnRJbnRvUGF0aChiZWdpbm5pbmdQYXRoW2pdLCBhZGRQYXRocywgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdTZWxlY3RvclBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhlbGVtZW50cywgc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgc2VsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goW25ldyBTZWxlY3RvcihlbGVtZW50cyldKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoc2VsID0gc2VsZWN0b3JzW2ldKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIHRoaW5nIGluIHNlbCBpcyBhIHBhcmVudCB0aGlzIG5lZWRzIHRvIGpvaW4gb24gdG8gaXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsW3NlbC5sZW5ndGggLSAxXSA9IHNlbFtzZWwubGVuZ3RoIC0gMV0uY3JlYXRlRGVyaXZlZChzZWxbc2VsLmxlbmd0aCAtIDFdLmVsZW1lbnRzLmNvbmNhdChlbGVtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLnB1c2gobmV3IFNlbGVjdG9yKGVsZW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgYWxsIHBhcmVudCBzZWxlY3RvcnMgaW5zaWRlIGBpblNlbGVjdG9yYCBieSBjb250ZW50IG9mIGBjb250ZXh0YCBhcnJheVxyXG4gICAgICAgICAgICAvLyByZXN1bHRpbmcgc2VsZWN0b3JzIGFyZSByZXR1cm5lZCBpbnNpZGUgYHBhdGhzYCBhcnJheVxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgYGluU2VsZWN0b3JgIGNvbnRhaW5lZCBhdCBsZWFzdCBvbmUgcGFyZW50IHNlbGVjdG9yXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VQYXJlbnRTZWxlY3RvcihwYXRocywgY29udGV4dCwgaW5TZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHBhdGhzIGFyZSBbW1NlbGVjdG9yXV1cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBsaXN0IGlzIGEgbGlzdCBvZiBjb21tYSBzZXBhcmF0ZWQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgaW5uZXIgbGlzdCBpcyBhIGxpc3Qgb2YgaW5oZXJpdGFuY2Ugc2VwYXJhdGVkIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgLy8gZS5nLlxyXG4gICAgICAgICAgICAgICAgLy8gLmEsIC5iIHtcclxuICAgICAgICAgICAgICAgIC8vICAgLmMge1xyXG4gICAgICAgICAgICAgICAgLy8gICB9XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyA9PSBbWy5hXSBbLmNdXSBbWy5iXSBbLmNdXVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIHZhciBpLCBqLCBrLCBjdXJyZW50RWxlbWVudHMsIG5ld1NlbGVjdG9ycywgc2VsZWN0b3JzTXVsdGlwbGllZCwgc2VsLCBlbCwgaGFkUGFyZW50U2VsZWN0b3IgPSBmYWxzZSwgbGVuZ3RoLCBsYXN0U2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaW5kTmVzdGVkU2VsZWN0b3IoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGVsZW1lbnQudmFsdWUgaW5zdGFuY2VvZiBQYXJlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1heWJlU2VsZWN0b3IgPSBlbGVtZW50LnZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1heWJlU2VsZWN0b3IgaW5zdGFuY2VvZiBTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnRzIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0b3Igc28gZmFyXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGxpc3Qgb2YgbmV3IHNlbGVjdG9ycyB0byBhZGQgdG8gdGhlIHBhdGguXHJcbiAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGJ1aWxkIGl0IHVwLiBXZSBpbml0aWF0ZSBpdCB3aXRoIG9uZSBlbXB0eSBzZWxlY3RvciBhcyB3ZSBcIm11bHRpcGx5XCIgdGhlIG5ldyBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSBwYXJlbnRzXHJcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgW11cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoZWwgPSBpblNlbGVjdG9yLmVsZW1lbnRzW2ldKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uIHBhcmVudCByZWZlcmVuY2UgZWxlbWVudHMganVzdCBnZXQgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwudmFsdWUgIT09ICcmJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkU2VsZWN0b3IgPSBmaW5kTmVzdGVkU2VsZWN0b3IoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkU2VsZWN0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGN1cnJlbnQgbGlzdCBvZiBub24gcGFyZW50IHNlbGVjdG9yIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiB0byB0aGUgY3VycmVudCBsaXN0IG9mIHNlbGVjdG9ycyB0byBhZGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRQYXRocyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VkTmV3U2VsZWN0b3JzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlZCA9IHJlcGxhY2VQYXJlbnRTZWxlY3RvcihuZXN0ZWRQYXRocywgY29udGV4dCwgbmVzdGVkU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFkUGFyZW50U2VsZWN0b3IgPSBoYWRQYXJlbnRTZWxlY3RvciB8fCByZXBsYWNlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXN0ZWRQYXRocyBhcnJheSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBtZW1iZXIgLSByZXBsYWNlUGFyZW50U2VsZWN0b3IgZG9lcyBub3QgbXVsdGlwbHkgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbmVzdGVkUGF0aHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKGNyZWF0ZVBhcmVudGhlc2lzKG5lc3RlZFBhdGhzW2tdLCBlbCksIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRBbGxSZXBsYWNlbWVudHNJbnRvUGF0aChuZXdTZWxlY3RvcnMsIFtyZXBsYWNlbWVudFNlbGVjdG9yXSwgZWwsIGluU2VsZWN0b3IsIHJlcGxhY2VkTmV3U2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9ycyA9IHJlcGxhY2VkTmV3U2VsZWN0b3JzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudHMucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhZFBhcmVudFNlbGVjdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5ldyBsaXN0IG9mIHNlbGVjdG9ycyB0byBhZGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzTXVsdGlwbGllZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgY3VycmVudCBsaXN0IG9mIG5vbiBwYXJlbnQgc2VsZWN0b3IgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIG91ciBjdXJyZW50IHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmV3U2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBuZXdTZWxlY3RvcnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSBwYXJlbnQgcGF0aHMsIHRoZSAmIG1pZ2h0IGJlIGluIGEgbWl4aW4gc28gdGhhdCBpdCBjYW4gYmUgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGVyZSBhcmUgcGFyZW50cyBvciBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb21iaW5hdG9yIHVzZWQgb24gZWwgc2hvdWxkIG5vdyBiZSBhcHBsaWVkIHRvIHRoZSBuZXh0IGVsZW1lbnQgaW5zdGVhZCBzbyB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgbm90IGxvc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsWzBdLmVsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnQoZWwuY29tYmluYXRvciwgJycsIGVsLmlzVmFyaWFibGUsIGVsLl9pbmRleCwgZWwuX2ZpbGVJbmZvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQucHVzaChzZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBwYXJlbnQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvbnRleHQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBwdXQgdGhlIGN1cnJlbnQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gam9pbiB0aGUgbGFzdCBzZWxlY3RvcidzIGVsZW1lbnRzIG9uIHRvIHRoZSBwYXJlbnRzIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3JQYXRoID0gYWRkUmVwbGFjZW1lbnRJbnRvUGF0aChzZWwsIGNvbnRleHRba10sIGVsLCBpblNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoYXQgdG8gb3VyIG5ldyBzZXQgb2Ygc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQucHVzaChuZXdTZWxlY3RvclBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgbmV3IHNlbGVjdG9ycyBoYXMgYmVlbiBtdWx0aXBsaWVkLCBzbyByZXNldCB0aGUgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JzID0gc2VsZWN0b3JzTXVsdGlwbGllZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgZWxlbWVudHMgbGVmdCBvdmVyIChlLmcuIC5hJiAuYiA9PSAuYilcclxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGVtIG9uIHRvIGFsbCB0aGUgY3VycmVudCBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudHNPblRvU2VsZWN0b3JzKGN1cnJlbnRFbGVtZW50cywgbmV3U2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBuZXdTZWxlY3RvcnNbaV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3U2VsZWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlbGVjdG9yID0gbmV3U2VsZWN0b3JzW2ldW2xlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnNbaV1bbGVuZ3RoIC0gMV0gPSBsYXN0U2VsZWN0b3IuY3JlYXRlRGVyaXZlZChsYXN0U2VsZWN0b3IuZWxlbWVudHMsIGluU2VsZWN0b3IuZXh0ZW5kTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhZFBhcmVudFNlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlcml2ZVNlbGVjdG9yKHZpc2liaWxpdHlJbmZvLCBkZXJpdmVGcm9tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3IgPSBkZXJpdmVGcm9tLmNyZWF0ZURlcml2ZWQoZGVyaXZlRnJvbS5lbGVtZW50cywgZGVyaXZlRnJvbS5leHRlbmRMaXN0LCBkZXJpdmVGcm9tLmV2YWxkQ29uZGl0aW9uKTtcclxuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gam9pblNlbGVjdG9yIGNvZGUgZm9sbG93c1xyXG4gICAgICAgICAgICB2YXIgaSwgbmV3UGF0aHMsIGhhZFBhcmVudFNlbGVjdG9yO1xyXG4gICAgICAgICAgICBuZXdQYXRocyA9IFtdO1xyXG4gICAgICAgICAgICBoYWRQYXJlbnRTZWxlY3RvciA9IHJlcGxhY2VQYXJlbnRTZWxlY3RvcihuZXdQYXRocywgY29udGV4dCwgc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIWhhZFBhcmVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGF0aHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uY2F0ZW5hdGVkID0gY29udGV4dFtpXS5tYXAoZGVyaXZlU2VsZWN0b3IuYmluZCh0aGlzLCBzZWxlY3Rvci52aXNpYmlsaXR5SW5mbygpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdGVuYXRlZC5wdXNoKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGF0aHMucHVzaChjb25jYXRlbmF0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhdGhzID0gW1tzZWxlY3Rvcl1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdQYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChuZXdQYXRoc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBBdFJ1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHJ1bGVzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBkZWJ1Z0luZm8sIGlzUm9vdGVkLCB2aXNpYmlsaXR5SW5mbykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpID8gdmFsdWUgOiAodmFsdWUgPyBuZXcgQW5vbnltb3VzKHZhbHVlKSA6IHZhbHVlKTtcclxuICAgICAgICBpZiAocnVsZXMpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzID0gW3J1bGVzXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXNbMF0uc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykpLmNyZWF0ZUVtcHR5U2VsZWN0b3JzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXNbaV0uYWxsb3dJbXBvcnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnJ1bGVzLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmRlYnVnSW5mbyA9IGRlYnVnSW5mbztcclxuICAgICAgICB0aGlzLmlzUm9vdGVkID0gaXNSb290ZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBBdFJ1bGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0F0UnVsZScsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCBydWxlcyA9IHRoaXMucnVsZXM7XHJcbiAgICAgICAgICAgIGlmIChydWxlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydWxlcyA9IHZpc2l0b3IudmlzaXRBcnJheShydWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUnVsZXNldExpa2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVsZXMgfHwgIXRoaXMuaXNDaGFyc2V0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0NoYXJzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdAY2hhcnNldCcgPT09IHRoaXMubmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLCBydWxlcyA9IHRoaXMucnVsZXM7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5uYW1lLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFJ1bGVzZXQoY29udGV4dCwgb3V0cHV0LCBydWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCc7Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYVBhdGhCYWNrdXAsIG1lZGlhQmxvY2tzQmFja3VwLCB2YWx1ZSA9IHRoaXMudmFsdWUsIHJ1bGVzID0gdGhpcy5ydWxlcztcclxuICAgICAgICAgICAgLy8gbWVkaWEgc3RvcmVkIGluc2lkZSBvdGhlciBhdHJ1bGUgc2hvdWxkIG5vdCBidWJibGUgb3ZlciBpdFxyXG4gICAgICAgICAgICAvLyBiYWNrcHVwIG1lZGlhIGJ1YmJsaW5nIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIG1lZGlhUGF0aEJhY2t1cCA9IGNvbnRleHQubWVkaWFQYXRoO1xyXG4gICAgICAgICAgICBtZWRpYUJsb2Nrc0JhY2t1cCA9IGNvbnRleHQubWVkaWFCbG9ja3M7XHJcbiAgICAgICAgICAgIC8vIGRlbGV0ZWQgbWVkaWEgYnViYmxpbmcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgY29udGV4dC5tZWRpYVBhdGggPSBbXTtcclxuICAgICAgICAgICAgY29udGV4dC5tZWRpYUJsb2NrcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcclxuICAgICAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzWzBdLmV2YWwoY29udGV4dCldO1xyXG4gICAgICAgICAgICAgICAgcnVsZXNbMF0ucm9vdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzdG9yZSBtZWRpYSBidWJibGluZyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICBjb250ZXh0Lm1lZGlhUGF0aCA9IG1lZGlhUGF0aEJhY2t1cDtcclxuICAgICAgICAgICAgY29udGV4dC5tZWRpYUJsb2NrcyA9IG1lZGlhQmxvY2tzQmFja3VwO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0UnVsZSh0aGlzLm5hbWUsIHZhbHVlLCBydWxlcywgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZGVidWdJbmZvLCB0aGlzLmlzUm9vdGVkLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUnVsZXNldC5wcm90b3R5cGUudmFyaWFibGUuY2FsbCh0aGlzLnJ1bGVzWzBdLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBydWxlIGF0IHRoaXMgcG9pbnQgLSB0aGF0IGlzIGhvdyBwYXJzZXIgY29uc3RydWN0cyB0aGUgcnVsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJ1bGVzZXQucHJvdG90eXBlLmZpbmQuYXBwbHkodGhpcy5ydWxlc1swXSwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVsZXNldHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcclxuICAgICAgICAgICAgICAgIHJldHVybiBSdWxlc2V0LnByb3RvdHlwZS5ydWxlc2V0cy5hcHBseSh0aGlzLnJ1bGVzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3V0cHV0UnVsZXNldDogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCwgcnVsZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVDbnQgPSBydWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnRhYkxldmVsID0gKGNvbnRleHQudGFiTGV2ZWwgfCAwKSArIDE7XHJcbiAgICAgICAgICAgIC8vIENvbXByZXNzZWRcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuY29tcHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJ3snKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJ30nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQudGFiTGV2ZWwtLTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOb24tY29tcHJlc3NlZFxyXG4gICAgICAgICAgICB2YXIgdGFiU2V0U3RyID0gXCJcXG5cIiArIEFycmF5KGNvbnRleHQudGFiTGV2ZWwpLmpvaW4oJyAgJyksIHRhYlJ1bGVTdHIgPSB0YWJTZXRTdHIgKyBcIiAgXCI7XHJcbiAgICAgICAgICAgIGlmICghcnVsZUNudCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZChcIiB7XCIgKyB0YWJTZXRTdHIgKyBcIn1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKFwiIHtcIiArIHRhYlJ1bGVTdHIpO1xyXG4gICAgICAgICAgICAgICAgcnVsZXNbMF0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcnVsZUNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZCh0YWJSdWxlU3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGFiU2V0U3RyICsgXCJ9XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQudGFiTGV2ZWwtLTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBEZXRhY2hlZFJ1bGVzZXQgPSBmdW5jdGlvbiAocnVsZXNldCwgZnJhbWVzKSB7XHJcbiAgICAgICAgdGhpcy5ydWxlc2V0ID0gcnVsZXNldDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcztcclxuICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnJ1bGVzZXQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIERldGFjaGVkUnVsZXNldC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnRGV0YWNoZWRSdWxlc2V0JyxcclxuICAgICAgICBldmFsRmlyc3Q6IHRydWUsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnJ1bGVzZXQgPSB2aXNpdG9yLnZpc2l0KHRoaXMucnVsZXNldCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXMgfHwgY29weUFycmF5KGNvbnRleHQuZnJhbWVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXRhY2hlZFJ1bGVzZXQodGhpcy5ydWxlc2V0LCBmcmFtZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FsbEV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVzZXQuZXZhbCh0aGlzLmZyYW1lcyA/IG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIHRoaXMuZnJhbWVzLmNvbmNhdChjb250ZXh0LmZyYW1lcykpIDogY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgVW5pdCA9IGZ1bmN0aW9uIChudW1lcmF0b3IsIGRlbm9taW5hdG9yLCBiYWNrdXBVbml0KSB7XHJcbiAgICAgICAgdGhpcy5udW1lcmF0b3IgPSBudW1lcmF0b3IgPyBjb3B5QXJyYXkobnVtZXJhdG9yKS5zb3J0KCkgOiBbXTtcclxuICAgICAgICB0aGlzLmRlbm9taW5hdG9yID0gZGVub21pbmF0b3IgPyBjb3B5QXJyYXkoZGVub21pbmF0b3IpLnNvcnQoKSA6IFtdO1xyXG4gICAgICAgIGlmIChiYWNrdXBVbml0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja3VwVW5pdCA9IGJhY2t1cFVuaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG51bWVyYXRvciAmJiBudW1lcmF0b3IubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja3VwVW5pdCA9IG51bWVyYXRvclswXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVW5pdC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnVW5pdCcsXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbml0KGNvcHlBcnJheSh0aGlzLm51bWVyYXRvciksIGNvcHlBcnJheSh0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5iYWNrdXBVbml0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICAvLyBEaW1lbnNpb24gY2hlY2tzIHRoZSB1bml0IGlzIHNpbmd1bGFyIGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgaW4gc3RyaWN0IG1hdGggbW9kZS5cclxuICAgICAgICAgICAgdmFyIHN0cmljdFVuaXRzID0gY29udGV4dCAmJiBjb250ZXh0LnN0cmljdFVuaXRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5udW1lcmF0b3IubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMubnVtZXJhdG9yWzBdKTsgLy8gdGhlIGlkZWFsIHNpdHVhdGlvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzdHJpY3RVbml0cyAmJiB0aGlzLmJhY2t1cFVuaXQpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5iYWNrdXBVbml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghc3RyaWN0VW5pdHMgJiYgdGhpcy5kZW5vbWluYXRvci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5kZW5vbWluYXRvclswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCByZXR1cm5TdHIgPSB0aGlzLm51bWVyYXRvci5qb2luKCcqJyk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbm9taW5hdG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5TdHIgKz0gXCIvXCIgKyB0aGlzLmRlbm9taW5hdG9yW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5TdHI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wYXJlOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXMob3RoZXIudG9TdHJpbmcoKSkgPyAwIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXM6IGZ1bmN0aW9uICh1bml0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA9PT0gdW5pdFN0cmluZy50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNMZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZ0V4cCgnXihweHxlbXxleHxjaHxyZW18aW58Y218bW18cGN8cHR8ZXh8dnd8dmh8dm1pbnx2bWF4KSQnLCAnZ2knKS50ZXN0KHRoaXMudG9DU1MoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bWVyYXRvci5sZW5ndGggPT09IDAgJiYgdGhpcy5kZW5vbWluYXRvci5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1Npbmd1bGFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bWVyYXRvci5sZW5ndGggPD0gMSAmJiB0aGlzLmRlbm9taW5hdG9yLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW1lcmF0b3IubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtZXJhdG9yW2ldID0gY2FsbGJhY2sodGhpcy5udW1lcmF0b3JbaV0sIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5vbWluYXRvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZW5vbWluYXRvcltpXSA9IGNhbGxiYWNrKHRoaXMuZGVub21pbmF0b3JbaV0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1c2VkVW5pdHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIHZhciBtYXBVbml0O1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lO1xyXG4gICAgICAgICAgICBtYXBVbml0ID0gZnVuY3Rpb24gKGF0b21pY1VuaXQpIHtcclxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuaGFzT3duUHJvcGVydHkoYXRvbWljVW5pdCkgJiYgIXJlc3VsdFtncm91cE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2dyb3VwTmFtZV0gPSBhdG9taWNVbml0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0b21pY1VuaXQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAoZ3JvdXBOYW1lIGluIHVuaXRDb252ZXJzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXRDb252ZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSB1bml0Q29udmVyc2lvbnNbZ3JvdXBOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcChtYXBVbml0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0ge307XHJcbiAgICAgICAgICAgIHZhciBhdG9taWNVbml0O1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtZXJhdG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhdG9taWNVbml0ID0gdGhpcy5udW1lcmF0b3JbaV07XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2F0b21pY1VuaXRdID0gKGNvdW50ZXJbYXRvbWljVW5pdF0gfHwgMCkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbm9taW5hdG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhdG9taWNVbml0ID0gdGhpcy5kZW5vbWluYXRvcltpXTtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJbYXRvbWljVW5pdF0gPSAoY291bnRlclthdG9taWNVbml0XSB8fCAwKSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5udW1lcmF0b3IgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5kZW5vbWluYXRvciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGF0b21pY1VuaXQgaW4gY291bnRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIuaGFzT3duUHJvcGVydHkoYXRvbWljVW5pdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBjb3VudGVyW2F0b21pY1VuaXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubnVtZXJhdG9yLnB1c2goYXRvbWljVW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAtY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZW5vbWluYXRvci5wdXNoKGF0b21pY1VuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubnVtZXJhdG9yLnNvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5kZW5vbWluYXRvci5zb3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICAvL1xyXG4gICAgLy8gQSBudW1iZXIgd2l0aCBhIHVuaXRcclxuICAgIC8vXHJcbiAgICB2YXIgRGltZW5zaW9uID0gZnVuY3Rpb24gKHZhbHVlLCB1bml0KSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgIGlmIChpc05hTih0aGlzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiBpcyBub3QgYSBudW1iZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudW5pdCA9ICh1bml0ICYmIHVuaXQgaW5zdGFuY2VvZiBVbml0KSA/IHVuaXQgOlxyXG4gICAgICAgICAgICBuZXcgVW5pdCh1bml0ID8gW3VuaXRdIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnVuaXQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIERpbWVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnRGltZW5zaW9uJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pdCA9IHZpc2l0b3IudmlzaXQodGhpcy51bml0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9Db2xvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKFt0aGlzLnZhbHVlLCB0aGlzLnZhbHVlLCB0aGlzLnZhbHVlXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgaWYgKChjb250ZXh0ICYmIGNvbnRleHQuc3RyaWN0VW5pdHMpICYmICF0aGlzLnVuaXQuaXNTaW5ndWxhcigpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSB1bml0cyBpbiBkaW1lbnNpb24uIENvcnJlY3QgdGhlIHVuaXRzIG9yIHVzZSB0aGUgdW5pdCBmdW5jdGlvbi4gQmFkIHVuaXQ6IFwiICsgdGhpcy51bml0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZnJvdW5kKGNvbnRleHQsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB2YXIgc3RyVmFsdWUgPSBTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IDAgJiYgdmFsdWUgPCAwLjAwMDAwMSAmJiB2YWx1ZSA+IC0wLjAwMDAwMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgb3V0cHV0IDFlLTYgZXRjLlxyXG4gICAgICAgICAgICAgICAgc3RyVmFsdWUgPSB2YWx1ZS50b0ZpeGVkKDIwKS5yZXBsYWNlKC8wKyQvLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jb21wcmVzcykge1xyXG4gICAgICAgICAgICAgICAgLy8gWmVybyB2YWx1ZXMgZG9lc24ndCBuZWVkIGEgdW5pdFxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHRoaXMudW5pdC5pc0xlbmd0aCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZChzdHJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRmxvYXQgdmFsdWVzIGRvZXNuJ3QgbmVlZCBhIGxlYWRpbmcgemVyb1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiB2YWx1ZSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJWYWx1ZSA9IChzdHJWYWx1ZSkuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoc3RyVmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnVuaXQuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBJbiBhbiBvcGVyYXRpb24gYmV0d2VlbiB0d28gRGltZW5zaW9ucyxcclxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIHRoZSBmaXJzdCBEaW1lbnNpb24ncyB1bml0LFxyXG4gICAgICAgIC8vIHNvIGAxcHggKyAyYCB3aWxsIHlpZWxkIGAzcHhgLlxyXG4gICAgICAgIG9wZXJhdGU6IGZ1bmN0aW9uIChjb250ZXh0LCBvcCwgb3RoZXIpIHtcclxuICAgICAgICAgICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fb3BlcmF0ZShjb250ZXh0LCBvcCwgdGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xyXG4gICAgICAgICAgICB2YXIgdW5pdCA9IHRoaXMudW5pdC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAob3AgPT09ICcrJyB8fCBvcCA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5pdC5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHVuaXQuZGVub21pbmF0b3IubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IG90aGVyLnVuaXQuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51bml0LmJhY2t1cFVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdC5iYWNrdXBVbml0ID0gdGhpcy51bml0LmJhY2t1cFVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3RoZXIudW5pdC5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHVuaXQuZGVub21pbmF0b3IubGVuZ3RoID09PSAwKSA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdGhlciA9IG90aGVyLmNvbnZlcnRUbyh0aGlzLnVuaXQudXNlZFVuaXRzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN0cmljdFVuaXRzICYmIG90aGVyLnVuaXQudG9TdHJpbmcoKSAhPT0gdW5pdC50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGF0aWJsZSB1bml0cy4gQ2hhbmdlIHRoZSB1bml0cyBvciB1c2UgdGhlIHVuaXQgZnVuY3Rpb24uIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChcIkJhZCB1bml0czogJ1wiICsgdW5pdC50b1N0cmluZygpICsgXCInIGFuZCAnXCIgKyBvdGhlci51bml0LnRvU3RyaW5nKCkgKyBcIicuXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9vcGVyYXRlKGNvbnRleHQsIG9wLCB0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3AgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgdW5pdC5udW1lcmF0b3IgPSB1bml0Lm51bWVyYXRvci5jb25jYXQob3RoZXIudW5pdC5udW1lcmF0b3IpLnNvcnQoKTtcclxuICAgICAgICAgICAgICAgIHVuaXQuZGVub21pbmF0b3IgPSB1bml0LmRlbm9taW5hdG9yLmNvbmNhdChvdGhlci51bml0LmRlbm9taW5hdG9yKS5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB1bml0LmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQubnVtZXJhdG9yID0gdW5pdC5udW1lcmF0b3IuY29uY2F0KG90aGVyLnVuaXQuZGVub21pbmF0b3IpLnNvcnQoKTtcclxuICAgICAgICAgICAgICAgIHVuaXQuZGVub21pbmF0b3IgPSB1bml0LmRlbm9taW5hdG9yLmNvbmNhdChvdGhlci51bml0Lm51bWVyYXRvcikuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgdW5pdC5jYW5jZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih2YWx1ZSwgdW5pdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wYXJlOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGI7XHJcbiAgICAgICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy51bml0LmlzRW1wdHkoKSB8fCBvdGhlci51bml0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBiID0gb3RoZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhID0gdGhpcy51bmlmeSgpO1xyXG4gICAgICAgICAgICAgICAgYiA9IG90aGVyLnVuaWZ5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS51bml0LmNvbXBhcmUoYi51bml0KSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE5vZGUubnVtZXJpY0NvbXBhcmUoYS52YWx1ZSwgYi52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VG8oeyBsZW5ndGg6ICdweCcsIGR1cmF0aW9uOiAncycsIGFuZ2xlOiAncmFkJyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnZlcnRUbzogZnVuY3Rpb24gKGNvbnZlcnNpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciB1bml0ID0gdGhpcy51bml0LmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXA7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRVbml0O1xyXG4gICAgICAgICAgICB2YXIgZGVyaXZlZENvbnZlcnNpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBhcHBseVVuaXQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udmVyc2lvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gdW5pdENvbnZlcnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXRDb252ZXJzaW9uc1tpXS5oYXNPd25Qcm9wZXJ0eShjb252ZXJzaW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVyaXZlZENvbnZlcnNpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcml2ZWRDb252ZXJzaW9uc1tpXSA9IGNvbnZlcnNpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnZlcnNpb25zID0gZGVyaXZlZENvbnZlcnNpb25zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFwcGx5VW5pdCA9IGZ1bmN0aW9uIChhdG9taWNVbml0LCBkZW5vbWluYXRvcikge1xyXG4gICAgICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cclxuICAgICAgICAgICAgICAgIGlmIChncm91cC5oYXNPd25Qcm9wZXJ0eShhdG9taWNVbml0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gKGdyb3VwW2F0b21pY1VuaXRdIC8gZ3JvdXBbdGFyZ2V0VW5pdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIChncm91cFthdG9taWNVbml0XSAvIGdyb3VwW3RhcmdldFVuaXRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFVuaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXRvbWljVW5pdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yIChncm91cE5hbWUgaW4gY29udmVyc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb252ZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShncm91cE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VW5pdCA9IGNvbnZlcnNpb25zW2dyb3VwTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSB1bml0Q29udmVyc2lvbnNbZ3JvdXBOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB1bml0Lm1hcChhcHBseVVuaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuaXQuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbHVlLCB1bml0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBNQVRIJDEgPSBNYXRoJDE7XHJcbiAgICB2YXIgT3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wLCBvcGVyYW5kcywgaXNTcGFjZWQpIHtcclxuICAgICAgICB0aGlzLm9wID0gb3AudHJpbSgpO1xyXG4gICAgICAgIHRoaXMub3BlcmFuZHMgPSBvcGVyYW5kcztcclxuICAgICAgICB0aGlzLmlzU3BhY2VkID0gaXNTcGFjZWQ7XHJcbiAgICB9O1xyXG4gICAgT3BlcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdPcGVyYXRpb24nLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYW5kcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLm9wZXJhbmRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5vcGVyYW5kc1swXS5ldmFsKGNvbnRleHQpLCBiID0gdGhpcy5vcGVyYW5kc1sxXS5ldmFsKGNvbnRleHQpLCBvcDtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNNYXRoT24odGhpcy5vcCkpIHtcclxuICAgICAgICAgICAgICAgIG9wID0gdGhpcy5vcCA9PT0gJy4vJyA/ICcvJyA6IHRoaXMub3A7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBiIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYS50b0NvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIERpbWVuc2lvbiAmJiBhIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gYi50b0NvbG9yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWEub3BlcmF0ZSB8fCAhYi5vcGVyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChhIGluc3RhbmNlb2YgT3BlcmF0aW9uIHx8IGIgaW5zdGFuY2VvZiBPcGVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGEub3AgPT09ICcvJyAmJiBjb250ZXh0Lm1hdGggPT09IE1BVEgkMS5QQVJFTlNfRElWSVNJT04pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb24odGhpcy5vcCwgW2EsIGJdLCB0aGlzLmlzU3BhY2VkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnT3BlcmF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ09wZXJhdGlvbiBvbiBhbiBpbnZhbGlkIHR5cGUnIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5vcGVyYXRlKGNvbnRleHQsIG9wLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKHRoaXMub3AsIFthLCBiXSwgdGhpcy5pc1NwYWNlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhbmRzWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NwYWNlZCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5vcCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3BhY2VkKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCcgJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcGVyYW5kc1sxXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG4gICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG4gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbiAgICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcbiAgICBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbiAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cyQxKCkge1xyXG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cblxuICAgIHZhciBFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZhbHVlLCBub1NwYWNpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5ub1NwYWNpbmcgPSBub1NwYWNpbmc7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cHJlc3Npb24gcmVxdWlyZXMgYW4gYXJyYXkgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0V4cHJlc3Npb24nLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZTtcclxuICAgICAgICAgICAgdmFyIG1hdGhPbiA9IGNvbnRleHQuaXNNYXRoT24oKTtcclxuICAgICAgICAgICAgdmFyIGluUGFyZW50aGVzaXMgPSB0aGlzLnBhcmVucztcclxuICAgICAgICAgICAgdmFyIGRvdWJsZVBhcmVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpblBhcmVudGhlc2lzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmluUGFyZW50aGVzaXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG5ldyBFeHByZXNzaW9uKHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmV2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5ub1NwYWNpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZVswXS5wYXJlbnMgJiYgIXRoaXMudmFsdWVbMF0ucGFyZW5zSW5PcCAmJiAhY29udGV4dC5pbkNhbGMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGVQYXJlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRoaXMudmFsdWVbMF0uZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5QYXJlbnRoZXNpcykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vdXRPZlBhcmVudGhlc2lzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW5zICYmIHRoaXMucGFyZW5zSW5PcCAmJiAhbWF0aE9uICYmICFkb3VibGVQYXJlblxyXG4gICAgICAgICAgICAgICAgJiYgKCEocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBuZXcgUGFyZW4ocmV0dXJuVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubm9TcGFjaW5nICYmIGkgKyAxIDwgdGhpcy52YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCcgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRocm93QXdheUNvbW1lbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEodiBpbnN0YW5jZW9mIENvbW1lbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBmdW5jdGlvbkNhbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbkNhbGxlcihuYW1lLCBjb250ZXh0LCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICAgICAgdGhpcy5mdW5jID0gY29udGV4dC5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeS5nZXQodGhpcy5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb25DYWxsZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZnVuYyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvbkNhbGxlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoYXJncykpKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzID0gW2FyZ3NdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBldmFsQXJncyA9IHRoaXMuZnVuYy5ldmFsQXJncztcclxuICAgICAgICAgICAgaWYgKGV2YWxBcmdzICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmV2YWwoX3RoaXMuY29udGV4dCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb21tZW50RmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICEoaXRlbS50eXBlID09PSAnQ29tbWVudCcpOyB9O1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdGVycmlibGUgYW5kIHNob3VsZCBiZSByZXBsYWNlZCBhcyBwZXIgdGhpcyBpc3N1ZS4uLlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGVzcy9sZXNzLmpzL2lzc3Vlcy8yNDc3XHJcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGNvbW1lbnRGaWx0ZXIpXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnRXhwcmVzc2lvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViTm9kZXMgPSBpdGVtLnZhbHVlLmZpbHRlcihjb21tZW50RmlsdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTm9kZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJOb2Rlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihzdWJOb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZXZhbEFyZ3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXlzJDEoW3RoaXMuY29udGV4dF0sIGFyZ3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbGVyO1xyXG4gICAgfSgpKTtcblxuICAgIC8vXHJcbiAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgbm9kZS5cclxuICAgIC8vXHJcbiAgICB2YXIgQ2FsbCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgICAgIHRoaXMuY2FsYyA9IG5hbWUgPT09ICdjYWxjJztcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgfTtcclxuICAgIENhbGwucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0NhbGwnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJncykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmdzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMuYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2hlbiBldmFsdWF0aW5nIGEgZnVuY3Rpb24gY2FsbCxcclxuICAgICAgICAvLyB3ZSBlaXRoZXIgZmluZCB0aGUgZnVuY3Rpb24gaW4gdGhlIGZ1bmN0aW9uUmVnaXN0cnksXHJcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjYWxsIGl0LCBwYXNzaW5nIHRoZSAgZXZhbHVhdGVkIGFyZ3VtZW50cyxcclxuICAgICAgICAvLyBpZiB0aGlzIHJldHVybnMgbnVsbCBvciB3ZSBjYW5ub3QgZmluZCB0aGUgZnVuY3Rpb24sIHdlXHJcbiAgICAgICAgLy8gc2ltcGx5IHByaW50IGl0IG91dCBhcyBpdCBhcHBlYXJlZCBvcmlnaW5hbGx5IFsyXS5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoZSByZWFzb24gd2h5IHdlIGV2YWx1YXRlIHRoZSBhcmd1bWVudHMsIGlzIGluIHRoZSBjYXNlIHdoZXJlXHJcbiAgICAgICAgLy8gd2UgdHJ5IHRvIHBhc3MgYSB2YXJpYWJsZSB0byBhIGZ1bmN0aW9uLCBsaWtlOiBgc2F0dXJhdGUoQGNvbG9yKWAuXHJcbiAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZWNlaXZlIHRoZSB2YWx1ZSwgbm90IHRoZSB2YXJpYWJsZS5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUdXJuIG9mZiBtYXRoIGZvciBjYWxjKCksIGFuZCBzd2l0Y2ggYmFjayBvbiBmb3IgZXZhbHVhdGluZyBuZXN0ZWQgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudE1hdGhDb250ZXh0ID0gY29udGV4dC5tYXRoT247XHJcbiAgICAgICAgICAgIGNvbnRleHQubWF0aE9uID0gIXRoaXMuY2FsYztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsYyB8fCBjb250ZXh0LmluQ2FsYykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5lbnRlckNhbGMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXhpdENhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FsYyB8fCBjb250ZXh0LmluQ2FsYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXhpdENhbGMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQubWF0aE9uID0gY3VycmVudE1hdGhDb250ZXh0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICB2YXIgZnVuY0NhbGxlciA9IG5ldyBmdW5jdGlvbkNhbGxlcih0aGlzLm5hbWUsIGNvbnRleHQsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKTtcclxuICAgICAgICAgICAgaWYgKGZ1bmNDYWxsZXIuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNDYWxsZXIuY2FsbCh0aGlzLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4aXRDYWxjKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmhhc093blByb3BlcnR5KCdsaW5lJykgJiYgZS5oYXNPd25Qcm9wZXJ0eSgnY29sdW1uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUgfHwgJ1J1bnRpbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkVycm9yIGV2YWx1YXRpbmcgZnVuY3Rpb24gYFwiICsgdGhpcy5uYW1lICsgXCJgXCIgKyAoZS5tZXNzYWdlID8gXCI6IFwiICsgZS5tZXNzYWdlIDogJycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5jb2x1bW5OdW1iZXJcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlc3VsdHMgdGhhdCB0aGF0IGFyZSBub3Qgbm9kZXMgYXJlIGNhc3QgYXMgQW5vbnltb3VzIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAvLyBGYWxzeSB2YWx1ZXMgb3IgYm9vbGVhbnMgYXJlIHJldHVybmVkIGFzIGVtcHR5IG5vZGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0IHx8IHJlc3VsdCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQW5vbnltb3VzKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFub255bW91cyhyZXN1bHQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0Ll9pbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Ll9maWxlSW5mbyA9IHRoaXMuX2ZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuZXZhbChjb250ZXh0KTsgfSk7XHJcbiAgICAgICAgICAgIGV4aXRDYWxjKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbCh0aGlzLm5hbWUsIGFyZ3MsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMubmFtZSArIFwiKFwiLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCB0aGlzLmFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnLCAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKCcpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgVmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgIH07XHJcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnVmFyaWFibGUnLFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZSwgbmFtZSA9IHRoaXMubmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignQEAnKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiQFwiICsgbmV3IFZhcmlhYmxlKG5hbWUuc2xpY2UoMSksIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKS5ldmFsKGNvbnRleHQpLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2YWx1YXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLCBtZXNzYWdlOiBcIlJlY3Vyc2l2ZSB2YXJpYWJsZSBkZWZpbml0aW9uIGZvciBcIiArIG5hbWUsIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlID0gdGhpcy5maW5kKGNvbnRleHQuZnJhbWVzLCBmdW5jdGlvbiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gZnJhbWUudmFyaWFibGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmltcG9ydGFudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0YW50U2NvcGUgPSBjb250ZXh0LmltcG9ydGFudFNjb3BlW2NvbnRleHQuaW1wb3J0YW50U2NvcGUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudFNjb3BlLmltcG9ydGFudCA9IHYuaW1wb3J0YW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbiBjYWxjLCB3cmFwIHZhcnMgaW4gYSBmdW5jdGlvbiBjYWxsIHRvIGNhc2NhZGUgZXZhbHVhdGUgYXJncyBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmluQ2FsYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBDYWxsKCdfU0VMRicsIFt2LnZhbHVlXSkpLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsdWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJywgbWVzc2FnZTogXCJ2YXJpYWJsZSBcIiArIG5hbWUgKyBcIiBpcyB1bmRlZmluZWRcIiwgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChvYmosIGZ1bikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciA9IHZvaWQgMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgciA9IGZ1bi5jYWxsKG9iaiwgb2JqW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgIH07XHJcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3J0ZW4gdGhpcyByZWZlcmVuY2VcclxuICAgICAgICAgICAgdmFyIG1lcmdlUnVsZXMgPSBjb250ZXh0LnBsdWdpbk1hbmFnZXIubGVzcy52aXNpdG9ycy5Ub0NTU1Zpc2l0b3IucHJvdG90eXBlLl9tZXJnZVJ1bGVzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmFsdWF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJywgbWVzc2FnZTogXCJSZWN1cnNpdmUgcHJvcGVydHkgcmVmZXJlbmNlIGZvciBcIiArIG5hbWUsIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHByb3BlcnR5ID0gdGhpcy5maW5kKGNvbnRleHQuZnJhbWVzLCBmdW5jdGlvbiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2O1xyXG4gICAgICAgICAgICAgICAgdmFyIHZBcnIgPSBmcmFtZS5wcm9wZXJ0eShuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICh2QXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2QXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB2QXJyW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2QXJyW2ldID0gbmV3IERlY2xhcmF0aW9uKHYubmFtZSwgdi52YWx1ZSwgdi5pbXBvcnRhbnQsIHYubWVyZ2UsIHYuaW5kZXgsIHYuY3VycmVudEZpbGVJbmZvLCB2LmlubGluZSwgdi52YXJpYWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlUnVsZXModkFycik7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHZBcnJbdkFyci5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5pbXBvcnRhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudFNjb3BlID0gY29udGV4dC5pbXBvcnRhbnRTY29wZVtjb250ZXh0LmltcG9ydGFudFNjb3BlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnRTY29wZS5pbXBvcnRhbnQgPSB2LmltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHYudmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsdWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJywgbWVzc2FnZTogXCJQcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInIGlzIHVuZGVmaW5lZFwiLCBmaWxlbmFtZTogdGhpcy5jdXJyZW50RmlsZUluZm8uZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXggfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmluZDogZnVuY3Rpb24gKG9iaiwgZnVuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByID0gdm9pZCAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByID0gZnVuLmNhbGwob2JqLCBvYmpbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoa2V5LCBvcCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLm9wID0gb3A7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIEF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQXR0cmlidXRlJyxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZSh0aGlzLmtleS5ldmFsID8gdGhpcy5rZXkuZXZhbChjb250ZXh0KSA6IHRoaXMua2V5LCB0aGlzLm9wLCAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmV2YWwpID8gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpIDogdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnRvQ1NTKGNvbnRleHQpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvQ1NTOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmtleS50b0NTUyA/IHRoaXMua2V5LnRvQ1NTKGNvbnRleHQpIDogdGhpcy5rZXk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLm9wO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKHRoaXMudmFsdWUudG9DU1MgPyB0aGlzLnZhbHVlLnRvQ1NTKGNvbnRleHQpIDogdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgdmFsdWUgKyBcIl1cIjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBRdW90ZWQgPSBmdW5jdGlvbiAoc3RyLCBjb250ZW50LCBlc2NhcGVkLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5lc2NhcGVkID0gKGVzY2FwZWQgPT0gbnVsbCkgPyB0cnVlIDogZXNjYXBlZDtcclxuICAgICAgICB0aGlzLnZhbHVlID0gY29udGVudCB8fCAnJztcclxuICAgICAgICB0aGlzLnF1b3RlID0gc3RyLmNoYXJBdCgwKTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVSZWdleCA9IC9AXFx7KFtcXHctXSspXFx9L2c7XHJcbiAgICAgICAgdGhpcy5wcm9wUmVnZXggPSAvXFwkXFx7KFtcXHctXSspXFx9L2c7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSBlc2NhcGVkO1xyXG4gICAgfTtcclxuICAgIFF1b3RlZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnUXVvdGVkJyxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVzY2FwZWQpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5xdW90ZSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lc2NhcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMucXVvdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250YWluc1ZhcmlhYmxlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5tYXRjaCh0aGlzLnZhcmlhYmxlUmVnZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgdmFyaWFibGVSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChfLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG5ldyBWYXJpYWJsZShcIkBcIiArIG5hbWUsIHRoYXQuZ2V0SW5kZXgoKSwgdGhhdC5maWxlSW5mbygpKS5ldmFsKGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2IGluc3RhbmNlb2YgUXVvdGVkKSA/IHYudmFsdWUgOiB2LnRvQ1NTKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKF8sIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gbmV3IFByb3BlcnR5KFwiJFwiICsgbmFtZSwgdGhhdC5nZXRJbmRleCgpLCB0aGF0LmZpbGVJbmZvKCkpLmV2YWwoY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHYgaW5zdGFuY2VvZiBRdW90ZWQpID8gdi52YWx1ZSA6IHYudG9DU1MoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0aXZlUmVwbGFjZSh2YWx1ZSwgcmVnZXhwLCByZXBsYWNlbWVudEZuYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsdWF0ZWRWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlZFZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIHJlcGxhY2VtZW50Rm5jKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHZhbHVlICE9PSBldmFsdWF0ZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVkVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRpdmVSZXBsYWNlKHZhbHVlLCB0aGlzLnZhcmlhYmxlUmVnZXgsIHZhcmlhYmxlUmVwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZXJhdGl2ZVJlcGxhY2UodmFsdWUsIHRoaXMucHJvcFJlZ2V4LCBwcm9wZXJ0eVJlcGxhY2VtZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdW90ZWQodGhpcy5xdW90ZSArIHZhbHVlICsgdGhpcy5xdW90ZSwgdmFsdWUsIHRoaXMuZXNjYXBlZCwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGFyZTogZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcGFyaW5nIHF1b3RlZCBzdHJpbmdzIGFsbG93IHRoZSBxdW90ZSB0byBkaWZmZXJcclxuICAgICAgICAgICAgaWYgKG90aGVyLnR5cGUgPT09ICdRdW90ZWQnICYmICF0aGlzLmVzY2FwZWQgJiYgIW90aGVyLmVzY2FwZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBOb2RlLm51bWVyaWNDb21wYXJlKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlci50b0NTUyAmJiB0aGlzLnRvQ1NTKCkgPT09IG90aGVyLnRvQ1NTKCkgPyAwIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVQYXRoKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9bXFwoXFwpJ1wiXFxzXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2g7IH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIFVSTCA9IGZ1bmN0aW9uICh2YWwsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIGlzRXZhbGQpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5pc0V2YWxkID0gaXNFdmFsZDtcclxuICAgIH07XHJcbiAgICBVUkwucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1VybCcsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKCd1cmwoJyk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoJyknKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZhciByb290cGF0aDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXZhbGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcm9vdHBhdGggaWYgdGhlIFVSTCByZXF1aXJlcyBhIHJld3JpdGVcclxuICAgICAgICAgICAgICAgIHJvb3RwYXRoID0gdGhpcy5maWxlSW5mbygpICYmIHRoaXMuZmlsZUluZm8oKS5yb290cGF0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygcm9vdHBhdGggPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbC52YWx1ZSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGhSZXF1aXJlc1Jld3JpdGUodmFsLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsLnF1b3RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RwYXRoID0gZXNjYXBlUGF0aChyb290cGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA9IGNvbnRleHQucmV3cml0ZVBhdGgodmFsLnZhbHVlLCByb290cGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgPSBjb250ZXh0Lm5vcm1hbGl6ZVBhdGgodmFsLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB1cmwgYXJncyBpZiBlbmFibGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC51cmxBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwudmFsdWUubWF0Y2goL15cXHMqZGF0YTovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsaW1pdGVyID0gdmFsLnZhbHVlLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmxBcmdzID0gZGVsaW1pdGVyICsgY29udGV4dC51cmxBcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLnZhbHVlLmluZGV4T2YoJyMnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA9IHZhbC52YWx1ZS5yZXBsYWNlKCcjJywgdXJsQXJncyArIFwiI1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSArPSB1cmxBcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHZhbCwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIE1lZGlhID0gZnVuY3Rpb24gKHZhbHVlLCBmZWF0dXJlcywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSAobmV3IFNlbGVjdG9yKFtdLCBudWxsLCBudWxsLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8pKS5jcmVhdGVFbXB0eVNlbGVjdG9ycygpO1xyXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgVmFsdWUoZmVhdHVyZXMpO1xyXG4gICAgICAgIHRoaXMucnVsZXMgPSBbbmV3IFJ1bGVzZXQoc2VsZWN0b3JzLCB2YWx1ZSldO1xyXG4gICAgICAgIHRoaXMucnVsZXNbMF0uYWxsb3dJbXBvcnRzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHNlbGVjdG9ycywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5mZWF0dXJlcywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5ydWxlcywgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWVkaWEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgQXRSdWxlKCksIHtcclxuICAgICAgICB0eXBlOiAnTWVkaWEnLFxyXG4gICAgICAgIGlzUnVsZXNldExpa2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gdmlzaXRvci52aXNpdCh0aGlzLmZlYXR1cmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydWxlcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnJ1bGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoJ0BtZWRpYSAnLCB0aGlzLl9maWxlSW5mbywgdGhpcy5faW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dFJ1bGVzZXQoY29udGV4dCwgb3V0cHV0LCB0aGlzLnJ1bGVzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5tZWRpYUJsb2Nrcykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5tZWRpYUJsb2NrcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5tZWRpYVBhdGggPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWVkaWEgPSBuZXcgTWVkaWEobnVsbCwgW10sIHRoaXMuX2luZGV4LCB0aGlzLl9maWxlSW5mbywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzWzBdLmRlYnVnSW5mbyA9IHRoaXMuZGVidWdJbmZvO1xyXG4gICAgICAgICAgICAgICAgbWVkaWEuZGVidWdJbmZvID0gdGhpcy5kZWJ1Z0luZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVkaWEuZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFQYXRoLnB1c2gobWVkaWEpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1lZGlhQmxvY2tzLnB1c2gobWVkaWEpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bGVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkgPSBjb250ZXh0LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5LmluaGVyaXQoKTtcclxuICAgICAgICAgICAgY29udGV4dC5mcmFtZXMudW5zaGlmdCh0aGlzLnJ1bGVzWzBdKTtcclxuICAgICAgICAgICAgbWVkaWEucnVsZXMgPSBbdGhpcy5ydWxlc1swXS5ldmFsKGNvbnRleHQpXTtcclxuICAgICAgICAgICAgY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgY29udGV4dC5tZWRpYVBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0Lm1lZGlhUGF0aC5sZW5ndGggPT09IDAgPyBtZWRpYS5ldmFsVG9wKGNvbnRleHQpIDpcclxuICAgICAgICAgICAgICAgIG1lZGlhLmV2YWxOZXN0ZWQoY29udGV4dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsVG9wOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcclxuICAgICAgICAgICAgLy8gUmVuZGVyIGFsbCBkZXBlbmRlbnQgTWVkaWEgYmxvY2tzLlxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZWRpYUJsb2Nrcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCkpKS5jcmVhdGVFbXB0eVNlbGVjdG9ycygpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJ1bGVzZXQoc2VsZWN0b3JzLCBjb250ZXh0Lm1lZGlhQmxvY2tzKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aU1lZGlhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5VmlzaWJpbGl0eUluZm8odGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KHJlc3VsdCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQubWVkaWFCbG9ja3M7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0Lm1lZGlhUGF0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWxOZXN0ZWQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gY29udGV4dC5tZWRpYVBhdGguY29uY2F0KFt0aGlzXSk7XHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIG1lZGlhLXF1ZXJ5IGNvbmRpdGlvbnMgc2VwYXJhdGVkIHdpdGggYCxgIChPUikuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhdGhbaV0uZmVhdHVyZXMgaW5zdGFuY2VvZiBWYWx1ZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aFtpXS5mZWF0dXJlcy52YWx1ZSA6IHBhdGhbaV0uZmVhdHVyZXM7XHJcbiAgICAgICAgICAgICAgICBwYXRoW2ldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVHJhY2UgYWxsIHBlcm11dGF0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcmVzdWx0aW5nIG1lZGlhLXF1ZXJ5LlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAoYSwgYiBhbmQgYykgd2l0aCBuZXN0ZWQgKGQsIGUpIC0+XHJcbiAgICAgICAgICAgIC8vICAgIGEgYW5kIGRcclxuICAgICAgICAgICAgLy8gICAgYSBhbmQgZVxyXG4gICAgICAgICAgICAvLyAgICBiIGFuZCBjIGFuZCBkXHJcbiAgICAgICAgICAgIC8vICAgIGIgYW5kIGMgYW5kIGVcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBWYWx1ZSh0aGlzLnBlcm11dGUocGF0aCkubWFwKGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7IHJldHVybiBmcmFnbWVudC50b0NTUyA/IGZyYWdtZW50IDogbmV3IEFub255bW91cyhmcmFnbWVudCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zcGxpY2UoaSwgMCwgbmV3IEFub255bW91cygnYW5kJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHBhdGgpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuZmVhdHVyZXMsIHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBGYWtlIGEgdHJlZS1ub2RlIHRoYXQgZG9lc24ndCBvdXRwdXQgYW55dGhpbmcuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVsZXNldChbXSwgW10pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGVybXV0ZTogZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGVybXV0ZShhcnIuc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJbMF0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyclswXVtqXV0uY29uY2F0KHJlc3RbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWJibGVTZWxlY3RvcnM6IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJ1bGVzID0gW25ldyBSdWxlc2V0KGNvcHlBcnJheShzZWxlY3RvcnMpLCBbdGhpcy5ydWxlc1swXV0pXTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5ydWxlcywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICAvL1xyXG4gICAgLy8gQ1NTIEBpbXBvcnQgbm9kZVxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBnZW5lcmFsIHN0cmF0ZWd5IGhlcmUgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIHdhaXRcclxuICAgIC8vIGZvciB0aGUgcGFyc2luZyB0byBiZSBjb21wbGV0ZWQsIGJlZm9yZSB3ZSBzdGFydCBpbXBvcnRpbmdcclxuICAgIC8vIHRoZSBmaWxlLiBUaGF0J3MgYmVjYXVzZSBpbiB0aGUgY29udGV4dCBvZiBhIGJyb3dzZXIsXHJcbiAgICAvLyBtb3N0IG9mIHRoZSB0aW1lIHdpbGwgYmUgc3BlbnQgd2FpdGluZyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kLlxyXG4gICAgLy9cclxuICAgIC8vIE9uIGNyZWF0aW9uLCB3ZSBwdXNoIHRoZSBpbXBvcnQgcGF0aCB0byBvdXIgaW1wb3J0IHF1ZXVlLCB0aG91Z2hcclxuICAgIC8vIGBpbXBvcnQscHVzaGAsIHdlIGFsc28gcGFzcyBpdCBhIGNhbGxiYWNrLCB3aGljaCBpdCdsbCBjYWxsIG9uY2VcclxuICAgIC8vIHRoZSBmaWxlIGhhcyBiZWVuIGZldGNoZWQsIGFuZCBwYXJzZWQuXHJcbiAgICAvL1xyXG4gICAgdmFyIEltcG9ydCA9IGZ1bmN0aW9uIChwYXRoLCBmZWF0dXJlcywgb3B0aW9ucywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVzcyAhPT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5jc3MgPSAhdGhpcy5vcHRpb25zLmxlc3MgfHwgdGhpcy5vcHRpb25zLmlubGluZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoVmFsdWUgPSB0aGlzLmdldFBhdGgoKTtcclxuICAgICAgICAgICAgaWYgKHBhdGhWYWx1ZSAmJiAvWyNcXC5cXCZcXD9dY3NzKFtcXD87XS4qKT8kLy50ZXN0KHBhdGhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3NzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5mZWF0dXJlcywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5wYXRoLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBJbXBvcnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0ltcG9ydCcsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHZpc2l0b3IudmlzaXQodGhpcy5mZWF0dXJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gdmlzaXRvci52aXNpdCh0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc1BsdWdpbiAmJiAhdGhpcy5vcHRpb25zLmlubGluZSAmJiB0aGlzLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHZpc2l0b3IudmlzaXQodGhpcy5yb290KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNzcyAmJiB0aGlzLnBhdGguX2ZpbGVJbmZvLnJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCdAaW1wb3J0ICcsIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLl9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGguZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRQYXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wYXRoIGluc3RhbmNlb2YgVVJMKSA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgudmFsdWUudmFsdWUgOiB0aGlzLnBhdGgudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1ZhcmlhYmxlSW1wb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFVSTCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBRdW90ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmNvbnRhaW5zVmFyaWFibGVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsRm9ySW1wb3J0OiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1wb3J0KHBhdGguZXZhbChjb250ZXh0KSwgdGhpcy5mZWF0dXJlcywgdGhpcy5vcHRpb25zLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsUGF0aDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGguZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIGZpbGVJbmZvID0gdGhpcy5fZmlsZUluZm87XHJcbiAgICAgICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBVUkwpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJvb3RwYXRoIGlmIHRoZSBVUkwgcmVxdWlyZXMgYSByZXdyaXRlXHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFZhbHVlID0gcGF0aC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxlSW5mbyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aFJlcXVpcmVzUmV3cml0ZShwYXRoVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC52YWx1ZSA9IGNvbnRleHQucmV3cml0ZVBhdGgocGF0aFZhbHVlLCBmaWxlSW5mby5yb290cGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnZhbHVlID0gY29udGV4dC5ub3JtYWxpemVQYXRoKHBhdGgudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZG9FdmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZmVyZW5jZSB8fCB0aGlzLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRvRXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzZXQ7XHJcbiAgICAgICAgICAgIHZhciByZWdpc3RyeTtcclxuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcyAmJiB0aGlzLmZlYXR1cmVzLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNQbHVnaW4pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgJiYgdGhpcy5yb290LmV2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gJ1BsdWdpbiBlcnJvciBkdXJpbmcgZXZhbHVhdGlvbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoZSwgdGhpcy5yb290LmltcG9ydHMsIHRoaXMucm9vdC5maWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVnaXN0cnkgPSBjb250ZXh0LmZyYW1lc1swXSAmJiBjb250ZXh0LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5ICYmIHRoaXMucm9vdCAmJiB0aGlzLnJvb3QuZnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cnkuYWRkTXVsdGlwbGUodGhpcy5yb290LmZ1bmN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNraXAgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAgPSB0aGlzLnNraXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNraXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IG5ldyBBbm9ueW1vdXModGhpcy5yb290LCAwLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuaW1wb3J0ZWRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHRoaXMucGF0aC5fZmlsZUluZm8gJiYgdGhpcy5wYXRoLl9maWxlSW5mby5yZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIH0sIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMgPyBuZXcgTWVkaWEoW2NvbnRlbnRzXSwgdGhpcy5mZWF0dXJlcy52YWx1ZSkgOiBbY29udGVudHNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3NzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3SW1wb3J0ID0gbmV3IEltcG9ydCh0aGlzLmV2YWxQYXRoKGNvbnRleHQpLCBmZWF0dXJlcywgdGhpcy5vcHRpb25zLCB0aGlzLl9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0ltcG9ydC5jc3MgJiYgdGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3SW1wb3J0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KG51bGwsIGNvcHlBcnJheSh0aGlzLnJvb3QucnVsZXMpKTtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXQuZXZhbEltcG9ydHMoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcyA/IG5ldyBNZWRpYShydWxlc2V0LnJ1bGVzLCB0aGlzLmZlYXR1cmVzLnZhbHVlKSA6IHJ1bGVzZXQucnVsZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBKc0V2YWxOb2RlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgSnNFdmFsTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICBldmFsdWF0ZUphdmFTY3JpcHQ6IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGV2YWxDb250ZXh0ID0ge307XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5qYXZhc2NyaXB0RW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnSW5saW5lIEphdmFTY3JpcHQgaXMgbm90IGVuYWJsZWQuIElzIGl0IHNldCBpbiB5b3VyIG9wdGlvbnM/JyxcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKC9AXFx7KFtcXHctXSspXFx9L2csIGZ1bmN0aW9uIChfLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5qc2lmeShuZXcgVmFyaWFibGUoXCJAXCIgKyBuYW1lLCB0aGF0LmdldEluZGV4KCksIHRoYXQuZmlsZUluZm8oKSkuZXZhbChjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBGdW5jdGlvbihcInJldHVybiAoXCIgKyBleHByZXNzaW9uICsgXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IFwiSmF2YVNjcmlwdCBldmFsdWF0aW9uIGVycm9yOiBcIiArIGUubWVzc2FnZSArIFwiIGZyb20gYFwiICsgZXhwcmVzc2lvbiArIFwiYFwiLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gY29udGV4dC5mcmFtZXNbMF0udmFyaWFibGVzKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVzLmhhc093blByb3BlcnR5KGspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICBldmFsQ29udGV4dFtrLnNsaWNlKDEpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhcmlhYmxlc1trXS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9KUzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcmVzc2lvbi5jYWxsKGV2YWxDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIkphdmFTY3JpcHQgZXZhbHVhdGlvbiBlcnJvcjogJ1wiICsgZS5uYW1lICsgXCI6IFwiICsgZS5tZXNzYWdlLnJlcGxhY2UoL1tcIl0vZywgJ1xcJycpICsgXCInXCIsIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBqc2lmeTogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoudmFsdWUpICYmIChvYmoudmFsdWUubGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIG9iai52YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYudG9DU1MoKTsgfSkuam9pbignLCAnKSArIFwiXVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai50b0NTUygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGVzY2FwZWQsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcclxuICAgICAgICB0aGlzLmVzY2FwZWQgPSBlc2NhcGVkO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHN0cmluZztcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgfTtcclxuICAgIEphdmFTY3JpcHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgSnNFdmFsTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0phdmFTY3JpcHQnLFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmV2YWx1YXRlSmF2YVNjcmlwdCh0aGlzLmV4cHJlc3Npb24sIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdW90ZWQoXCJcXFwiXCIgKyByZXN1bHQgKyBcIlxcXCJcIiwgcmVzdWx0LCB0aGlzLmVzY2FwZWQsIHRoaXMuX2luZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHJlc3VsdC5qb2luKCcsICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBBc3NpZ25tZW50ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcclxuICAgIH07XHJcbiAgICBBc3NpZ25tZW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdBc3NpZ25tZW50JyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZXZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50KHRoaXMua2V5LCB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5rZXkgKyBcIj1cIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmdlbkNTUykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBDb25kaXRpb24gPSBmdW5jdGlvbiAob3AsIGwsIHIsIGksIG5lZ2F0ZSkge1xyXG4gICAgICAgIHRoaXMub3AgPSBvcC50cmltKCk7XHJcbiAgICAgICAgdGhpcy5sdmFsdWUgPSBsO1xyXG4gICAgICAgIHRoaXMucnZhbHVlID0gcjtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGk7XHJcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XHJcbiAgICB9O1xyXG4gICAgQ29uZGl0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdDb25kaXRpb24nLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5sdmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMubHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5ydmFsdWUgPSB2aXNpdG9yLnZpc2l0KHRoaXMucnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKG9wLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYW5kJzogcmV0dXJuIGEgJiYgYjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdvcic6IHJldHVybiBhIHx8IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChOb2RlLmNvbXBhcmUoYSwgYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wID09PSAnPCcgfHwgb3AgPT09ICc9PCcgfHwgb3AgPT09ICc8PSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHwgb3AgPT09ICc+PScgfHwgb3AgPT09ICc9PCcgfHwgb3AgPT09ICc8PSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wID09PSAnPicgfHwgb3AgPT09ICc+PSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSh0aGlzLm9wLCB0aGlzLmx2YWx1ZS5ldmFsKGNvbnRleHQpLCB0aGlzLnJ2YWx1ZS5ldmFsKGNvbnRleHQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlID8gIXJlc3VsdCA6IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBVbmljb2RlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBVbmljb2RlRGVzY3JpcHRvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnVW5pY29kZURlc2NyaXB0b3InXHJcbiAgICB9KTtcblxuICAgIHZhciBOZWdhdGl2ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5vZGU7XHJcbiAgICB9O1xyXG4gICAgTmVnYXRpdmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ05lZ2F0aXZlJyxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCgnLScpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNNYXRoT24oKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgT3BlcmF0aW9uKCcqJywgW25ldyBEaW1lbnNpb24oLTEpLCB0aGlzLnZhbHVlXSkpLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOZWdhdGl2ZSh0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIEV4dGVuZCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0aW9uLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCB2aXNpYmlsaXR5SW5mbykge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuICAgICAgICB0aGlzLm9iamVjdF9pZCA9IEV4dGVuZC5uZXh0X2lkKys7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRfaWRzID0gW3RoaXMub2JqZWN0X2lkXTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAnYWxsJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dCZWZvcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0FmdGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0JlZm9yZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0FmdGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5zZWxlY3RvciwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXh0ZW5kLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdFeHRlbmQnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHZpc2l0b3IudmlzaXQodGhpcy5zZWxlY3Rvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4dGVuZCh0aGlzLnNlbGVjdG9yLmV2YWwoY29udGV4dCksIHRoaXMub3B0aW9uLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4dGVuZCh0aGlzLnNlbGVjdG9yLCB0aGlzLm9wdGlvbiwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpdCBjb25jYXRlbmF0ZXMgKGpvaW5zKSBhbGwgc2VsZWN0b3JzIGluIHNlbGVjdG9yIGFycmF5XHJcbiAgICAgICAgZmluZFNlbGZTZWxlY3RvcnM6IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGZFbGVtZW50cyA9IFtdLCBpLCBzZWxlY3RvckVsZW1lbnRzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvckVsZW1lbnRzID0gc2VsZWN0b3JzW2ldLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgLy8gZHVwbGljYXRlIHRoZSBsb2dpYyBpbiBnZW5DU1MgZnVuY3Rpb24gaW5zaWRlIHRoZSBzZWxlY3RvciBub2RlLlxyXG4gICAgICAgICAgICAgICAgLy8gZnV0dXJlIFRPRE8gLSBtb3ZlIGJvdGggbG9naWNzIGludG8gdGhlIHNlbGVjdG9yIGpvaW5lciB2aXNpdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgc2VsZWN0b3JFbGVtZW50cy5sZW5ndGggJiYgc2VsZWN0b3JFbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yRWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9ICcgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGZFbGVtZW50cyA9IHNlbGZFbGVtZW50cy5jb25jYXQoc2VsZWN0b3JzW2ldLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbGZTZWxlY3RvcnMgPSBbbmV3IFNlbGVjdG9yKHNlbGZFbGVtZW50cyldO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGZTZWxlY3RvcnNbMF0uY29weVZpc2liaWxpdHlJbmZvKHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBFeHRlbmQubmV4dF9pZCA9IDA7XG5cbiAgICB2YXIgVmFyaWFibGVDYWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFZhcmlhYmxlQ2FsbC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnVmFyaWFibGVDYWxsJyxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcnVsZXM7XHJcbiAgICAgICAgICAgIHZhciBkZXRhY2hlZFJ1bGVzZXQgPSBuZXcgVmFyaWFibGUodGhpcy52YXJpYWJsZSwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCkpLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBMZXNzRXJyb3IoeyBtZXNzYWdlOiBcIkNvdWxkIG5vdCBldmFsdWF0ZSB2YXJpYWJsZSBjYWxsIFwiICsgdGhpcy52YXJpYWJsZSB9KTtcclxuICAgICAgICAgICAgaWYgKCFkZXRhY2hlZFJ1bGVzZXQucnVsZXNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaGVkUnVsZXNldC5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gZGV0YWNoZWRSdWxlc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZXRhY2hlZFJ1bGVzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBuZXcgUnVsZXNldCgnJywgZGV0YWNoZWRSdWxlc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGV0YWNoZWRSdWxlc2V0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gbmV3IFJ1bGVzZXQoJycsIGRldGFjaGVkUnVsZXNldC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRldGFjaGVkUnVsZXNldCA9IG5ldyBEZXRhY2hlZFJ1bGVzZXQocnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXRhY2hlZFJ1bGVzZXQucnVsZXNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldGFjaGVkUnVsZXNldC5jYWxsRXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBOYW1lc3BhY2VWYWx1ZSA9IGZ1bmN0aW9uIChydWxlQ2FsbCwgbG9va3VwcywgaW5kZXgsIGZpbGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHJ1bGVDYWxsO1xyXG4gICAgICAgIHRoaXMubG9va3VwcyA9IGxvb2t1cHM7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGZpbGVJbmZvO1xyXG4gICAgfTtcclxuICAgIE5hbWVzcGFjZVZhbHVlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdOYW1lc3BhY2VWYWx1ZScsXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGksIG5hbWUsIHJ1bGVzID0gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sb29rdXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5sb29rdXBzW2ldO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFdmFsJ2QgRFJzIHJldHVybiBydWxlc2V0cy5cclxuICAgICAgICAgICAgICAgICAqIEV2YWwnZCBtaXhpbnMgcmV0dXJuIHJ1bGVzLCBzbyBsZXQncyBtYWtlIGEgcnVsZXNldCBpZiB3ZSBuZWVkIGl0LlxyXG4gICAgICAgICAgICAgICAgICogV2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2Ugb2YgbGF0ZSBwYXJzaW5nIG9mIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IG5ldyBSdWxlc2V0KFtuZXcgU2VsZWN0b3IoKV0sIHJ1bGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMubGFzdERlY2xhcmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiQFwiICsgbmV3IFZhcmlhYmxlKG5hbWUuc3Vic3RyKDEpKS5ldmFsKGNvbnRleHQpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXMudmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMudmFyaWFibGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsIG1lc3NhZ2U6IFwidmFyaWFibGUgXCIgKyBuYW1lICsgXCIgbm90IGZvdW5kXCIsIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDIpID09PSAnJEAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIiRcIiArIG5ldyBWYXJpYWJsZShuYW1lLnN1YnN0cigxKSkuZXZhbChjb250ZXh0KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyQnID8gbmFtZSA6IFwiJFwiICsgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBydWxlcy5wcm9wZXJ0eShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJywgbWVzc2FnZTogXCJwcm9wZXJ0eSBcXFwiXCIgKyBuYW1lLnN1YnN0cigxKSArIFwiXFxcIiBub3QgZm91bmRcIiwgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBhcmUgYW4gYXJyYXkgb2YgdmFsdWVzLCBzaW5jZSBhIHJ1bGVzZXQgY2FuIGhhdmUgbXVsdGlwbGUgcHJvcHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcGljayB0aGUgbGFzdCBvbmUgKHRoZSBcImNhc2NhZGVkXCIgdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBydWxlc1tydWxlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChydWxlcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMuZXZhbChjb250ZXh0KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChydWxlcy5ydWxlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBydWxlcy5ydWxlc2V0LmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIERlZmluaXRpb24gPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zLCBydWxlcywgY29uZGl0aW9uLCB2YXJpYWRpYywgZnJhbWVzLCB2aXNpYmlsaXR5SW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ2Fub255bW91cyBtaXhpbic7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBbbmV3IFNlbGVjdG9yKFtuZXcgRWxlbWVudChudWxsLCBuYW1lLCBmYWxzZSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvKV0pXTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnZhcmlhZGljID0gdmFyaWFkaWM7XHJcbiAgICAgICAgdGhpcy5hcml0eSA9IHBhcmFtcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG4gICAgICAgIHRoaXMuX2xvb2t1cHMgPSB7fTtcclxuICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbWV0ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBwKSB7XHJcbiAgICAgICAgICAgIGlmICghcC5uYW1lIHx8IChwLm5hbWUgJiYgIXAudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxQYXJhbWV0ZXJzLnB1c2gocC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWxQYXJhbWV0ZXJzID0gb3B0aW9uYWxQYXJhbWV0ZXJzO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzO1xyXG4gICAgICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgRGVmaW5pdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBSdWxlc2V0KCksIHtcclxuICAgICAgICB0eXBlOiAnTWl4aW5EZWZpbml0aW9uJyxcclxuICAgICAgICBldmFsRmlyc3Q6IHRydWUsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbXMgJiYgdGhpcy5wYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ydWxlcyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnJ1bGVzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHZpc2l0b3IudmlzaXQodGhpcy5jb25kaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsUGFyYW1zOiBmdW5jdGlvbiAoY29udGV4dCwgbWl4aW5FbnYsIGFyZ3MsIGV2YWxkQXJndW1lbnRzKSB7XHJcbiAgICAgICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cclxuICAgICAgICAgICAgdmFyIGZyYW1lID0gbmV3IFJ1bGVzZXQobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciB2YXJhcmdzO1xyXG4gICAgICAgICAgICB2YXIgYXJnO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gY29weUFycmF5KHRoaXMucGFyYW1zKTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICAgICAgdmFyIGlzTmFtZWRGb3VuZDtcclxuICAgICAgICAgICAgdmFyIGFyZ0luZGV4O1xyXG4gICAgICAgICAgICB2YXIgYXJnc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChtaXhpbkVudi5mcmFtZXMgJiYgbWl4aW5FbnYuZnJhbWVzWzBdICYmIG1peGluRW52LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5mdW5jdGlvblJlZ2lzdHJ5ID0gbWl4aW5FbnYuZnJhbWVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkuaW5oZXJpdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1peGluRW52ID0gbmV3IGNvbnRleHRzLkV2YWwobWl4aW5FbnYsIFtmcmFtZV0uY29uY2F0KG1peGluRW52LmZyYW1lcykpO1xyXG4gICAgICAgICAgICBpZiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IGNvcHlBcnJheShhcmdzKTtcclxuICAgICAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID0gKGFyZyAmJiBhcmcubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOYW1lZEZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXJhbXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZhbGRBcmd1bWVudHNbal0gJiYgbmFtZSA9PT0gcGFyYW1zW2pdLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsZEFyZ3VtZW50c1tqXSA9IGFyZy52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBEZWNsYXJhdGlvbihuYW1lLCBhcmcudmFsdWUuZXZhbChjb250ZXh0KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmFtZWRGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFtZWRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1J1bnRpbWUnLCBtZXNzYWdlOiBcIk5hbWVkIGFyZ3VtZW50IGZvciBcIiArIHRoaXMubmFtZSArIFwiIFwiICsgYXJnc1tpXS5uYW1lICsgXCIgbm90IGZvdW5kXCIgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmdJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmFsZEFyZ3VtZW50c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXJnID0gYXJncyAmJiBhcmdzW2FyZ0luZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID0gcGFyYW1zW2ldLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zW2ldLnZhcmlhZGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYXJnSW5kZXg7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmFyZ3MucHVzaChhcmdzW2pdLnZhbHVlLmV2YWwoY29udGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBEZWNsYXJhdGlvbihuYW1lLCBuZXcgRXhwcmVzc2lvbih2YXJhcmdzKS5ldmFsKGNvbnRleHQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmcgJiYgYXJnLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBhIG1peGluIGNhbGwsIHBhc3MgaW4gYSBkZXRhY2hlZCBydWxlc2V0IG9mIGl0J3MgZXZhbCdkIHJ1bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IERldGFjaGVkUnVsZXNldChuZXcgUnVsZXNldCgnJywgdmFsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXNbaV0udmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcmFtc1tpXS52YWx1ZS5ldmFsKG1peGluRW52KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1J1bnRpbWUnLCBtZXNzYWdlOiBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIFwiICsgdGhpcy5uYW1lICsgXCIgKFwiICsgYXJnc0xlbmd0aCArIFwiIGZvciBcIiArIHRoaXMuYXJpdHkgKyBcIilcIiB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBEZWNsYXJhdGlvbihuYW1lLCB2YWwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbGRBcmd1bWVudHNbaV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tpXS52YXJpYWRpYyAmJiBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYXJnSW5kZXg7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbGRBcmd1bWVudHNbal0gPSBhcmdzW2pdLnZhbHVlLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXJnSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYWtlSW1wb3J0YW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9ICF0aGlzLnJ1bGVzID8gdGhpcy5ydWxlcyA6IHRoaXMucnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoci5tYWtlSW1wb3J0YW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIubWFrZUltcG9ydGFudCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEZWZpbml0aW9uKHRoaXMubmFtZSwgdGhpcy5wYXJhbXMsIHJ1bGVzLCB0aGlzLmNvbmRpdGlvbiwgdGhpcy52YXJpYWRpYywgdGhpcy5mcmFtZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZpbml0aW9uKHRoaXMubmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMucnVsZXMsIHRoaXMuY29uZGl0aW9uLCB0aGlzLnZhcmlhZGljLCB0aGlzLmZyYW1lcyB8fCBjb3B5QXJyYXkoY29udGV4dC5mcmFtZXMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWxDYWxsOiBmdW5jdGlvbiAoY29udGV4dCwgYXJncywgaW1wb3J0YW50KSB7XHJcbiAgICAgICAgICAgIHZhciBfYXJndW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBtaXhpbkZyYW1lcyA9IHRoaXMuZnJhbWVzID8gdGhpcy5mcmFtZXMuY29uY2F0KGNvbnRleHQuZnJhbWVzKSA6IGNvbnRleHQuZnJhbWVzO1xyXG4gICAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLmV2YWxQYXJhbXMoY29udGV4dCwgbmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCwgbWl4aW5GcmFtZXMpLCBhcmdzLCBfYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzO1xyXG4gICAgICAgICAgICB2YXIgcnVsZXNldDtcclxuICAgICAgICAgICAgZnJhbWUucHJlcGVuZFJ1bGUobmV3IERlY2xhcmF0aW9uKCdAYXJndW1lbnRzJywgbmV3IEV4cHJlc3Npb24oX2FyZ3VtZW50cykuZXZhbChjb250ZXh0KSkpO1xyXG4gICAgICAgICAgICBydWxlcyA9IGNvcHlBcnJheSh0aGlzLnJ1bGVzKTtcclxuICAgICAgICAgICAgcnVsZXNldCA9IG5ldyBSdWxlc2V0KG51bGwsIHJ1bGVzKTtcclxuICAgICAgICAgICAgcnVsZXNldC5vcmlnaW5hbFJ1bGVzZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBydWxlc2V0ID0gcnVsZXNldC5ldmFsKG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIFt0aGlzLCBmcmFtZV0uY29uY2F0KG1peGluRnJhbWVzKSkpO1xyXG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50KSB7XHJcbiAgICAgICAgICAgICAgICBydWxlc2V0ID0gcnVsZXNldC5tYWtlSW1wb3J0YW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXRjaENvbmRpdGlvbjogZnVuY3Rpb24gKGFyZ3MsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uICYmICF0aGlzLmNvbmRpdGlvbi5ldmFsKG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIFt0aGlzLmV2YWxQYXJhbXMoY29udGV4dCwgLyogdGhlIHBhcmFtZXRlciB2YXJpYWJsZXMgKi8gbmV3IGNvbnRleHRzLkV2YWwoY29udGV4dCwgdGhpcy5mcmFtZXMgPyB0aGlzLmZyYW1lcy5jb25jYXQoY29udGV4dC5mcmFtZXMpIDogY29udGV4dC5mcmFtZXMpLCBhcmdzLCBbXSldXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZnJhbWVzIHx8IFtdKSAvLyB0aGUgcGFyZW50IG5hbWVzcGFjZS9taXhpbiBmcmFtZXNcclxuICAgICAgICAgICAgICAgIC5jb25jYXQoY29udGV4dC5mcmFtZXMpKSkpIHsgLy8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZnJhbWVzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXRjaEFyZ3M6IGZ1bmN0aW9uIChhcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxBcmdzQ250ID0gKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBsZW47XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25hbFBhcmFtZXRlcnMgPSB0aGlzLm9wdGlvbmFsUGFyYW1ldGVycztcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVkQXJnc0NudCA9ICFhcmdzID8gMCA6IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsUGFyYW1ldGVycy5pbmRleE9mKHAubmFtZSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YXJpYWRpYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkQXJnc0NudCA8IHRoaXMucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxsQXJnc0NudCA+IHRoaXMucGFyYW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZEFyZ3NDbnQgPCAodGhpcy5yZXF1aXJlZCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhdHRlcm5zXHJcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWluKHJlcXVpcmVkQXJnc0NudCwgdGhpcy5hcml0eSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJhbXNbaV0ubmFtZSAmJiAhdGhpcy5wYXJhbXNbaV0udmFyaWFkaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1tpXS52YWx1ZS5ldmFsKGNvbnRleHQpLnRvQ1NTKCkgIT0gdGhpcy5wYXJhbXNbaV0udmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgTWl4aW5DYWxsID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBhcmdzLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpbXBvcnRhbnQpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKGVsZW1lbnRzKTtcclxuICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3MgfHwgW107XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmltcG9ydGFudCA9IGltcG9ydGFudDtcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5zZWxlY3RvciwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWl4aW5DYWxsLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdNaXhpbkNhbGwnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB2aXNpdG9yLnZpc2l0KHRoaXMuc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMuYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIG1peGlucztcclxuICAgICAgICAgICAgdmFyIG1peGluO1xyXG4gICAgICAgICAgICB2YXIgbWl4aW5QYXRoO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgYXJnO1xyXG4gICAgICAgICAgICB2YXIgYXJnVmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBtO1xyXG4gICAgICAgICAgICB2YXIgZjtcclxuICAgICAgICAgICAgdmFyIGlzUmVjdXJzaXZlO1xyXG4gICAgICAgICAgICB2YXIgaXNPbmVGb3VuZDtcclxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZTtcclxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvblJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGRlZkZhbHNlRWl0aGVyQ2FzZSA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgZGVmTm9uZSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBkZWZUcnVlID0gMTtcclxuICAgICAgICAgICAgdmFyIGRlZkZhbHNlID0gMjtcclxuICAgICAgICAgICAgdmFyIGNvdW50O1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxSdWxlc2V0O1xyXG4gICAgICAgICAgICB2YXIgbm9Bcmd1bWVudHNGaWx0ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGNEZWZHcm91cChtaXhpbiwgbWl4aW5QYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiwgcCwgbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8IDI7IGYrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdFtmXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEZ1bmMudmFsdWUoZik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IG1peGluUGF0aC5sZW5ndGggJiYgY29uZGl0aW9uUmVzdWx0W2ZdOyBwKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlID0gbWl4aW5QYXRoW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlLm1hdGNoQ29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHRbZl0gPSBjb25kaXRpb25SZXN1bHRbZl0gJiYgbmFtZXNwYWNlLm1hdGNoQ29uZGl0aW9uKG51bGwsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXhpbi5tYXRjaENvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHRbZl0gPSBjb25kaXRpb25SZXN1bHRbZl0gJiYgbWl4aW4ubWF0Y2hDb25kaXRpb24oYXJncywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdFswXSB8fCBjb25kaXRpb25SZXN1bHRbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0WzBdICE9IGNvbmRpdGlvblJlc3VsdFsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uUmVzdWx0WzFdID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZlRydWUgOiBkZWZGYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZk5vbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmRmFsc2VFaXRoZXJDYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5hcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBhcmdWYWx1ZSA9IGFyZy52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5leHBhbmQgJiYgQXJyYXkuaXNBcnJheShhcmdWYWx1ZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZSA9IGFyZ1ZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBhcmdWYWx1ZS5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goeyB2YWx1ZTogYXJnVmFsdWVbbV0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHsgbmFtZTogYXJnLm5hbWUsIHZhbHVlOiBhcmdWYWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub0FyZ3VtZW50c0ZpbHRlciA9IGZ1bmN0aW9uIChydWxlKSB7IHJldHVybiBydWxlLm1hdGNoQXJncyhudWxsLCBjb250ZXh0KTsgfTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHQuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKG1peGlucyA9IGNvbnRleHQuZnJhbWVzW2ldLmZpbmQodGhpcy5zZWxlY3RvciwgbnVsbCwgbm9Bcmd1bWVudHNGaWx0ZXIpKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbmVGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gbWFrZSBgZGVmYXVsdCgpYCBmdW5jdGlvbiBpbmRlcGVuZGVudCBvZiBkZWZpbml0aW9uIG9yZGVyIHdlIGhhdmUgdHdvIFwic3VicGFzc2VzXCIgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBdCBmaXJzdCB3ZSBldmFsdWF0ZSBlYWNoIGd1YXJkICp0d2ljZSogKHdpdGggYGRlZmF1bHQoKSA9PSB0cnVlYCBhbmQgYGRlZmF1bHQoKSA9PSBmYWxzZWApLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBidWlsZCBjYW5kaWRhdGUgbGlzdCB3aXRoIGNvcnJlc3BvbmRpbmcgZmxhZ3MuIFRoZW4sIHdoZW4gd2Uga25vdyBhbGwgcG9zc2libGUgbWF0Y2hlcyxcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtYWtlIGEgZmluYWwgZGVjaXNpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IG1peGlucy5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhpbiA9IG1peGluc1ttXS5ydWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhpblBhdGggPSBtaXhpbnNbbV0ucGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWN1cnNpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8IGNvbnRleHQuZnJhbWVzLmxlbmd0aDsgZisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCEobWl4aW4gaW5zdGFuY2VvZiBEZWZpbml0aW9uKSkgJiYgbWl4aW4gPT09IChjb250ZXh0LmZyYW1lc1tmXS5vcmlnaW5hbFJ1bGVzZXQgfHwgY29udGV4dC5mcmFtZXNbZl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWN1cnNpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlY3Vyc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1peGluLm1hdGNoQXJncyhhcmdzLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0geyBtaXhpbjogbWl4aW4sIGdyb3VwOiBjYWxjRGVmR3JvdXAobWl4aW4sIG1peGluUGF0aCkgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuZ3JvdXAgIT09IGRlZkZhbHNlRWl0aGVyQ2FzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRGdW5jLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRbY2FuZGlkYXRlc1ttXS5ncm91cF0rKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50W2RlZk5vbmVdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UmVzdWx0ID0gZGVmRmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UmVzdWx0ID0gZGVmVHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudFtkZWZUcnVlXSArIGNvdW50W2RlZkZhbHNlXSkgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdSdW50aW1lJywgbWVzc2FnZTogXCJBbWJpZ3VvdXMgdXNlIG9mIGBkZWZhdWx0KClgIGZvdW5kIHdoZW4gbWF0Y2hpbmcgZm9yIGBcIiArIHRoaXMuZm9ybWF0KGFyZ3MpICsgXCJgXCIsIGluZGV4OiB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgY2FuZGlkYXRlcy5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW21dLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNhbmRpZGF0ZSA9PT0gZGVmTm9uZSkgfHwgKGNhbmRpZGF0ZSA9PT0gZGVmYXVsdFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4gPSBjYW5kaWRhdGVzW21dLm1peGluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1peGluIGluc3RhbmNlb2YgRGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSdWxlc2V0ID0gbWl4aW4ub3JpZ2luYWxSdWxlc2V0IHx8IG1peGluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXhpbiA9IG5ldyBEZWZpbml0aW9uKCcnLCBbXSwgbWl4aW4ucnVsZXMsIG51bGwsIGZhbHNlLCBudWxsLCBvcmlnaW5hbFJ1bGVzZXQudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peGluLm9yaWdpbmFsUnVsZXNldCA9IG9yaWdpbmFsUnVsZXNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1J1bGVzID0gbWl4aW4uZXZhbENhbGwoY29udGV4dCwgYXJncywgdGhpcy5pbXBvcnRhbnQpLnJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFZpc2liaWxpdHlUb1JlcGxhY2VtZW50KG5ld1J1bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShydWxlcywgbmV3UnVsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IGUubWVzc2FnZSwgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSwgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSwgc3RhY2s6IGUuc3RhY2sgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNPbmVGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnUnVudGltZScsIG1lc3NhZ2U6IFwiTm8gbWF0Y2hpbmcgZGVmaW5pdGlvbiB3YXMgZm91bmQgZm9yIGBcIiArIHRoaXMuZm9ybWF0KGFyZ3MpICsgXCJgXCIsIGluZGV4OiB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLCBtZXNzYWdlOiB0aGlzLnNlbGVjdG9yLnRvQ1NTKCkudHJpbSgpICsgXCIgaXMgdW5kZWZpbmVkXCIsIGluZGV4OiB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NldFZpc2liaWxpdHlUb1JlcGxhY2VtZW50OiBmdW5jdGlvbiAocmVwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGksIHJ1bGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGxhY2VtZW50Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IHJlcGxhY2VtZW50W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYWRkVmlzaWJpbGl0eUJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IudG9DU1MoKS50cmltKCkgKyBcIihcIiArIChhcmdzID8gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ1ZhbHVlICs9IGEubmFtZSArIFwiOlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGEudmFsdWUudG9DU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZSArPSBhLnZhbHVlLnRvQ1NTKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZSArPSAnPz8/JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdWYWx1ZTtcclxuICAgICAgICAgICAgfSkuam9pbignLCAnKSA6ICcnKSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIHRyZWUgPSB7XHJcbiAgICAgICAgTm9kZTogTm9kZSwgQ29sb3I6IENvbG9yLCBBdFJ1bGU6IEF0UnVsZSwgRGV0YWNoZWRSdWxlc2V0OiBEZXRhY2hlZFJ1bGVzZXQsIE9wZXJhdGlvbjogT3BlcmF0aW9uLFxyXG4gICAgICAgIERpbWVuc2lvbjogRGltZW5zaW9uLCBVbml0OiBVbml0LCBLZXl3b3JkOiBLZXl3b3JkLCBWYXJpYWJsZTogVmFyaWFibGUsIFByb3BlcnR5OiBQcm9wZXJ0eSxcclxuICAgICAgICBSdWxlc2V0OiBSdWxlc2V0LCBFbGVtZW50OiBFbGVtZW50LCBBdHRyaWJ1dGU6IEF0dHJpYnV0ZSwgQ29tYmluYXRvcjogQ29tYmluYXRvciwgU2VsZWN0b3I6IFNlbGVjdG9yLFxyXG4gICAgICAgIFF1b3RlZDogUXVvdGVkLCBFeHByZXNzaW9uOiBFeHByZXNzaW9uLCBEZWNsYXJhdGlvbjogRGVjbGFyYXRpb24sIENhbGw6IENhbGwsIFVSTDogVVJMLCBJbXBvcnQ6IEltcG9ydCxcclxuICAgICAgICBDb21tZW50OiBDb21tZW50LCBBbm9ueW1vdXM6IEFub255bW91cywgVmFsdWU6IFZhbHVlLCBKYXZhU2NyaXB0OiBKYXZhU2NyaXB0LCBBc3NpZ25tZW50OiBBc3NpZ25tZW50LFxyXG4gICAgICAgIENvbmRpdGlvbjogQ29uZGl0aW9uLCBQYXJlbjogUGFyZW4sIE1lZGlhOiBNZWRpYSwgVW5pY29kZURlc2NyaXB0b3I6IFVuaWNvZGVEZXNjcmlwdG9yLCBOZWdhdGl2ZTogTmVnYXRpdmUsXHJcbiAgICAgICAgRXh0ZW5kOiBFeHRlbmQsIFZhcmlhYmxlQ2FsbDogVmFyaWFibGVDYWxsLCBOYW1lc3BhY2VWYWx1ZTogTmFtZXNwYWNlVmFsdWUsXHJcbiAgICAgICAgbWl4aW46IHtcclxuICAgICAgICAgICAgQ2FsbDogTWl4aW5DYWxsLFxyXG4gICAgICAgICAgICBEZWZpbml0aW9uOiBEZWZpbml0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfTtcblxuICAgIHZhciBBYnN0cmFjdEZpbGVNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0RmlsZU1hbmFnZXIoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGogPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignPycpO1xyXG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuc2xpY2UoMCwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaiA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCcvJyk7XHJcbiAgICAgICAgICAgIGlmIChqIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaiA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCdcXFxcJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnNsaWNlKDAsIGogKyAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnRyeUFwcGVuZEV4dGVuc2lvbiA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC8oXFwuW2Etel0qJCl8KFtcXD87XS4qKSQvLnRlc3QocGF0aCkgPyBwYXRoIDogcGF0aCArIGV4dDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnRyeUFwcGVuZExlc3NFeHRlbnNpb24gPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cnlBcHBlbmRFeHRlbnNpb24ocGF0aCwgJy5sZXNzJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5zdXBwb3J0c1N5bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmFsd2F5c01ha2VQYXRoc0Fic29sdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5pc1BhdGhBYnNvbHV0ZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKC9eKD86W2Etei1dKzp8XFwvfFxcXFx8IykvaSkudGVzdChmaWxlbmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUT0RPOiBwdWxsIG91dCAvIHJlcGxhY2U/XHJcbiAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChiYXNlUGF0aCwgbGF0ZXJQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmICghYmFzZVBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYXRlclBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJhc2VQYXRoICsgbGF0ZXJQYXRoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUucGF0aERpZmYgPSBmdW5jdGlvbiAodXJsLCBiYXNlVXJsKSB7XHJcbiAgICAgICAgICAgIC8vIGRpZmYgYmV0d2VlbiB0d28gcGF0aHMgdG8gY3JlYXRlIGEgcmVsYXRpdmUgcGF0aFxyXG4gICAgICAgICAgICB2YXIgdXJsUGFydHMgPSB0aGlzLmV4dHJhY3RVcmxQYXJ0cyh1cmwpO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybFBhcnRzID0gdGhpcy5leHRyYWN0VXJsUGFydHMoYmFzZVVybCk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgbWF4O1xyXG4gICAgICAgICAgICB2YXIgdXJsRGlyZWN0b3JpZXM7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsRGlyZWN0b3JpZXM7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gJyc7XHJcbiAgICAgICAgICAgIGlmICh1cmxQYXJ0cy5ob3N0UGFydCAhPT0gYmFzZVVybFBhcnRzLmhvc3RQYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoYmFzZVVybFBhcnRzLmRpcmVjdG9yaWVzLmxlbmd0aCwgdXJsUGFydHMuZGlyZWN0b3JpZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVVybFBhcnRzLmRpcmVjdG9yaWVzW2ldICE9PSB1cmxQYXJ0cy5kaXJlY3Rvcmllc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhc2VVcmxEaXJlY3RvcmllcyA9IGJhc2VVcmxQYXJ0cy5kaXJlY3Rvcmllcy5zbGljZShpKTtcclxuICAgICAgICAgICAgdXJsRGlyZWN0b3JpZXMgPSB1cmxQYXJ0cy5kaXJlY3Rvcmllcy5zbGljZShpKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2VVcmxEaXJlY3Rvcmllcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgKz0gJy4uLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHVybERpcmVjdG9yaWVzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZGlmZiArPSB1cmxEaXJlY3Rvcmllc1tpXSArIFwiL1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gaGVscGVyIGZ1bmN0aW9uLCBub3QgcGFydCBvZiBBUElcclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5leHRyYWN0VXJsUGFydHMgPSBmdW5jdGlvbiAodXJsLCBiYXNlVXJsKSB7XHJcbiAgICAgICAgICAgIC8vIHVybFBhcnRzWzFdID0gcHJvdG9jb2w6Ly9ob3N0bmFtZS8gT1IgL1xyXG4gICAgICAgICAgICAvLyB1cmxQYXJ0c1syXSA9IC8gaWYgcGF0aCByZWxhdGl2ZSB0byBob3N0IGJhc2VcclxuICAgICAgICAgICAgLy8gdXJsUGFydHNbM10gPSBkaXJlY3Rvcmllc1xyXG4gICAgICAgICAgICAvLyB1cmxQYXJ0c1s0XSA9IGZpbGVuYW1lXHJcbiAgICAgICAgICAgIC8vIHVybFBhcnRzWzVdID0gcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICB2YXIgdXJsUGFydHNSZWdleCA9IC9eKCg/OlthLXotXSs6KT9cXC97Mn0oPzpbXlxcL1xcPyNdKlxcLyl8KFtcXC9cXFxcXSkpPygoPzpbXlxcL1xcXFxcXD8jXSpbXFwvXFxcXF0pKikoW15cXC9cXFxcXFw/I10qKShbI1xcP10uKik/JC9pO1xyXG4gICAgICAgICAgICB2YXIgdXJsUGFydHMgPSB1cmwubWF0Y2godXJsUGFydHNSZWdleCk7XHJcbiAgICAgICAgICAgIHZhciByZXR1cm5lciA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgcmF3RGlyZWN0b3JpZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdG9yaWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybFBhcnRzO1xyXG4gICAgICAgICAgICBpZiAoIXVybFBhcnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2Ugc2hlZXQgaHJlZiAtICdcIiArIHVybCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdHlsZXNoZWV0cyBpbiBJRSBkb24ndCBhbHdheXMgcmV0dXJuIHRoZSBmdWxsIHBhdGhcclxuICAgICAgICAgICAgaWYgKGJhc2VVcmwgJiYgKCF1cmxQYXJ0c1sxXSB8fCB1cmxQYXJ0c1syXSkpIHtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmxQYXJ0cyA9IGJhc2VVcmwubWF0Y2godXJsUGFydHNSZWdleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2VVcmxQYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBwYWdlIHVybCAtICdcIiArIGJhc2VVcmwgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJ0c1sxXSA9IHVybFBhcnRzWzFdIHx8IGJhc2VVcmxQYXJ0c1sxXSB8fCAnJztcclxuICAgICAgICAgICAgICAgIGlmICghdXJsUGFydHNbMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmxQYXJ0c1szXSA9IGJhc2VVcmxQYXJ0c1szXSArIHVybFBhcnRzWzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1cmxQYXJ0c1szXSkge1xyXG4gICAgICAgICAgICAgICAgcmF3RGlyZWN0b3JpZXMgPSB1cmxQYXJ0c1szXS5yZXBsYWNlKC9cXFxcL2csICcvJykuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlICcuLicgYW5kIHNraXAgJy4nXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RGlyZWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3RGlyZWN0b3JpZXNbaV0gPT09ICcuLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3JpZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd0RpcmVjdG9yaWVzW2ldICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3JpZXMucHVzaChyYXdEaXJlY3Rvcmllc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybmVyLmhvc3RQYXJ0ID0gdXJsUGFydHNbMV07XHJcbiAgICAgICAgICAgIHJldHVybmVyLmRpcmVjdG9yaWVzID0gZGlyZWN0b3JpZXM7XHJcbiAgICAgICAgICAgIHJldHVybmVyLnJhd1BhdGggPSAodXJsUGFydHNbMV0gfHwgJycpICsgcmF3RGlyZWN0b3JpZXMuam9pbignLycpO1xyXG4gICAgICAgICAgICByZXR1cm5lci5wYXRoID0gKHVybFBhcnRzWzFdIHx8ICcnKSArIGRpcmVjdG9yaWVzLmpvaW4oJy8nKTtcclxuICAgICAgICAgICAgcmV0dXJuZXIuZmlsZW5hbWUgPSB1cmxQYXJ0c1s0XTtcclxuICAgICAgICAgICAgcmV0dXJuZXIuZmlsZVVybCA9IHJldHVybmVyLnBhdGggKyAodXJsUGFydHNbNF0gfHwgJycpO1xyXG4gICAgICAgICAgICByZXR1cm5lci51cmwgPSByZXR1cm5lci5maWxlVXJsICsgKHVybFBhcnRzWzVdIHx8ICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0RmlsZU1hbmFnZXI7XHJcbiAgICB9KCkpO1xuXG4gICAgdmFyIEFic3RyYWN0UGx1Z2luTG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0UGx1Z2luTG9hZGVyKCkge1xyXG4gICAgICAgICAgICAvLyBJbXBsZW1lbnRlZCBieSBOb2RlLmpzIHBsdWdpbiBsb2FkZXJcclxuICAgICAgICAgICAgdGhpcy5yZXF1aXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS5ldmFsUGx1Z2luID0gZnVuY3Rpb24gKGNvbnRlbnRzLCBjb250ZXh0LCBpbXBvcnRzLCBwbHVnaW5PcHRpb25zLCBmaWxlSW5mbykge1xyXG4gICAgICAgICAgICB2YXIgbG9hZGVyLCByZWdpc3RyeSwgcGx1Z2luT2JqLCBsb2NhbE1vZHVsZSwgcGx1Z2luTWFuYWdlciwgZmlsZW5hbWUsIHJlc3VsdDtcclxuICAgICAgICAgICAgcGx1Z2luTWFuYWdlciA9IGNvbnRleHQucGx1Z2luTWFuYWdlcjtcclxuICAgICAgICAgICAgaWYgKGZpbGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVJbmZvID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZUluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVJbmZvLmZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaG9ydG5hbWUgPSAobmV3IHRoaXMubGVzcy5GaWxlTWFuYWdlcigpKS5leHRyYWN0VXJsUGFydHMoZmlsZW5hbWUpLmZpbGVuYW1lO1xyXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbk9iaiA9IHBsdWdpbk1hbmFnZXIuZ2V0KGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5PYmopIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRyeVNldE9wdGlvbnMocGx1Z2luT2JqLCBmaWxlbmFtZSwgc2hvcnRuYW1lLCBwbHVnaW5PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW5PYmoudXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW5PYmoudXNlLmNhbGwodGhpcy5jb250ZXh0LCBwbHVnaW5PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGUubWVzc2FnZSB8fCAnRXJyb3IgZHVyaW5nIEBwbHVnaW4gY2FsbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbk9iajtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2NhbE1vZHVsZSA9IHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luTWFuYWdlcjogcGx1Z2luTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIGZpbGVJbmZvOiBmaWxlSW5mb1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZWdpc3RyeSA9IGZ1bmN0aW9uUmVnaXN0cnkuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciByZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbk9iaiA9IG9iajtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxvYWRlciA9IG5ldyBGdW5jdGlvbignbW9kdWxlJywgJ3JlcXVpcmUnLCAncmVnaXN0ZXJQbHVnaW4nLCAnZnVuY3Rpb25zJywgJ3RyZWUnLCAnbGVzcycsICdmaWxlSW5mbycsIGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIGxvYWRlcihsb2NhbE1vZHVsZSwgdGhpcy5yZXF1aXJlKGZpbGVuYW1lKSwgcmVnaXN0ZXJQbHVnaW4sIHJlZ2lzdHJ5LCB0aGlzLmxlc3MudHJlZSwgdGhpcy5sZXNzLCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXBsdWdpbk9iaikge1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luT2JqID0gbG9jYWxNb2R1bGUuZXhwb3J0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwbHVnaW5PYmogPSB0aGlzLnZhbGlkYXRlUGx1Z2luKHBsdWdpbk9iaiwgZmlsZW5hbWUsIHNob3J0bmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW5PYmogaW5zdGFuY2VvZiBMZXNzRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5PYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBsdWdpbk9iaikge1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luT2JqLmltcG9ydHMgPSBpbXBvcnRzO1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luT2JqLmZpbGVuYW1lID0gZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgPCAzLnggKG9yIHVuc3BlY2lmaWVkIG1pblZlcnNpb24pIC0gc2V0T3B0aW9ucygpIGJlZm9yZSBpbnN0YWxsKClcclxuICAgICAgICAgICAgICAgIGlmICghcGx1Z2luT2JqLm1pblZlcnNpb24gfHwgdGhpcy5jb21wYXJlVmVyc2lvbignMy4wLjAnLCBwbHVnaW5PYmoubWluVmVyc2lvbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50cnlTZXRPcHRpb25zKHBsdWdpbk9iaiwgZmlsZW5hbWUsIHNob3J0bmFtZSwgcGx1Z2luT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJ1biBvbiBmaXJzdCBsb2FkXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5NYW5hZ2VyLmFkZFBsdWdpbihwbHVnaW5PYmosIGZpbGVJbmZvLmZpbGVuYW1lLCByZWdpc3RyeSk7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW5PYmouZnVuY3Rpb25zID0gcmVnaXN0cnkuZ2V0TG9jYWxGdW5jdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBzZXRPcHRpb25zIGFnYWluIGJlY2F1c2UgdGhlIHBsdWdpbk9iaiBtaWdodCBoYXZlIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50cnlTZXRPcHRpb25zKHBsdWdpbk9iaiwgZmlsZW5hbWUsIHNob3J0bmFtZSwgcGx1Z2luT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJ1biBldmVyeSBAcGx1Z2luIGNhbGxcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbk9iai51c2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luT2JqLnVzZS5jYWxsKHRoaXMuY29udGV4dCwgcGx1Z2luT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGUubWVzc2FnZSB8fCAnRXJyb3IgZHVyaW5nIEBwbHVnaW4gY2FsbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMZXNzRXJyb3IoZSwgaW1wb3J0cywgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMZXNzRXJyb3IoeyBtZXNzYWdlOiAnTm90IGEgdmFsaWQgcGx1Z2luJyB9LCBpbXBvcnRzLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbk9iajtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS50cnlTZXRPcHRpb25zID0gZnVuY3Rpb24gKHBsdWdpbiwgZmlsZW5hbWUsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgIXBsdWdpbi5zZXRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJPcHRpb25zIGhhdmUgYmVlbiBwcm92aWRlZCBidXQgdGhlIHBsdWdpbiBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBzdXBwb3J0IGFueSBvcHRpb25zLlwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luLnNldE9wdGlvbnMgJiYgcGx1Z2luLnNldE9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlci5wcm90b3R5cGUudmFsaWRhdGVQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luLCBmaWxlbmFtZSwgbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAocGx1Z2luKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IHBsdWdpbnMgYmVpbmcgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgcGx1Z2luIGNhbiBiZSBtb3JlIHVzYWJsZSBwcm9ncmFtbWF0aWNhbGx5XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IG5ldyBwbHVnaW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubWluVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVWZXJzaW9uKHBsdWdpbi5taW5WZXJzaW9uLCB0aGlzLmxlc3MudmVyc2lvbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUGx1Z2luIFwiICsgbmFtZSArIFwiIHJlcXVpcmVzIHZlcnNpb24gXCIgKyB0aGlzLnZlcnNpb25Ub1N0cmluZyhwbHVnaW4ubWluVmVyc2lvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS5jb21wYXJlVmVyc2lvbiA9IGZ1bmN0aW9uIChhVmVyc2lvbiwgYlZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhVmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGFWZXJzaW9uID0gYVZlcnNpb24ubWF0Y2goL14oXFxkKylcXC4/KFxcZCspP1xcLj8oXFxkKyk/Lyk7XHJcbiAgICAgICAgICAgICAgICBhVmVyc2lvbi5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVZlcnNpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhVmVyc2lvbltpXSAhPT0gYlZlcnNpb25baV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoYVZlcnNpb25baV0pID4gcGFyc2VJbnQoYlZlcnNpb25baV0pID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWJzdHJhY3RQbHVnaW5Mb2FkZXIucHJvdG90eXBlLnZlcnNpb25Ub1N0cmluZyA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uU3RyaW5nID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVyc2lvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvblN0cmluZyArPSAodmVyc2lvblN0cmluZyA/ICcuJyA6ICcnKSArIHZlcnNpb25baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25TdHJpbmc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlci5wcm90b3R5cGUucHJpbnRVc2FnZSA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnByaW50VXNhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ucHJpbnRVc2FnZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gQWJzdHJhY3RQbHVnaW5Mb2FkZXI7XHJcbiAgICB9KCkpO1xuXG4gICAgdmFyIF92aXNpdEFyZ3MgPSB7IHZpc2l0RGVlcGVyOiB0cnVlIH07XHJcbiAgICB2YXIgX2hhc0luZGV4ZWQgPSBmYWxzZTtcclxuICAgIGZ1bmN0aW9uIF9ub29wKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluZGV4Tm9kZVR5cGVzKHBhcmVudCwgdGlja2VyKSB7XHJcbiAgICAgICAgLy8gYWRkIC50eXBlSW5kZXggdG8gdHJlZSBub2RlIHR5cGVzIGZvciBsb29rdXAgdGFibGVcclxuICAgICAgICB2YXIga2V5LCBjaGlsZDtcclxuICAgICAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcclxuICAgICAgICAgICAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xyXG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudFtrZXldO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBib3VuZCBmdW5jdGlvbnMgZGlyZWN0bHkgb24gdHJlZSB3aGljaCBkbyBub3QgaGF2ZSBhIHByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGFyZW4ndCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wcm90b3R5cGUgJiYgY2hpbGQucHJvdG90eXBlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlLnR5cGVJbmRleCA9IHRpY2tlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGlja2VyID0gaW5kZXhOb2RlVHlwZXMoY2hpbGQsIHRpY2tlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpY2tlcjtcclxuICAgIH1cclxuICAgIHZhciBWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFZpc2l0b3IoaW1wbGVtZW50YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5faW1wbGVtZW50YXRpb24gPSBpbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRJbkNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0T3V0Q2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgaWYgKCFfaGFzSW5kZXhlZCkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhOb2RlVHlwZXModHJlZSwgMSk7XHJcbiAgICAgICAgICAgICAgICBfaGFzSW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBub2RlVHlwZUluZGV4ID0gbm9kZS50eXBlSW5kZXg7XHJcbiAgICAgICAgICAgIGlmICghbm9kZVR5cGVJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWl4aW5DYWxsIGFyZ3MgYXJlbid0IGEgbm9kZSB0eXBlP1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZS50eXBlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGltcGwgPSB0aGlzLl9pbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSB0aGlzLl92aXNpdEluQ2FjaGVbbm9kZVR5cGVJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBmdW5jT3V0ID0gdGhpcy5fdmlzaXRPdXRDYWNoZVtub2RlVHlwZUluZGV4XTtcclxuICAgICAgICAgICAgdmFyIHZpc2l0QXJncyA9IF92aXNpdEFyZ3M7XHJcbiAgICAgICAgICAgIHZhciBmbk5hbWU7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICghZnVuYykge1xyXG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJ2aXNpdFwiICsgbm9kZS50eXBlO1xyXG4gICAgICAgICAgICAgICAgZnVuYyA9IGltcGxbZm5OYW1lXSB8fCBfbm9vcDtcclxuICAgICAgICAgICAgICAgIGZ1bmNPdXQgPSBpbXBsW2ZuTmFtZSArIFwiT3V0XCJdIHx8IF9ub29wO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaXRJbkNhY2hlW25vZGVUeXBlSW5kZXhdID0gZnVuYztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0T3V0Q2FjaGVbbm9kZVR5cGVJbmRleF0gPSBmdW5jT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmdW5jICE9PSBfbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBmdW5jLmNhbGwoaW1wbCwgbm9kZSwgdmlzaXRBcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIGltcGwuaXNSZXBsYWNpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmlzaXRBcmdzLnZpc2l0RGVlcGVyICYmIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjbnQgPSBub2RlLmxlbmd0aDsgaSA8IGNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlW2ldLmFjY2VwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtpXS5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmFjY2VwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmdW5jT3V0ICE9IF9ub29wKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jT3V0LmNhbGwoaW1wbCwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKG5vZGVzLCBub25SZXBsYWNpbmcpIHtcclxuICAgICAgICAgICAgaWYgKCFub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjbnQgPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAvLyBOb24tcmVwbGFjaW5nXHJcbiAgICAgICAgICAgIGlmIChub25SZXBsYWNpbmcgfHwgIXRoaXMuX2ltcGxlbWVudGF0aW9uLmlzUmVwbGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXBsYWNpbmdcclxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmFsZCA9IHRoaXMudmlzaXQobm9kZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2YWxkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZXZhbGQuc3BsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goZXZhbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZhbGQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuKGV2YWxkLCBvdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBWaXNpdG9yLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gKGFyciwgb3V0KSB7XHJcbiAgICAgICAgICAgIGlmICghb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY250LCBpLCBpdGVtLCBuZXN0ZWRDbnQsIGosIG5lc3RlZEl0ZW07XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGNudCA9IGFyci5sZW5ndGg7IGkgPCBjbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaXRlbSA9IGFycltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXRlbS5zcGxpY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIG5lc3RlZENudCA9IGl0ZW0ubGVuZ3RoOyBqIDwgbmVzdGVkQ250OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRJdGVtID0gaXRlbVtqXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkSXRlbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3RlZEl0ZW0uc3BsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKG5lc3RlZEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXN0ZWRJdGVtLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsYXR0ZW4obmVzdGVkSXRlbSwgb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBWaXNpdG9yO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBJbXBvcnRTZXF1ZW5jZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gSW1wb3J0U2VxdWVuY2VyKG9uU2VxdWVuY2VyRW1wdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbXBvcnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVJbXBvcnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX29uU2VxdWVuY2VyRW1wdHkgPSBvblNlcXVlbmNlckVtcHR5O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGVwdGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBJbXBvcnRTZXF1ZW5jZXIucHJvdG90eXBlLmFkZEltcG9ydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaW1wb3J0U2VxdWVuY2VyID0gdGhpcywgaW1wb3J0SXRlbSA9IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBpc1JlYWR5OiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmltcG9ydHMucHVzaChpbXBvcnRJdGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydEl0ZW0uYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRJdGVtLmlzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0U2VxdWVuY2VyLnRyeVJ1bigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSW1wb3J0U2VxdWVuY2VyLnByb3RvdHlwZS5hZGRWYXJpYWJsZUltcG9ydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlSW1wb3J0cy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEltcG9ydFNlcXVlbmNlci5wcm90b3R5cGUudHJ5UnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGVwdGgrKztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuaW1wb3J0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRJdGVtID0gdGhpcy5pbXBvcnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydEl0ZW0uaXNSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0cyA9IHRoaXMuaW1wb3J0cy5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0SXRlbS5jYWxsYmFjay5hcHBseShudWxsLCBpbXBvcnRJdGVtLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YXJpYWJsZUltcG9ydHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVJbXBvcnQgPSB0aGlzLnZhcmlhYmxlSW1wb3J0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlSW1wb3J0cyA9IHRoaXMudmFyaWFibGVJbXBvcnRzLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlSW1wb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RGVwdGgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudERlcHRoID09PSAwICYmIHRoaXMuX29uU2VxdWVuY2VyRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU2VxdWVuY2VyRW1wdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEltcG9ydFNlcXVlbmNlcjtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgSW1wb3J0VmlzaXRvciA9IGZ1bmN0aW9uIChpbXBvcnRlciwgZmluaXNoKSB7XHJcbiAgICAgICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2ltcG9ydGVyID0gaW1wb3J0ZXI7XHJcbiAgICAgICAgdGhpcy5fZmluaXNoID0gZmluaXNoO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBjb250ZXh0cy5FdmFsKCk7XHJcbiAgICAgICAgdGhpcy5pbXBvcnRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5vbmNlRmlsZURldGVjdGlvbk1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGV0ZWN0b3IgPSB7fTtcclxuICAgICAgICB0aGlzLl9zZXF1ZW5jZXIgPSBuZXcgSW1wb3J0U2VxdWVuY2VyKHRoaXMuX29uU2VxdWVuY2VyRW1wdHkuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgSW1wb3J0VmlzaXRvci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgaXNSZXBsYWNpbmc6IGZhbHNlLFxyXG4gICAgICAgIHJ1bjogZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGNvbnRlbnRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb25TZXF1ZW5jZXJFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGaW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaCh0aGlzLmVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0SW1wb3J0OiBmdW5jdGlvbiAoaW1wb3J0Tm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmxpbmVDU1MgPSBpbXBvcnROb2RlLm9wdGlvbnMuaW5saW5lO1xyXG4gICAgICAgICAgICBpZiAoIWltcG9ydE5vZGUuY3NzIHx8IGlubGluZUNTUykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgY29udGV4dHMuRXZhbCh0aGlzLmNvbnRleHQsIGNvcHlBcnJheSh0aGlzLmNvbnRleHQuZnJhbWVzKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0UGFyZW50ID0gY29udGV4dC5mcmFtZXNbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0Tm9kZS5pc1ZhcmlhYmxlSW1wb3J0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZXIuYWRkVmFyaWFibGVJbXBvcnQodGhpcy5wcm9jZXNzSW1wb3J0Tm9kZS5iaW5kKHRoaXMsIGltcG9ydE5vZGUsIGNvbnRleHQsIGltcG9ydFBhcmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW1wb3J0Tm9kZShpbXBvcnROb2RlLCBjb250ZXh0LCBpbXBvcnRQYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvY2Vzc0ltcG9ydE5vZGU6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCBjb250ZXh0LCBpbXBvcnRQYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGV2YWxkSW1wb3J0Tm9kZTtcclxuICAgICAgICAgICAgdmFyIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBldmFsZEltcG9ydE5vZGUgPSBpbXBvcnROb2RlLmV2YWxGb3JJbXBvcnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZS5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuaW5kZXggPSBpbXBvcnROb2RlLmdldEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5maWxlbmFtZSA9IGltcG9ydE5vZGUuZmlsZUluZm8oKS5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZXZhbCBwcm9wZXJseSBhbmQgdHJlYXQgYXMgY3NzXHJcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLmNzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGZhaWxzLCB0aGlzIGVycm9yIHdpbGwgYmUgdGhyb3duXHJcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLmVycm9yID0gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZhbGRJbXBvcnROb2RlICYmICghZXZhbGRJbXBvcnROb2RlLmNzcyB8fCBpbmxpbmVDU1MpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZhbGRJbXBvcnROb2RlLm9wdGlvbnMubXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmltcG9ydE11bHRpcGxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRyeSBhcHBlbmRpbmcgaWYgd2UgaGF2ZW4ndCBkZXRlcm1pbmVkIGlmIGl0IGlzIGNzcyBvciBub3RcclxuICAgICAgICAgICAgICAgIHZhciB0cnlBcHBlbmRMZXNzRXh0ZW5zaW9uID0gZXZhbGRJbXBvcnROb2RlLmNzcyA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbXBvcnRQYXJlbnQucnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0UGFyZW50LnJ1bGVzW2ldID09PSBpbXBvcnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFBhcmVudC5ydWxlc1tpXSA9IGV2YWxkSW1wb3J0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9uSW1wb3J0ZWQgPSB0aGlzLm9uSW1wb3J0ZWQuYmluZCh0aGlzLCBldmFsZEltcG9ydE5vZGUsIGNvbnRleHQpLCBzZXF1ZW5jZWRPbkltcG9ydGVkID0gdGhpcy5fc2VxdWVuY2VyLmFkZEltcG9ydChvbkltcG9ydGVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ltcG9ydGVyLnB1c2goZXZhbGRJbXBvcnROb2RlLmdldFBhdGgoKSwgdHJ5QXBwZW5kTGVzc0V4dGVuc2lvbiwgZXZhbGRJbXBvcnROb2RlLmZpbGVJbmZvKCksIGV2YWxkSW1wb3J0Tm9kZS5vcHRpb25zLCBzZXF1ZW5jZWRPbkltcG9ydGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0Q291bnQtLTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uSW1wb3J0ZWQ6IGZ1bmN0aW9uIChpbXBvcnROb2RlLCBjb250ZXh0LCBlLCByb290LCBpbXBvcnRlZEF0Um9vdCwgZnVsbFBhdGgpIHtcclxuICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZS5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuaW5kZXggPSBpbXBvcnROb2RlLmdldEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5maWxlbmFtZSA9IGltcG9ydE5vZGUuZmlsZUluZm8oKS5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbXBvcnRWaXNpdG9yID0gdGhpcywgaW5saW5lQ1NTID0gaW1wb3J0Tm9kZS5vcHRpb25zLmlubGluZSwgaXNQbHVnaW4gPSBpbXBvcnROb2RlLm9wdGlvbnMuaXNQbHVnaW4sIGlzT3B0aW9uYWwgPSBpbXBvcnROb2RlLm9wdGlvbnMub3B0aW9uYWwsIGR1cGxpY2F0ZUltcG9ydCA9IGltcG9ydGVkQXRSb290IHx8IGZ1bGxQYXRoIGluIGltcG9ydFZpc2l0b3IucmVjdXJzaW9uRGV0ZWN0b3I7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pbXBvcnRNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZUltcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydE5vZGUuc2tpcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlLnNraXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdWxsUGF0aCBpbiBpbXBvcnRWaXNpdG9yLm9uY2VGaWxlRGV0ZWN0aW9uTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRWaXNpdG9yLm9uY2VGaWxlRGV0ZWN0aW9uTWFwW2Z1bGxQYXRoXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZnVsbFBhdGggJiYgaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZS5za2lwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZS5yb290ID0gcm9vdDtcclxuICAgICAgICAgICAgICAgIGltcG9ydE5vZGUuaW1wb3J0ZWRGaWxlbmFtZSA9IGZ1bGxQYXRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbmxpbmVDU1MgJiYgIWlzUGx1Z2luICYmIChjb250ZXh0LmltcG9ydE11bHRpcGxlIHx8ICFkdXBsaWNhdGVJbXBvcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0VmlzaXRvci5yZWN1cnNpb25EZXRlY3RvcltmdWxsUGF0aF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG9sZENvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW1wb3J0VmlzaXRvci5pbXBvcnRDb3VudC0tO1xyXG4gICAgICAgICAgICBpZiAoaW1wb3J0VmlzaXRvci5pc0ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRWaXNpdG9yLl9zZXF1ZW5jZXIudHJ5UnVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWNsTm9kZS52YWx1ZS50eXBlID09PSAnRGV0YWNoZWRSdWxlc2V0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KGRlY2xOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdERlY2xhcmF0aW9uT3V0OiBmdW5jdGlvbiAoZGVjbE5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKGRlY2xOb2RlLnZhbHVlLnR5cGUgPT09ICdEZXRhY2hlZFJ1bGVzZXQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0QXRSdWxlOiBmdW5jdGlvbiAoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChhdFJ1bGVOb2RlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0QXRSdWxlT3V0OiBmdW5jdGlvbiAoYXRSdWxlTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdE1peGluRGVmaW5pdGlvbjogZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnVuc2hpZnQobWl4aW5EZWZpbml0aW9uTm9kZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdE1peGluRGVmaW5pdGlvbk91dDogZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnVuc2hpZnQocnVsZXNldE5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRSdWxlc2V0T3V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRNZWRpYTogZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChtZWRpYU5vZGUucnVsZXNbMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRNZWRpYU91dDogZnVuY3Rpb24gKG1lZGlhTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcblxuICAgIHZhciBTZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yKHZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpc2l0KHJvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY250ID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTZXRUcmVlVmlzaWJpbGl0eVZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QXJyYXkobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFub2RlLmJsb2Nrc1Zpc2liaWxpdHkgfHwgbm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZW5zdXJlVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5lbnN1cmVJbnZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLmFjY2VwdCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yO1xyXG4gICAgfSgpKTtcblxuICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXHJcbiAgICB2YXIgRXh0ZW5kRmluZGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFeHRlbmRGaW5kZXJWaXNpdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sgPSBbW11dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFeHRlbmRGaW5kZXJWaXNpdG9yLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgICAgICByb290ID0gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcclxuICAgICAgICAgICAgcm9vdC5hbGxFeHRlbmRzID0gdGhpcy5hbGxFeHRlbmRzU3RhY2tbMF07XHJcbiAgICAgICAgICAgIHJldHVybiByb290O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNaXhpbkRlZmluaXRpb24gPSBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSdWxlc2V0ID0gZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmQ7XHJcbiAgICAgICAgICAgIHZhciBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRMaXN0O1xyXG4gICAgICAgICAgICAvLyBnZXQgJjpleHRlbmQoLmEpOyBydWxlcyB3aGljaCBhcHBseSB0byBhbGwgc2VsZWN0b3JzIGluIHRoaXMgcnVsZXNldFxyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBydWxlc2V0Tm9kZS5ydWxlcywgcnVsZUNudCA9IHJ1bGVzID8gcnVsZXMubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJ1bGVzW2ldIGluc3RhbmNlb2YgdHJlZS5FeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0LnB1c2gocnVsZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLmV4dGVuZE9uRXZlcnlQYXRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBub3cgZmluZCBldmVyeSBzZWxlY3RvciBhbmQgYXBwbHkgdGhlIGV4dGVuZHMgdGhhdCBhcHBseSB0byBhbGwgZXh0ZW5kc1xyXG4gICAgICAgICAgICAvLyBhbmQgdGhlIG9uZXMgd2hpY2ggYXBwbHkgdG8gYW4gaW5kaXZpZHVhbCBleHRlbmRcclxuICAgICAgICAgICAgdmFyIHBhdGhzID0gcnVsZXNldE5vZGUucGF0aHM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yUGF0aCA9IHBhdGhzW2ldLCBzZWxlY3RvciA9IHNlbGVjdG9yUGF0aFtzZWxlY3RvclBhdGgubGVuZ3RoIC0gMV0sIHNlbEV4dGVuZExpc3QgPSBzZWxlY3Rvci5leHRlbmRMaXN0O1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IHNlbEV4dGVuZExpc3QgPyBjb3B5QXJyYXkoc2VsRXh0ZW5kTGlzdCkuY29uY2F0KGFsbFNlbGVjdG9yc0V4dGVuZExpc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBhbGxTZWxlY3RvcnNFeHRlbmRMaXN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZExpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmRMaXN0ID0gZXh0ZW5kTGlzdC5tYXAoZnVuY3Rpb24gKGFsbFNlbGVjdG9yc0V4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsU2VsZWN0b3JzRXh0ZW5kLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXh0ZW5kTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm91bmRFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQgPSBleHRlbmRMaXN0W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZC5maW5kU2VsZlNlbGVjdG9ycyhzZWxlY3RvclBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZC5ydWxlc2V0ID0gcnVsZXNldE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kLmZpcnN0RXh0ZW5kT25UaGlzU2VsZWN0b3JQYXRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV0ucHVzaChleHRlbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMucHVzaChydWxlc2V0Tm9kZS5zZWxlY3RvcnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSdWxlc2V0T3V0ID0gZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghcnVsZXNldE5vZGUucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sZW5ndGggPSB0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWVkaWEgPSBmdW5jdGlvbiAobWVkaWFOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgbWVkaWFOb2RlLmFsbEV4dGVuZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChtZWRpYU5vZGUuYWxsRXh0ZW5kcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFeHRlbmRGaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1lZGlhT3V0ID0gZnVuY3Rpb24gKG1lZGlhTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdFJ1bGUgPSBmdW5jdGlvbiAoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGF0UnVsZU5vZGUuYWxsRXh0ZW5kcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5wdXNoKGF0UnVsZU5vZGUuYWxsRXh0ZW5kcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFeHRlbmRGaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0UnVsZU91dCA9IGZ1bmN0aW9uIChhdFJ1bGVOb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRXh0ZW5kRmluZGVyVmlzaXRvcjtcclxuICAgIH0oKSk7XHJcbiAgICB2YXIgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFByb2Nlc3NFeHRlbmRzVmlzaXRvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRGaW5kZXIgPSBuZXcgRXh0ZW5kRmluZGVyVmlzaXRvcigpO1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuZEluZGljZXMgPSB7fTtcclxuICAgICAgICAgICAgZXh0ZW5kRmluZGVyLnJ1bihyb290KTtcclxuICAgICAgICAgICAgaWYgKCFleHRlbmRGaW5kZXIuZm91bmRFeHRlbmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290LmFsbEV4dGVuZHMgPSByb290LmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhyb290LmFsbEV4dGVuZHMsIHJvb3QuYWxsRXh0ZW5kcykpO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjayA9IFtyb290LmFsbEV4dGVuZHNdO1xyXG4gICAgICAgICAgICB2YXIgbmV3Um9vdCA9IHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFeHRlbmRzRm9yTm9uTWF0Y2hlZChyb290LmFsbEV4dGVuZHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Um9vdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUuY2hlY2tFeHRlbmRzRm9yTm9uTWF0Y2hlZCA9IGZ1bmN0aW9uIChleHRlbmRMaXN0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5leHRlbmRJbmRpY2VzO1xyXG4gICAgICAgICAgICBleHRlbmRMaXN0LmZpbHRlcihmdW5jdGlvbiAoZXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWV4dGVuZC5oYXNGb3VuZE1hdGNoZXMgJiYgZXh0ZW5kLnBhcmVudF9pZHMubGVuZ3RoID09IDE7XHJcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gJ191bmtub3duXyc7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gZXh0ZW5kLnNlbGVjdG9yLnRvQ1NTKHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cclxuICAgICAgICAgICAgICAgIGlmICghaW5kaWNlc1tleHRlbmQuaW5kZXggKyBcIiBcIiArIHNlbGVjdG9yXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNbZXh0ZW5kLmluZGV4ICsgXCIgXCIgKyBzZWxlY3Rvcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZXh0ZW5kICdcIiArIHNlbGVjdG9yICsgXCInIGhhcyBubyBtYXRjaGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUuZG9FeHRlbmRDaGFpbmluZyA9IGZ1bmN0aW9uIChleHRlbmRzTGlzdCwgZXh0ZW5kc0xpc3RUYXJnZXQsIGl0ZXJhdGlvbkNvdW50KSB7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIGNoYWluaW5nIGlzIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBleHRlbnNpb24uLiBpZiB3ZSBleHRlbmQgYW4gZXh0ZW5kIHRoZW4gd2UgYXJlIG5vdCBqdXN0IGNvcHlpbmcsIGFsdGVyaW5nXHJcbiAgICAgICAgICAgIC8vIGFuZCBwYXN0aW5nIHRoZSBzZWxlY3RvciB3ZSB3b3VsZCBkbyBub3JtYWxseSwgYnV0IHdlIGFyZSBhbHNvIGFkZGluZyBhbiBleHRlbmQgd2l0aCB0aGUgc2FtZSB0YXJnZXQgc2VsZWN0b3JcclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGlzIG5ldyBleHRlbmQgY2FuIHRoZW4gZ28gYW5kIGFsdGVyIG90aGVyIGV4dGVuZHNcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gdGhpcyBtZXRob2QgZGVhbHMgd2l0aCBhbGwgdGhlIGNoYWluaW5nIHdvcmsgLSB3aXRob3V0IGl0LCBleHRlbmQgaXMgZmxhdCBhbmQgZG9lc24ndCB3b3JrIG9uIG90aGVyIGV4dGVuZCBzZWxlY3RvcnNcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhbHNvIHRoZSBtb3N0IGV4cGVuc2l2ZS4uIGFuZCBhIG1hdGNoIG9uIG9uZSBzZWxlY3RvciBjYW4gY2F1c2UgYW4gZXh0ZW5zaW9uIG9mIGEgc2VsZWN0b3Igd2UgaGFkIGFscmVhZHlcclxuICAgICAgICAgICAgLy8gcHJvY2Vzc2VkIGlmIHdlIGxvb2sgYXQgZWFjaCBzZWxlY3RvciBhdCBhIHRpbWUsIGFzIGlzIGRvbmUgaW4gdmlzaXRSdWxlc2V0XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRJbmRleDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldEV4dGVuZEluZGV4O1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcztcclxuICAgICAgICAgICAgdmFyIGV4dGVuZHNUb0FkZCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRWaXNpdG9yID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yUGF0aDtcclxuICAgICAgICAgICAgdmFyIGV4dGVuZDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldEV4dGVuZDtcclxuICAgICAgICAgICAgdmFyIG5ld0V4dGVuZDtcclxuICAgICAgICAgICAgaXRlcmF0aW9uQ291bnQgPSBpdGVyYXRpb25Db3VudCB8fCAwO1xyXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggY29tcGFyaW5nIGV2ZXJ5IGV4dGVuZCB3aXRoIGV2ZXJ5IHRhcmdldCBleHRlbmQuXHJcbiAgICAgICAgICAgIC8vIGEgdGFyZ2V0IGV4dGVuZCBpcyB0aGUgb25lIG9uIHRoZSBydWxlc2V0IHdlIGFyZSBsb29raW5nIGF0IGNvcHkvZWRpdC9wYXN0aW5nIGluIHBsYWNlXHJcbiAgICAgICAgICAgIC8vIGUuZy4gIC5hOmV4dGVuZCguYikge30gIGFuZCAuYjpleHRlbmQoLmMpIHt9IHRoZW4gdGhlIGZpcnN0IGV4dGVuZCBleHRlbmRzIHRoZSBzZWNvbmQgb25lXHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0aW9uIGludG8gdHdvIGxpc3RzIGFsbG93cyB1cyB0byBwcm9jZXNzIGEgc3Vic2V0IG9mIGNoYWlucyB3aXRoIGEgYmlnZ2VyIHNldCwgYXMgaXMgdGhlXHJcbiAgICAgICAgICAgIC8vIGNhc2Ugd2hlbiBwcm9jZXNzaW5nIG1lZGlhIHF1ZXJpZXNcclxuICAgICAgICAgICAgZm9yIChleHRlbmRJbmRleCA9IDA7IGV4dGVuZEluZGV4IDwgZXh0ZW5kc0xpc3QubGVuZ3RoOyBleHRlbmRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHRhcmdldEV4dGVuZEluZGV4ID0gMDsgdGFyZ2V0RXh0ZW5kSW5kZXggPCBleHRlbmRzTGlzdFRhcmdldC5sZW5ndGg7IHRhcmdldEV4dGVuZEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQgPSBleHRlbmRzTGlzdFtleHRlbmRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RXh0ZW5kID0gZXh0ZW5kc0xpc3RUYXJnZXRbdGFyZ2V0RXh0ZW5kSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kLnBhcmVudF9pZHMuaW5kZXhPZih0YXJnZXRFeHRlbmQub2JqZWN0X2lkKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGEgbWF0Y2ggaW4gdGhlIHRhcmdldCBleHRlbmRzIHNlbGYgc2VsZWN0b3IgKHRoZSBiaXQgYmVmb3JlIDpleHRlbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JQYXRoID0gW3RhcmdldEV4dGVuZC5zZWxmU2VsZWN0b3JzWzBdXTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gZXh0ZW5kVmlzaXRvci5maW5kTWF0Y2goZXh0ZW5kLCBzZWxlY3RvclBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQuaGFzRm91bmRNYXRjaGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBtYXRjaCwgc28gZm9yIGVhY2ggc2VsZiBzZWxlY3Rvci4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZC5zZWxmU2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGZTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0YXJnZXRFeHRlbmQudmlzaWJpbGl0eUluZm8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGV4dGVuZCBhcyB1c3VhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBleHRlbmRWaXNpdG9yLmV4dGVuZFNlbGVjdG9yKG1hdGNoZXMsIHNlbGVjdG9yUGF0aCwgc2VsZlNlbGVjdG9yLCBleHRlbmQuaXNWaXNpYmxlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG5vdyB3ZSBjcmVhdGUgYSBuZXcgZXh0ZW5kIGZyb20gaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZCA9IG5ldyAodHJlZS5FeHRlbmQpKHRhcmdldEV4dGVuZC5zZWxlY3RvciwgdGFyZ2V0RXh0ZW5kLm9wdGlvbiwgMCwgdGFyZ2V0RXh0ZW5kLmZpbGVJbmZvKCksIGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnNlbGZTZWxlY3RvcnMgPSBuZXdTZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgZXh0ZW5kIG9udG8gdGhlIGxpc3Qgb2YgZXh0ZW5kcyBmb3IgdGhhdCBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JbbmV3U2VsZWN0b3IubGVuZ3RoIC0gMV0uZXh0ZW5kTGlzdCA9IFtuZXdFeHRlbmRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3JkIHRoYXQgd2UgbmVlZCB0byBhZGQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRzVG9BZGQucHVzaChuZXdFeHRlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnJ1bGVzZXQgPSB0YXJnZXRFeHRlbmQucnVsZXNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIGl0cyBwYXJlbnRzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQucGFyZW50X2lkcyA9IG5ld0V4dGVuZC5wYXJlbnRfaWRzLmNvbmNhdCh0YXJnZXRFeHRlbmQucGFyZW50X2lkcywgZXh0ZW5kLnBhcmVudF9pZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBwcm9jZXNzIHRoZSBzZWxlY3RvciBvbmNlLi4gaWYgd2UgaGF2ZSA6ZXh0ZW5kKC5hLC5iKSB0aGVuIG11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmRzIHdpbGwgbG9vayBhdCB0aGUgc2FtZSBzZWxlY3RvciBwYXRoLCBzbyB3aGVuIGV4dGVuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IGFueSBvdGhlcnMgd2lsbCBiZSBkdXBsaWNhdGVzIGluIHRlcm1zIG9mIHdoYXQgaXMgYWRkZWQgdG8gdGhlIGNzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEV4dGVuZC5maXJzdEV4dGVuZE9uVGhpc1NlbGVjdG9yUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5maXJzdEV4dGVuZE9uVGhpc1NlbGVjdG9yUGF0aCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RXh0ZW5kLnJ1bGVzZXQucGF0aHMucHVzaChuZXdTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXh0ZW5kc1RvQWRkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGRldGVjdCBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHN0b3AgYSBzdGFjayBvdmVyZmxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG1heSBubyBsb25nZXIgYmUgbmVlZGVkLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRDaGFpbkNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uQ291bnQgPiAxMDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JPbmUgPSAne3VuYWJsZSB0byBjYWxjdWxhdGV9JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JUd28gPSAne3VuYWJsZSB0byBjYWxjdWxhdGV9JztcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvck9uZSA9IGV4dGVuZHNUb0FkZFswXS5zZWxmU2VsZWN0b3JzWzBdLnRvQ1NTKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVHdvID0gZXh0ZW5kc1RvQWRkWzBdLnNlbGVjdG9yLnRvQ1NTKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IFwiZXh0ZW5kIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZC4gT25lIG9mIHRoZSBjaXJjdWxhciBleHRlbmRzIGlzIGN1cnJlbnRseTpcIiArIHNlbGVjdG9yT25lICsgXCI6ZXh0ZW5kKFwiICsgc2VsZWN0b3JUd28gKyBcIilcIiB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbm93IHByb2Nlc3MgdGhlIG5ldyBleHRlbmRzIG9uIHRoZSBleGlzdGluZyBydWxlcyBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgYSBleHRlbmRpbmcgYiBleHRlbmRpbmcgYyBleHRlbmRpbmdcclxuICAgICAgICAgICAgICAgIC8vIGQgZXh0ZW5kaW5nIGUuLi5cclxuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRzVG9BZGQuY29uY2F0KGV4dGVuZFZpc2l0b3IuZG9FeHRlbmRDaGFpbmluZyhleHRlbmRzVG9BZGQsIGV4dGVuZHNMaXN0VGFyZ2V0LCBpdGVyYXRpb25Db3VudCArIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRzVG9BZGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChydWxlTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1peGluRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChtaXhpbkRlZmluaXRpb25Ob2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0U2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0UnVsZXNldCA9IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5yb290KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1hdGNoZXM7XHJcbiAgICAgICAgICAgIHZhciBwYXRoSW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRJbmRleDtcclxuICAgICAgICAgICAgdmFyIGFsbEV4dGVuZHMgPSB0aGlzLmFsbEV4dGVuZHNTdGFja1t0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yc1RvQWRkID0gW107XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRWaXNpdG9yID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yUGF0aDtcclxuICAgICAgICAgICAgLy8gbG9vayBhdCBlYWNoIHNlbGVjdG9yIHBhdGggaW4gdGhlIHJ1bGVzZXQsIGZpbmQgYW55IGV4dGVuZCBtYXRjaGVzIGFuZCB0aGVuIGNvcHksIGZpbmQgYW5kIHJlcGxhY2VcclxuICAgICAgICAgICAgZm9yIChleHRlbmRJbmRleCA9IDA7IGV4dGVuZEluZGV4IDwgYWxsRXh0ZW5kcy5sZW5ndGg7IGV4dGVuZEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAocGF0aEluZGV4ID0gMDsgcGF0aEluZGV4IDwgcnVsZXNldE5vZGUucGF0aHMubGVuZ3RoOyBwYXRoSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yUGF0aCA9IHJ1bGVzZXROb2RlLnBhdGhzW3BhdGhJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kaW5nIGV4dGVuZHMgaGFwcGVucyBpbml0aWFsbHksIGJlZm9yZSB0aGUgbWFpbiBwYXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLmV4dGVuZE9uRXZlcnlQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kTGlzdCA9IHNlbGVjdG9yUGF0aFtzZWxlY3RvclBhdGgubGVuZ3RoIC0gMV0uZXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCAmJiBleHRlbmRMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRoaXMuZmluZE1hdGNoKGFsbEV4dGVuZHNbZXh0ZW5kSW5kZXhdLCBzZWxlY3RvclBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzW2V4dGVuZEluZGV4XS5oYXNGb3VuZE1hdGNoZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzW2V4dGVuZEluZGV4XS5zZWxmU2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGZTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZGVkU2VsZWN0b3JzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRTZWxlY3RvcnMgPSBleHRlbmRWaXNpdG9yLmV4dGVuZFNlbGVjdG9yKG1hdGNoZXMsIHNlbGVjdG9yUGF0aCwgc2VsZlNlbGVjdG9yLCBhbGxFeHRlbmRzW2V4dGVuZEluZGV4XS5pc1Zpc2libGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNUb0FkZC5wdXNoKGV4dGVuZGVkU2VsZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJ1bGVzZXROb2RlLnBhdGhzID0gcnVsZXNldE5vZGUucGF0aHMuY29uY2F0KHNlbGVjdG9yc1RvQWRkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUuZmluZE1hdGNoID0gZnVuY3Rpb24gKGV4dGVuZCwgaGF5c3RhY2tTZWxlY3RvclBhdGgpIHtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gbG9vayB0aHJvdWdoIHRoZSBoYXlzdGFjayBzZWxlY3RvciBwYXRoIHRvIHRyeSBhbmQgZmluZCB0aGUgbmVlZGxlIC0gZXh0ZW5kLnNlbGVjdG9yXHJcbiAgICAgICAgICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2Ygc2VsZWN0b3IgbWF0Y2hlcyB0aGF0IGNhbiB0aGVuIGJlIHJlcGxhY2VkXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHZhciBoYXlzdGFja1NlbGVjdG9ySW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBoYWNrc3RhY2tTZWxlY3RvcjtcclxuICAgICAgICAgICAgdmFyIGhhY2tzdGFja0VsZW1lbnRJbmRleDtcclxuICAgICAgICAgICAgdmFyIGhheXN0YWNrRWxlbWVudDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldENvbWJpbmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kVmlzaXRvciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBuZWVkbGVFbGVtZW50cyA9IGV4dGVuZC5zZWxlY3Rvci5lbGVtZW50cztcclxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbE1hdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbE1hdGNoO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGhheXN0YWNrIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGZvciAoaGF5c3RhY2tTZWxlY3RvckluZGV4ID0gMDsgaGF5c3RhY2tTZWxlY3RvckluZGV4IDwgaGF5c3RhY2tTZWxlY3RvclBhdGgubGVuZ3RoOyBoYXlzdGFja1NlbGVjdG9ySW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgaGFja3N0YWNrU2VsZWN0b3IgPSBoYXlzdGFja1NlbGVjdG9yUGF0aFtoYXlzdGFja1NlbGVjdG9ySW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChoYWNrc3RhY2tFbGVtZW50SW5kZXggPSAwOyBoYWNrc3RhY2tFbGVtZW50SW5kZXggPCBoYWNrc3RhY2tTZWxlY3Rvci5lbGVtZW50cy5sZW5ndGg7IGhhY2tzdGFja0VsZW1lbnRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGF5c3RhY2tFbGVtZW50ID0gaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHNbaGFja3N0YWNrRWxlbWVudEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbGxvdyBlbGVtZW50cyBiZWZvcmUgb3VyIG1hdGNoIHdlIGNhbiBhZGQgYSBwb3RlbnRpYWwgbWF0Y2ggZXZlcnkgdGltZS4gb3RoZXJ3aXNlIG9ubHkgYXQgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZC5hbGxvd0JlZm9yZSB8fCAoaGF5c3RhY2tTZWxlY3RvckluZGV4ID09PSAwICYmIGhhY2tzdGFja0VsZW1lbnRJbmRleCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcy5wdXNoKHsgcGF0aEluZGV4OiBoYXlzdGFja1NlbGVjdG9ySW5kZXgsIGluZGV4OiBoYWNrc3RhY2tFbGVtZW50SW5kZXgsIG1hdGNoZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29tYmluYXRvcjogaGF5c3RhY2tFbGVtZW50LmNvbWJpbmF0b3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3RlbnRpYWxNYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoID0gcG90ZW50aWFsTWF0Y2hlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3JzIGFkZCBcIiBcIiBvbnRvIHRoZSBmaXJzdCBlbGVtZW50LiBXaGVuIHdlIHVzZSAmIGl0IGpvaW5zIHRoZSBzZWxlY3RvcnMgdG9nZXRoZXIsIGJ1dCBpZiB3ZSBkb24ndFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGVhY2ggc2VsZWN0b3IgaW4gaGF5c3RhY2tTZWxlY3RvclBhdGggaGFzIGEgc3BhY2UgYmVmb3JlIGl0IGFkZGVkIGluIHRoZSB0b0NTUyBwaGFzZS4gc28gd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrIG91dCB3aGF0IHRoZSByZXN1bHRpbmcgY29tYmluYXRvciB3aWxsIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbWJpbmF0b3IgPSBoYXlzdGFja0VsZW1lbnQuY29tYmluYXRvci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldENvbWJpbmF0b3IgPT09ICcnICYmIGhhY2tzdGFja0VsZW1lbnRJbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tYmluYXRvciA9ICcgJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBtYXRjaCwgbnVsbCBvdXIgbWF0Y2ggdG8gaW5kaWNhdGUgZmFpbHVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dGVuZFZpc2l0b3IuaXNFbGVtZW50VmFsdWVzRXF1YWwobmVlZGxlRWxlbWVudHNbcG90ZW50aWFsTWF0Y2gubWF0Y2hlZF0udmFsdWUsIGhheXN0YWNrRWxlbWVudC52YWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb3RlbnRpYWxNYXRjaC5tYXRjaGVkID4gMCAmJiBuZWVkbGVFbGVtZW50c1twb3RlbnRpYWxNYXRjaC5tYXRjaGVkXS5jb21iaW5hdG9yLnZhbHVlICE9PSB0YXJnZXRDb21iaW5hdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2gubWF0Y2hlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCB2YWxpZCBhbmQgaGF2ZSBmaW5pc2hlZCwgdGVzdCB3aGV0aGVyIHdlIGhhdmUgZWxlbWVudHMgYWZ0ZXIgYW5kIHdoZXRoZXIgdGhlc2UgYXJlIGFsbG93ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5maW5pc2hlZCA9IHBvdGVudGlhbE1hdGNoLm1hdGNoZWQgPT09IG5lZWRsZUVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaC5maW5pc2hlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghZXh0ZW5kLmFsbG93QWZ0ZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhhY2tzdGFja0VsZW1lbnRJbmRleCArIDEgPCBoYWNrc3RhY2tTZWxlY3Rvci5lbGVtZW50cy5sZW5ndGggfHwgaGF5c3RhY2tTZWxlY3RvckluZGV4ICsgMSA8IGhheXN0YWNrU2VsZWN0b3JQYXRoLmxlbmd0aCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG51bGwgd2UgcmVtb3ZlLCBpZiBub3QsIHdlIGFyZSBzdGlsbCB2YWxpZCwgc28gZWl0aGVyIHB1c2ggYXMgYSB2YWxpZCBtYXRjaCBvciBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaC5maW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmxlbmd0aCA9IG5lZWRsZUVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5lbmRQYXRoSW5kZXggPSBoYXlzdGFja1NlbGVjdG9ySW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2guZW5kUGF0aEVsZW1lbnRJbmRleCA9IGhhY2tzdGFja0VsZW1lbnRJbmRleCArIDE7IC8vIGluZGV4IGFmdGVyIGVuZCBvZiBtYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoZXMubGVuZ3RoID0gMDsgLy8gd2UgZG9uJ3QgYWxsb3cgbWF0Y2hlcyB0byBvdmVybGFwLCBzbyBzdGFydCBtYXRjaGluZyBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChwb3RlbnRpYWxNYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUuaXNFbGVtZW50VmFsdWVzRXF1YWwgPSBmdW5jdGlvbiAoZWxlbWVudFZhbHVlMSwgZWxlbWVudFZhbHVlMikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRWYWx1ZTEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50VmFsdWUyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRWYWx1ZTEgPT09IGVsZW1lbnRWYWx1ZTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEgaW5zdGFuY2VvZiB0cmVlLkF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEub3AgIT09IGVsZW1lbnRWYWx1ZTIub3AgfHwgZWxlbWVudFZhbHVlMS5rZXkgIT09IGVsZW1lbnRWYWx1ZTIua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50VmFsdWUxLnZhbHVlIHx8ICFlbGVtZW50VmFsdWUyLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZTEudmFsdWUgfHwgZWxlbWVudFZhbHVlMi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudFZhbHVlMSA9IGVsZW1lbnRWYWx1ZTEudmFsdWUudmFsdWUgfHwgZWxlbWVudFZhbHVlMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRWYWx1ZTIgPSBlbGVtZW50VmFsdWUyLnZhbHVlLnZhbHVlIHx8IGVsZW1lbnRWYWx1ZTIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudFZhbHVlMSA9PT0gZWxlbWVudFZhbHVlMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGVtZW50VmFsdWUxID0gZWxlbWVudFZhbHVlMS52YWx1ZTtcclxuICAgICAgICAgICAgZWxlbWVudFZhbHVlMiA9IGVsZW1lbnRWYWx1ZTIudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxIGluc3RhbmNlb2YgdHJlZS5TZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoZWxlbWVudFZhbHVlMiBpbnN0YW5jZW9mIHRyZWUuU2VsZWN0b3IpIHx8IGVsZW1lbnRWYWx1ZTEuZWxlbWVudHMubGVuZ3RoICE9PSBlbGVtZW50VmFsdWUyLmVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudFZhbHVlMS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUgIT09IGVsZW1lbnRWYWx1ZTIuZWxlbWVudHNbaV0uY29tYmluYXRvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCB8fCAoZWxlbWVudFZhbHVlMS5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlIHx8ICcgJykgIT09IChlbGVtZW50VmFsdWUyLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUgfHwgJyAnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0VsZW1lbnRWYWx1ZXNFcXVhbChlbGVtZW50VmFsdWUxLmVsZW1lbnRzW2ldLnZhbHVlLCBlbGVtZW50VmFsdWUyLmVsZW1lbnRzW2ldLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS5leHRlbmRTZWxlY3RvciA9IGZ1bmN0aW9uIChtYXRjaGVzLCBzZWxlY3RvclBhdGgsIHJlcGxhY2VtZW50U2VsZWN0b3IsIGlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBmb3IgYSBzZXQgb2YgbWF0Y2hlcywgcmVwbGFjZSBlYWNoIG1hdGNoIHdpdGggdGhlIHJlcGxhY2VtZW50IHNlbGVjdG9yXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPSAwLCBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMCwgcGF0aCA9IFtdLCBtYXRjaEluZGV4LCBzZWxlY3RvciwgZmlyc3RFbGVtZW50LCBtYXRjaCwgbmV3RWxlbWVudHM7XHJcbiAgICAgICAgICAgIGZvciAobWF0Y2hJbmRleCA9IDA7IG1hdGNoSW5kZXggPCBtYXRjaGVzLmxlbmd0aDsgbWF0Y2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXNbbWF0Y2hJbmRleF07XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yUGF0aFttYXRjaC5wYXRoSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50ID0gbmV3IHRyZWUuRWxlbWVudChtYXRjaC5pbml0aWFsQ29tYmluYXRvciwgcmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50c1swXS52YWx1ZSwgcmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50c1swXS5pc1ZhcmlhYmxlLCByZXBsYWNlbWVudFNlbGVjdG9yLmVsZW1lbnRzWzBdLmdldEluZGV4KCksIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0uZmlsZUluZm8oKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gucGF0aEluZGV4ID4gY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ICYmIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdLmVsZW1lbnRzID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbGVtZW50cy5jb25jYXQoc2VsZWN0b3JQYXRoW2N1cnJlbnRTZWxlY3RvclBhdGhJbmRleF0uZWxlbWVudHMuc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHMgPSBzZWxlY3Rvci5lbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4LCBtYXRjaC5pbmRleClcclxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KFtmaXJzdEVsZW1lbnRdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQocmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50cy5zbGljZSgxKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ID09PSBtYXRjaC5wYXRoSW5kZXggJiYgbWF0Y2hJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMuY29uY2F0KG5ld0VsZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmNvbmNhdChzZWxlY3RvclBhdGguc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEluZGV4LCBtYXRjaC5wYXRoSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobmV3IHRyZWUuU2VsZWN0b3IobmV3RWxlbWVudHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCA9IG1hdGNoLmVuZFBhdGhJbmRleDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPSBtYXRjaC5lbmRQYXRoRWxlbWVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPj0gc2VsZWN0b3JQYXRoW2N1cnJlbnRTZWxlY3RvclBhdGhJbmRleF0uZWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCA8IHNlbGVjdG9yUGF0aC5sZW5ndGggJiYgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXS5lbGVtZW50cyA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbGVtZW50cy5jb25jYXQoc2VsZWN0b3JQYXRoW2N1cnJlbnRTZWxlY3RvclBhdGhJbmRleF0uZWxlbWVudHMuc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KHNlbGVjdG9yUGF0aC5zbGljZShjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgsIHNlbGVjdG9yUGF0aC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uIChjdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiByZS11c2UgZWxlbWVudHMgaGVyZSwgYmVjYXVzZSB0aGUgdmlzaWJpbGl0eSBwcm9wZXJ0eSBtYXR0ZXJzIG9ubHkgZm9yIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcml2ZWQgPSBjdXJyZW50VmFsdWUuY3JlYXRlRGVyaXZlZChjdXJyZW50VmFsdWUuZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcml2ZWQuZW5zdXJlVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVyaXZlZC5lbnN1cmVJbnZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXJpdmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0TWVkaWEgPSBmdW5jdGlvbiAobWVkaWFOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0FsbEV4dGVuZHMgPSBtZWRpYU5vZGUuYWxsRXh0ZW5kcy5jb25jYXQodGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICBuZXdBbGxFeHRlbmRzID0gbmV3QWxsRXh0ZW5kcy5jb25jYXQodGhpcy5kb0V4dGVuZENoYWluaW5nKG5ld0FsbEV4dGVuZHMsIG1lZGlhTm9kZS5hbGxFeHRlbmRzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2gobmV3QWxsRXh0ZW5kcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0TWVkaWFPdXQgPSBmdW5jdGlvbiAobWVkaWFOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSBsYXN0SW5kZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXRSdWxlID0gZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2YXIgbmV3QWxsRXh0ZW5kcyA9IGF0UnVsZU5vZGUuYWxsRXh0ZW5kcy5jb25jYXQodGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICBuZXdBbGxFeHRlbmRzID0gbmV3QWxsRXh0ZW5kcy5jb25jYXQodGhpcy5kb0V4dGVuZENoYWluaW5nKG5ld0FsbEV4dGVuZHMsIGF0UnVsZU5vZGUuYWxsRXh0ZW5kcykpO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5wdXNoKG5ld0FsbEV4dGVuZHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0UnVsZU91dCA9IGZ1bmN0aW9uIChhdFJ1bGVOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSBsYXN0SW5kZXg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUHJvY2Vzc0V4dGVuZHNWaXNpdG9yO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBKb2luU2VsZWN0b3JWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEpvaW5TZWxlY3RvclZpc2l0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMgPSBbW11dO1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEpvaW5TZWxlY3RvclZpc2l0b3IucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRNaXhpbkRlZmluaXRpb24gPSBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSdWxlc2V0ID0gZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRzW3RoaXMuY29udGV4dHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBwYXRocyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2gocGF0aHMpO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHJ1bGVzZXROb2RlLnNlbGVjdG9ycztcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuZ2V0SXNPdXRwdXQoKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuc2VsZWN0b3JzID0gc2VsZWN0b3JzLmxlbmd0aCA/IHNlbGVjdG9ycyA6IChzZWxlY3RvcnMgPSBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLmpvaW5TZWxlY3RvcnMocGF0aHMsIGNvbnRleHQsIHNlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5ydWxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5wYXRocyA9IHBhdGhzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBKb2luU2VsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJ1bGVzZXRPdXQgPSBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sZW5ndGggPSB0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBKb2luU2VsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1lZGlhID0gZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBtZWRpYU5vZGUucnVsZXNbMF0ucm9vdCA9IChjb250ZXh0Lmxlbmd0aCA9PT0gMCB8fCBjb250ZXh0WzBdLm11bHRpTWVkaWEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdFJ1bGUgPSBmdW5jdGlvbiAoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAoYXRSdWxlTm9kZS5ydWxlcyAmJiBhdFJ1bGVOb2RlLnJ1bGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYXRSdWxlTm9kZS5ydWxlc1swXS5yb290ID0gKGF0UnVsZU5vZGUuaXNSb290ZWQgfHwgY29udGV4dC5sZW5ndGggPT09IDAgfHwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBKb2luU2VsZWN0b3JWaXNpdG9yO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBDU1NWaXNpdG9yVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gQ1NTVmlzaXRvclV0aWxzKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZS5jb250YWluc1NpbGVudE5vbkJsb2NrZWRDaGlsZCA9IGZ1bmN0aW9uIChib2R5UnVsZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGU7XHJcbiAgICAgICAgICAgIGlmICghYm9keVJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBib2R5UnVsZXMubGVuZ3RoOyByKyspIHtcclxuICAgICAgICAgICAgICAgIHJ1bGUgPSBib2R5UnVsZXNbcl07XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pc1NpbGVudCAmJiBydWxlLmlzU2lsZW50KHRoaXMuX2NvbnRleHQpICYmICFydWxlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhdHJ1bGUgY29udGFpbnMgc29tZXRoaW5nIHRoYXQgd2FzIHJlZmVyZW5jZWQgKGxpa2VseSBieSBleHRlbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmVmb3JlIGl0IG5lZWRzIHRvIGJlIHNob3duIGluIG91dHB1dCB0b29cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDU1NWaXNpdG9yVXRpbHMucHJvdG90eXBlLmtlZXBPbmx5VmlzaWJsZUNoaWxkcyA9IGZ1bmN0aW9uIChvd25lcikge1xyXG4gICAgICAgICAgICBpZiAob3duZXIgJiYgb3duZXIucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIG93bmVyLnJ1bGVzID0gb3duZXIucnVsZXMuZmlsdGVyKGZ1bmN0aW9uICh0aGluZykgeyByZXR1cm4gdGhpbmcuaXNWaXNpYmxlKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDU1NWaXNpdG9yVXRpbHMucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAob3duZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChvd25lciAmJiBvd25lci5ydWxlcylcclxuICAgICAgICAgICAgICAgID8gKG93bmVyLnJ1bGVzLmxlbmd0aCA9PT0gMCkgOiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZS5oYXNWaXNpYmxlU2VsZWN0b3IgPSBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChydWxlc2V0Tm9kZSAmJiBydWxlc2V0Tm9kZS5wYXRocylcclxuICAgICAgICAgICAgICAgID8gKHJ1bGVzZXROb2RlLnBhdGhzLmxlbmd0aCA+IDApIDogZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDU1NWaXNpdG9yVXRpbHMucHJvdG90eXBlLnJlc29sdmVWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKG5vZGUsIG9yaWdpbmFsUnVsZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eShub2RlKSAmJiAhdGhpcy5jb250YWluc1NpbGVudE5vbkJsb2NrZWRDaGlsZChvcmlnaW5hbFJ1bGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb21waWxlZFJ1bGVzQm9keSA9IG5vZGUucnVsZXNbMF07XHJcbiAgICAgICAgICAgIHRoaXMua2VlcE9ubHlWaXNpYmxlQ2hpbGRzKGNvbXBpbGVkUnVsZXNCb2R5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eShjb21waWxlZFJ1bGVzQm9keSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLmVuc3VyZVZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgbm9kZS5yZW1vdmVWaXNpYmlsaXR5QmxvY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDU1NWaXNpdG9yVXRpbHMucHJvdG90eXBlLmlzVmlzaWJsZVJ1bGVzZXQgPSBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLmZpcnN0Um9vdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eShydWxlc2V0Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QgJiYgIXRoaXMuaGFzVmlzaWJsZVNlbGVjdG9yKHJ1bGVzZXROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENTU1Zpc2l0b3JVdGlscztcclxuICAgIH0oKSk7XHJcbiAgICB2YXIgVG9DU1NWaXNpdG9yID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl92aXNpdG9yID0gbmV3IFZpc2l0b3IodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy51dGlscyA9IG5ldyBDU1NWaXNpdG9yVXRpbHMoY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgVG9DU1NWaXNpdG9yLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBpc1JlcGxhY2luZzogdHJ1ZSxcclxuICAgICAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXREZWNsYXJhdGlvbjogZnVuY3Rpb24gKGRlY2xOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGRlY2xOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSB8fCBkZWNsTm9kZS52YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNsTm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0TWl4aW5EZWZpbml0aW9uOiBmdW5jdGlvbiAobWl4aW5Ob2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgLy8gbWl4aW4gZGVmaW5pdGlvbnMgZG8gbm90IGdldCBldmFsJ2QgLSB0aGlzIG1lYW5zIHRoZXkga2VlcCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIGNsZWFyIHRoYXQgc3RhdGUgaGVyZSBzbyBpdCBpc24ndCB1c2VkIGlmIHRvQ1NTIGlzIGNhbGxlZCB0d2ljZVxyXG4gICAgICAgICAgICBtaXhpbk5vZGUuZnJhbWVzID0gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdEV4dGVuZDogZnVuY3Rpb24gKGV4dGVuZE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRDb21tZW50OiBmdW5jdGlvbiAoY29tbWVudE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICBpZiAoY29tbWVudE5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpIHx8IGNvbW1lbnROb2RlLmlzU2lsZW50KHRoaXMuX2NvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnROb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRNZWRpYTogZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFJ1bGVzID0gbWVkaWFOb2RlLnJ1bGVzWzBdLnJ1bGVzO1xyXG4gICAgICAgICAgICBtZWRpYU5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXRpbHMucmVzb2x2ZVZpc2liaWxpdHkobWVkaWFOb2RlLCBvcmlnaW5hbFJ1bGVzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0SW1wb3J0OiBmdW5jdGlvbiAoaW1wb3J0Tm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnROb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRBdFJ1bGU6IGZ1bmN0aW9uIChhdFJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGF0UnVsZU5vZGUucnVsZXMgJiYgYXRSdWxlTm9kZS5ydWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QXRSdWxlV2l0aEJvZHkoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QXRSdWxlV2l0aG91dEJvZHkoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRBbm9ueW1vdXM6IGZ1bmN0aW9uIChhbm9ueW1vdXNOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFhbm9ueW1vdXNOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzTm9kZS5hY2NlcHQodGhpcy5fdmlzaXRvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5vbnltb3VzTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRBdFJ1bGVXaXRoQm9keTogZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBuZXN0ZWQgcnVsZXNldCBhbmQgdGhhdCBvbmUgaGFzIG5vIHBhdGgsIHRoZW4gaXQgaXNcclxuICAgICAgICAgICAgLy8ganVzdCBmYWtlIHJ1bGVzZXRcclxuICAgICAgICAgICAgZnVuY3Rpb24gaGFzRmFrZVJ1bGVzZXQoYXRSdWxlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvZHlSdWxlcyA9IGF0UnVsZU5vZGUucnVsZXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keVJ1bGVzLmxlbmd0aCA9PT0gMSAmJiAoIWJvZHlSdWxlc1swXS5wYXRocyB8fCBib2R5UnVsZXNbMF0ucGF0aHMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRCb2R5UnVsZXMoYXRSdWxlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVSdWxlcyA9IGF0UnVsZU5vZGUucnVsZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmFrZVJ1bGVzZXQoYXRSdWxlTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVJ1bGVzWzBdLnJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVSdWxlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpdCBpcyBzdGlsbCB0cnVlIHRoYXQgaXQgaXMgb25seSBvbmUgcnVsZXNldCBpbiBhcnJheVxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGxhc3Qgc3VjaCBtb21lbnRcclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBjaGlsZHNcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsUnVsZXMgPSBnZXRCb2R5UnVsZXMoYXRSdWxlTm9kZSk7XHJcbiAgICAgICAgICAgIGF0UnVsZU5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzRW1wdHkoYXRSdWxlTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21lcmdlUnVsZXMoYXRSdWxlTm9kZS5ydWxlc1swXS5ydWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXRpbHMucmVzb2x2ZVZpc2liaWxpdHkoYXRSdWxlTm9kZSwgb3JpZ2luYWxSdWxlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdEF0UnVsZVdpdGhvdXRCb2R5OiBmdW5jdGlvbiAoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChhdFJ1bGVOb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhdFJ1bGVOb2RlLm5hbWUgPT09ICdAY2hhcnNldCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgb3V0cHV0IHRoZSBkZWJ1ZyBpbmZvIHRvZ2V0aGVyIHdpdGggc3Vic2VxdWVudCBAY2hhcnNldCBkZWZpbml0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjb21tZW50IChvciBAbWVkaWEgc3RhdGVtZW50KSBiZWZvcmUgdGhlIGFjdHVhbCBAY2hhcnNldCBhdHJ1bGUgd291bGRcclxuICAgICAgICAgICAgICAgIC8vIGJlIGNvbnNpZGVyZWQgaWxsZWdhbCBjc3MgYXMgaXQgaGFzIHRvIGJlIG9uIHRoZSBmaXJzdCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFyc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0UnVsZU5vZGUuZGVidWdJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gbmV3IHRyZWUuQ29tbWVudChcIi8qIFwiICsgYXRSdWxlTm9kZS50b0NTUyh0aGlzLl9jb250ZXh0KS5yZXBsYWNlKC9cXG4vZywgJycpICsgXCIgKi9cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuZGVidWdJbmZvID0gYXRSdWxlTm9kZS5kZWJ1Z0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdG9yLnZpc2l0KGNvbW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJzZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhdFJ1bGVOb2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hlY2tWYWxpZE5vZGVzOiBmdW5jdGlvbiAocnVsZXMsIGlzUm9vdCkge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVOb2RlID0gcnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSb290ICYmIHJ1bGVOb2RlIGluc3RhbmNlb2YgdHJlZS5EZWNsYXJhdGlvbiAmJiAhcnVsZU5vZGUudmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdQcm9wZXJ0aWVzIG11c3QgYmUgaW5zaWRlIHNlbGVjdG9yIGJsb2Nrcy4gVGhleSBjYW5ub3QgYmUgaW4gdGhlIHJvb3QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcnVsZU5vZGUuZ2V0SW5kZXgoKSwgZmlsZW5hbWU6IHJ1bGVOb2RlLmZpbGVJbmZvKCkgJiYgcnVsZU5vZGUuZmlsZUluZm8oKS5maWxlbmFtZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVOb2RlIGluc3RhbmNlb2YgdHJlZS5DYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIkZ1bmN0aW9uICdcIiArIHJ1bGVOb2RlLm5hbWUgKyBcIicgZGlkIG5vdCByZXR1cm4gYSByb290IG5vZGVcIiwgaW5kZXg6IHJ1bGVOb2RlLmdldEluZGV4KCksIGZpbGVuYW1lOiBydWxlTm9kZS5maWxlSW5mbygpICYmIHJ1bGVOb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChydWxlTm9kZS50eXBlICYmICFydWxlTm9kZS5hbGxvd1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6IHJ1bGVOb2RlLnR5cGUgKyBcIiBub2RlIHJldHVybmVkIGJ5IGEgZnVuY3Rpb24gaXMgbm90IHZhbGlkIGhlcmVcIiwgaW5kZXg6IHJ1bGVOb2RlLmdldEluZGV4KCksIGZpbGVuYW1lOiBydWxlTm9kZS5maWxlSW5mbygpICYmIHJ1bGVOb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRSdWxlc2V0OiBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHJ1bGVzZXRzIGFyZSBuZXN0ZWQgaW50byBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICB2YXIgcnVsZXNldHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja1ZhbGlkTm9kZXMocnVsZXNldE5vZGUucnVsZXMsIHJ1bGVzZXROb2RlLmZpcnN0Um9vdCk7XHJcbiAgICAgICAgICAgIGlmICghcnVsZXNldE5vZGUucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGludmlzaWJsZSBwYXRoc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZVJ1bGVzZXRQYXRocyhydWxlc2V0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgcnVsZXNldHMgZnJvbSB0aGlzIHJ1bGVzZXQgYm9keSBhbmQgY29tcGlsZSB0aGVtIHNlcGFyYXRlbHlcclxuICAgICAgICAgICAgICAgIHZhciBub2RlUnVsZXMgPSBydWxlc2V0Tm9kZS5ydWxlcztcclxuICAgICAgICAgICAgICAgIHZhciBub2RlUnVsZUNudCA9IG5vZGVSdWxlcyA/IG5vZGVSdWxlcy5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlUnVsZUNudDspIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlID0gbm9kZVJ1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlzaXQgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIHRoZW0gb3V0IGZyb20gYmVpbmcgYSBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlc2V0cy5wdXNoKHRoaXMuX3Zpc2l0b3IudmlzaXQocnVsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUnVsZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUnVsZUNudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYWNjZXB0IHRoZSB2aXNpdG9yIHRvIHJlbW92ZSBydWxlcyBhbmQgcmVmYWN0b3IgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBkZWNpZGUgbm9ndyB3aGV0aGVyIHdlIHdhbnQgaXQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlIGJvZHlcclxuICAgICAgICAgICAgICAgIGlmIChub2RlUnVsZUNudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5hY2NlcHQodGhpcy5fdmlzaXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5ydWxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gaWYgKCEgcnVsZXNldE5vZGUucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXJnZVJ1bGVzKHJ1bGVzZXROb2RlLnJ1bGVzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUR1cGxpY2F0ZVJ1bGVzKHJ1bGVzZXROb2RlLnJ1bGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBub3cgZGVjaWRlIHdoZXRoZXIgd2Uga2VlcCB0aGUgcnVsZXNldFxyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc1Zpc2libGVSdWxlc2V0KHJ1bGVzZXROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuZW5zdXJlVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldHMuc3BsaWNlKDAsIDAsIHJ1bGVzZXROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocnVsZXNldHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZXNldHNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2NvbXBpbGVSdWxlc2V0UGF0aHM6IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSkge1xyXG4gICAgICAgICAgICBpZiAocnVsZXNldE5vZGUucGF0aHMpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLnBhdGhzID0gcnVsZXNldE5vZGUucGF0aHNcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBbMF0uZWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMF0uZWxlbWVudHNbMF0uY29tYmluYXRvciA9IG5ldyAodHJlZS5Db21iaW5hdG9yKSgnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2ldLmlzVmlzaWJsZSgpICYmIHBbaV0uZ2V0SXNPdXRwdXQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZW1vdmVEdXBsaWNhdGVSdWxlczogZnVuY3Rpb24gKHJ1bGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAgICB2YXIgcnVsZUNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHZhciBydWxlTGlzdDtcclxuICAgICAgICAgICAgdmFyIHJ1bGU7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBydWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiB0cmVlLkRlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlQ2FjaGVbcnVsZS5uYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVbcnVsZS5uYW1lXSA9IHJ1bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdCA9IHJ1bGVDYWNoZVtydWxlLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUxpc3QgaW5zdGFuY2VvZiB0cmVlLkRlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlTGlzdCA9IHJ1bGVDYWNoZVtydWxlLm5hbWVdID0gW3J1bGVDYWNoZVtydWxlLm5hbWVdLnRvQ1NTKHRoaXMuX2NvbnRleHQpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZUNTUyA9IHJ1bGUudG9DU1ModGhpcy5fY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlTGlzdC5pbmRleE9mKHJ1bGVDU1MpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QucHVzaChydWxlQ1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX21lcmdlUnVsZXM6IGZ1bmN0aW9uIChydWxlcykge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBzQXJyID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5tZXJnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBydWxlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2tleV0gPyBydWxlcy5zcGxpY2UoaS0tLCAxKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc0Fyci5wdXNoKGdyb3Vwc1trZXldID0gW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JvdXBzQXJyLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IGdyb3VwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZV8xID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hXzEgPSBbbmV3IHRyZWUuRXhwcmVzc2lvbihzcGFjZV8xKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJ1bGUubWVyZ2UgPT09ICcrJykgJiYgKHNwYWNlXzEubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hXzEucHVzaChuZXcgdHJlZS5FeHByZXNzaW9uKHNwYWNlXzEgPSBbXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlXzEucHVzaChydWxlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEuaW1wb3J0YW50ID0gcmVzdWx0XzEuaW1wb3J0YW50IHx8IHJ1bGUuaW1wb3J0YW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xLnZhbHVlID0gbmV3IHRyZWUuVmFsdWUoY29tbWFfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgdmlzaXRvcnMgPSB7XHJcbiAgICAgICAgVmlzaXRvcjogVmlzaXRvcixcclxuICAgICAgICBJbXBvcnRWaXNpdG9yOiBJbXBvcnRWaXNpdG9yLFxyXG4gICAgICAgIE1hcmtWaXNpYmxlU2VsZWN0b3JzVmlzaXRvcjogU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLFxyXG4gICAgICAgIEV4dGVuZFZpc2l0b3I6IFByb2Nlc3NFeHRlbmRzVmlzaXRvcixcclxuICAgICAgICBKb2luU2VsZWN0b3JWaXNpdG9yOiBKb2luU2VsZWN0b3JWaXNpdG9yLFxyXG4gICAgICAgIFRvQ1NTVmlzaXRvcjogVG9DU1NWaXNpdG9yXHJcbiAgICB9O1xuXG4gICAgLy8gU3BsaXQgdGhlIGlucHV0IGludG8gY2h1bmtzLlxyXG4gICAgZnVuY3Rpb24gY2h1bmtlciAoaW5wdXQsIGZhaWwpIHtcclxuICAgICAgICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsZXZlbCA9IDA7XHJcbiAgICAgICAgdmFyIHBhcmVuTGV2ZWwgPSAwO1xyXG4gICAgICAgIHZhciBsYXN0T3BlbmluZztcclxuICAgICAgICB2YXIgbGFzdE9wZW5pbmdQYXJlbjtcclxuICAgICAgICB2YXIgbGFzdE11bHRpQ29tbWVudDtcclxuICAgICAgICB2YXIgbGFzdE11bHRpQ29tbWVudEVuZEJyYWNlO1xyXG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcclxuICAgICAgICB2YXIgZW1pdEZyb20gPSAwO1xyXG4gICAgICAgIHZhciBjaHVua2VyQ3VycmVudEluZGV4O1xyXG4gICAgICAgIHZhciBjdXJyZW50Q2h1bmtTdGFydEluZGV4O1xyXG4gICAgICAgIHZhciBjYztcclxuICAgICAgICB2YXIgY2MyO1xyXG4gICAgICAgIHZhciBtYXRjaGVkO1xyXG4gICAgICAgIGZ1bmN0aW9uIGVtaXRDaHVuayhmb3JjZSkge1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gY2h1bmtlckN1cnJlbnRJbmRleCAtIGVtaXRGcm9tO1xyXG4gICAgICAgICAgICBpZiAoKChsZW4gPCA1MTIpICYmICFmb3JjZSkgfHwgIWxlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGlucHV0LnNsaWNlKGVtaXRGcm9tLCBjaHVua2VyQ3VycmVudEluZGV4ICsgMSkpO1xyXG4gICAgICAgICAgICBlbWl0RnJvbSA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNodW5rZXJDdXJyZW50SW5kZXggPSAwOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcclxuICAgICAgICAgICAgY2MgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoKChjYyA+PSA5NykgJiYgKGNjIDw9IDEyMikpIHx8IChjYyA8IDM0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYS16IG9yIHdoaXRlc3BhY2VcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY2MpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDA6IC8vIChcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbkxldmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9wZW5pbmdQYXJlbiA9IGNodW5rZXJDdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQxOiAvLyApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tcGFyZW5MZXZlbCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ21pc3Npbmcgb3BlbmluZyBgKGAnLCBjaHVua2VyQ3VycmVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU5OiAvLyA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbkxldmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRDaHVuaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTIzOiAvLyB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwrKztcclxuICAgICAgICAgICAgICAgICAgICBsYXN0T3BlbmluZyA9IGNodW5rZXJDdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyNTogLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxldmVsIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBvcGVuaW5nIGB7YCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxldmVsICYmICFwYXJlbkxldmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRDaHVuaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTI6IC8vIFxcXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rZXJDdXJyZW50SW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCd1bmVzY2FwZWQgYFxcXFxgJywgY2h1bmtlckN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOTpcclxuICAgICAgICAgICAgICAgIGNhc2UgOTY6IC8vIFwiLCAnIGFuZCBgXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rU3RhcnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDE7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW47IGNodW5rZXJDdXJyZW50SW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYzIgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID4gOTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gY2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA9PSA5MikgeyAvLyBcXFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPT0gbGVuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCd1bmVzY2FwZWQgYFxcXFxgJywgY2h1bmtlckN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VyQ3VycmVudEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwidW5tYXRjaGVkIGBcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpICsgXCJgXCIsIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0NzogLy8gLywgY2hlY2sgZm9yIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW5MZXZlbCB8fCAoY2h1bmtlckN1cnJlbnRJbmRleCA9PSBsZW4gLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA9PSA0Nykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAvLywgZmluZCBsbmZlZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDI7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW47IGNodW5rZXJDdXJyZW50SW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2MyIDw9IDEzKSAmJiAoKGNjMiA9PSAxMCkgfHwgKGNjMiA9PSAxMykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2MyID09IDQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC8qLCBmaW5kICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNdWx0aUNvbW1lbnQgPSBjdXJyZW50Q2h1bmtTdGFydEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gY2h1bmtlckN1cnJlbnRJbmRleCArIDI7IGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID09IDEyNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNdWx0aUNvbW1lbnRFbmRCcmFjZSA9IGNodW5rZXJDdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MyICE9IDQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4ICsgMSkgPT0gNDcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtlckN1cnJlbnRJbmRleCA9PSBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBjbG9zaW5nIGAqL2AnLCBjdXJyZW50Q2h1bmtTdGFydEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VyQ3VycmVudEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0MjogLy8gKiwgY2hlY2sgZm9yIHVubWF0Y2hlZCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbiAtIDEpICYmIChpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXggKyAxKSA9PSA0NykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ3VubWF0Y2hlZCBgLypgJywgY2h1bmtlckN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZXZlbCAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoKGxhc3RNdWx0aUNvbW1lbnQgPiBsYXN0T3BlbmluZykgJiYgKGxhc3RNdWx0aUNvbW1lbnRFbmRCcmFjZSA+IGxhc3RNdWx0aUNvbW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBjbG9zaW5nIGB9YCBvciBgKi9gJywgbGFzdE9wZW5pbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ21pc3NpbmcgY2xvc2luZyBgfWAnLCBsYXN0T3BlbmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyZW5MZXZlbCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgnbWlzc2luZyBjbG9zaW5nIGApYCcsIGxhc3RPcGVuaW5nUGFyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbWl0Q2h1bmsodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNodW5rcztcclxuICAgIH1cblxuICAgIHZhciBnZXRQYXJzZXJJbnB1dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIC8vIExlc3MgaW5wdXQgc3RyaW5nXHJcbiAgICAgICAgaW5wdXQ7XHJcbiAgICAgICAgdmFyIC8vIGN1cnJlbnQgY2h1bmtcclxuICAgICAgICBqO1xyXG4gICAgICAgIHZhciAvLyBob2xkcyBzdGF0ZSBmb3IgYmFja3RyYWNraW5nXHJcbiAgICAgICAgc2F2ZVN0YWNrID0gW107XHJcbiAgICAgICAgdmFyIC8vIGZ1cnRoZXN0IGluZGV4IHRoZSBwYXJzZXIgaGFzIGdvbmUgdG9cclxuICAgICAgICBmdXJ0aGVzdDtcclxuICAgICAgICB2YXIgLy8gaWYgdGhpcyBpcyBmdXJ0aGVzdCB3ZSBnb3QgdG8sIHRoaXMgaXMgdGhlIHByb2JhYmx5IGNhdXNlXHJcbiAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTtcclxuICAgICAgICB2YXIgLy8gY2h1bmtpZmllZCBpbnB1dFxyXG4gICAgICAgIGNodW5rcztcclxuICAgICAgICB2YXIgLy8gY3VycmVudCBjaHVua1xyXG4gICAgICAgIGN1cnJlbnQ7XHJcbiAgICAgICAgdmFyIC8vIGluZGV4IG9mIGN1cnJlbnQgY2h1bmssIGluIGBpbnB1dGBcclxuICAgICAgICBjdXJyZW50UG9zO1xyXG4gICAgICAgIHZhciBwYXJzZXJJbnB1dCA9IHt9O1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9TUEFDRSA9IDMyO1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9UQUIgPSA5O1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9MRiA9IDEwO1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9DUiA9IDEzO1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9QTFVTID0gNDM7XHJcbiAgICAgICAgdmFyIENIQVJDT0RFX0NPTU1BID0gNDQ7XHJcbiAgICAgICAgdmFyIENIQVJDT0RFX0ZPUldBUkRfU0xBU0ggPSA0NztcclxuICAgICAgICB2YXIgQ0hBUkNPREVfOSA9IDU3O1xyXG4gICAgICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkaSA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgIHZhciBvbGRqID0gajtcclxuICAgICAgICAgICAgdmFyIGN1cnIgPSBwYXJzZXJJbnB1dC5pIC0gY3VycmVudFBvcztcclxuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gcGFyc2VySW5wdXQuaSArIGN1cnJlbnQubGVuZ3RoIC0gY3VycjtcclxuICAgICAgICAgICAgdmFyIG1lbSA9IChwYXJzZXJJbnB1dC5pICs9IGxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciBpbnAgPSBpbnB1dDtcclxuICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhcjtcclxuICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XHJcbiAgICAgICAgICAgIGZvciAoOyBwYXJzZXJJbnB1dC5pIDwgZW5kSW5kZXg7IHBhcnNlcklucHV0LmkrKykge1xyXG4gICAgICAgICAgICAgICAgYyA9IGlucC5jaGFyQ29kZUF0KHBhcnNlcklucHV0LmkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiICYmIGMgPT09IENIQVJDT0RFX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhciA9IGlucC5jaGFyQXQocGFyc2VySW5wdXQuaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB7IGluZGV4OiBwYXJzZXJJbnB1dC5pLCBpc0xpbmVDb21tZW50OiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0TmV3TGluZSA9IGlucC5pbmRleE9mKCdcXG4nLCBwYXJzZXJJbnB1dC5pICsgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TmV3TGluZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHROZXdMaW5lID0gZW5kSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IG5leHROZXdMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnRleHQgPSBpbnAuc3Vic3RyKGNvbW1lbnQuaW5kZXgsIHBhcnNlcklucHV0LmkgLSBjb21tZW50LmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLnB1c2goY29tbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RhclNsYXNoID0gaW5wLmluZGV4T2YoJyovJywgcGFyc2VySW5wdXQuaSArIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXJTbGFzaCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZXJJbnB1dC5pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGlucC5zdWJzdHIocGFyc2VySW5wdXQuaSwgbmV4dFN0YXJTbGFzaCArIDIgLSBwYXJzZXJJbnB1dC5pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xpbmVDb21tZW50OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgKz0gY29tbWVudC50ZXh0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUucHVzaChjb21tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChjICE9PSBDSEFSQ09ERV9TUEFDRSkgJiYgKGMgIT09IENIQVJDT0RFX0xGKSAmJiAoYyAhPT0gQ0hBUkNPREVfVEFCKSAmJiAoYyAhPT0gQ0hBUkNPREVfQ1IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2xpY2UobGVuZ3RoICsgcGFyc2VySW5wdXQuaSAtIG1lbSArIGN1cnIpO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCBjaHVua3MubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjaHVua3NbKytqXTtcclxuICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgwKTsgLy8gc2tpcCBzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgY2h1bmtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gdGhpbmdzIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2xkaSAhPT0gcGFyc2VySW5wdXQuaSB8fCBvbGRqICE9PSBqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJzZXJJbnB1dC5zYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgc2F2ZVN0YWNrLnB1c2goeyBjdXJyZW50OiBjdXJyZW50LCBpOiBwYXJzZXJJbnB1dC5pLCBqOiBqIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSA9IGZ1bmN0aW9uIChwb3NzaWJsZUVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuaSA+IGZ1cnRoZXN0IHx8IChwYXJzZXJJbnB1dC5pID09PSBmdXJ0aGVzdCAmJiBwb3NzaWJsZUVycm9yTWVzc2FnZSAmJiAhZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2UgPSBwb3NzaWJsZUVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzYXZlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBzdGF0ZS5jdXJyZW50O1xyXG4gICAgICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaSA9IHN0YXRlLmk7XHJcbiAgICAgICAgICAgIGogPSBzdGF0ZS5qO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzYXZlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBwYXJzZXJJbnB1dC5pICsgKG9mZnNldCB8fCAwKTtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29kZSA9PT0gQ0hBUkNPREVfU1BBQ0UgfHwgY29kZSA9PT0gQ0hBUkNPREVfQ1IgfHwgY29kZSA9PT0gQ0hBUkNPREVfVEFCIHx8IGNvZGUgPT09IENIQVJDT0RFX0xGKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mICQodG9rKVxyXG4gICAgICAgIHBhcnNlcklucHV0LiRyZSA9IGZ1bmN0aW9uICh0b2spIHtcclxuICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmkgPiBjdXJyZW50UG9zKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zbGljZShwYXJzZXJJbnB1dC5pIC0gY3VycmVudFBvcyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbSA9IHRvay5leGVjKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKG1bMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG0ubGVuZ3RoID09PSAxID8gbVswXSA6IG07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC4kY2hhciA9IGZ1bmN0aW9uICh0b2spIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKSAhPT0gdG9rKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvaztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnNlcklucHV0LiRzdHIgPSBmdW5jdGlvbiAodG9rKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tMZW5ndGggPSB0b2subGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLXN0YXJ0c3dpdGgvMjFcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pICsgaSkgIT09IHRvay5jaGFyQXQoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBza2lwV2hpdGVzcGFjZSh0b2tMZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuJHF1b3RlZCA9IGZ1bmN0aW9uIChsb2MpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IGxvYyB8fCBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRDaGFyID0gaW5wdXQuY2hhckF0KHBvcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydENoYXIgIT09ICdcXCcnICYmIHN0YXJ0Q2hhciAhPT0gJ1wiJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpICsgY3VycmVudFBvc2l0aW9uIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGlucHV0LmNoYXJBdChpICsgY3VycmVudFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobmV4dENoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXFxcJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHInOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc3RhcnRDaGFyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gaW5wdXQuc3Vic3RyKGN1cnJlbnRQb3NpdGlvbiwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYyAmJiBsb2MgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydENoYXIsIHN0cl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJtaXNzaXZlIHBhcnNpbmcuIElnbm9yZXMgZXZlcnl0aGluZyBleGNlcHQgbWF0Y2hpbmcge30gW10gKCkgYW5kIHF1b3Rlc1xyXG4gICAgICAgICAqIHVudGlsIG1hdGNoaW5nIHRva2VuIChvdXRzaWRlIG9mIGJsb2NrcylcclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJzZXJJbnB1dC4kcGFyc2VVbnRpbCA9IGZ1bmN0aW9uICh0b2spIHtcclxuICAgICAgICAgICAgdmFyIHF1b3RlID0gJyc7XHJcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWwgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgaW5Db21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBibG9ja0RlcHRoID0gMDtcclxuICAgICAgICAgICAgdmFyIGJsb2NrU3RhY2sgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBhcnNlR3JvdXBzID0gW107XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgIHZhciBsYXN0UG9zID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgdmFyIGkgPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICB2YXIgbG9vcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB0ZXN0Q2hhcjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0Q2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiBjaGFyID09PSB0b2s7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0Q2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiB0b2sudGVzdChjaGFyKTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBpbnB1dC5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tEZXB0aCA9PT0gMCAmJiB0ZXN0Q2hhcihuZXh0Q2hhcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBpbnB1dC5zdWJzdHIobGFzdFBvcywgaSAtIGxhc3RQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VHcm91cHMucHVzaChyZXR1cm5WYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VHcm91cHMucHVzaCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBwYXJzZUdyb3VwcztcclxuICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZShpIC0gc3RhcnRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkNvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSAnKicgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmNoYXJBdChpICsgMSkgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Db21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0Q2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdcXFxcJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGFyID0gaW5wdXQuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VHcm91cHMucHVzaChpbnB1dC5zdWJzdHIobGFzdFBvcywgaSAtIGxhc3RQb3MgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KGkgKyAxKSA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQ29tbWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcJyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlID0gcGFyc2VySW5wdXQuJHF1b3RlZChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdW90ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2goaW5wdXQuc3Vic3RyKGxhc3RQb3MsIGkgLSBsYXN0UG9zKSwgcXVvdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcXVvdGVbMV0ubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZShpIC0gc3RhcnRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IG5leHRDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU3RhY2sucHVzaCgnfScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTdGFjay5wdXNoKCcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0RlcHRoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1N0YWNrLnB1c2goJ10nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRGVwdGgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd9JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gYmxvY2tTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gZXhwZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0RlcHRoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBwYXJzZXIgdG8gdGhlIGVycm9yIGFuZCByZXR1cm4gZXhwZWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZShpIC0gc3RhcnRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IGV4cGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGxvb3ApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsID8gcmV0dXJuVmFsIDogbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gdHJ1ZTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUgPSBbXTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5maW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIFNhbWUgYXMgJCgpLCBidXQgZG9uJ3QgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLFxyXG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBtYXRjaC5cclxuICAgICAgICBwYXJzZXJJbnB1dC5wZWVrID0gZnVuY3Rpb24gKHRvaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9zdHJpbmctc3RhcnRzd2l0aC8yMVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkgKyBpKSAhPT0gdG9rLmNoYXJBdChpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnRlc3QoY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mIHBlZWsoKVxyXG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlIG9yIGNoYW5nZSBzb21lIGN1cnJlbnRDaGFyIGNhbGxzIHRvIHBlZWtDaGFyXHJcbiAgICAgICAgcGFyc2VySW5wdXQucGVla0NoYXIgPSBmdW5jdGlvbiAodG9rKSB7IHJldHVybiBpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSkgPT09IHRvazsgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pKTsgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5wcmV2Q2hhciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pIC0gMSk7IH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuZ2V0SW5wdXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dDsgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5wZWVrTm90TnVtZXJpYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBpbnB1dC5jaGFyQ29kZUF0KHBhcnNlcklucHV0LmkpO1xyXG4gICAgICAgICAgICAvLyBJcyB0aGUgZmlyc3QgY2hhciBvZiB0aGUgZGltZW5zaW9uIDAtOSwgJy4nLCAnKycgb3IgJy0nXHJcbiAgICAgICAgICAgIHJldHVybiAoYyA+IENIQVJDT0RFXzkgfHwgYyA8IENIQVJDT0RFX1BMVVMpIHx8IGMgPT09IENIQVJDT0RFX0ZPUldBUkRfU0xBU0ggfHwgYyA9PT0gQ0hBUkNPREVfQ09NTUE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5zdGFydCA9IGZ1bmN0aW9uIChzdHIsIGNodW5rSW5wdXQsIGZhaWxGdW5jdGlvbikge1xyXG4gICAgICAgICAgICBpbnB1dCA9IHN0cjtcclxuICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGogPSBjdXJyZW50UG9zID0gZnVydGhlc3QgPSAwO1xyXG4gICAgICAgICAgICAvLyBjaHVua2luZyBhcHBhcmVudGx5IG1ha2VzIHRoaW5ncyBxdWlja2VyIChidXQgbXkgdGVzdHMgaW5kaWNhdGVcclxuICAgICAgICAgICAgLy8gaXQgbWlnaHQgYWN0dWFsbHkgbWFrZSB0aGluZ3Mgc2xvd2VyIGluIG5vZGUgYXQgbGVhc3QpXHJcbiAgICAgICAgICAgIC8vIGFuZCBpdCBpcyBhIG5vbi1wZXJmZWN0IHBhcnNlIC0gaXQgY2FuJ3QgcmVjb2duaXNlXHJcbiAgICAgICAgICAgIC8vIHVucXVvdGVkIHVybHMsIG1lYW5pbmcgaXQgY2FuJ3QgZGlzdGluZ3Vpc2ggY29tbWVudHNcclxuICAgICAgICAgICAgLy8gbWVhbmluZyBjb21tZW50cyB3aXRoIHF1b3RlcyBvciB7fSgpIGluIHRoZW0gZ2V0ICdjb3VudGVkJ1xyXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBsZWFkIHRvIHBhcnNlIGVycm9ycy5cclxuICAgICAgICAgICAgLy8gSW4gYWRkaXRpb24gaWYgdGhlIGNodW5raW5nIGNodW5rcyBpbiB0aGUgd3JvbmcgcGxhY2Ugd2UgbWlnaHRcclxuICAgICAgICAgICAgLy8gbm90IGJlIGFibGUgdG8gcGFyc2UgYSBwYXJzZXIgc3RhdGVtZW50IGluIG9uZSBnb1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9mZmljaWFsbHkgZGVwcmVjYXRlZCBidXQgY2FuIGJlIHN3aXRjaGVkIG9uIHZpYSBhbiBvcHRpb25cclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2UgaXQgY2F1c2VzIHRvbyBtdWNoIHBlcmZvcm1hbmNlIGlzc3Vlcy5cclxuICAgICAgICAgICAgaWYgKGNodW5rSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGNodW5rcyA9IGNodW5rZXIoc3RyLCBmYWlsRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2h1bmtzID0gW3N0cl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGNodW5rc1swXTtcclxuICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xyXG4gICAgICAgICAgICB2YXIgaXNGaW5pc2hlZCA9IHBhcnNlcklucHV0LmkgPj0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuaSA8IGZ1cnRoZXN0KSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBmdXJ0aGVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXNGaW5pc2hlZDogaXNGaW5pc2hlZCxcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0OiBwYXJzZXJJbnB1dC5pLFxyXG4gICAgICAgICAgICAgICAgZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTogbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0UmVhY2hlZEVuZDogcGFyc2VySW5wdXQuaSA+PSBpbnB1dC5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICAgZnVydGhlc3RDaGFyOiBpbnB1dFtwYXJzZXJJbnB1dC5pXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlcklucHV0O1xyXG4gICAgfSk7XG5cbiAgICAvL1xyXG4gICAgLy8gbGVzcy5qcyAtIHBhcnNlclxyXG4gICAgLy9cclxuICAgIC8vICAgIEEgcmVsYXRpdmVseSBzdHJhaWdodC1mb3J3YXJkIHByZWRpY3RpdmUgcGFyc2VyLlxyXG4gICAgLy8gICAgVGhlcmUgaXMgbm8gdG9rZW5pemF0aW9uL2xleGluZyBzdGFnZSwgdGhlIGlucHV0IGlzIHBhcnNlZFxyXG4gICAgLy8gICAgaW4gb25lIHN3ZWVwLlxyXG4gICAgLy9cclxuICAgIC8vICAgIFRvIG1ha2UgdGhlIHBhcnNlciBmYXN0IGVub3VnaCB0byBydW4gaW4gdGhlIGJyb3dzZXIsIHNldmVyYWxcclxuICAgIC8vICAgIG9wdGltaXphdGlvbiBoYWQgdG8gYmUgbWFkZTpcclxuICAgIC8vXHJcbiAgICAvLyAgICAtIE1hdGNoaW5nIGFuZCBzbGljaW5nIG9uIGEgaHVnZSBpbnB1dCBpcyBvZnRlbiBjYXVzZSBvZiBzbG93ZG93bnMuXHJcbiAgICAvLyAgICAgIFRoZSBzb2x1dGlvbiBpcyB0byBjaHVua2lmeSB0aGUgaW5wdXQgaW50byBzbWFsbGVyIHN0cmluZ3MuXHJcbiAgICAvLyAgICAgIFRoZSBjaHVua3MgYXJlIHN0b3JlZCBpbiB0aGUgYGNodW5rc2AgdmFyLFxyXG4gICAgLy8gICAgICBgamAgaG9sZHMgdGhlIGN1cnJlbnQgY2h1bmsgaW5kZXgsIGFuZCBgY3VycmVudFBvc2AgaG9sZHNcclxuICAgIC8vICAgICAgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNodW5rIGluIHJlbGF0aW9uIHRvIGBpbnB1dGAuXHJcbiAgICAvLyAgICAgIFRoaXMgZ2l2ZXMgdXMgYW4gYWxtb3N0IDR4IHNwZWVkLXVwLlxyXG4gICAgLy9cclxuICAgIC8vICAgIC0gSW4gbWFueSBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBtYXRjaCBpbmRpdmlkdWFsIHRva2VucztcclxuICAgIC8vICAgICAgZm9yIGV4YW1wbGUsIGlmIGEgdmFsdWUgZG9lc24ndCBob2xkIGFueSB2YXJpYWJsZXMsIG9wZXJhdGlvbnNcclxuICAgIC8vICAgICAgb3IgZHluYW1pYyByZWZlcmVuY2VzLCB0aGUgcGFyc2VyIGNhbiBlZmZlY3RpdmVseSAnc2tpcCcgaXQsXHJcbiAgICAvLyAgICAgIHRyZWF0aW5nIGl0IGFzIGEgbGl0ZXJhbC5cclxuICAgIC8vICAgICAgQW4gZXhhbXBsZSB3b3VsZCBiZSAnMXB4IHNvbGlkICMwMDAnIC0gd2hpY2ggZXZhbHVhdGVzIHRvIGl0c2VsZixcclxuICAgIC8vICAgICAgd2UgZG9uJ3QgbmVlZCB0byBrbm93IHdoYXQgdGhlIGluZGl2aWR1YWwgY29tcG9uZW50cyBhcmUuXHJcbiAgICAvLyAgICAgIFRoZSBkcmF3YmFjaywgb2YgY291cnNlIGlzIHRoYXQgeW91IGRvbid0IGdldCB0aGUgYmVuZWZpdHMgb2ZcclxuICAgIC8vICAgICAgc3ludGF4LWNoZWNraW5nIG9uIHRoZSBDU1MuIFRoaXMgZ2l2ZXMgdXMgYSA1MCUgc3BlZWQtdXAgaW4gdGhlIHBhcnNlcixcclxuICAgIC8vICAgICAgYW5kIGEgc21hbGxlciBzcGVlZC11cCBpbiB0aGUgY29kZS1nZW4uXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vICAgIFRva2VuIG1hdGNoaW5nIGlzIGRvbmUgd2l0aCB0aGUgYCRgIGZ1bmN0aW9uLCB3aGljaCBlaXRoZXIgdGFrZXNcclxuICAgIC8vICAgIGEgdGVybWluYWwgc3RyaW5nIG9yIHJlZ2V4cCwgb3IgYSBub24tdGVybWluYWwgZnVuY3Rpb24gdG8gY2FsbC5cclxuICAgIC8vICAgIEl0IGFsc28gdGFrZXMgY2FyZSBvZiBtb3ZpbmcgYWxsIHRoZSBpbmRpY2VzIGZvcndhcmRzLlxyXG4gICAgLy9cclxuICAgIHZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIoY29udGV4dCwgaW1wb3J0cywgZmlsZUluZm8pIHtcclxuICAgICAgICB2YXIgcGFyc2VycztcclxuICAgICAgICB2YXIgcGFyc2VySW5wdXQgPSBnZXRQYXJzZXJJbnB1dCgpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGVycm9yKG1zZywgdHlwZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZXJJbnB1dC5pLFxyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVJbmZvLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSB8fCAnU3ludGF4JyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xyXG4gICAgICAgICAgICB9LCBpbXBvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0KGFyZywgbXNnKSB7XHJcbiAgICAgICAgICAgIC8vIHNvbWUgb2xkZXIgYnJvd3NlcnMgcmV0dXJuIHR5cGVvZiAnZnVuY3Rpb24nIGZvciBSZWdFeHBcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBhcmcuY2FsbChwYXJzZXJzKSA6IHBhcnNlcklucHV0LiRyZShhcmcpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yKG1zZyB8fCAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gXCJleHBlY3RlZCAnXCIgKyBhcmcgKyBcIicgZ290ICdcIiArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyBcIidcIlxyXG4gICAgICAgICAgICAgICAgOiAndW5leHBlY3RlZCB0b2tlbicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3BlY2lhbGl6YXRpb24gb2YgZXhwZWN0KClcclxuICAgICAgICBmdW5jdGlvbiBleHBlY3RDaGFyKGFyZywgbXNnKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcihhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yKG1zZyB8fCBcImV4cGVjdGVkICdcIiArIGFyZyArIFwiJyBnb3QgJ1wiICsgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVidWdJbmZvKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGVJbmZvLmZpbGVuYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogZ2V0TG9jYXRpb24oaW5kZXgsIHBhcnNlcklucHV0LmdldElucHV0KCkpLmxpbmUgKyAxLFxyXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVuYW1lXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICBVc2VkIGFmdGVyIGluaXRpYWwgcGFyc2luZyB0byBjcmVhdGUgbm9kZXMgb24gdGhlIGZseVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgLSBzdHJpbmcgdG8gcGFyc2VcclxuICAgICAgICAgKiAgQHBhcmFtIHtBcnJheX0gIHBhcnNlTGlzdCAgICAtIGFycmF5IG9mIHBhcnNlcnMgdG8gcnVuIGlucHV0IHRocm91Z2ggZS5nLiBbXCJ2YWx1ZVwiLCBcImltcG9ydGFudFwiXVxyXG4gICAgICAgICAqICBAcGFyYW0ge051bWJlcn0gY3VycmVudEluZGV4IC0gc3RhcnQgbnVtYmVyIHRvIGJlZ2luIGluZGV4aW5nXHJcbiAgICAgICAgICogIEBwYXJhbSB7T2JqZWN0fSBmaWxlSW5mbyAgICAgLSBmaWxlSW5mbyB0byBhdHRhY2ggdG8gY3JlYXRlZCBub2Rlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTm9kZShzdHIsIHBhcnNlTGlzdCwgY3VycmVudEluZGV4LCBmaWxlSW5mbywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIHJldHVybk5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSBwYXJzZXJJbnB1dDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5zdGFydChzdHIsIGZhbHNlLCBmdW5jdGlvbiBmYWlsKG1zZywgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4ICsgY3VycmVudEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCBwID0gdm9pZCAwLCBpID0gdm9pZCAwOyAocCA9IHBhcnNlTGlzdFt4XSk7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYXJzZXIuaTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZXJzW3BdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9pbmRleCA9IGkgKyBjdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuX2ZpbGVJbmZvID0gZmlsZUluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Ob2Rlcy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Ob2Rlcy5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmZvID0gcGFyc2VyLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZEluZm8uaXNGaW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJldHVybk5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZS5pbmRleCArIGN1cnJlbnRJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIH0sIGltcG9ydHMsIGZpbGVJbmZvLmZpbGVuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoZSBQYXJzZXJcclxuICAgICAgICAvL1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBhcnNlcklucHV0OiBwYXJzZXJJbnB1dCxcclxuICAgICAgICAgICAgaW1wb3J0czogaW1wb3J0cyxcclxuICAgICAgICAgICAgZmlsZUluZm86IGZpbGVJbmZvLFxyXG4gICAgICAgICAgICBwYXJzZU5vZGU6IHBhcnNlTm9kZSxcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUsXHJcbiAgICAgICAgICAgIC8vIEBwYXJhbSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyAnbGVzcycgbWFya3VwXHJcbiAgICAgICAgICAgIC8vIEBwYXJhbSBjYWxsYmFjayBjYWxsIGBjYWxsYmFja2Agd2hlbiBkb25lLlxyXG4gICAgICAgICAgICAvLyBAcGFyYW0gW2FkZGl0aW9uYWxEYXRhXSBBbiBvcHRpb25hbCBtYXAgd2hpY2ggY2FuIGNvbnRhaW5zIHZhcnMgLSBhIG1hcCAoa2V5LCB2YWx1ZSkgb2YgdmFyaWFibGVzIHRvIGFwcGx5XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaywgYWRkaXRpb25hbERhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb290O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxWYXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmeVZhcnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlZDtcclxuICAgICAgICAgICAgICAgIHZhciBwcmVUZXh0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICBnbG9iYWxWYXJzID0gKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLmdsb2JhbFZhcnMpID8gUGFyc2VyLnNlcmlhbGl6ZVZhcnMoYWRkaXRpb25hbERhdGEuZ2xvYmFsVmFycykgKyBcIlxcblwiIDogJyc7XHJcbiAgICAgICAgICAgICAgICBtb2RpZnlWYXJzID0gKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLm1vZGlmeVZhcnMpID8gXCJcXG5cIiArIFBhcnNlci5zZXJpYWxpemVWYXJzKGFkZGl0aW9uYWxEYXRhLm1vZGlmeVZhcnMpIDogJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5wbHVnaW5NYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZVByb2Nlc3NvcnMgPSBjb250ZXh0LnBsdWdpbk1hbmFnZXIuZ2V0UHJlUHJvY2Vzc29ycygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlUHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBwcmVQcm9jZXNzb3JzW2ldLnByb2Nlc3Moc3RyLCB7IGNvbnRleHQ6IGNvbnRleHQsIGltcG9ydHM6IGltcG9ydHMsIGZpbGVJbmZvOiBmaWxlSW5mbyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVmFycyB8fCAoYWRkaXRpb25hbERhdGEgJiYgYWRkaXRpb25hbERhdGEuYmFubmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZVRleHQgPSAoKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLmJhbm5lcikgPyBhZGRpdGlvbmFsRGF0YS5iYW5uZXIgOiAnJykgKyBnbG9iYWxWYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgPSBpbXBvcnRzLmNvbnRlbnRzSWdub3JlZENoYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWRbZmlsZUluZm8uZmlsZW5hbWVdID0gaWdub3JlZFtmaWxlSW5mby5maWxlbmFtZV0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkW2ZpbGVJbmZvLmZpbGVuYW1lXSArPSBwcmVUZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwb3RlbnRpYWwgVVRGIEJ5dGUgT3JkZXIgTWFya1xyXG4gICAgICAgICAgICAgICAgc3RyID0gcHJlVGV4dCArIHN0ci5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKSArIG1vZGlmeVZhcnM7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRzLmNvbnRlbnRzW2ZpbGVJbmZvLmZpbGVuYW1lXSA9IHN0cjtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHByaW1hcnkgcnVsZS5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBzeW50YXggdHJlZSBpcyBoZWxkIHVuZGVyIGEgUnVsZXNldCBub2RlLFxyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgYHJvb3RgIHByb3BlcnR5IHNldCB0byB0cnVlLCBzbyBubyBge31gIGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gb3V0cHV0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIGlucHV0IGlzIHBhcnNlZC5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc3RhcnQoc3RyLCBjb250ZXh0LmNodW5rSW5wdXQsIGZ1bmN0aW9uIGZhaWwobXNnLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJzZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaW1wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZS5Ob2RlLnByb3RvdHlwZS5wYXJzZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG5ldyB0cmVlLlJ1bGVzZXQobnVsbCwgdGhpcy5wYXJzZXJzLnByaW1hcnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZS5Ob2RlLnByb3RvdHlwZS5yb290Tm9kZSA9IHJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5yb290ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByb290LmZpcnN0Um9vdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5mdW5jdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb25SZWdpc3RyeS5pbmhlcml0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVJbmZvLmZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBgaWAgaXMgc21hbGxlciB0aGFuIHRoZSBgaW5wdXQubGVuZ3RoIC0gMWAsXHJcbiAgICAgICAgICAgICAgICAvLyBpdCBtZWFucyB0aGUgcGFyc2VyIHdhc24ndCBhYmxlIHRvIHBhcnNlIHRoZSB3aG9sZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBzbyB3ZSd2ZSBnb3QgYSBwYXJzaW5nIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIFdlIHRyeSB0byBleHRyYWN0IGEgXFxuIGRlbGltaXRlZCBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAvLyBzaG93aW5nIHRoZSBsaW5lIHdoZXJlIHRoZSBwYXJzZSBlcnJvciBvY2N1cnJlZC5cclxuICAgICAgICAgICAgICAgIC8vIFdlIHNwbGl0IGl0IHVwIGludG8gdHdvIHBhcnRzICh0aGUgcGFydCB3aGljaCBwYXJzZWQsXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIHBhcnQgd2hpY2ggZGlkbid0KSwgc28gd2UgY2FuIGNvbG9yIHRoZW0gZGlmZmVyZW50bHkuXHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5mbyA9IHBhcnNlcklucHV0LmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbmRJbmZvLmlzRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVuZEluZm8uZnVydGhlc3RQb3NzaWJsZUVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdVbnJlY29nbmlzZWQgaW5wdXQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5mby5mdXJ0aGVzdENoYXIgPT09ICd9Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnLiBQb3NzaWJseSBtaXNzaW5nIG9wZW5pbmcgXFwne1xcJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kSW5mby5mdXJ0aGVzdENoYXIgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnLiBQb3NzaWJseSBtaXNzaW5nIG9wZW5pbmcgXFwnKFxcJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kSW5mby5mdXJ0aGVzdFJlYWNoZWRFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJy4gUG9zc2libHkgbWlzc2luZyBzb21ldGhpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQYXJzZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbmRJbmZvLmZ1cnRoZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZUluZm8uZmlsZW5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9LCBpbXBvcnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2ggPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBlcnJvciB8fCBlIHx8IGltcG9ydHMuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIExlc3NFcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVJbmZvLmZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnByb2Nlc3NJbXBvcnRzICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyB2aXNpdG9ycy5JbXBvcnRWaXNpdG9yKGltcG9ydHMsIGZpbmlzaClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJ1bihyb290KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gSGVyZSBpbiwgdGhlIHBhcnNpbmcgcnVsZXMvZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHN5bnRheCB0cmVlIGdlbmVyYXRlZCBpcyBhcyBmb2xsb3dzOlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgIFJ1bGVzZXQgLT4gIERlY2xhcmF0aW9uIC0+IFZhbHVlIC0+IEV4cHJlc3Npb24gLT4gRW50aXR5XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEhlcmUncyBzb21lIExlc3MgY29kZTpcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gICAgLmNsYXNzIHtcclxuICAgICAgICAgICAgLy8gICAgICBjb2xvcjogI2ZmZjtcclxuICAgICAgICAgICAgLy8gICAgICBib3JkZXI6IDFweCBzb2xpZCAjMDAwO1xyXG4gICAgICAgICAgICAvLyAgICAgIHdpZHRoOiBAdyArIDRweDtcclxuICAgICAgICAgICAgLy8gICAgICA+IC5jaGlsZCB7Li4ufVxyXG4gICAgICAgICAgICAvLyAgICB9XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEFuZCBoZXJlJ3Mgd2hhdCB0aGUgcGFyc2UgdHJlZSBtaWdodCBsb29rIGxpa2U6XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICAgICBSdWxlc2V0IChTZWxlY3RvciAnLmNsYXNzJywgW1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIERlY2xhcmF0aW9uIChcImNvbG9yXCIsICBWYWx1ZSAoW0V4cHJlc3Npb24gW0NvbG9yICNmZmZdXSkpXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgRGVjbGFyYXRpb24gKFwiYm9yZGVyXCIsIFZhbHVlIChbRXhwcmVzc2lvbiBbRGltZW5zaW9uIDFweF1bS2V5d29yZCBcInNvbGlkXCJdW0NvbG9yICMwMDBdXSkpXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgRGVjbGFyYXRpb24gKFwid2lkdGhcIiwgIFZhbHVlIChbRXhwcmVzc2lvbiBbT3BlcmF0aW9uIFwiICsgXCIgW1ZhcmlhYmxlIFwiQHdcIl1bRGltZW5zaW9uIDRweF1dXSkpXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgUnVsZXNldCAoU2VsZWN0b3IgW0VsZW1lbnQgJz4nLCAnLmNoaWxkJ10sIFsuLi5dKVxyXG4gICAgICAgICAgICAvLyAgICAgXSlcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gIEluIGdlbmVyYWwsIG1vc3QgcnVsZXMgd2lsbCB0cnkgdG8gcGFyc2UgYSB0b2tlbiB3aXRoIHRoZSBgJHJlKClgIGZ1bmN0aW9uLCBhbmQgaWYgdGhlIHJldHVyblxyXG4gICAgICAgICAgICAvLyAgdmFsdWUgaXMgdHJ1bHksIHdpbGwgcmV0dXJuIGEgbmV3IG5vZGUsIG9mIHRoZSByZWxldmFudCB0eXBlLiBTb21ldGltZXMsIHdlIG5lZWQgdG8gY2hlY2tcclxuICAgICAgICAgICAgLy8gIGZpcnN0LCBiZWZvcmUgcGFyc2luZywgdGhhdCdzIHdoZW4gd2UgdXNlIGBwZWVrKClgLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBwYXJzZXJzOiBwYXJzZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBgcHJpbWFyeWAgcnVsZSBpcyB0aGUgKmVudHJ5KiBhbmQgKmV4aXQqIHBvaW50IG9mIHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcnVsZXMgaGVyZSBjYW4gYXBwZWFyIGF0IGFueSBsZXZlbCBvZiB0aGUgcGFyc2UgdHJlZS5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVjdXJzaXZlIG5hdHVyZSBvZiB0aGUgZ3JhbW1hciBpcyBhbiBpbnRlcnBsYXkgYmV0d2VlbiB0aGUgYGJsb2NrYFxyXG4gICAgICAgICAgICAgICAgLy8gcnVsZSwgd2hpY2ggcmVwcmVzZW50cyBgeyAuLi4gfWAsIHRoZSBgcnVsZXNldGAgcnVsZSwgYW5kIHRoaXMgYHByaW1hcnlgIHJ1bGUsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyByZXByZXNlbnRlZCBieSB0aGlzIHNpbXBsaWZpZWQgZ3JhbW1hcjpcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgcHJpbWFyeSAg4oaSICAocnVsZXNldCB8IGRlY2xhcmF0aW9uKStcclxuICAgICAgICAgICAgICAgIC8vICAgICBydWxlc2V0ICDihpIgIHNlbGVjdG9yKyBibG9ja1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGJsb2NrICAgIOKGkiAgJ3snIHByaW1hcnkgJ30nXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBhdCBvbmUgcG9pbnQgaXMgdGhlIHByaW1hcnkgcnVsZSBub3QgY2FsbGVkIGZyb20gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBibG9jayBydWxlOiBhdCB0aGUgcm9vdCBsZXZlbC5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1peGluID0gdGhpcy5taXhpbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5jb21tZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgcHJvY2VzcyBjb21tZW50cyBiZWZvcmUgZGVjaWRpbmcgaWYgZmluaXNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygnfScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5leHRlbmRSdWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290ID0gcm9vdC5jb25jYXQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbWl4aW4uZGVmaW5pdGlvbigpIHx8IHRoaXMuZGVjbGFyYXRpb24oKSB8fCBtaXhpbi5jYWxsKGZhbHNlLCBmYWxzZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZXNldCgpIHx8IHRoaXMudmFyaWFibGVDYWxsKCkgfHwgdGhpcy5lbnRpdGllcy5jYWxsKCkgfHwgdGhpcy5hdHJ1bGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZFNlbWlDb2xvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnNlcklucHV0LiRjaGFyKCc7JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbWlDb2xvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU2VtaUNvbG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gY29tbWVudHMgYXJlIGNvbGxlY3RlZCBieSB0aGUgbWFpbiBwYXJzaW5nIG1lY2hhbmlzbSBhbmQgdGhlbiBhc3NpZ25lZCB0byBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgdGhlIGN1cnJlbnQgc3RydWN0dXJlIGFsbG93cyBpdFxyXG4gICAgICAgICAgICAgICAgY29tbWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQ29tbWVudCkoY29tbWVudC50ZXh0LCBjb21tZW50LmlzTGluZUNvbW1lbnQsIGNvbW1lbnQuaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0b2tlbnMgd2hpY2ggY2FuIGJlIGZvdW5kIGluc2lkZSBhbiBFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgZW50aXRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBtaXhpbkxvb2t1cDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2Vycy5taXhpbi5jYWxsKHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIHN0cmluZywgd2hpY2ggc3VwcG9ydHMgZXNjYXBpbmcgXCIgYW5kICdcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBcIm1pbGt5IHdheVwiICdoZVxcJ3MgdGhlIG9uZSEnXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBxdW90ZWQ6IGZ1bmN0aW9uIChmb3JjZUVzY2FwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRXNjYXBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignficpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VzY2FwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmNlRXNjYXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHBhcnNlcklucHV0LiRxdW90ZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5RdW90ZWQpKHN0ci5jaGFyQXQoMCksIHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpLCBpc0VzY2FwZWQsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY2F0Y2gtYWxsIHdvcmQsIHN1Y2ggYXM6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYmxhY2sgYm9yZGVyLWNvbGxhcHNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gcGFyc2VySW5wdXQuJGNoYXIoJyUnKSB8fCBwYXJzZXJJbnB1dC4kcmUoL15cXFs/KD86W1xcdy1dfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrXFxdPy8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyZWUuQ29sb3IuZnJvbUtleXdvcmQoaykgfHwgbmV3ICh0cmVlLktleXdvcmQpKGspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJnYigyNTUsIDAsIDI1NSlcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHBhcnNlZCB3aXRoIHRoZSBgZW50aXRpZXMuYXJndW1lbnRzYCBwYXJzZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBjYWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nhc2UtaW5zZW5zaXRpdmUtcmVnZXgtdnMtc3RydG9sb3dlci10aGVuLXJlZ2V4LzE4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9edXJsXFwoL2kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eKFtcXHctXSt8JXx+fHByb2dpZDpbXFx3XFwuXSspXFwoLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMgPSB0aGlzLmN1c3RvbUZ1bmNDYWxsKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGZ1bmMucGFyc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzICYmIGZ1bmMuc3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLmFyZ3VtZW50cyhhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdDb3VsZCBub3QgcGFyc2UgY2FsbCBhcmd1bWVudHMgb3IgbWlzc2luZyBcXCcpXFwnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQ2FsbCkobmFtZSwgYXJncywgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2luZyBydWxlcyBmb3IgZnVuY3Rpb25zIHdpdGggbm9uLXN0YW5kYXJkIGFyZ3MsIGUuZy46XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYm9vbGVhbihub3QoMiA+IDEpKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIFRoaXMgaXMgYSBxdWljayBwcm90b3R5cGUsIHRvIGJlIG1vZGlmaWVkL2ltcHJvdmVkIHdoZW5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbW9yZSBjdXN0b20tcGFyc2VkIGZ1bmNzIGNvbWUgKGUuZy4gYHNlbGVjdG9yKC4uLilgKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tRnVuY0NhbGw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElkZWFsbHkgdGhlIHRhYmxlIGlzIHRvIGJlIG1vdmVkIG91dCBvZiBoZXJlIGZvciBmYXN0ZXIgcGVyZi4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dCBpdCdzIHF1aXRlIHRyaWNreSBzaW5jZSBpdCByZWxpZXMgb24gYWxsIHRoZXNlIGBwYXJzZXJzYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYGV4cGVjdGAgYXZhaWxhYmxlIG9ubHkgaGVyZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IGYocGFyc2Vycy5pZUFscGhhLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IGYoY29uZGl0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZic6IGYoY29uZGl0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9W25hbWUudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYocGFyc2UsIHN0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2U6IHBhcnNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3A6IHN0b3AgLy8gd2hlbiB0cnVlIC0gc3RvcCBhZnRlciBwYXJzZSgpIGFuZCByZXR1cm4gaXRzIHJlc3VsdCwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIGZvciBwbGFpbiBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbmRpdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZXhwZWN0KHBhcnNlcnMuY29uZGl0aW9uLCAnZXhwZWN0ZWQgY29uZGl0aW9uJyldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGZ1bmN0aW9uIChwcmV2QXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc0NvbW1hID0gcHJldkFyZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzU2VtaUNvbG9uID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1NlbWlDb2xvblNlcGFyYXRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2QXJncyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzLmRldGFjaGVkUnVsZXNldCgpIHx8IHRoaXMuYXNzaWdubWVudCgpIHx8IHBhcnNlcnMuZXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZSAmJiB2YWx1ZS52YWx1ZS5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzQ29tbWEucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc7JykgfHwgaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoYXJnc0NvbW1hLmxlbmd0aCA8IDEpID8gYXJnc0NvbW1hWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHRyZWUuVmFsdWUoYXJnc0NvbW1hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzU2VtaUNvbG9uLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NDb21tYSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTZW1pQ29sb25TZXBhcmF0ZWQgPyBhcmdzU2VtaUNvbG9uIDogYXJnc0NvbW1hO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvcigpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1b3RlZCgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaWNvZGVEZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ25tZW50cyBhcmUgYXJndW1lbnQgZW50aXRpZXMgZm9yIGNhbGxzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgYXJlIHByZXNlbnQgaW4gaWUgZmlsdGVyIHByb3BlcnRpZXMgYXMgc2hvd24gYmVsb3cuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoICpvcGFjaXR5PTUwKiApXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZXJJbnB1dC4kcmUoL15cXHcrKD89XFxzPz0pL2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vycy5lbnRpdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQXNzaWdubWVudCkoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdXJsKCkgdG9rZW5zXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBzcGVjaWZpYyBydWxlIGZvciB1cmxzLCBiZWNhdXNlIHRoZXkgZG9uJ3QgcmVhbGx5IGJlaGF2ZSBsaWtlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZnVuY3Rpb24gY2FsbHMuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFyZ3VtZW50IGRvZXNuJ3QgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGVuY2xvc2VkIHdpdGhpbiBhIHN0cmluZywgc28gaXQgY2FuJ3QgYmUgcGFyc2VkIGFzIGFuIEV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoJ3VybCgnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5xdW90ZWQoKSB8fCB0aGlzLnZhcmlhYmxlKCkgfHwgdGhpcy5wcm9wZXJ0eSgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kcmUoL14oPzooPzpcXFxcW1xcKFxcKSdcIl0pfFteXFwoXFwpJ1wiXSkrLykgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlVSTCkoKHZhbHVlLnZhbHVlICE9IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiB0cmVlLlByb3BlcnR5KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IG5ldyAodHJlZS5Bbm9ueW1vdXMpKHZhbHVlLCBpbmRleCksIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgVmFyaWFibGUgZW50aXR5LCBzdWNoIGFzIGBAZmlua2AsIGluXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgd2lkdGg6IEBmaW5rICsgMnB4XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBkaWZmZXJlbnQgcGFyc2VyIGZvciB2YXJpYWJsZSBkZWZpbml0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgYHBhcnNlcnMudmFyaWFibGVgLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ0AnICYmIChuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eQEA/W1xcdy1dKy8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnKCcgfHwgY2ggPT09ICdbJyAmJiAhcGFyc2VySW5wdXQucHJldkNoYXIoKS5tYXRjaCgvXlxccy8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtYXkgYmUgYSBWYXJpYWJsZUNhbGwgbG9va3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlcnMudmFyaWFibGVDYWxsKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlZhcmlhYmxlKShuYW1lLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgdmFyaWFibGUgZW50aXR5IHVzaW5nIHRoZSBwcm90ZWN0aXZlIHt9IGUuZy4gQHt2YXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVDdXJseTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VybHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnQCcgJiYgKGN1cmx5ID0gcGFyc2VySW5wdXQuJHJlKC9eQFxceyhbXFx3LV0rKVxcfS8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5WYXJpYWJsZSkoXCJAXCIgKyBjdXJseVsxXSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIFByb3BlcnR5IGFjY2Vzc29yLCBzdWNoIGFzIGAkY29sb3JgLCBpblxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJhY2tncm91bmQtY29sb3I6ICRjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnJCcgJiYgKG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL15cXCRbXFx3LV0rLykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlByb3BlcnR5KShuYW1lLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBBIHByb3BlcnR5IGVudGl0eSB1c2VpbmcgdGhlIHByb3RlY3RpdmUge30gZS5nLiAke3Byb3B9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDdXJseTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VybHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnJCcgJiYgKGN1cmx5ID0gcGFyc2VySW5wdXQuJHJlKC9eXFwkXFx7KFtcXHctXSspXFx9LykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlByb3BlcnR5KShcIiRcIiArIGN1cmx5WzFdLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgSGV4YWRlY2ltYWwgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAjNEYzQzJGXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBgcmdiYCBhbmQgYGhzbGAgY29sb3JzIGFyZSBwYXJzZWQgdGhyb3VnaCB0aGUgYGVudGl0aWVzLmNhbGxgIHBhcnNlci5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZ2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICcjJyAmJiAocmdiID0gcGFyc2VySW5wdXQuJHJlKC9eIyhbQS1GYS1mMC05XXs4fXxbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszLDR9KShbXFx3LiNcXFtdKT8vKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmdiWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5Db2xvcikocmdiWzFdLCB1bmRlZmluZWQsIHJnYlswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JLZXl3b3JkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9Db21tZW50QWJzb3JiID0gcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gcGFyc2VySW5wdXQuJHJlKC9eW19BLVphLXotXVtfQS1aYS16MC05LV0rLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gYXV0b0NvbW1lbnRBYnNvcmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0cmVlLkNvbG9yLmZyb21LZXl3b3JkKGspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRzdHIoayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBEaW1lbnNpb24sIHRoYXQgaXMsIGEgbnVtYmVyIGFuZCBhIHVuaXRcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAwLjVlbSA5NSVcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVla05vdE51bWVyaWMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlcklucHV0LiRyZSgvXihbKy1dP1xcZCpcXC4/XFxkKykoJXxbYS16X10rKT8vaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5EaW1lbnNpb24pKHZhbHVlWzFdLCB2YWx1ZVsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSB1bmljb2RlIGRlc2NyaXB0b3IsIGFzIGlzIHVzZWQgaW4gdW5pY29kZS1yYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVSswPz8gIG9yIFUrMDBBMS0wMEE5XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICB1bmljb2RlRGVzY3JpcHRvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVkID0gcGFyc2VySW5wdXQuJHJlKC9eVVxcK1swLTlhLWZBLUY/XSsoXFwtWzAtOWEtZkEtRj9dKyk/Lyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1ZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5Vbmljb2RlRGVzY3JpcHRvcikodWRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEphdmFTY3JpcHQgY29kZSB0byBiZSBldmFsdWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBgd2luZG93LmxvY2F0aW9uLmhyZWZgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBqYXZhc2NyaXB0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlID0gcGFyc2VySW5wdXQuJGNoYXIoJ34nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpzUXVvdGUgPSBwYXJzZXJJbnB1dC4kY2hhcignYCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWpzUXVvdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqcyA9IHBhcnNlcklucHV0LiRyZSgvXlteYF0qYC8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5KYXZhU2NyaXB0KShqcy5zdWJzdHIoMCwganMubGVuZ3RoIC0gMSksIEJvb2xlYW4oZXNjYXBlKSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdpbnZhbGlkIGphdmFzY3JpcHQgZGVmaW5pdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhcmlhYmxlIHBhcnQgb2YgYSB2YXJpYWJsZSBkZWZpbml0aW9uLiBVc2VkIGluIHRoZSBgcnVsZWAgcGFyc2VyXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIEBmaW5rOlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJyAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihAW1xcdy1dKylcXHMqOi8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIENhbGwgYSB2YXJpYWJsZSB2YWx1ZSB0byByZXRyaWV2ZSBhIGRldGFjaGVkIHJ1bGVzZXRcclxuICAgICAgICAgICAgICAgIC8vIG9yIGEgdmFsdWUgZnJvbSBhIGRldGFjaGVkIHJ1bGVzZXQncyBydWxlcy5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgQGZpbmsoKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICBAZmluaztcclxuICAgICAgICAgICAgICAgIC8vICAgICBjb2xvcjogQGZpbmtbQGNvbG9yXTtcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZUNhbGw6IGZ1bmN0aW9uIChwYXJzZWROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvb2t1cHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpblZhbHVlID0gISFwYXJzZWROYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcGFyc2VkTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgfHwgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihAW1xcdy1dKykoXFwoXFxzKlxcKSk/LykpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBzID0gdGhpcy5taXhpbi5ydWxlTG9va3VwcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2t1cHMgJiYgKChpblZhbHVlICYmIHBhcnNlcklucHV0LiRzdHIoJygpJykgIT09ICcoKScpIHx8IChuYW1lWzJdICE9PSAnKCknKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ01pc3NpbmcgXFwnWy4uLl1cXCcgbG9va3VwIGluIHZhcmlhYmxlIGNhbGwnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsID0gbmV3IHRyZWUuVmFyaWFibGVDYWxsKG5hbWUsIGksIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpblZhbHVlICYmIHBhcnNlcnMuZW5kKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5OYW1lc3BhY2VWYWx1ZShjYWxsLCBsb29rdXBzLCBpLCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgc3ludGF4IC0gdXNlZCB0byBleHRlbmQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAoaXNSdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJHN0cihpc1J1bGUgPyAnJjpleHRlbmQoJyA6ICc6ZXh0ZW5kKCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghKG9wdGlvbiA9IHBhcnNlcklucHV0LiRyZSgvXihhbGwpKD89XFxzKihcXCl8LCkpLykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb24gJiYgb3B0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignTWlzc2luZyB0YXJnZXQgc2VsZWN0b3IgZm9yIDpleHRlbmQoKS4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQgPSBuZXcgKHRyZWUuRXh0ZW5kKShuZXcgKHRyZWUuU2VsZWN0b3IpKGVsZW1lbnRzKSwgb3B0aW9uLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGlzdC5wdXNoKGV4dGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRMaXN0ID0gW2V4dGVuZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwYXJzZXJJbnB1dC4kY2hhcignLCcpKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoL15cXCkvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCgvXjsvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZExpc3Q7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZFJ1bGUgLSB1c2VkIGluIGEgcnVsZSB0byBleHRlbmQgYWxsIHRoZSBwYXJlbnQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kUnVsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gTWl4aW5zXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgbWl4aW46IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgTWl4aW4gY2FsbCwgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudCBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgI21peGlucyA+IC5zcXVhcmUoI2ZmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICNtaXhpbnMuc3F1YXJlKCNmZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAucm91bmRlZCg0cHgsIGJsYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgLmJ1dHRvbjtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBsb29rdXAgLyByZXR1cm4gYSB2YWx1ZSB1c2luZyB0aGUgbG9va3VwIHN5bnRheDpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBjb2xvcjogI21peGluLnNxdWFyZSgjZmZmKVtAY29sb3JdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGB3aGlsZWAgbG9vcCBpcyB0aGVyZSBiZWNhdXNlIG1peGlucyBjYW4gYmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2VkLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBjaGlsZCBhbmQgZGVzY2VuZGFudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGZvciBub3cuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBjYWxsOiBmdW5jdGlvbiAoaW5WYWx1ZSwgZ2V0TG9va3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9va3VwcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1BhcmVucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09ICcuJyAmJiBzICE9PSAnIycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7IC8vIHN0b3AgdXMgYWJzb3JiaW5nIHBhcnQgb2YgYW4gaW52YWxpZCBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLmFyZ3ModHJ1ZSkuYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRMb29rdXAgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9va3VwcyA9IHRoaXMucnVsZUxvb2t1cHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRMb29rdXAgPT09IHRydWUgJiYgIWxvb2t1cHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluVmFsdWUgJiYgIWxvb2t1cHMgJiYgIWhhc1BhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXNuJ3QgYSB2YWxpZCBpbi12YWx1ZSBtaXhpbiBjYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5WYWx1ZSAmJiBwYXJzZXJzLmltcG9ydGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblZhbHVlIHx8IHBhcnNlcnMuZW5kKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWl4aW4gPSBuZXcgKHRyZWUubWl4aW4uQ2FsbCkoZWxlbWVudHMsIGFyZ3MsIGluZGV4LCBmaWxlSW5mbywgIWxvb2t1cHMgJiYgaW1wb3J0YW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9va3Vwcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuTmFtZXNwYWNlVmFsdWUobWl4aW4sIGxvb2t1cHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1peGluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBNYXRjaGluZyBlbGVtZW50cyBmb3IgbWl4aW5zXHJcbiAgICAgICAgICAgICAgICAgICAgICogKFN0YXJ0IHdpdGggLiBvciAjIGFuZCBjYW4gaGF2ZSA+IClcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZSA9IC9eWyMuXSg/OltcXHctXXxcXFxcKD86W0EtRmEtZjAtOV17MSw2fSA/fFteQS1GYS1mMC05XSkpKy87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtSW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHBhcnNlcklucHV0LiRyZShyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBuZXcgKHRyZWUuRWxlbWVudCkoYywgZSwgZmFsc2UsIGVsZW1JbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHBhcnNlcklucHV0LiRjaGFyKCc+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZnVuY3Rpb24gKGlzQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSBwYXJzZXJzLmVudGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZXIgPSB7IGFyZ3M6IG51bGwsIHZhcmlhZGljOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NTZW1pQ29sb24gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NDb21tYSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNTZW1pQ29sb25TZXBhcmF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uQ29udGFpbnNOYW1lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTG9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU2VwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHBhcnNlcnMuZGV0YWNoZWRSdWxlc2V0KCkgfHwgcGFyc2Vycy5leHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cignLi4uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIudmFyaWFkaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzsnKSAmJiAhaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNTZW1pQ29sb25TZXBhcmF0ZWQgPyBhcmdzU2VtaUNvbG9uIDogYXJnc0NvbW1hKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goeyB2YXJpYWRpYzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGVudGl0aWVzLnZhcmlhYmxlKCkgfHwgZW50aXRpZXMucHJvcGVydHkoKSB8fCBlbnRpdGllcy5saXRlcmFsKCkgfHwgZW50aXRpZXMua2V5d29yZCgpIHx8IHRoaXMuY2FsbCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJnIHx8ICFoYXNTZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29wID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudGhyb3dBd2F5Q29tbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGhyb3dBd2F5Q29tbWVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnZhbHVlICYmIGFyZy52YWx1ZS5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmcudmFsdWVbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAmJiAodmFsIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSB8fCB2YWwgaW5zdGFuY2VvZiB0cmVlLlByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignOicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IG1peCA7IGFuZCAsIGFzIGRlbGltaXRlciB0eXBlcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vycy5kZXRhY2hlZFJ1bGVzZXQoKSB8fCBwYXJzZXJzLmV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdjb3VsZCBub3QgdW5kZXJzdGFuZCB2YWx1ZSBmb3IgbmFtZWQgYXJndW1lbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci5hcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29wID0gKG5hbWUgPSB2YWwubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlcklucHV0LiRzdHIoJy4uLicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lci52YXJpYWRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzsnKSAmJiAhaXNTZW1pQ29sb25TZXBhcmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNTZW1pQ29sb25TZXBhcmF0ZWQgPyBhcmdzU2VtaUNvbG9uIDogYXJnc0NvbW1hKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wdXNoKHsgbmFtZTogYXJnLm5hbWUsIHZhcmlhZGljOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0NhbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVMb29wID0gdmFsLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NDb21tYS5wdXNoKHsgbmFtZTogbmFtZUxvb3AsIHZhbHVlOiB2YWx1ZSwgZXhwYW5kOiBleHBhbmQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1NlcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNTZXAgPSBwYXJzZXJJbnB1dC4kY2hhcignOycpID09PSAnOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2VwIHx8IGlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25Db250YWluc05hbWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgbWl4IDsgYW5kICwgYXMgZGVsaW1pdGVyIHR5cGVzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VtaUNvbG9uU2VwYXJhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyAodHJlZS5WYWx1ZSkoZXhwcmVzc2lvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzU2VtaUNvbG9uLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGV4cGFuZDogZXhwYW5kIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIuYXJncyA9IGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIE1peGluIGRlZmluaXRpb24sIHdpdGggYSBsaXN0IG9mIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAucm91bmRlZCAoQHJhZGl1czogMnB4LCBAY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVudGlsIHdlIGhhdmUgYSBmaW5lciBncmFpbmVkIHN0YXRlLW1hY2hpbmUsIHdlIGhhdmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBhIGxvb2stYWhlYWQsIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIGEgbWl4aW4gY2FsbC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgdGhlIGBydWxlYCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHN0YXJ0IGJ5IG1hdGNoaW5nIGAucm91bmRlZCAoYCwgYW5kIHRoZW4gcHJvY2VlZCBvbiB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhcmd1bWVudCBsaXN0LCB3aGljaCBoYXMgb3B0aW9uYWwgZGVmYXVsdCB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhlIHBhcmFtZXRlcnMgaW4gYHBhcmFtc2AsIHdpdGggYSBgdmFsdWVgIGtleSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHZhbHVlLCBzdWNoIGFzIGluIHRoZSBjYXNlIG9mIGBAcmFkaXVzYC5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2UndmUgZ290IG91ciBwYXJhbXMgbGlzdCwgYW5kIGEgY2xvc2luZyBgKWAsIHdlIHBhcnNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGB7Li4ufWAgYmxvY2suXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFkaWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICE9PSAnLicgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJyMnKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucGVlaygvXltee10qXFx9LykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcGFyc2VySW5wdXQuJHJlKC9eKFsjLl0oPzpbXFx3LV18XFxcXCg/OltBLUZhLWYwLTldezEsNn0gP3xbXkEtRmEtZjAtOV0pKSspXFxzKlxcKC8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdJbmZvID0gdGhpcy5hcmdzKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ0luZm8uYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhZGljID0gYXJnSW5mby52YXJpYWRpYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5taXhpbmNhbGwoXCJAe2F9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va3MgYSBiaXQgbGlrZSBhIG1peGluIGRlZmluaXRpb24uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLm1peGluY2FsbChAYToge3J1bGU6IHNldDt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gYmUgbmljZSBhbmQgcmVzdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgnTWlzc2luZyBjbG9zaW5nIFxcJylcXCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKCd3aGVuJykpIHsgLy8gR3VhcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kID0gZXhwZWN0KHBhcnNlcnMuY29uZGl0aW9ucywgJ2V4cGVjdGVkIGNvbmRpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNldCA9IHBhcnNlcnMuYmxvY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5taXhpbi5EZWZpbml0aW9uKShuYW1lLCBwYXJhbXMsIHJ1bGVzZXQsIGNvbmQsIHZhcmlhZGljKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZUxvb2t1cHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb29rdXBzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICE9PSAnWycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZSA9IHRoaXMubG9va3VwVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSAmJiBydWxlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cHMucHVzaChydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29rdXBzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29rdXBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBsb29rdXBWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJ1snKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eKD86W0AkXXswLDJ9KVtfYS16QS1aMC05LV0qLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJ10nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIHx8IG5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEVudGl0aWVzIGFyZSB0aGUgc21hbGxlc3QgcmVjb2duaXplZCB0b2tlbixcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBjYW4gYmUgZm91bmQgaW5zaWRlIGEgcnVsZSdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCgpIHx8IGVudGl0aWVzLmxpdGVyYWwoKSB8fCBlbnRpdGllcy52YXJpYWJsZSgpIHx8IGVudGl0aWVzLnVybCgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnByb3BlcnR5KCkgfHwgZW50aXRpZXMuY2FsbCgpIHx8IGVudGl0aWVzLmtleXdvcmQoKSB8fCB0aGlzLm1peGluLmNhbGwodHJ1ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMuamF2YXNjcmlwdCgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBIERlY2xhcmF0aW9uIHRlcm1pbmF0b3IuIE5vdGUgdGhhdCB3ZSB1c2UgYHBlZWsoKWAgdG8gY2hlY2sgZm9yICd9JyxcclxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGBibG9ja2AgcnVsZSB3aWxsIGJlIGV4cGVjdGluZyBpdCwgYnV0IHdlIHN0aWxsIG5lZWQgdG8gbWFrZSBzdXJlXHJcbiAgICAgICAgICAgICAgICAvLyBpdCdzIHRoZXJlLCBpZiAnOycgd2FzIG9taXR0ZWQuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcklucHV0LiRjaGFyKCc7JykgfHwgcGFyc2VySW5wdXQucGVlaygnfScpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBJRSdzIGFscGhhIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGFscGhhKG9wYWNpdHk9ODgpXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgaWVBbHBoYTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jYXNlLWluc2Vuc2l0aXZlLXJlZ2V4LXZzLXN0cnRvbG93ZXItdGhlbi1yZWdleC8xOFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJHJlKC9eb3BhY2l0eT0vaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlcklucHV0LiRyZSgvXlxcZCsvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXhwZWN0KHBhcnNlcnMuZW50aXRpZXMudmFyaWFibGUsICdDb3VsZCBub3QgcGFyc2UgYWxwaGEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIkB7XCIgKyB2YWx1ZS5uYW1lLnNsaWNlKDEpICsgXCJ9XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuUXVvdGVkKCcnLCBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQSBTZWxlY3RvciBFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGRpdlxyXG4gICAgICAgICAgICAgICAgLy8gICAgICsgaDFcclxuICAgICAgICAgICAgICAgIC8vICAgICAjc29ja3NcclxuICAgICAgICAgICAgICAgIC8vICAgICBpbnB1dFt0eXBlPVwidGV4dFwiXVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnRzIGFyZSB0aGUgYnVpbGRpbmcgYmxvY2tzIGZvciBTZWxlY3RvcnMsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBtYWRlIG91dCBvZiBhIGBDb21iaW5hdG9yYCAoc2VlIGNvbWJpbmF0b3IgcnVsZSksXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgYW4gZWxlbWVudCBuYW1lLCBzdWNoIGFzIGEgdGFnIGEgY2xhc3MsIG9yIGAqYC5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb21iaW5hdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHBhcnNlcklucHV0LiRyZSgvXig/OlxcZCtcXC5cXGQrfFxcZCspJS8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRyZSgvXig/OlsuI10/fDoqKSg/OltcXHctXXxbXlxceDAwLVxceDlmXXxcXFxcKD86W0EtRmEtZjAtOV17MSw2fSA/fFteQS1GYS1mMC05XSkpKy8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRjaGFyKCcqJykgfHwgcGFyc2VySW5wdXQuJGNoYXIoJyYnKSB8fCB0aGlzLmF0dHJpYnV0ZSgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LiRyZSgvXlxcKFteJigpQF0rXFwpLykgfHwgcGFyc2VySW5wdXQuJHJlKC9eW1xcLiM6XSg/PUApLykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRpdGllcy52YXJpYWJsZUN1cmx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodiA9IHRoaXMuc2VsZWN0b3IoZmFsc2UpKSAmJiBwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyAodHJlZS5QYXJlbikodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdNaXNzaW5nIGNsb3NpbmcgXFwnKVxcJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5FbGVtZW50KShjLCBlLCBlIGluc3RhbmNlb2YgdHJlZS5WYXJpYWJsZSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIENvbWJpbmF0b3JzIGNvbWJpbmUgZWxlbWVudHMgdG9nZXRoZXIsIGluIGEgU2VsZWN0b3IuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBvdXIgcGFyc2VyIGlzbid0IHdoaXRlLXNwYWNlIHNlbnNpdGl2ZSwgc3BlY2lhbCBjYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgdG8gYmUgdGFrZW4sIHdoZW4gcGFyc2luZyB0aGUgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBgIGAsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIGFuIGVtcHR5IHNwYWNlLiBXZSBoYXZlIHRvIGNoZWNrIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBpbnB1dCwgdG8gc2VlIGlmIGl0J3MgYSBgIGAgY2hhcmFjdGVyLiBNb3JlIGluZm8gb24gaG93XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBkZWFsIHdpdGggdGhpcyBpbiAqY29tYmluYXRvci5qcyouXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgY29tYmluYXRvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsYXNoZWRDb21iaW5hdG9yID0gcGFyc2VySW5wdXQuJHJlKC9eXFwvW2Etel0rXFwvL2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xhc2hlZENvbWJpbmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5Db21iaW5hdG9yKShzbGFzaGVkQ29tYmluYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJz4nIHx8IGMgPT09ICcrJyB8fCBjID09PSAnficgfHwgYyA9PT0gJ3wnIHx8IGMgPT09ICdeJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ14nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gJ15eJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkNvbWJpbmF0b3IpKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQ29tYmluYXRvcikoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQ29tYmluYXRvcikobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBIENTUyBTZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBsZXNzIGV4dGVuc2lvbnMgZS5nLiB0aGUgYWJpbGl0eSB0byBleHRlbmQgYW5kIGd1YXJkXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIC5jbGFzcyA+IGRpdiArIGgxXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgbGkgYTpob3ZlclxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9ycyBhcmUgbWFkZSBvdXQgb2Ygb25lIG9yIG1vcmUgRWxlbWVudHMsIHNlZSBhYm92ZS5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogZnVuY3Rpb24gKGlzTGVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxFeHRlbmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaXNMZXNzID0gaXNMZXNzICE9PSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGlzTGVzcyAmJiAoZXh0ZW5kTGlzdCA9IHRoaXMuZXh0ZW5kKCkpKSB8fCAoaXNMZXNzICYmICh3aGVuID0gcGFyc2VySW5wdXQuJHN0cignd2hlbicpKSkgfHwgKGUgPSB0aGlzLmVsZW1lbnQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdoZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IGV4cGVjdCh0aGlzLmNvbmRpdGlvbnMsICdleHBlY3RlZCBjb25kaXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdDU1MgZ3VhcmQgY2FuIG9ubHkgYmUgdXNlZCBhdCB0aGUgZW5kIG9mIHNlbGVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0ZW5kTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbEV4dGVuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzID0gYWxsRXh0ZW5kcy5jb25jYXQoZXh0ZW5kTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxFeHRlbmRzID0gZXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4dGVuZCBjYW4gb25seSBiZSB1c2VkIGF0IHRoZSBlbmQgb2Ygc2VsZWN0b3InKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICd7JyB8fCBjID09PSAnfScgfHwgYyA9PT0gJzsnIHx8IGMgPT09ICcsJyB8fCBjID09PSAnKScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLlNlbGVjdG9yKShlbGVtZW50cywgYWxsRXh0ZW5kcywgY29uZGl0aW9uLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRXh0ZW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXh0ZW5kIG11c3QgYmUgdXNlZCB0byBleHRlbmQgYSBzZWxlY3RvciwgaXQgY2Fubm90IGJlIHVzZWQgb24gaXRzIG93bicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0aGlzLnNlbGVjdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2gocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBbc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLmNvbmRpdGlvbiAmJiBzZWxlY3RvcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJHdWFyZHMgYXJlIG9ubHkgY3VycmVudGx5IGFsbG93ZWQgb24gYSBzaW5nbGUgc2VsZWN0b3IuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuY29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIkd1YXJkcyBhcmUgb25seSBjdXJyZW50bHkgYWxsb3dlZCBvbiBhIHNpbmdsZSBzZWxlY3Rvci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcnM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignWycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSA9IGVudGl0aWVzLnZhcmlhYmxlQ3VybHkoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZXhwZWN0KC9eKD86W19BLVphLXowLTktXFwqXSpcXHwpPyg/OltfQS1aYS16MC05LV18XFxcXC4pKy8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRyZSgvXlt8fiokXl0/PS8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBlbnRpdGllcy5xdW90ZWQoKSB8fCBwYXJzZXJJbnB1dC4kcmUoL15bMC05XSslLykgfHwgcGFyc2VySW5wdXQuJHJlKC9eW1xcdy1dKy8pIHx8IGVudGl0aWVzLnZhcmlhYmxlQ3VybHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignXScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQXR0cmlidXRlKShrZXksIG9wLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgYGJsb2NrYCBydWxlIGlzIHVzZWQgYnkgYHJ1bGVzZXRgIGFuZCBgbWl4aW4uZGVmaW5pdGlvbmAuXHJcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgd3JhcHBlciBhcm91bmQgdGhlIGBwcmltYXJ5YCBydWxlLCB3aXRoIGFkZGVkIGB7fWAuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgYmxvY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJ3snKSAmJiAoY29udGVudCA9IHRoaXMucHJpbWFyeSgpKSAmJiBwYXJzZXJJbnB1dC4kY2hhcignfScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBibG9ja1J1bGVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbmV3IHRyZWUuUnVsZXNldChudWxsLCBibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZXRhY2hlZFJ1bGVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnSW5mbztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWRpYztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRyZSgvXlsuI11cXCgvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogRFIgYXJncyBjdXJyZW50bHkgb25seSBpbXBsZW1lbnRlZCBmb3IgZWFjaCgpIGZ1bmN0aW9uLCBhbmQgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHlldCBzZXR0YWJsZSBhcyBgQGRyOiAjKEBhcmcpIHt9YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHNob3VsZCBiZSBkb25lIHdoZW4gRFJzIGFyZSBtZXJnZWQgd2l0aCBtaXhpbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2xlc3MvbGVzcy1tZXRhL2lzc3Vlcy8xNlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnSW5mbyA9IHRoaXMubWl4aW4uYXJncyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ0luZm8uYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFkaWMgPSBhcmdJbmZvLnZhcmlhZGljO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tSdWxlc2V0ID0gdGhpcy5ibG9ja1J1bGVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tSdWxlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUubWl4aW4uRGVmaW5pdGlvbihudWxsLCBwYXJhbXMsIGJsb2NrUnVsZXNldCwgbnVsbCwgdmFyaWFkaWMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5EZXRhY2hlZFJ1bGVzZXQoYmxvY2tSdWxlc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBkaXYsIC5jbGFzcywgYm9keSA+IHAgey4uLn1cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBydWxlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9ycztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlYnVnSW5mbztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhwYXJzZXJJbnB1dC5pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzICYmIChydWxlcyA9IHRoaXMuYmxvY2soKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlc2V0ID0gbmV3ICh0cmVlLlJ1bGVzZXQpKHNlbGVjdG9ycywgcnVsZXMsIGNvbnRleHQuc3RyaWN0SW1wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNldC5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0RSO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0YW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNWYXJpYWJsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJy4nIHx8IGMgPT09ICcjJyB8fCBjID09PSAnJicgfHwgYyA9PT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLnZhcmlhYmxlKCkgfHwgdGhpcy5ydWxlUHJvcGVydHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhcmlhYmxlID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmRldGFjaGVkUnVsZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRFIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG5hbWUgcmV0dXJuZWQgYnkgdGhpcy5ydWxlUHJvcGVydHkoKSBpcyBhbHdheXMgYW4gYXJyYXkgb2YgdGhlIGZvcm06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbc3RyaW5nLTEsIC4uLiwgc3RyaW5nLW4sIFwiXCJdIG9yIFtzdHJpbmctMSwgLi4uLCBzdHJpbmctbiwgXCIrXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSBlYWNoIGl0ZW0gaXMgYSB0cmVlLktleXdvcmQgb3IgdHJlZS5WYXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgPSAhaXNWYXJpYWJsZSAmJiBuYW1lLmxlbmd0aCA+IDEgJiYgbmFtZS5wb3AoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgZ2V0IHBlcm1pc3NpdmUgcGFyc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVbMF0udmFsdWUgJiYgbmFtZVswXS52YWx1ZS5zbGljZSgwLCAyKSA9PT0gJy0tJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wZXJtaXNzaXZlVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzdG9yZSB2YWx1ZXMgYXMgYW5vbnltb3VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHRoZSB2YWx1ZSBsYXRlciB3ZSdsbCByZS1wYXJzZSBpdCBpbiBydWxlc2V0LnBhcnNlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5hbm9ueW1vdXNWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5vbnltb3VzIHZhbHVlcyBhYnNvcmIgdGhlIGVuZCAnOycgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHRoZW0gdG8gd29ya1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuRGVjbGFyYXRpb24pKG5hbWUsIHZhbHVlLCBmYWxzZSwgbWVyZ2UsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSB0aGlzLmltcG9ydGFudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzIGEgbGFzdCByZXNvcnQsIHRyeSBwZXJtaXNzaXZlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGVybWlzc2l2ZVZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmICh0aGlzLmVuZCgpIHx8IGhhc0RSKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkRlY2xhcmF0aW9uKShuYW1lLCB2YWx1ZSwgaW1wb3J0YW50LCBtZXJnZSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXNWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcGFyc2VySW5wdXQuJHJlKC9eKFteLiNAXFwkK1xcLydcIipgKDt7fS1dKik7Lyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQW5vbnltb3VzKShtYXRjaFsxXSwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVzZWQgZm9yIGN1c3RvbSBwcm9wZXJ0aWVzLCBhdC1ydWxlcywgYW5kIHZhcmlhYmxlcyAoYXMgZmFsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgKiBQYXJzZXMgYWxtb3N0IGFueXRoaW5nIGluc2lkZSBvZiB7fSBbXSAoKSBcIlwiIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgICogdW50aWwgaXQgcmVhY2hlcyBvdXRlci1tb3N0IHRva2Vucy5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBGaXJzdCwgaXQgd2lsbCB0cnkgdG8gcGFyc2UgY29tbWVudHMgYW5kIGVudGl0aWVzIHRvIHJlYWNoXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgZW5kLiBUaGlzIGlzIG1vc3RseSBsaWtlIHRoZSBFeHByZXNzaW9uIHBhcnNlciBleGNlcHQgbm9cclxuICAgICAgICAgICAgICAgICAqIG1hdGggaXMgYWxsb3dlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcGVybWlzc2l2ZVZhbHVlOiBmdW5jdGlvbiAodW50aWxUb2tlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvayA9IHVudGlsVG9rZW5zIHx8ICc7JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXN0Q3VycmVudENoYXIoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhciA9PT0gdG9rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay50ZXN0KGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0Q3VycmVudENoYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5jb21tZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuZW50aXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRlc3RDdXJyZW50Q2hhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3ICh0cmVlLkV4cHJlc3Npb24pKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgJHBhcnNlVW50aWwgYXMgaXQgd2lsbCBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnByZXZDaGFyKCkgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IHRyZWUuQW5vbnltb3VzKCcgJywgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJJbnB1dC4kcGFyc2VVbnRpbCh0b2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyB2YWx1ZSArIFwiJ1wiLCAnUGFyc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxICYmIHZhbHVlWzBdID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkFub255bW91cygnJywgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgYWN0dWFsIHF1b3RlcyBhcyBub3JtYWwgcXVvdGVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyB0cmVlLlF1b3RlZChpdGVtWzBdLCBpdGVtWzFdLCB0cnVlLCBpbmRleCwgZmlsZUluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2YWx1ZS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgbGlrZSBxdW90ZWQgdmFsdWVzLCBidXQgcmVwbGFjZSB2YXJzIGxpa2UgdW5xdW90ZWQgZXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGUgPSBuZXcgdHJlZS5RdW90ZWQoJ1xcJycsIGl0ZW0sIHRydWUsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGUudmFyaWFibGVSZWdleCA9IC9AKFtcXHctXSspL2c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGUucHJvcFJlZ2V4ID0gL1xcJChbXFx3LV0rKS9nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkV4cHJlc3Npb24ocmVzdWx0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBbiBAaW1wb3J0IGF0cnVsZVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICBAaW1wb3J0IFwibGliXCI7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIG91ciBlbnZpcm9ubWVudCwgaW1wb3J0aW5nIGlzIGRvbmUgZGlmZmVyZW50bHk6XHJcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYnJvd3NlciwgaXQncyBhbiBYSFIgcmVxdWVzdCwgaW4gTm9kZSwgaXQgd291bGQgYmUgYVxyXG4gICAgICAgICAgICAgICAgLy8gZmlsZS1zeXN0ZW0gb3BlcmF0aW9uLiBUaGUgZnVuY3Rpb24gdXNlZCBmb3IgaW1wb3J0aW5nIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZWQgaW4gYGltcG9ydGAsIHdoaWNoIHdlIHBhc3MgdG8gdGhlIEltcG9ydCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAnaW1wb3J0JzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSBwYXJzZXJJbnB1dC4kcmUoL15AaW1wb3J0P1xccysvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gKGRpciA/IHRoaXMuaW1wb3J0T3B0aW9ucygpIDogbnVsbCkgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocGF0aCA9IHRoaXMuZW50aXRpZXMucXVvdGVkKCkgfHwgdGhpcy5lbnRpdGllcy51cmwoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gdGhpcy5tZWRpYUZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCc7JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21pc3Npbmcgc2VtaS1jb2xvbiBvciB1bnJlY29nbmlzZWQgbWVkaWEgZmVhdHVyZXMgb24gaW1wb3J0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzICYmIG5ldyAodHJlZS5WYWx1ZSkoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5JbXBvcnQpKHBhdGgsIGZlYXR1cmVzLCBvcHRpb25zLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21hbGZvcm1lZCBpbXBvcnQgc3RhdGVtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW1wb3J0T3B0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2Ygb3B0aW9ucywgc3Vycm91bmRlZCBieSBwYXJlbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHRoaXMuaW1wb3J0T3B0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lID0gbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nzcyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSAnbGVzcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29uY2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lID0gJ211bHRpcGxlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpbXBvcnRPcHRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gcGFyc2VySW5wdXQuJHJlKC9eKGxlc3N8Y3NzfG11bHRpcGxlfG9uY2V8aW5saW5lfHJlZmVyZW5jZXxvcHRpb25hbCkvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG1lZGlhRmVhdHVyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGVudGl0aWVzLmtleXdvcmQoKSB8fCBlbnRpdGllcy52YXJpYWJsZSgpIHx8IGVudGl0aWVzLm1peGluTG9va3VwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLnByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy52YWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCAmJiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3ICh0cmVlLlBhcmVuKShuZXcgKHRyZWUuRGVjbGFyYXRpb24pKHAsIGUsIG51bGwsIG51bGwsIHBhcnNlcklucHV0LmksIGZpbGVJbmZvLCB0cnVlKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3ICh0cmVlLlBhcmVuKShlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignYmFkbHkgZm9ybWVkIG1lZGlhIGZlYXR1cmUgZGVmaW5pdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdNaXNzaW5nIGNsb3NpbmcgXFwnKVxcJycsICdQYXJzZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5FeHByZXNzaW9uKShub2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG1lZGlhRmVhdHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMubWVkaWFGZWF0dXJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gZW50aXRpZXMudmFyaWFibGUoKSB8fCBlbnRpdGllcy5taXhpbkxvb2t1cCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZXMubGVuZ3RoID4gMCA/IGZlYXR1cmVzIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtZWRpYTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lZGlhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWJ1Z0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdJbmZvID0gZ2V0RGVidWdJbmZvKGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKCdAbWVkaWEnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHRoaXMubWVkaWFGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHRoaXMuYmxvY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21lZGlhIGRlZmluaXRpb25zIHJlcXVpcmUgYmxvY2sgc3RhdGVtZW50cyBhZnRlciBhbnkgZmVhdHVyZXMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWEgPSBuZXcgKHRyZWUuTWVkaWEpKHJ1bGVzLCBmZWF0dXJlcywgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYS5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEEgQHBsdWdpbiBkaXJlY3RpdmUsIHVzZWQgdG8gaW1wb3J0IHBsdWdpbnMgZHluYW1pY2FsbHkuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIEBwbHVnaW4gKGFyZ3MpIFwibGliXCI7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gcGFyc2VySW5wdXQuJHJlKC9eQHBsdWdpbj9cXHMrLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5wbHVnaW5BcmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbkFyZ3M6IGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQbHVnaW46IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBpc1BsdWdpbjogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocGF0aCA9IHRoaXMuZW50aXRpZXMucXVvdGVkKCkgfHwgdGhpcy5lbnRpdGllcy51cmwoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJzsnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignbWlzc2luZyBzZW1pLWNvbG9uIG9uIEBwbHVnaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuSW1wb3J0KShwYXRoLCBudWxsLCBvcHRpb25zLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21hbGZvcm1lZCBAcGx1Z2luIHN0YXRlbWVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkFyZ3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMsIHN1cnJvdW5kZWQgYnkgcGFyZW5zXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHBhcnNlcklucHV0LiRyZSgvXlxccyooW15cXCk7XSspXFwpXFxzKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1sxXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQSBDU1MgQXRSdWxlXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIEBjaGFyc2V0IFwidXRmLThcIjtcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBhdHJ1bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vblZlbmRvclNwZWNpZmljTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzRXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVW5rbm93bjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1Jvb3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICdAJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1snaW1wb3J0J10oKSB8fCB0aGlzLnBsdWdpbigpIHx8IHRoaXMubWVkaWEoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXkBbYS16LV0rLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uVmVuZG9yU3BlY2lmaWNOYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMSkgPT0gJy0nICYmIG5hbWUuaW5kZXhPZignLScsIDIpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub25WZW5kb3JTcGVjaWZpY05hbWUgPSBcIkBcIiArIG5hbWUuc2xpY2UobmFtZS5pbmRleE9mKCctJywgMikgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub25WZW5kb3JTcGVjaWZpY05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQGNoYXJzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzSWRlbnRpZmllciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0BuYW1lc3BhY2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXhwcmVzc2lvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0BrZXlmcmFtZXMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdAY291bnRlci1zdHlsZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNJZGVudGlmaWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdAZG9jdW1lbnQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdAc3VwcG9ydHMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Jvb3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNVbmtub3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50aXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiZXhwZWN0ZWQgXCIgKyBuYW1lICsgXCIgaWRlbnRpZmllclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5leHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiZXhwZWN0ZWQgXCIgKyBuYW1lICsgXCIgZXhwcmVzc2lvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNVbmtub3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wZXJtaXNzaXZlVmFsdWUoL15beztdLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Jsb2NrID0gKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICd7Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzQmxvY2sgJiYgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJzsnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IobmFtZSArIFwiIHJ1bGUgaXMgbWlzc2luZyBibG9jayBvciBlbmRpbmcgc2VtaS1jb2xvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdmFsdWUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLmJsb2NrUnVsZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXMgfHwgKCFoYXNCbG9jayAmJiB2YWx1ZSAmJiBwYXJzZXJJbnB1dC4kY2hhcignOycpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5BdFJ1bGUpKG5hbWUsIHZhbHVlLCBydWxlcywgaW5kZXgsIGZpbGVJbmZvLCBjb250ZXh0LmR1bXBMaW5lTnVtYmVycyA/IGdldERlYnVnSW5mbyhpbmRleCkgOiBudWxsLCBpc1Jvb3RlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ2F0LXJ1bGUgb3B0aW9ucyBub3QgcmVjb2duaXNlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBIFZhbHVlIGlzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgRXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgZm9udC1mYW1pbHk6IEJhc2tlcnZpbGxlLCBHZW9yZ2lhLCBzZXJpZjtcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBhIFJ1bGUsIGEgVmFsdWUgcmVwcmVzZW50cyBldmVyeXRoaW5nIGFmdGVyIHRoZSBgOmAsXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgYmVmb3JlIHRoZSBgO2AuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuZXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5WYWx1ZSkoZXhwcmVzc2lvbnMsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW1wb3J0YW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICchJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VySW5wdXQuJHJlKC9eISAqaW1wb3J0YW50Lyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN1YjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJygnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5hZGRpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgKHRyZWUuRXhwcmVzc2lvbikoW2FdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ0V4cGVjdGVkIFxcJylcXCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGljYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTcGFjZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHRoaXMub3BlcmFuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wZWVrKC9eXFwvWypcXC9dLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gcGFyc2VySW5wdXQuJGNoYXIoJy8nKSB8fCBwYXJzZXJJbnB1dC4kY2hhcignKicpIHx8IHBhcnNlcklucHV0LiRzdHIoJy4vJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5vcGVyYW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFyZW5zSW5PcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnBhcmVuc0luT3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3ICh0cmVlLk9wZXJhdGlvbikob3AsIFtvcGVyYXRpb24gfHwgbSwgYV0sIGlzU3BhY2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uIHx8IG07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3BhY2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB0aGlzLm11bHRpcGxpY2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBwYXJzZXJJbnB1dC4kcmUoL15bLStdXFxzKy8pIHx8ICghaXNTcGFjZWQgJiYgKHBhcnNlcklucHV0LiRjaGFyKCcrJykgfHwgcGFyc2VySW5wdXQuJGNoYXIoJy0nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMubXVsdGlwbGljYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5wYXJlbnNJbk9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucGFyZW5zSW5PcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBuZXcgKHRyZWUuT3BlcmF0aW9uKShvcCwgW29wZXJhdGlvbiB8fCBtLCBhXSwgaXNTcGFjZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTcGFjZWQgPSBwYXJzZXJJbnB1dC5pc1doaXRlc3BhY2UoLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24gfHwgbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBhID0gdGhpcy5jb25kaXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQucGVlaygvXixcXHMqKG5vdFxccyopP1xcKC8pIHx8ICFwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5jb25kaXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IG5ldyAodHJlZS5Db25kaXRpb24pKCdvcicsIGNvbmRpdGlvbiB8fCBhLCBiLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiB8fCBhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2ljYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kc3RyKCdvcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbmRpdGlvbkFuZChuZWVkc1BhcmVucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsb2dpY2FsID0gb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9naWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5jb25kaXRpb24obmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3ICh0cmVlLkNvbmRpdGlvbikobG9naWNhbCwgcmVzdWx0LCBuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbkFuZDogZnVuY3Rpb24gKG5lZWRzUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9naWNhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5zaWRlQ29uZGl0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZCA9IHNlbGYubmVnYXRlZENvbmRpdGlvbihuZWVkc1BhcmVucykgfHwgc2VsZi5wYXJlbnRoZXNpc0NvbmRpdGlvbihuZWVkc1BhcmVucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZCAmJiAhbmVlZHNQYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmF0b21pY0NvbmRpdGlvbihuZWVkc1BhcmVucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFuZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcklucHV0LiRzdHIoJ2FuZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnNpZGVDb25kaXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2ljYWwgPSBhbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9naWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5jb25kaXRpb25BbmQobmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3ICh0cmVlLkNvbmRpdGlvbikobG9naWNhbCwgcmVzdWx0LCBuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5lZ2F0ZWRDb25kaXRpb246IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kc3RyKCdub3QnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJlbnRoZXNpc0NvbmRpdGlvbihuZWVkc1BhcmVucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZWdhdGUgPSAhcmVzdWx0Lm5lZ2F0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRoZXNpc0NvbmRpdGlvbjogZnVuY3Rpb24gKG5lZWRzUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJ5Q29uZGl0aW9uRm9sbG93ZWRCeVBhcmVudGhlc2lzKG1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBtZS5jb25kaXRpb24obmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoJygnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRyeUNvbmRpdGlvbkZvbGxvd2VkQnlQYXJlbnRoZXNpcyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmF0b21pY0NvbmRpdGlvbihuZWVkc1BhcmVucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcpJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZShcImV4cGVjdGVkICcpJyBnb3QgJ1wiICsgcGFyc2VySW5wdXQuY3VycmVudENoYXIoKSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdG9taWNDb25kaXRpb246IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkaXRpb24oKSB8fCBlbnRpdGllcy5rZXl3b3JkKCkgfHwgZW50aXRpZXMucXVvdGVkKCkgfHwgZW50aXRpZXMubWl4aW5Mb29rdXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZCA9IGNvbmQuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gY29uZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz49JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc8JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPD0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc+JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9ICc9Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPTwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gY29uZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV3ICh0cmVlLkNvbmRpdGlvbikob3AsIGEsIGIsIGluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignZXhwZWN0ZWQgZXhwcmVzc2lvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyAodHJlZS5Db25kaXRpb24pKCc9JywgYSwgbmV3ICh0cmVlLktleXdvcmQpKCd0cnVlJyksIGluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBbiBvcGVyYW5kIGlzIGFueXRoaW5nIHRoYXQgY2FuIGJlIHBhcnQgb2YgYW4gb3BlcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgLy8gc3VjaCBhcyBhIENvbG9yLCBvciBhIFZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgb3BlcmFuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lZ2F0ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygvXi1bQFxcJFxcKF0vKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWdhdGUgPSBwYXJzZXJJbnB1dC4kY2hhcignLScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMuc3ViKCkgfHwgZW50aXRpZXMuZGltZW5zaW9uKCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMuY29sb3IoKSB8fCBlbnRpdGllcy52YXJpYWJsZSgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnByb3BlcnR5KCkgfHwgZW50aXRpZXMuY2FsbCgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnF1b3RlZCh0cnVlKSB8fCBlbnRpdGllcy5jb2xvcktleXdvcmQoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5taXhpbkxvb2t1cCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWdhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wYXJlbnNJbk9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IG5ldyAodHJlZS5OZWdhdGl2ZSkobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBFeHByZXNzaW9ucyBlaXRoZXIgcmVwcmVzZW50IG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgLy8gb3Igd2hpdGUtc3BhY2UgZGVsaW1pdGVkIEVudGl0aWVzLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICAxcHggc29saWQgYmxhY2tcclxuICAgICAgICAgICAgICAgIC8vICAgICBAdmFyICogMlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsaW07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmNvbW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5hZGRpdGlvbigpIHx8IHRoaXMuZW50aXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgdHJlZS5Db21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbnMgZG8gbm90IGFsbG93IGtleXdvcmQgXCIvXCIgZGltZW5zaW9uIChlLmcuIHNtYWxsLzIwcHgpIHNvIHdlIHN1cHBvcnQgdGhhdCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LnBlZWsoL15cXC9bXFwvKl0vKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltID0gcGFyc2VySW5wdXQuJGNoYXIoJy8nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMucHVzaChuZXcgKHRyZWUuQW5vbnltb3VzKShkZWxpbSwgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50aXRpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkV4cHJlc3Npb24pKGVudGl0aWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihcXCo/LT9bX2EtekEtWjAtOS1dKylcXHMqOi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBydWxlUHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2ltcGxlUHJvcGVydHkgPSBwYXJzZXJJbnB1dC4kcmUoL14oW19hLXpBLVowLTktXSspXFxzKjovKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxlUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFtuZXcgKHRyZWUuS2V5d29yZCkoc2ltcGxlUHJvcGVydHlbMV0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBtYXRjaChyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IHBhcnNlcklucHV0LiRyZShyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLnB1c2goY2h1bmtbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKC9eKFxcKj8pLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgvXigoPzpbXFx3LV0rKXwoPzpbQFxcJF1cXHtbXFx3LV0rXFx9KSkvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuYW1lLmxlbmd0aCA+IDEpICYmIG1hdGNoKC9eKCg/OlxcK198XFwrKT8pXFxzKjovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXQgbGFzdCwgd2UgaGF2ZSB0aGUgY29tcGxldGUgbWF0Y2ggbm93LiBtb3ZlIGZvcndhcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbmFtZSBwYXJ0aWNsZXMgdG8gdHJlZSBvYmplY3RzIGFuZCByZXR1cm46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXguc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbmFtZS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG5hbWVba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lW2tdID0gKHMuY2hhckF0KDApICE9PSAnQCcgJiYgcy5jaGFyQXQoMCkgIT09ICckJykgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyAodHJlZS5LZXl3b3JkKShzKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHMuY2hhckF0KDApID09PSAnQCcgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgKHRyZWUuVmFyaWFibGUpKFwiQFwiICsgcy5zbGljZSgyLCAtMSksIGluZGV4W2tdLCBmaWxlSW5mbykgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgKHRyZWUuUHJvcGVydHkpKFwiJFwiICsgcy5zbGljZSgyLCAtMSksIGluZGV4W2tdLCBmaWxlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFBhcnNlci5zZXJpYWxpemVWYXJzID0gZnVuY3Rpb24gKHZhcnMpIHtcclxuICAgICAgICB2YXIgcyA9ICcnO1xyXG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh2YXJzLCBuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YXJzW25hbWVfMV07XHJcbiAgICAgICAgICAgICAgICBzICs9ICgobmFtZV8xWzBdID09PSAnQCcpID8gJycgOiAnQCcpICsgbmFtZV8xICsgXCI6IFwiICsgdmFsdWUgKyAoKFN0cmluZyh2YWx1ZSkuc2xpY2UoLTEpID09PSAnOycpID8gJycgOiAnOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJvb2xlYW4oY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9ucyB3aXRoIGV2YWxBcmdzIHNldCB0byBmYWxzZSBhcmUgc2VudCBjb250ZXh0XHJcbiAgICAgKiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIElmKGNvbnRleHQsIGNvbmRpdGlvbiwgdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbi5ldmFsKGNvbnRleHQpID8gdHJ1ZVZhbHVlLmV2YWwoY29udGV4dClcclxuICAgICAgICAgICAgOiAoZmFsc2VWYWx1ZSA/IGZhbHNlVmFsdWUuZXZhbChjb250ZXh0KSA6IG5ldyBBbm9ueW1vdXMpO1xyXG4gICAgfVxyXG4gICAgSWYuZXZhbEFyZ3MgPSBmYWxzZTtcclxuICAgIGZ1bmN0aW9uIGlzZGVmaW5lZChjb250ZXh0LCB2YXJpYWJsZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBLZXl3b3JkLlRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBLZXl3b3JkLkZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzZGVmaW5lZC5ldmFsQXJncyA9IGZhbHNlO1xyXG4gICAgdmFyIGJvb2xlYW4kMSA9IHsgaXNkZWZpbmVkOiBpc2RlZmluZWQsIGJvb2xlYW46IGJvb2xlYW4sICdpZic6IElmIH07XG5cbiAgICB2YXIgY29sb3JGdW5jdGlvbnM7XHJcbiAgICBmdW5jdGlvbiBjbGFtcCQxKHZhbCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB2YWwpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhzbGEob3JpZ0NvbG9yLCBoc2wpIHtcclxuICAgICAgICB2YXIgY29sb3IgPSBjb2xvckZ1bmN0aW9ucy5oc2xhKGhzbC5oLCBoc2wucywgaHNsLmwsIGhzbC5hKTtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKG9yaWdDb2xvci52YWx1ZSAmJlxyXG4gICAgICAgICAgICAgICAgL14ocmdifGhzbCkvLnRlc3Qob3JpZ0NvbG9yLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IudmFsdWUgPSBvcmlnQ29sb3IudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvci52YWx1ZSA9ICdyZ2InO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0b0hTTChjb2xvcikge1xyXG4gICAgICAgIGlmIChjb2xvci50b0hTTCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3IudG9IU0woKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgY2Fubm90IGJlIGV2YWx1YXRlZCB0byBhIGNvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdG9IU1YoY29sb3IpIHtcclxuICAgICAgICBpZiAoY29sb3IudG9IU1YpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLnRvSFNWKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGNhbm5vdCBiZSBldmFsdWF0ZWQgdG8gYSBjb2xvcicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG51bWJlcihuKSB7XHJcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBEaW1lbnNpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobi51bml0LmlzKCclJykgPyBuLnZhbHVlIC8gMTAwIDogbi52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdBcmd1bWVudCcsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnY29sb3IgZnVuY3Rpb25zIHRha2UgbnVtYmVycyBhcyBwYXJhbWV0ZXJzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNjYWxlZChuLCBzaXplKSB7XHJcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBEaW1lbnNpb24gJiYgbi51bml0LmlzKCclJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobi52YWx1ZSAqIHNpemUgLyAxMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlcihuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb2xvckZ1bmN0aW9ucyA9IHtcclxuICAgICAgICByZ2I6IGZ1bmN0aW9uIChyLCBnLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gMTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbW1hLWxlc3Mgc3ludGF4XHJcbiAgICAgICAgICAgICAqICAgZS5nLiByZ2IoMCAxMjggMjU1IC8gNTAlKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHIgPSB2YWxbMF07XHJcbiAgICAgICAgICAgICAgICBnID0gdmFsWzFdO1xyXG4gICAgICAgICAgICAgICAgYiA9IHZhbFsyXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHRvZG8gLSBzaG91bGQgdGhpcyBiZSBub3JtYWxpemVkIGluXHJcbiAgICAgICAgICAgICAgICAgKiAgIGZ1bmN0aW9uIGNhbGxlcj8gT3IgcGFyc2VkIGRpZmZlcmVudGx5P1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IG9wLm9wZXJhbmRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBvcC5vcGVyYW5kc1sxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvckZ1bmN0aW9ucy5yZ2JhKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yLnZhbHVlID0gJ3JnYic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJnYmE6IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG51bWJlcihnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSByLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIucmdiLCBhLCAncmdiYScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJnYiA9IFtyLCBnLCBiXS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHNjYWxlZChjLCAyNTUpOyB9KTtcclxuICAgICAgICAgICAgICAgIGEgPSBudW1iZXIoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYiwgYSwgJ3JnYmEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoc2w6IGZ1bmN0aW9uIChoLCBzLCBsKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gMTtcclxuICAgICAgICAgICAgaWYgKGggaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gaC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGggPSB2YWxbMF07XHJcbiAgICAgICAgICAgICAgICBzID0gdmFsWzFdO1xyXG4gICAgICAgICAgICAgICAgbCA9IHZhbFsyXTtcclxuICAgICAgICAgICAgICAgIGlmIChsIGluc3RhbmNlb2YgT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbDtcclxuICAgICAgICAgICAgICAgICAgICBsID0gb3Aub3BlcmFuZHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IG9wLm9wZXJhbmRzWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yRnVuY3Rpb25zLmhzbGEoaCwgcywgbCwgYSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY29sb3IudmFsdWUgPSAnaHNsJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaHNsYTogZnVuY3Rpb24gKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChoIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gbnVtYmVyKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGguYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoaC5yZ2IsIGEsICdoc2xhJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbTFfMTtcclxuICAgICAgICAgICAgICAgIHZhciBtMl8xO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaHVlKGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoID0gaCA8IDAgPyBoICsgMSA6IChoID4gMSA/IGggLSAxIDogaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggKiA2IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTFfMSArIChtMl8xIC0gbTFfMSkgKiBoICogNjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaCAqIDIgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtMl8xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoICogMyA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0xXzEgKyAobTJfMSAtIG0xXzEpICogKDIgLyAzIC0gaCkgKiA2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0xXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaCA9IChudW1iZXIoaCkgJSAzNjApIC8gMzYwO1xyXG4gICAgICAgICAgICAgICAgcyA9IGNsYW1wJDEobnVtYmVyKHMpKTtcclxuICAgICAgICAgICAgICAgIGwgPSBjbGFtcCQxKG51bWJlcihsKSk7XHJcbiAgICAgICAgICAgICAgICBhID0gY2xhbXAkMShudW1iZXIoYSkpO1xyXG4gICAgICAgICAgICAgICAgbTJfMSA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xyXG4gICAgICAgICAgICAgICAgbTFfMSA9IGwgKiAyIC0gbTJfMTtcclxuICAgICAgICAgICAgICAgIHZhciByZ2IgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgaHVlKGggKyAxIC8gMykgKiAyNTUsXHJcbiAgICAgICAgICAgICAgICAgICAgaHVlKGgpICogMjU1LFxyXG4gICAgICAgICAgICAgICAgICAgIGh1ZShoIC0gMSAvIDMpICogMjU1XHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgYSA9IG51bWJlcihhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiLCBhLCAnaHNsYScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzdjogZnVuY3Rpb24gKGgsIHMsIHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLmhzdmEoaCwgcywgdiwgMS4wKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzdmE6IGZ1bmN0aW9uIChoLCBzLCB2LCBhKSB7XHJcbiAgICAgICAgICAgIGggPSAoKG51bWJlcihoKSAlIDM2MCkgLyAzNjApICogMzYwO1xyXG4gICAgICAgICAgICBzID0gbnVtYmVyKHMpO1xyXG4gICAgICAgICAgICB2ID0gbnVtYmVyKHYpO1xyXG4gICAgICAgICAgICBhID0gbnVtYmVyKGEpO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGY7XHJcbiAgICAgICAgICAgIGkgPSBNYXRoLmZsb29yKChoIC8gNjApICUgNik7XHJcbiAgICAgICAgICAgIGYgPSAoaCAvIDYwKSAtIGk7XHJcbiAgICAgICAgICAgIHZhciB2cyA9IFt2LFxyXG4gICAgICAgICAgICAgICAgdiAqICgxIC0gcyksXHJcbiAgICAgICAgICAgICAgICB2ICogKDEgLSBmICogcyksXHJcbiAgICAgICAgICAgICAgICB2ICogKDEgLSAoMSAtIGYpICogcyldO1xyXG4gICAgICAgICAgICB2YXIgcGVybSA9IFtbMCwgMywgMV0sXHJcbiAgICAgICAgICAgICAgICBbMiwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICBbMSwgMCwgM10sXHJcbiAgICAgICAgICAgICAgICBbMSwgMiwgMF0sXHJcbiAgICAgICAgICAgICAgICBbMywgMSwgMF0sXHJcbiAgICAgICAgICAgICAgICBbMCwgMSwgMl1dO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMucmdiYSh2c1twZXJtW2ldWzBdXSAqIDI1NSwgdnNbcGVybVtpXVsxXV0gKiAyNTUsIHZzW3Blcm1baV1bMl1dICogMjU1LCBhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGh1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHRvSFNMKGNvbG9yKS5oKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhdHVyYXRpb246IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih0b0hTTChjb2xvcikucyAqIDEwMCwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpZ2h0bmVzczogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHRvSFNMKGNvbG9yKS5sICogMTAwLCAnJScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaHN2aHVlOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odG9IU1YoY29sb3IpLmgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaHN2c2F0dXJhdGlvbjogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHRvSFNWKGNvbG9yKS5zICogMTAwLCAnJScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaHN2dmFsdWU6IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih0b0hTVihjb2xvcikudiAqIDEwMCwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZDogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlswXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBncmVlbjogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlsxXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBibHVlOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oY29sb3IucmdiWzJdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFscGhhOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odG9IU0woY29sb3IpLmEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbHVtYTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLmx1bWEoKSAqIGNvbG9yLmFscGhhICogMTAwLCAnJScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbHVtaW5hbmNlOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIGx1bWluYW5jZSA9ICgwLjIxMjYgKiBjb2xvci5yZ2JbMF0gLyAyNTUpICtcclxuICAgICAgICAgICAgICAgICgwLjcxNTIgKiBjb2xvci5yZ2JbMV0gLyAyNTUpICtcclxuICAgICAgICAgICAgICAgICgwLjA3MjIgKiBjb2xvci5yZ2JbMl0gLyAyNTUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihsdW1pbmFuY2UgKiBjb2xvci5hbHBoYSAqIDEwMCwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbHRlcjogc2F0dXJhdGUoMy4yKTtcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGtlcHQgYXMgaXMsIHNvIGNoZWNrIGZvciBjb2xvclxyXG4gICAgICAgICAgICBpZiAoIWNvbG9yLnJnYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xyXG4gICAgICAgICAgICAgICAgaHNsLnMgKz0gaHNsLnMgKiBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoc2wucyArPSBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHNsLnMgPSBjbGFtcCQxKGhzbC5zKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXNhdHVyYXRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHZhciBoc2wgPSB0b0hTTChjb2xvcik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJyAmJiBtZXRob2QudmFsdWUgPT09ICdyZWxhdGl2ZScpIHtcclxuICAgICAgICAgICAgICAgIGhzbC5zIC09IGhzbC5zICogYW1vdW50LnZhbHVlIC8gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHNsLnMgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhzbC5zID0gY2xhbXAkMShoc2wucyk7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhKGNvbG9yLCBoc2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlnaHRlbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gdG9IU0woY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcgJiYgbWV0aG9kLnZhbHVlID09PSAncmVsYXRpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICBoc2wubCArPSBoc2wubCAqIGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhzbC5sICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoc2wubCA9IGNsYW1wJDEoaHNsLmwpO1xyXG4gICAgICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhcmtlbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gdG9IU0woY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcgJiYgbWV0aG9kLnZhbHVlID09PSAncmVsYXRpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICBoc2wubCAtPSBoc2wubCAqIGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhzbC5sIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoc2wubCA9IGNsYW1wJDEoaHNsLmwpO1xyXG4gICAgICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhZGVpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gdG9IU0woY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcgJiYgbWV0aG9kLnZhbHVlID09PSAncmVsYXRpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICBoc2wuYSArPSBoc2wuYSAqIGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhzbC5hICs9IGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoc2wuYSA9IGNsYW1wJDEoaHNsLmEpO1xyXG4gICAgICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhZGVvdXQ6IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xyXG4gICAgICAgICAgICAgICAgaHNsLmEgLT0gaHNsLmEgKiBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoc2wuYSAtPSBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHNsLmEgPSBjbGFtcCQxKGhzbC5hKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWRlOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gdG9IU0woY29sb3IpO1xyXG4gICAgICAgICAgICBoc2wuYSA9IGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgaHNsLmEgPSBjbGFtcCQxKGhzbC5hKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcGluOiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gdG9IU0woY29sb3IpO1xyXG4gICAgICAgICAgICB2YXIgaHVlID0gKGhzbC5oICsgYW1vdW50LnZhbHVlKSAlIDM2MDtcclxuICAgICAgICAgICAgaHNsLmggPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgSGFtcHRvbiBDYXRsaW4sIE5hdGFsaWUgV2VpemVuYmF1bSwgYW5kIENocmlzIEVwcHN0ZWluXHJcbiAgICAgICAgLy8gaHR0cDovL3Nhc3MtbGFuZy5jb21cclxuICAgICAgICAvL1xyXG4gICAgICAgIG1peDogZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyLCB3ZWlnaHQpIHtcclxuICAgICAgICAgICAgaWYgKCF3ZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHdlaWdodCA9IG5ldyBEaW1lbnNpb24oNTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwID0gd2VpZ2h0LnZhbHVlIC8gMTAwLjA7XHJcbiAgICAgICAgICAgIHZhciB3ID0gcCAqIDIgLSAxO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRvSFNMKGNvbG9yMSkuYSAtIHRvSFNMKGNvbG9yMikuYTtcclxuICAgICAgICAgICAgdmFyIHcxID0gKCgodyAqIGEgPT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcclxuICAgICAgICAgICAgdmFyIHcyID0gMSAtIHcxO1xyXG4gICAgICAgICAgICB2YXIgcmdiID0gW2NvbG9yMS5yZ2JbMF0gKiB3MSArIGNvbG9yMi5yZ2JbMF0gKiB3MixcclxuICAgICAgICAgICAgICAgIGNvbG9yMS5yZ2JbMV0gKiB3MSArIGNvbG9yMi5yZ2JbMV0gKiB3MixcclxuICAgICAgICAgICAgICAgIGNvbG9yMS5yZ2JbMl0gKiB3MSArIGNvbG9yMi5yZ2JbMl0gKiB3Ml07XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNvbG9yMS5hbHBoYSAqIHAgKyBjb2xvcjIuYWxwaGEgKiAoMSAtIHApO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYiwgYWxwaGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3JleXNjYWxlOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLmRlc2F0dXJhdGUoY29sb3IsIG5ldyBEaW1lbnNpb24oMTAwKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yLCBkYXJrLCBsaWdodCwgdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbHRlcjogY29udHJhc3QoMy4yKTtcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGtlcHQgYXMgaXMsIHNvIGNoZWNrIGZvciBjb2xvclxyXG4gICAgICAgICAgICBpZiAoIWNvbG9yLnJnYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGxpZ2h0ID0gY29sb3JGdW5jdGlvbnMucmdiYSgyNTUsIDI1NSwgMjU1LCAxLjApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGFyayA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGRhcmsgPSBjb2xvckZ1bmN0aW9ucy5yZ2JhKDAsIDAsIDAsIDEuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBpcyBhY3R1YWxseSBsaWdodCBhbmQgZGFyazpcclxuICAgICAgICAgICAgaWYgKGRhcmsubHVtYSgpID4gbGlnaHQubHVtYSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGxpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbGlnaHQgPSBkYXJrO1xyXG4gICAgICAgICAgICAgICAgZGFyayA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSAwLjQzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gbnVtYmVyKHRocmVzaG9sZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbG9yLmx1bWEoKSA8IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhcms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIENoYW5nZXMgbWFkZSBpbiAyLjcuMCAtIFJldmVydGVkIGluIDMuMC4wXHJcbiAgICAgICAgLy8gY29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvciwgY29sb3IxLCBjb2xvcjIsIHRocmVzaG9sZCkge1xyXG4gICAgICAgIC8vICAgICAvLyBSZXR1cm4gd2hpY2ggb2YgYGNvbG9yMWAgYW5kIGBjb2xvcjJgIGhhcyB0aGUgZ3JlYXRlc3QgY29udHJhc3Qgd2l0aCBgY29sb3JgXHJcbiAgICAgICAgLy8gICAgIC8vIGFjY29yZGluZyB0byB0aGUgc3RhbmRhcmQgV0NBRyBjb250cmFzdCByYXRpbyBjYWxjdWxhdGlvbi5cclxuICAgICAgICAvLyAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxyXG4gICAgICAgIC8vICAgICAvLyBUaGUgdGhyZXNob2xkIHBhcmFtIGlzIG5vIGxvbmdlciB1c2VkLCBpbiBsaW5lIHdpdGggU0FTUy5cclxuICAgICAgICAvLyAgICAgLy8gZmlsdGVyOiBjb250cmFzdCgzLjIpO1xyXG4gICAgICAgIC8vICAgICAvLyBzaG91bGQgYmUga2VwdCBhcyBpcywgc28gY2hlY2sgZm9yIGNvbG9yXHJcbiAgICAgICAgLy8gICAgIGlmICghY29sb3IucmdiKSB7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBpZiAodHlwZW9mIGNvbG9yMSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyAgICAgICAgIGNvbG9yMSA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMCwgMCwgMCwgMS4wKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBpZiAodHlwZW9mIGNvbG9yMiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyAgICAgICAgIGNvbG9yMiA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMjU1LCAyNTUsIDI1NSwgMS4wKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICB2YXIgY29udHJhc3QxLCBjb250cmFzdDI7XHJcbiAgICAgICAgLy8gICAgIHZhciBsdW1hID0gY29sb3IubHVtYSgpO1xyXG4gICAgICAgIC8vICAgICB2YXIgbHVtYTEgPSBjb2xvcjEubHVtYSgpO1xyXG4gICAgICAgIC8vICAgICB2YXIgbHVtYTIgPSBjb2xvcjIubHVtYSgpO1xyXG4gICAgICAgIC8vICAgICAvLyBDYWxjdWxhdGUgY29udHJhc3QgcmF0aW9zIGZvciBlYWNoIGNvbG9yXHJcbiAgICAgICAgLy8gICAgIGlmIChsdW1hID4gbHVtYTEpIHtcclxuICAgICAgICAvLyAgICAgICAgIGNvbnRyYXN0MSA9IChsdW1hICsgMC4wNSkgLyAobHVtYTEgKyAwLjA1KTtcclxuICAgICAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgIGNvbnRyYXN0MSA9IChsdW1hMSArIDAuMDUpIC8gKGx1bWEgKyAwLjA1KTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBpZiAobHVtYSA+IGx1bWEyKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb250cmFzdDIgPSAobHVtYSArIDAuMDUpIC8gKGx1bWEyICsgMC4wNSk7XHJcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb250cmFzdDIgPSAobHVtYTIgKyAwLjA1KSAvIChsdW1hICsgMC4wNSk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgaWYgKGNvbnRyYXN0MSA+IGNvbnRyYXN0Mikge1xyXG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIGNvbG9yMTtcclxuICAgICAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiBjb2xvcjI7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIGFyZ2I6IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhjb2xvci50b0FSR0IoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xvcjogZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgaWYgKChjIGluc3RhbmNlb2YgUXVvdGVkKSAmJlxyXG4gICAgICAgICAgICAgICAgKC9eIyhbQS1GYS1mMC05XXs4fXxbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszLDR9KSQvaS50ZXN0KGMudmFsdWUpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGMudmFsdWUuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHZhbCwgdW5kZWZpbmVkLCBcIiNcIiArIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChjIGluc3RhbmNlb2YgQ29sb3IpIHx8IChjID0gQ29sb3IuZnJvbUtleXdvcmQoYy52YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjLnZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0FyZ3VtZW50JyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdhcmd1bWVudCBtdXN0IGJlIGEgY29sb3Iga2V5d29yZCBvciAzfDR8Nnw4IGRpZ2l0IGhleCBlLmcuICNGRkYnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aW50OiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbnMubWl4KGNvbG9yRnVuY3Rpb25zLnJnYigyNTUsIDI1NSwgMjU1KSwgY29sb3IsIGFtb3VudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGFkZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLm1peChjb2xvckZ1bmN0aW9ucy5yZ2IoMCwgMCwgMCksIGNvbG9yLCBhbW91bnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgY29sb3IgPSBjb2xvckZ1bmN0aW9ucztcblxuICAgIC8vIENvbG9yIEJsZW5kaW5nXHJcbiAgICAvLyByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSL2NvbXBvc2l0aW5nLTFcclxuICAgIGZ1bmN0aW9uIGNvbG9yQmxlbmQobW9kZSwgY29sb3IxLCBjb2xvcjIpIHtcclxuICAgICAgICB2YXIgYWIgPSBjb2xvcjEuYWxwaGE7IC8vIHJlc3VsdFxyXG4gICAgICAgIHZhciAvLyBiYWNrZHJvcFxyXG4gICAgICAgIGNiO1xyXG4gICAgICAgIHZhciBhcyA9IGNvbG9yMi5hbHBoYTtcclxuICAgICAgICB2YXIgLy8gc291cmNlXHJcbiAgICAgICAgY3M7XHJcbiAgICAgICAgdmFyIGFyO1xyXG4gICAgICAgIHZhciBjcjtcclxuICAgICAgICB2YXIgciA9IFtdO1xyXG4gICAgICAgIGFyID0gYXMgKyBhYiAqICgxIC0gYXMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNiID0gY29sb3IxLnJnYltpXSAvIDI1NTtcclxuICAgICAgICAgICAgY3MgPSBjb2xvcjIucmdiW2ldIC8gMjU1O1xyXG4gICAgICAgICAgICBjciA9IG1vZGUoY2IsIGNzKTtcclxuICAgICAgICAgICAgaWYgKGFyKSB7XHJcbiAgICAgICAgICAgICAgICBjciA9IChhcyAqIGNzICsgYWIgKiAoY2IgLVxyXG4gICAgICAgICAgICAgICAgICAgIGFzICogKGNiICsgY3MgLSBjcikpKSAvIGFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbaV0gPSBjciAqIDI1NTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBhcik7XHJcbiAgICB9XHJcbiAgICB2YXIgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMgPSB7XHJcbiAgICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChjYiwgY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNiICogY3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY3JlZW46IGZ1bmN0aW9uIChjYiwgY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNiICsgY3MgLSBjYiAqIGNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3ZlcmxheTogZnVuY3Rpb24gKGNiLCBjcykge1xyXG4gICAgICAgICAgICBjYiAqPSAyO1xyXG4gICAgICAgICAgICByZXR1cm4gKGNiIDw9IDEpID9cclxuICAgICAgICAgICAgICAgIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLm11bHRpcGx5KGNiLCBjcykgOlxyXG4gICAgICAgICAgICAgICAgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMuc2NyZWVuKGNiIC0gMSwgY3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc29mdGxpZ2h0OiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHZhciBkID0gMTtcclxuICAgICAgICAgICAgdmFyIGUgPSBjYjtcclxuICAgICAgICAgICAgaWYgKGNzID4gMC41KSB7XHJcbiAgICAgICAgICAgICAgICBlID0gMTtcclxuICAgICAgICAgICAgICAgIGQgPSAoY2IgPiAwLjI1KSA/IE1hdGguc3FydChjYilcclxuICAgICAgICAgICAgICAgICAgICA6ICgoMTYgKiBjYiAtIDEyKSAqIGNiICsgNCkgKiBjYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2IgLSAoMSAtIDIgKiBjcykgKiBlICogKGQgLSBjYik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXJkbGlnaHQ6IGZ1bmN0aW9uIChjYiwgY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLm92ZXJsYXkoY3MsIGNiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIChjYiwgY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGNiIC0gY3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhjbHVzaW9uOiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYiArIGNzIC0gMiAqIGNiICogY3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBub24tdzNjIGZ1bmN0aW9uczpcclxuICAgICAgICBhdmVyYWdlOiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY2IgKyBjcykgLyAyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmVnYXRpb246IGZ1bmN0aW9uIChjYiwgY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmFicyhjYiArIGNzIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZvciAodmFyIGYgaW4gY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMpIHtcclxuICAgICAgICBpZiAoY29sb3JCbGVuZE1vZGVGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoZikpIHtcclxuICAgICAgICAgICAgY29sb3JCbGVuZFtmXSA9IGNvbG9yQmxlbmQuYmluZChudWxsLCBjb2xvckJsZW5kTW9kZUZ1bmN0aW9uc1tmXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxuXG4gICAgdmFyIGRhdGFVcmkgPSAoZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XHJcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bmN0aW9uVGhpcywgbm9kZSkgeyByZXR1cm4gbmV3IFVSTChub2RlLCBmdW5jdGlvblRoaXMuaW5kZXgsIGZ1bmN0aW9uVGhpcy5jdXJyZW50RmlsZUluZm8pLmV2YWwoZnVuY3Rpb25UaGlzLmNvbnRleHQpOyB9O1xyXG4gICAgICAgIHJldHVybiB7ICdkYXRhLXVyaSc6IGZ1bmN0aW9uIChtaW1ldHlwZU5vZGUsIGZpbGVQYXRoTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlUGF0aE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aE5vZGUgPSBtaW1ldHlwZU5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWltZXR5cGVOb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtaW1ldHlwZSA9IG1pbWV0eXBlTm9kZSAmJiBtaW1ldHlwZU5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVBhdGggPSBmaWxlUGF0aE5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZpbGVJbmZvID0gdGhpcy5jdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudERpcmVjdG9yeSA9IGN1cnJlbnRGaWxlSW5mby5yZXdyaXRlVXJscyA/XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnkgOiBjdXJyZW50RmlsZUluZm8uZW50cnlQYXRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50U3RhcnQgPSBmaWxlUGF0aC5pbmRleE9mKCcjJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcclxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudFN0YXJ0ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlsZVBhdGguc2xpY2UoZnJhZ21lbnRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgwLCBmcmFnbWVudFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2xvbmUodGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmF3QnVmZmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlTWFuYWdlciA9IGVudmlyb25tZW50LmdldEZpbGVNYW5hZ2VyKGZpbGVQYXRoLCBjdXJyZW50RGlyZWN0b3J5LCBjb250ZXh0LCBlbnZpcm9ubWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGVNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNlQmFzZTY0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgdGhlIG1pbWV0eXBlIGlmIG5vdCBnaXZlblxyXG4gICAgICAgICAgICAgICAgaWYgKCFtaW1ldHlwZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW1ldHlwZSA9IGVudmlyb25tZW50Lm1pbWVMb29rdXAoZmlsZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW1ldHlwZSA9PT0gJ2ltYWdlL3N2Zyt4bWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUJhc2U2NCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGJhc2UgNjQgdW5sZXNzIGl0J3MgYW4gQVNDSUkgb3IgVVRGLTggZm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyc2V0ID0gZW52aXJvbm1lbnQuY2hhcnNldExvb2t1cChtaW1ldHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUJhc2U2NCA9IFsnVVMtQVNDSUknLCAnVVRGLTgnXS5pbmRleE9mKGNoYXJzZXQpIDwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUJhc2U2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1ldHlwZSArPSAnO2Jhc2U2NCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlQmFzZTY0ID0gLztiYXNlNjQkLy50ZXN0KG1pbWV0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmaWxlU3luYyA9IGZpbGVNYW5hZ2VyLmxvYWRGaWxlU3luYyhmaWxlUGF0aCwgY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlU3luYy5jb250ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiU2tpcHBlZCBkYXRhLXVyaSBlbWJlZGRpbmcgb2YgXCIgKyBmaWxlUGF0aCArIFwiIGJlY2F1c2UgZmlsZSBub3QgZm91bmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSB8fCBtaW1ldHlwZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IGZpbGVTeW5jLmNvbnRlbnRzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZUJhc2U2NCAmJiAhZW52aXJvbm1lbnQuZW5jb2RlQmFzZTY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKHRoaXMsIGZpbGVQYXRoTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBidWYgPSB1c2VCYXNlNjQgPyBlbnZpcm9ubWVudC5lbmNvZGVCYXNlNjQoYnVmKSA6IGVuY29kZVVSSUNvbXBvbmVudChidWYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVyaSA9IFwiZGF0YTpcIiArIG1pbWV0eXBlICsgXCIsXCIgKyBidWYgKyBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKG5ldyBRdW90ZWQoXCJcXFwiXCIgKyB1cmkgKyBcIlxcXCJcIiwgdXJpLCBmYWxzZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyk7XHJcbiAgICAgICAgICAgIH0gfTtcclxuICAgIH0pO1xuXG4gICAgdmFyIGdldEl0ZW1zRnJvbU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIC8vIGhhbmRsZSBub24tYXJyYXkgdmFsdWVzIGFzIGFuIGFycmF5IG9mIGxlbmd0aCAxXHJcbiAgICAgICAgLy8gcmV0dXJuICd1bmRlZmluZWQnIGlmIGluZGV4IGlzIGludmFsaWRcclxuICAgICAgICB2YXIgaXRlbXMgPSBBcnJheS5pc0FycmF5KG5vZGUudmFsdWUpID9cclxuICAgICAgICAgICAgbm9kZS52YWx1ZSA6IEFycmF5KG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH07XHJcbiAgICB2YXIgbGlzdCA9IHtcclxuICAgICAgICBfU0VMRjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnfic6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGV4cHIgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGV4cHJbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXhwci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHByWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUoZXhwcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHRyYWN0OiBmdW5jdGlvbiAodmFsdWVzLCBpbmRleCkge1xyXG4gICAgICAgICAgICAvLyAoMS1iYXNlZCBpbmRleClcclxuICAgICAgICAgICAgaW5kZXggPSBpbmRleC52YWx1ZSAtIDE7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRJdGVtc0Zyb21Ob2RlKHZhbHVlcylbaW5kZXhdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGdldEl0ZW1zRnJvbU5vZGUodmFsdWVzKS5sZW5ndGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIExlc3MgbGlzdCBvZiBpbmNyZW1lbnRhbCB2YWx1ZXMuXHJcbiAgICAgICAgICogTW9kZWxlZCBhZnRlciBMb2Rhc2gncyByYW5nZSBmdW5jdGlvbiwgYWxzbyBleGlzdHMgbmF0aXZlbHkgaW4gUEhQXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0RpbWVuc2lvbn0gW3N0YXJ0PTFdXHJcbiAgICAgICAgICogQHBhcmFtIHtEaW1lbnNpb259IGVuZCAgLSBlLmcuIDEwIG9yIDEwcHggLSB1bml0IGlzIGFkZGVkIHRvIG91dHB1dFxyXG4gICAgICAgICAqIEBwYXJhbSB7RGltZW5zaW9ufSBbc3RlcD0xXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJhbmdlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCkge1xyXG4gICAgICAgICAgICB2YXIgZnJvbTtcclxuICAgICAgICAgICAgdmFyIHRvO1xyXG4gICAgICAgICAgICB2YXIgc3RlcFZhbHVlID0gMTtcclxuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdG8gPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBmcm9tID0gc3RhcnQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBWYWx1ZSA9IHN0ZXAudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tID0gMTtcclxuICAgICAgICAgICAgICAgIHRvID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPD0gdG8udmFsdWU7IGkgKz0gc3RlcFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gobmV3IERpbWVuc2lvbihpLCB0by51bml0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKGxpc3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGxpc3QsIHJzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbmV3UnVsZXM7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIHRyeUV2YWwgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZXZhbChfdGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChsaXN0LnZhbHVlICYmICEobGlzdCBpbnN0YW5jZW9mIFF1b3RlZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBsaXN0LnZhbHVlLm1hcCh0cnlFdmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gW3RyeUV2YWwobGlzdC52YWx1ZSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxpc3QucnVsZXNldCkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSB0cnlFdmFsKGxpc3QucnVsZXNldCkucnVsZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGlzdC5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBsaXN0LnJ1bGVzLm1hcCh0cnlFdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGxpc3QubWFwKHRyeUV2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBbdHJ5RXZhbChsaXN0KV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlTmFtZSA9ICdAdmFsdWUnO1xyXG4gICAgICAgICAgICB2YXIga2V5TmFtZSA9ICdAa2V5JztcclxuICAgICAgICAgICAgdmFyIGluZGV4TmFtZSA9ICdAaW5kZXgnO1xyXG4gICAgICAgICAgICBpZiAocnMucGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZU5hbWUgPSBycy5wYXJhbXNbMF0gJiYgcnMucGFyYW1zWzBdLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gcnMucGFyYW1zWzFdICYmIHJzLnBhcmFtc1sxXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhOYW1lID0gcnMucGFyYW1zWzJdICYmIHJzLnBhcmFtc1syXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgcnMgPSBycy5ydWxlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJzID0gcnMucnVsZXNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvcltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0eXBlb2YgaXRlbS5uYW1lID09PSAnc3RyaW5nJyA/IGl0ZW0ubmFtZSA6IGl0ZW0ubmFtZVswXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXcgRGltZW5zaW9uKGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld1J1bGVzID0gcnMucnVsZXMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UnVsZXMucHVzaChuZXcgRGVjbGFyYXRpb24odmFsdWVOYW1lLCB2YWx1ZSwgZmFsc2UsIGZhbHNlLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1J1bGVzLnB1c2gobmV3IERlY2xhcmF0aW9uKGluZGV4TmFtZSwgbmV3IERpbWVuc2lvbihpICsgMSksIGZhbHNlLCBmYWxzZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UnVsZXMucHVzaChuZXcgRGVjbGFyYXRpb24oa2V5TmFtZSwga2V5LCBmYWxzZSwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBydWxlcy5wdXNoKG5ldyBSdWxlc2V0KFtuZXcgKFNlbGVjdG9yKShbbmV3IEVsZW1lbnQoXCJcIiwgJyYnKV0pXSwgbmV3UnVsZXMsIHJzLnN0cmljdEltcG9ydHMsIHJzLnZpc2liaWxpdHlJbmZvKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bGVzZXQoW25ldyAoU2VsZWN0b3IpKFtuZXcgRWxlbWVudChcIlwiLCAnJicpXSldLCBydWxlcywgcnMuc3RyaWN0SW1wb3J0cywgcnMudmlzaWJpbGl0eUluZm8oKSkuZXZhbCh0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgTWF0aEhlbHBlciA9IGZ1bmN0aW9uIChmbiwgdW5pdCwgbikge1xyXG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XHJcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ2FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bml0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdW5pdCA9IG4udW5pdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnVuaWZ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGZuKHBhcnNlRmxvYXQobi52YWx1ZSkpLCB1bml0KTtcclxuICAgIH07XG5cbiAgICB2YXIgbWF0aEZ1bmN0aW9ucyA9IHtcclxuICAgICAgICAvLyBuYW1lLCAgdW5pdFxyXG4gICAgICAgIGNlaWw6IG51bGwsXHJcbiAgICAgICAgZmxvb3I6IG51bGwsXHJcbiAgICAgICAgc3FydDogbnVsbCxcclxuICAgICAgICBhYnM6IG51bGwsXHJcbiAgICAgICAgdGFuOiAnJyxcclxuICAgICAgICBzaW46ICcnLFxyXG4gICAgICAgIGNvczogJycsXHJcbiAgICAgICAgYXRhbjogJ3JhZCcsXHJcbiAgICAgICAgYXNpbjogJ3JhZCcsXHJcbiAgICAgICAgYWNvczogJ3JhZCdcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBmJDEgaW4gbWF0aEZ1bmN0aW9ucykge1xyXG4gICAgICAgIGlmIChtYXRoRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGYkMSkpIHtcclxuICAgICAgICAgICAgbWF0aEZ1bmN0aW9uc1tmJDFdID0gTWF0aEhlbHBlci5iaW5kKG51bGwsIE1hdGhbZiQxXSwgbWF0aEZ1bmN0aW9uc1tmJDFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRoRnVuY3Rpb25zLnJvdW5kID0gZnVuY3Rpb24gKG4sIGYpIHtcclxuICAgICAgICB2YXIgZnJhY3Rpb24gPSB0eXBlb2YgZiA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogZi52YWx1ZTtcclxuICAgICAgICByZXR1cm4gTWF0aEhlbHBlcihmdW5jdGlvbiAobnVtKSB7IHJldHVybiBudW0udG9GaXhlZChmcmFjdGlvbik7IH0sIG51bGwsIG4pO1xyXG4gICAgfTtcblxuICAgIHZhciBtaW5NYXggPSBmdW5jdGlvbiAoaXNNaW4sIGFyZ3MpIHtcclxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XHJcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6IHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ29uZSBvciBtb3JlIGFyZ3VtZW50cyByZXF1aXJlZCcgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGk7IC8vIGtleSBpcyB0aGUgdW5pdC50b1N0cmluZygpIGZvciB1bmlmaWVkIERpbWVuc2lvbiB2YWx1ZXMsXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQ7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRVbmlmaWVkO1xyXG4gICAgICAgIHZhciByZWZlcmVuY2VVbmlmaWVkO1xyXG4gICAgICAgIHZhciB1bml0O1xyXG4gICAgICAgIHZhciB1bml0U3RhdGljO1xyXG4gICAgICAgIHZhciB1bml0Q2xvbmU7XHJcbiAgICAgICAgdmFyIC8vIGVsZW1zIG9ubHkgY29udGFpbnMgb3JpZ2luYWwgYXJndW1lbnQgdmFsdWVzLlxyXG4gICAgICAgIG9yZGVyID0gW107XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9O1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHRoZSBpbmRleCBpbnRvIHRoZSBvcmRlciBhcnJheS5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgaWYgKCEoY3VycmVudCBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbaV0udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJnc1tpXS52YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudFVuaWZpZWQgPSBjdXJyZW50LnVuaXQudG9TdHJpbmcoKSA9PT0gJycgJiYgdW5pdENsb25lICE9PSB1bmRlZmluZWQgPyBuZXcgRGltZW5zaW9uKGN1cnJlbnQudmFsdWUsIHVuaXRDbG9uZSkudW5pZnkoKSA6IGN1cnJlbnQudW5pZnkoKTtcclxuICAgICAgICAgICAgdW5pdCA9IGN1cnJlbnRVbmlmaWVkLnVuaXQudG9TdHJpbmcoKSA9PT0gJycgJiYgdW5pdFN0YXRpYyAhPT0gdW5kZWZpbmVkID8gdW5pdFN0YXRpYyA6IGN1cnJlbnRVbmlmaWVkLnVuaXQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdW5pdFN0YXRpYyA9IHVuaXQgIT09ICcnICYmIHVuaXRTdGF0aWMgPT09IHVuZGVmaW5lZCB8fCB1bml0ICE9PSAnJyAmJiBvcmRlclswXS51bmlmeSgpLnVuaXQudG9TdHJpbmcoKSA9PT0gJycgPyB1bml0IDogdW5pdFN0YXRpYztcclxuICAgICAgICAgICAgdW5pdENsb25lID0gdW5pdCAhPT0gJycgJiYgdW5pdENsb25lID09PSB1bmRlZmluZWQgPyBjdXJyZW50LnVuaXQudG9TdHJpbmcoKSA6IHVuaXRDbG9uZTtcclxuICAgICAgICAgICAgaiA9IHZhbHVlc1snJ10gIT09IHVuZGVmaW5lZCAmJiB1bml0ICE9PSAnJyAmJiB1bml0ID09PSB1bml0U3RhdGljID8gdmFsdWVzWycnXSA6IHZhbHVlc1t1bml0XTtcclxuICAgICAgICAgICAgaWYgKGogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXRTdGF0aWMgIT09IHVuZGVmaW5lZCAmJiB1bml0ICE9PSB1bml0U3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLCBtZXNzYWdlOiAnaW5jb21wYXRpYmxlIHR5cGVzJyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWVzW3VuaXRdID0gb3JkZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZmVyZW5jZVVuaWZpZWQgPSBvcmRlcltqXS51bml0LnRvU3RyaW5nKCkgPT09ICcnICYmIHVuaXRDbG9uZSAhPT0gdW5kZWZpbmVkID8gbmV3IERpbWVuc2lvbihvcmRlcltqXS52YWx1ZSwgdW5pdENsb25lKS51bmlmeSgpIDogb3JkZXJbal0udW5pZnkoKTtcclxuICAgICAgICAgICAgaWYgKGlzTWluICYmIGN1cnJlbnRVbmlmaWVkLnZhbHVlIDwgcmVmZXJlbmNlVW5pZmllZC52YWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgIWlzTWluICYmIGN1cnJlbnRVbmlmaWVkLnZhbHVlID4gcmVmZXJlbmNlVW5pZmllZC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgb3JkZXJbal0gPSBjdXJyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmRlci5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JkZXJbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFyZ3MgPSBvcmRlci5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudG9DU1ModGhpcy5jb250ZXh0KTsgfSkuam9pbih0aGlzLmNvbnRleHQuY29tcHJlc3MgPyAnLCcgOiAnLCAnKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFub255bW91cygoaXNNaW4gPyAnbWluJyA6ICdtYXgnKSArIFwiKFwiICsgYXJncyArIFwiKVwiKTtcclxuICAgIH07XHJcbiAgICB2YXIgbnVtYmVyJDEgPSB7XHJcbiAgICAgICAgbWluOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaW5NYXgodHJ1ZSwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaW5NYXgoZmFsc2UsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh2YWwsIHVuaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbC5jb252ZXJ0VG8odW5pdC52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwaTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihNYXRoLlBJKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vZDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oYS52YWx1ZSAlIGIudmFsdWUsIGEudW5pdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb3c6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gbmV3IERpbWVuc2lvbih4KTtcclxuICAgICAgICAgICAgICAgIHkgPSBuZXcgRGltZW5zaW9uKHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCEoeCBpbnN0YW5jZW9mIERpbWVuc2lvbikgfHwgISh5IGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLCBtZXNzYWdlOiAnYXJndW1lbnRzIG11c3QgYmUgbnVtYmVycycgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihNYXRoLnBvdyh4LnZhbHVlLCB5LnZhbHVlKSwgeC51bml0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBlcmNlbnRhZ2U6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBNYXRoSGVscGVyKGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuIG51bSAqIDEwMDsgfSwgJyUnLCBuKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIHN0cmluZyA9IHtcclxuICAgICAgICBlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVvdGVkKCdcIicsIHN0ciBpbnN0YW5jZW9mIEphdmFTY3JpcHQgPyBzdHIuZXZhbHVhdGVkIDogc3RyLnZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVzY2FwZTogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhlbmNvZGVVUkkoc3RyLnZhbHVlKS5yZXBsYWNlKC89L2csICclM0QnKS5yZXBsYWNlKC86L2csICclM0EnKS5yZXBsYWNlKC8jL2csICclMjMnKS5yZXBsYWNlKC87L2csICclM0InKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoc3RyaW5nLCBwYXR0ZXJuLCByZXBsYWNlbWVudCwgZmxhZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZy52YWx1ZTtcclxuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAocmVwbGFjZW1lbnQudHlwZSA9PT0gJ1F1b3RlZCcpID9cclxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnZhbHVlIDogcmVwbGFjZW1lbnQudG9DU1MoKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLnZhbHVlLCBmbGFncyA/IGZsYWdzLnZhbHVlIDogJycpLCByZXBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHN0cmluZy5xdW90ZSB8fCAnJywgcmVzdWx0LCBzdHJpbmcuZXNjYXBlZCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnJSc6IGZ1bmN0aW9uIChzdHJpbmcgLyogYXJnLCBhcmcsIC4uLiAqLykge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvJVtzZGFdL2ksIGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICgoYXJnc1tpXS50eXBlID09PSAnUXVvdGVkJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2goL3MvaSkpID8gYXJnc1tpXS52YWx1ZSA6IGFyZ3NbaV0udG9DU1MoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubWF0Y2goL1tBLVpdJC8pID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMShpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvJSUvZywgJyUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdW90ZWQoc3RyaW5nLnF1b3RlIHx8ICcnLCByZXN1bHQsIHN0cmluZy5lc2NhcGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIHN2ZyA9IChmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcclxuICAgICAgICByZXR1cm4geyAnc3ZnLWdyYWRpZW50JzogZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3BzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50RGlyZWN0aW9uU3ZnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50VHlwZSA9ICdsaW5lYXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RhbmdsZURpbWVuc2lvbiA9ICd4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiJztcclxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJFbnYgPSB7IGNvbXByZXNzOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHVybmVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblZhbHVlID0gZGlyZWN0aW9uLnRvQ1NTKHJlbmRlckVudik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xvcjtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnc3ZnLWdyYWRpZW50IGV4cGVjdHMgZGlyZWN0aW9uLCBzdGFydF9jb2xvciBbc3RhcnRfcG9zaXRpb25dLCBbY29sb3IgcG9zaXRpb24sXS4uLiwnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgZW5kX2NvbG9yIFtlbmRfcG9zaXRpb25dIG9yIGRpcmVjdGlvbiwgY29sb3IgbGlzdCcgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzFdLnZhbHVlLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcHMgPSBhcmd1bWVudHNbMV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvblZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG8gYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAneDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0byByaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIxMDAlXCIgeTI9XCIwJVwiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG8gYm90dG9tIHJpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAneDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjEwMCVcIiB5Mj1cIjEwMCVcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvIHRvcCByaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjEwMCVcIiB4Mj1cIjEwMCVcIiB5Mj1cIjAlXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdlbGxpcHNlJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdlbGxpcHNlIGF0IGNlbnRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdyYWRpYWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudERpcmVjdGlvblN2ZyA9ICdjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjc1JVwiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlRGltZW5zaW9uID0gJ3g9XCItNTBcIiB5PVwiLTUwXCIgd2lkdGg9XCIxMDFcIiBoZWlnaHQ9XCIxMDFcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ3N2Zy1ncmFkaWVudCBkaXJlY3Rpb24gbXVzdCBiZSBcXCd0byBib3R0b21cXCcsIFxcJ3RvIHJpZ2h0XFwnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgXFwndG8gYm90dG9tIHJpZ2h0XFwnLCBcXCd0byB0b3AgcmlnaHRcXCcgb3IgXFwnZWxsaXBzZSBhdCBjZW50ZXJcXCcnIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm5lciA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAxIDFcXFwiPjxcIiArIGdyYWRpZW50VHlwZSArIFwiR3JhZGllbnQgaWQ9XFxcImdcXFwiIFwiICsgZ3JhZGllbnREaXJlY3Rpb25TdmcgKyBcIj5cIjtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wc1tpXSBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdG9wc1tpXS52YWx1ZVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzdG9wc1tpXS52YWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3RvcHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSB8fCAoISgoaSA9PT0gMCB8fCBpICsgMSA9PT0gc3RvcHMubGVuZ3RoKSAmJiBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSAmJiAhKHBvc2l0aW9uIGluc3RhbmNlb2YgRGltZW5zaW9uKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dBcmd1bWVudERlc2NyaXB0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25WYWx1ZSA9IHBvc2l0aW9uID8gcG9zaXRpb24udG9DU1MocmVuZGVyRW52KSA6IGkgPT09IDAgPyAnMCUnIDogJzEwMCUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gY29sb3IuYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIgKz0gXCI8c3RvcCBvZmZzZXQ9XFxcIlwiICsgcG9zaXRpb25WYWx1ZSArIFwiXFxcIiBzdG9wLWNvbG9yPVxcXCJcIiArIGNvbG9yLnRvUkdCKCkgKyBcIlxcXCJcIiArIChhbHBoYSA8IDEgPyBcIiBzdG9wLW9wYWNpdHk9XFxcIlwiICsgYWxwaGEgKyBcIlxcXCJcIiA6ICcnKSArIFwiLz5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybmVyICs9IFwiPC9cIiArIGdyYWRpZW50VHlwZSArIFwiR3JhZGllbnQ+PHJlY3QgXCIgKyByZWN0YW5nbGVEaW1lbnNpb24gKyBcIiBmaWxsPVxcXCJ1cmwoI2cpXFxcIiAvPjwvc3ZnPlwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuZXIgPSBlbmNvZGVVUklDb21wb25lbnQocmV0dXJuZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuZXIgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIHJldHVybmVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwobmV3IFF1b3RlZChcIidcIiArIHJldHVybmVyICsgXCInXCIsIHJldHVybmVyLCBmYWxzZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbyk7XHJcbiAgICAgICAgICAgIH0gfTtcclxuICAgIH0pO1xuXG4gICAgdmFyIGlzYSA9IGZ1bmN0aW9uIChuLCBUeXBlKSB7IHJldHVybiAobiBpbnN0YW5jZW9mIFR5cGUpID8gS2V5d29yZC5UcnVlIDogS2V5d29yZC5GYWxzZTsgfTtcclxuICAgIHZhciBpc3VuaXQgPSBmdW5jdGlvbiAobiwgdW5pdCkge1xyXG4gICAgICAgIGlmICh1bml0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnQXJndW1lbnQnLCBtZXNzYWdlOiAnbWlzc2luZyB0aGUgcmVxdWlyZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGlzdW5pdC4nIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaXQgPSB0eXBlb2YgdW5pdC52YWx1ZSA9PT0gJ3N0cmluZycgPyB1bml0LnZhbHVlIDogdW5pdDtcclxuICAgICAgICBpZiAodHlwZW9mIHVuaXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ1NlY29uZCBhcmd1bWVudCB0byBpc3VuaXQgc2hvdWxkIGJlIGEgdW5pdCBvciBhIHN0cmluZy4nIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAobiBpbnN0YW5jZW9mIERpbWVuc2lvbikgJiYgbi51bml0LmlzKHVuaXQpID8gS2V5d29yZC5UcnVlIDogS2V5d29yZC5GYWxzZTtcclxuICAgIH07XHJcbiAgICB2YXIgdHlwZXMgPSB7XHJcbiAgICAgICAgaXNydWxlc2V0OiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNhKG4sIERldGFjaGVkUnVsZXNldCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc2NvbG9yOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNhKG4sIENvbG9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzbnVtYmVyOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNhKG4sIERpbWVuc2lvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc3N0cmluZzogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzYShuLCBRdW90ZWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNrZXl3b3JkOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNhKG4sIEtleXdvcmQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXN1cmw6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc2EobiwgVVJMKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzcGl4ZWw6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc3VuaXQobiwgJ3B4Jyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc3BlcmNlbnRhZ2U6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc3VuaXQobiwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzZW06IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc3VuaXQobiwgJ2VtJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc3VuaXQ6IGlzdW5pdCxcclxuICAgICAgICB1bml0OiBmdW5jdGlvbiAodmFsLCB1bml0KSB7XHJcbiAgICAgICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogXCJ0aGUgZmlyc3QgYXJndW1lbnQgdG8gdW5pdCBtdXN0IGJlIGEgbnVtYmVyXCIgKyAodmFsIGluc3RhbmNlb2YgT3BlcmF0aW9uID8gJy4gSGF2ZSB5b3UgZm9yZ290dGVuIHBhcmVudGhlc2lzPycgOiAnJykgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBLZXl3b3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHVuaXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1bml0ID0gdW5pdC50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHZhbC52YWx1ZSwgdW5pdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnZ2V0LXVuaXQnOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhuLnVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgZnVuY3Rpb25zID0gKGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIHZhciBmdW5jdGlvbnMgPSB7IGZ1bmN0aW9uUmVnaXN0cnk6IGZ1bmN0aW9uUmVnaXN0cnksIGZ1bmN0aW9uQ2FsbGVyOiBmdW5jdGlvbkNhbGxlciB9O1xyXG4gICAgICAgIC8vIHJlZ2lzdGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoYm9vbGVhbiQxKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZCgnZGVmYXVsdCcsIGRlZmF1bHRGdW5jLmV2YWwuYmluZChkZWZhdWx0RnVuYykpO1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoY29sb3IpO1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoY29sb3JCbGVuZCk7XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShkYXRhVXJpKGVudmlyb25tZW50KSk7XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShsaXN0KTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKG1hdGhGdW5jdGlvbnMpO1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUobnVtYmVyJDEpO1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoc3RyaW5nKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHN2ZygpKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHR5cGVzKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb25zO1xyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1UcmVlIChyb290LCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIGV2YWxkUm9vdDtcclxuICAgICAgICB2YXIgdmFyaWFibGVzID0gb3B0aW9ucy52YXJpYWJsZXM7XHJcbiAgICAgICAgdmFyIGV2YWxFbnYgPSBuZXcgY29udGV4dHMuRXZhbChvcHRpb25zKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEFsbG93cyBzZXR0aW5nIHZhcmlhYmxlcyB3aXRoIGEgaGFzaCwgc286XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgIGB7IGNvbG9yOiBuZXcgdHJlZS5Db2xvcignI2YwMScpIH1gIHdpbGwgYmVjb21lOlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICBuZXcgdHJlZS5EZWNsYXJhdGlvbignQGNvbG9yJyxcclxuICAgICAgICAvLyAgICAgbmV3IHRyZWUuVmFsdWUoW1xyXG4gICAgICAgIC8vICAgICAgIG5ldyB0cmVlLkV4cHJlc3Npb24oW1xyXG4gICAgICAgIC8vICAgICAgICAgbmV3IHRyZWUuQ29sb3IoJyNmMDEnKVxyXG4gICAgICAgIC8vICAgICAgIF0pXHJcbiAgICAgICAgLy8gICAgIF0pXHJcbiAgICAgICAgLy8gICApXHJcbiAgICAgICAgLy9cclxuICAgICAgICBpZiAodHlwZW9mIHZhcmlhYmxlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFyaWFibGVzKSkge1xyXG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBPYmplY3Qua2V5cyh2YXJpYWJsZXMpLm1hcChmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFyaWFibGVzW2tdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiB0cmVlLlZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHJlZS5FeHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyB0cmVlLkV4cHJlc3Npb24oW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IHRyZWUuVmFsdWUoW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGVjbGFyYXRpb24oXCJAXCIgKyBrLCB2YWx1ZSwgZmFsc2UsIG51bGwsIDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZXZhbEVudi5mcmFtZXMgPSBbbmV3IHRyZWUuUnVsZXNldChudWxsLCB2YXJpYWJsZXMpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZpc2l0b3JzJDEgPSBbXHJcbiAgICAgICAgICAgIG5ldyB2aXNpdG9ycy5Kb2luU2VsZWN0b3JWaXNpdG9yKCksXHJcbiAgICAgICAgICAgIG5ldyB2aXNpdG9ycy5NYXJrVmlzaWJsZVNlbGVjdG9yc1Zpc2l0b3IodHJ1ZSksXHJcbiAgICAgICAgICAgIG5ldyB2aXNpdG9ycy5FeHRlbmRWaXNpdG9yKCksXHJcbiAgICAgICAgICAgIG5ldyB2aXNpdG9ycy5Ub0NTU1Zpc2l0b3IoeyBjb21wcmVzczogQm9vbGVhbihvcHRpb25zLmNvbXByZXNzKSB9KVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIHByZUV2YWxWaXNpdG9ycyA9IFtdO1xyXG4gICAgICAgIHZhciB2O1xyXG4gICAgICAgIHZhciB2aXNpdG9ySXRlcmF0b3I7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZmlyc3QoKSAvIGdldCgpIGFsbG93cyB2aXNpdG9ycyB0byBiZSBhZGRlZCB3aGlsZSB2aXNpdGluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHRvZG8gQWRkIHNjb3BpbmcgZm9yIHZpc2l0b3JzIGp1c3QgbGlrZSBmdW5jdGlvbnMgZm9yIEBwbHVnaW47IHJpZ2h0IG5vdyB0aGV5J3JlIGdsb2JhbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcclxuICAgICAgICAgICAgdmlzaXRvckl0ZXJhdG9yID0gb3B0aW9ucy5wbHVnaW5NYW5hZ2VyLnZpc2l0b3IoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0b3JJdGVyYXRvci5maXJzdCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCh2ID0gdmlzaXRvckl0ZXJhdG9yLmdldCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmlzUHJlRXZhbFZpc2l0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgcHJlRXZhbFZpc2l0b3JzLmluZGV4T2YodikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVFdmFsVmlzaXRvcnMucHVzaCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYucnVuKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCB2aXNpdG9ycyQxLmluZGV4T2YodikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5pc1ByZVZpc2l0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdG9ycyQxLnVuc2hpZnQodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdG9ycyQxLnB1c2godik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZhbGRSb290ID0gcm9vdC5ldmFsKGV2YWxFbnYpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaXRvcnMkMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2aXNpdG9ycyQxW2ldLnJ1bihldmFsZFJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSdW4gYW55IHJlbWFpbmluZyB2aXNpdG9ycyBhZGRlZCBhZnRlciBldmFsIHBhc3NcclxuICAgICAgICBpZiAob3B0aW9ucy5wbHVnaW5NYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHZpc2l0b3JJdGVyYXRvci5maXJzdCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAoKHYgPSB2aXNpdG9ySXRlcmF0b3IuZ2V0KCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRvcnMkMS5pbmRleE9mKHYpID09PSAtMSAmJiBwcmVFdmFsVmlzaXRvcnMuaW5kZXhPZih2KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LnJ1bihldmFsZFJvb3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmFsZFJvb3Q7XHJcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIFBsdWdpbiBNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHZhciBQbHVnaW5NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFBsdWdpbk1hbmFnZXIobGVzcykge1xyXG4gICAgICAgICAgICB0aGlzLmxlc3MgPSBsZXNzO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2l0b3JzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMucHJlUHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFsbGVkUGx1Z2lucyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luQ2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5Mb2FkZXIgPSBuZXcgbGVzcy5QbHVnaW5Mb2FkZXIobGVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYWxsIHRoZSBwbHVnaW5zIGluIHRoZSBhcnJheVxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHBsdWdpbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQbHVnaW5zID0gZnVuY3Rpb24gKHBsdWdpbnMpIHtcclxuICAgICAgICAgICAgaWYgKHBsdWdpbnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGx1Z2luKHBsdWdpbnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBwbHVnaW5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luLCBmaWxlbmFtZSwgZnVuY3Rpb25SZWdpc3RyeSkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xyXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luQ2FjaGVbZmlsZW5hbWVdID0gcGx1Z2luO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW4uaW5zdGFsbCkge1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwodGhpcy5sZXNzLCB0aGlzLCBmdW5jdGlvblJlZ2lzdHJ5IHx8IHRoaXMubGVzcy5mdW5jdGlvbnMuZnVuY3Rpb25SZWdpc3RyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGZpbGVuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbkNhY2hlW2ZpbGVuYW1lXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSB2aXNpdG9yLiBUaGUgdmlzaXRvciBvYmplY3QgaGFzIG9wdGlvbnMgb24gaXRzZWxmIHRvIGRldGVybWluZVxyXG4gICAgICAgICAqIHdoZW4gaXQgc2hvdWxkIHJ1bi5cclxuICAgICAgICAgKiBAcGFyYW0gdmlzaXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFZpc2l0b3IgPSBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnZpc2l0b3JzLnB1c2godmlzaXRvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgcHJlIHByb2Nlc3NvciBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlUHJvY2Vzc29yXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IC0gZ3VpZGVsaW5lcyAxID0gYmVmb3JlIGltcG9ydCwgMTAwMCA9IGltcG9ydCwgMjAwMCA9IGFmdGVyIGltcG9ydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFByZVByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcmVQcm9jZXNzb3IsIHByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleFRvSW5zZXJ0QXQ7XHJcbiAgICAgICAgICAgIGZvciAoaW5kZXhUb0luc2VydEF0ID0gMDsgaW5kZXhUb0luc2VydEF0IDwgdGhpcy5wcmVQcm9jZXNzb3JzLmxlbmd0aDsgaW5kZXhUb0luc2VydEF0KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZVByb2Nlc3NvcnNbaW5kZXhUb0luc2VydEF0XS5wcmlvcml0eSA+PSBwcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJlUHJvY2Vzc29ycy5zcGxpY2UoaW5kZXhUb0luc2VydEF0LCAwLCB7IHByZVByb2Nlc3NvcjogcHJlUHJvY2Vzc29yLCBwcmlvcml0eTogcHJpb3JpdHkgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgcG9zdCBwcm9jZXNzb3Igb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBvc3RQcm9jZXNzb3JcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHkgLSBndWlkZWxpbmVzIDEgPSBiZWZvcmUgY29tcHJlc3Npb24sIDEwMDAgPSBjb21wcmVzc2lvbiwgMjAwMCA9IGFmdGVyIGNvbXByZXNzaW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkUG9zdFByb2Nlc3NvciA9IGZ1bmN0aW9uIChwb3N0UHJvY2Vzc29yLCBwcmlvcml0eSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXhUb0luc2VydEF0O1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4VG9JbnNlcnRBdCA9IDA7IGluZGV4VG9JbnNlcnRBdCA8IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoOyBpbmRleFRvSW5zZXJ0QXQrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zdFByb2Nlc3NvcnNbaW5kZXhUb0luc2VydEF0XS5wcmlvcml0eSA+PSBwcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnMuc3BsaWNlKGluZGV4VG9JbnNlcnRBdCwgMCwgeyBwb3N0UHJvY2Vzc29yOiBwb3N0UHJvY2Vzc29yLCBwcmlvcml0eTogcHJpb3JpdHkgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBtYW5hZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkRmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAobWFuYWdlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2Vycy5wdXNoKG1hbmFnZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRQcmVQcm9jZXNzb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJlUHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJlUHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcHJlUHJvY2Vzc29ycy5wdXNoKHRoaXMucHJlUHJvY2Vzc29yc1tpXS5wcmVQcm9jZXNzb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVQcm9jZXNzb3JzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRQb3N0UHJvY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBvc3RQcm9jZXNzb3JzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcG9zdFByb2Nlc3NvcnMucHVzaCh0aGlzLnBvc3RQcm9jZXNzb3JzW2ldLnBvc3RQcm9jZXNzb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwb3N0UHJvY2Vzc29ycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0VmlzaXRvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0b3JzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUudmlzaXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLml0ZXJhdG9yID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudmlzaXRvcnNbc2VsZi5pdGVyYXRvcl07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pdGVyYXRvciArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnZpc2l0b3JzW3NlbGYuaXRlcmF0b3JdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRGaWxlTWFuYWdlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVNYW5hZ2VycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQbHVnaW5NYW5hZ2VyO1xyXG4gICAgfSgpKTtcclxuICAgIHZhciBwbTtcclxuICAgIHZhciBQbHVnaW5NYW5hZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChsZXNzLCBuZXdGYWN0b3J5KSB7XHJcbiAgICAgICAgaWYgKG5ld0ZhY3RvcnkgfHwgIXBtKSB7XHJcbiAgICAgICAgICAgIHBtID0gbmV3IFBsdWdpbk1hbmFnZXIobGVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbTtcclxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBPdXRwdXQgKGVudmlyb25tZW50KSB7XHJcbiAgICAgICAgdmFyIFNvdXJjZU1hcE91dHB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU291cmNlTWFwT3V0cHV0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NzcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGUgPSBvcHRpb25zLnJvb3ROb2RlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudHNNYXAgPSBvcHRpb25zLmNvbnRlbnRzTWFwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXAgPSBvcHRpb25zLmNvbnRlbnRzSWdub3JlZENoYXJzTWFwO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwRmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBGaWxlbmFtZSA9IG9wdGlvbnMuc291cmNlTWFwRmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0RmlsZW5hbWUgPSBvcHRpb25zLm91dHB1dEZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXBVUkwgPSBvcHRpb25zLnNvdXJjZU1hcFVSTDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwQmFzZXBhdGggPSBvcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFJvb3RwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwUm9vdHBhdGggPSBvcHRpb25zLnNvdXJjZU1hcFJvb3RwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlTWFwUm9vdHBhdGguY2hhckF0KHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwUm9vdHBhdGggKz0gJy8nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRTb3VyY2VGaWxlcyA9IG9wdGlvbnMub3V0cHV0U291cmNlRmlsZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3JDb25zdHJ1Y3RvciA9IGVudmlyb25tZW50LmdldFNvdXJjZU1hcEdlbmVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU51bWJlciA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcE91dHB1dC5wcm90b3R5cGUucmVtb3ZlQmFzZXBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZU1hcEJhc2VwYXRoICYmIHBhdGguaW5kZXhPZih0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcodGhpcy5fc291cmNlTWFwQmFzZXBhdGgubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICdcXFxcJyB8fCBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5ub3JtYWxpemVGaWxlbmFtZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHRoaXMucmVtb3ZlQmFzZXBhdGgoZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9zb3VyY2VNYXBSb290cGF0aCB8fCAnJykgKyBmaWxlbmFtZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY2h1bmssIGZpbGVJbmZvLCBpbmRleCwgbWFwTGluZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBhZGRpbmcgZW1wdHkgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsaW5lcywgc291cmNlTGluZXMsIGNvbHVtbnMsIHNvdXJjZUNvbHVtbnMsIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUluZm8gJiYgZmlsZUluZm8uZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRTb3VyY2UgPSB0aGlzLl9jb250ZW50c01hcFtmaWxlSW5mby5maWxlbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHZhcnMvYmFubmVyIGFkZGVkIHRvIHRoZSB0b3Agb2YgdGhlIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZUluZm8uZmlsZW5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gdGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZUluZm8uZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBzb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRTb3VyY2UgPSBpbnB1dFNvdXJjZS5zbGljZSh0aGlzLl9jb250ZW50c0lnbm9yZWRDaGFyc01hcFtmaWxlSW5mby5maWxlbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBpZ25vcmUgZW1wdHkgY29udGVudCwgb3IgZmFpbHNhZmVcclxuICAgICAgICAgICAgICAgICAgICAgKiBpZiBjb250ZW50cyBtYXAgaXMgaW5jb3JyZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U291cmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3NzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0U291cmNlID0gaW5wdXRTb3VyY2Uuc3Vic3RyaW5nKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VMaW5lcyA9IGlucHV0U291cmNlLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2x1bW5zID0gc291cmNlTGluZXNbc291cmNlTGluZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaW5lcyA9IGNodW5rLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxlSW5mbyAmJiBmaWxlSW5mby5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFwTGluZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLmFkZE1hcHBpbmcoeyBnZW5lcmF0ZWQ6IHsgbGluZTogdGhpcy5fbGluZU51bWJlciArIDEsIGNvbHVtbjogdGhpcy5fY29sdW1uIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogeyBsaW5lOiBzb3VyY2VMaW5lcy5sZW5ndGgsIGNvbHVtbjogc291cmNlQ29sdW1ucy5sZW5ndGggfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5ub3JtYWxpemVGaWxlbmFtZShmaWxlSW5mby5maWxlbmFtZSkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcEdlbmVyYXRvci5hZGRNYXBwaW5nKHsgZ2VuZXJhdGVkOiB7IGxpbmU6IHRoaXMuX2xpbmVOdW1iZXIgKyBpICsgMSwgY29sdW1uOiBpID09PSAwID8gdGhpcy5fY29sdW1uIDogMCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB7IGxpbmU6IHNvdXJjZUxpbmVzLmxlbmd0aCArIGksIGNvbHVtbjogaSA9PT0gMCA/IHNvdXJjZUNvbHVtbnMubGVuZ3RoIDogMCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5ub3JtYWxpemVGaWxlbmFtZShmaWxlSW5mby5maWxlbmFtZSkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sdW1uICs9IGNvbHVtbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU51bWJlciArPSBsaW5lcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IGNvbHVtbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3NzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3NzLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IgPSBuZXcgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yQ29uc3RydWN0b3IoeyBmaWxlOiB0aGlzLl9vdXRwdXRGaWxlbmFtZSwgc291cmNlUm9vdDogbnVsbCB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vdXRwdXRTb3VyY2VGaWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZpbGVuYW1lIGluIHRoaXMuX2NvbnRlbnRzTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZW50c01hcC5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9jb250ZW50c01hcFtmaWxlbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZW5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlLnNsaWNlKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudCh0aGlzLm5vcm1hbGl6ZUZpbGVuYW1lKGZpbGVuYW1lKSwgc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlLmdlbkNTUyhjb250ZXh0LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jc3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBVUkwgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IudG9KU09OKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcFVSTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkwgPSB0aGlzLnNvdXJjZU1hcFVSTDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc291cmNlTWFwRmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwVVJMID0gdGhpcy5fc291cmNlTWFwRmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwVVJMO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwQ29udGVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jc3Muam9pbignJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTb3VyY2VNYXBPdXRwdXQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICByZXR1cm4gU291cmNlTWFwT3V0cHV0O1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU291cmNlTWFwQnVpbGRlciAoU291cmNlTWFwT3V0cHV0LCBlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIHZhciBTb3VyY2VNYXBCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTb3VyY2VNYXBCdWlsZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbiAocm9vdE5vZGUsIG9wdGlvbnMsIGltcG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBPdXRwdXQgPSBuZXcgU291cmNlTWFwT3V0cHV0KHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50c0lnbm9yZWRDaGFyc01hcDogaW1wb3J0cy5jb250ZW50c0lnbm9yZWRDaGFycyxcclxuICAgICAgICAgICAgICAgICAgICByb290Tm9kZTogcm9vdE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNNYXA6IGltcG9ydHMuY29udGVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwRmlsZW5hbWU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBVUkw6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBVUkwsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0RmlsZW5hbWU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBPdXRwdXRGaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBCYXNlcGF0aDogdGhpcy5vcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcFJvb3RwYXRoOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwUm9vdHBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U291cmNlRmlsZXM6IHRoaXMub3B0aW9ucy5vdXRwdXRTb3VyY2VGaWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBHZW5lcmF0b3I6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBHZW5lcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwRmlsZUlubGluZTogdGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVNvdXJjZW1hcEFubm90YXRpb246IHRoaXMub3B0aW9ucy5kaXNhYmxlU291cmNlbWFwQW5ub3RhdGlvblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3NzID0gc291cmNlTWFwT3V0cHV0LnRvQ1NTKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXAgPSBzb3VyY2VNYXBPdXRwdXQuc291cmNlTWFwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXBVUkwgPSBzb3VyY2VNYXBPdXRwdXQuc291cmNlTWFwVVJMO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VNYXBJbnB1dEZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXBJbnB1dEZpbGVuYW1lID0gc291cmNlTWFwT3V0cHV0Lm5vcm1hbGl6ZUZpbGVuYW1lKHRoaXMub3B0aW9ucy5zb3VyY2VNYXBJbnB1dEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlTWFwQmFzZXBhdGggIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNvdXJjZU1hcFVSTCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXBVUkwgPSBzb3VyY2VNYXBPdXRwdXQucmVtb3ZlQmFzZXBhdGgodGhpcy5zb3VyY2VNYXBVUkwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzcyArIHRoaXMuZ2V0Q1NTQXBwZW5kYWdlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldENTU0FwcGVuZGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBVUkwgPSB0aGlzLnNvdXJjZU1hcFVSTDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlTWFwRmlsZUlubGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwVVJMID0gXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgZW52aXJvbm1lbnQuZW5jb2RlQmFzZTY0KHRoaXMuc291cmNlTWFwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZVNvdXJjZW1hcEFubm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlTWFwVVJMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBzb3VyY2VNYXBVUkwgKyBcIiAqL1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRFeHRlcm5hbFNvdXJjZU1hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hcDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuc2V0RXh0ZXJuYWxTb3VyY2VNYXAgPSBmdW5jdGlvbiAoc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZU1hcCA9IHNvdXJjZU1hcDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuaXNJbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldFNvdXJjZU1hcFVSTCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hcFVSTDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0T3V0cHV0RmlsZW5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZU1hcE91dHB1dEZpbGVuYW1lO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dEZpbGVuYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwSW5wdXRGaWxlbmFtZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEJ1aWxkZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICByZXR1cm4gU291cmNlTWFwQnVpbGRlcjtcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhcnNlVHJlZSAoU291cmNlTWFwQnVpbGRlcikge1xyXG4gICAgICAgIHZhciBQYXJzZVRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhcnNlVHJlZShyb290LCBpbXBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzID0gaW1wb3J0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQYXJzZVRyZWUucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmFsZFJvb3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwQnVpbGRlcjtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZhbGRSb290ID0gdHJhbnNmb3JtVHJlZSh0aGlzLnJvb3QsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKGUsIHRoaXMuaW1wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wcmVzcyA9IEJvb2xlYW4ob3B0aW9ucy5jb21wcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdUaGUgY29tcHJlc3Mgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1dlIHJlY29tbWVuZCB5b3UgdXNlIGEgZGVkaWNhdGVkIGNzcyBtaW5pZmllciwgZm9yIGluc3RhbmNlIHNlZSBsZXNzLXBsdWdpbi1jbGVhbi1jc3MuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b0NTU09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzOiBjb21wcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtcExpbmVOdW1iZXJzOiBvcHRpb25zLmR1bXBMaW5lTnVtYmVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0VW5pdHM6IEJvb2xlYW4ob3B0aW9ucy5zdHJpY3RVbml0cyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVByZWNpc2lvbjogOFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcEJ1aWxkZXIgPSBuZXcgU291cmNlTWFwQnVpbGRlcihvcHRpb25zLnNvdXJjZU1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBzb3VyY2VNYXBCdWlsZGVyLnRvQ1NTKGV2YWxkUm9vdCwgdG9DU1NPcHRpb25zLCB0aGlzLmltcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNzcyA9IGV2YWxkUm9vdC50b0NTUyh0b0NTU09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcihlLCB0aGlzLmltcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGx1Z2luTWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0UHJvY2Vzc29ycyA9IG9wdGlvbnMucGx1Z2luTWFuYWdlci5nZXRQb3N0UHJvY2Vzc29ycygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNzcyA9IHBvc3RQcm9jZXNzb3JzW2ldLnByb2Nlc3MocmVzdWx0LmNzcywgeyBzb3VyY2VNYXA6IHNvdXJjZU1hcEJ1aWxkZXIsIG9wdGlvbnM6IG9wdGlvbnMsIGltcG9ydHM6IHRoaXMuaW1wb3J0cyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWFwID0gc291cmNlTWFwQnVpbGRlci5nZXRFeHRlcm5hbFNvdXJjZU1hcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmltcG9ydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpbGUgaW4gdGhpcy5pbXBvcnRzLmZpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0cy5maWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlKSAmJiBmaWxlICE9PSB0aGlzLmltcG9ydHMucm9vdEZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pbXBvcnRzLnB1c2goZmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlVHJlZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiBQYXJzZVRyZWU7XHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbXBvcnRNYW5hZ2VyIChlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIC8vIEZpbGVJbmZvID0ge1xyXG4gICAgICAgIC8vICAncmV3cml0ZVVybHMnIC0gb3B0aW9uIC0gd2hldGhlciB0byBhZGp1c3QgVVJMJ3MgdG8gYmUgcmVsYXRpdmVcclxuICAgICAgICAvLyAgJ2ZpbGVuYW1lJyAtIGZ1bGwgcmVzb2x2ZWQgZmlsZW5hbWUgb2YgY3VycmVudCBmaWxlXHJcbiAgICAgICAgLy8gICdyb290cGF0aCcgLSBwYXRoIHRvIGFwcGVuZCB0byBub3JtYWwgVVJMcyBmb3IgdGhpcyBub2RlXHJcbiAgICAgICAgLy8gICdjdXJyZW50RGlyZWN0b3J5JyAtIHBhdGggdG8gdGhlIGN1cnJlbnQgZmlsZSwgYWJzb2x1dGVcclxuICAgICAgICAvLyAgJ3Jvb3RGaWxlbmFtZScgLSBmaWxlbmFtZSBvZiB0aGUgYmFzZSBmaWxlXHJcbiAgICAgICAgLy8gICdlbnRyeVBhdGgnIC0gYWJzb2x1dGUgcGF0aCB0byB0aGUgZW50cnkgZmlsZVxyXG4gICAgICAgIC8vICAncmVmZXJlbmNlJyAtIHdoZXRoZXIgdGhlIGZpbGUgc2hvdWxkIG5vdCBiZSBvdXRwdXQgYW5kIG9ubHkgb3V0cHV0IHBhcnRzIHRoYXQgYXJlIHJlZmVyZW5jZWRcclxuICAgICAgICB2YXIgSW1wb3J0TWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSW1wb3J0TWFuYWdlcihsZXNzLCBjb250ZXh0LCByb290RmlsZUluZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVzcyA9IGxlc3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RGaWxlbmFtZSA9IHJvb3RGaWxlSW5mby5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aHMgPSBjb250ZXh0LnBhdGhzIHx8IFtdOyAvLyBTZWFyY2ggcGF0aHMsIHdoZW4gaW1wb3J0aW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0ge307IC8vIG1hcCAtIGZpbGVuYW1lIHRvIGNvbnRlbnRzIG9mIGFsbCB0aGUgZmlsZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudHNJZ25vcmVkQ2hhcnMgPSB7fTsgLy8gbWFwIC0gZmlsZW5hbWUgdG8gbGluZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIGZpbGUgdG8gaWdub3JlXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbWUgPSBjb250ZXh0Lm1pbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAvLyBEZXByZWNhdGVkPyBVbnVzZWQgb3V0c2lkZSBvZiBoZXJlLCBjb3VsZCBiZSB1c2VmdWwuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107IC8vIEZpbGVzIHdoaWNoIGhhdmVuJ3QgYmVlbiBpbXBvcnRlZCB5ZXRcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXMgPSB7fTsgLy8gSG9sZHMgdGhlIGltcG9ydGVkIHBhcnNlIHRyZWVzLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGQgYW4gaW1wb3J0IHRvIGJlIGltcG9ydGVkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYXRoIC0gdGhlIHJhdyBwYXRoXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB0cnlBcHBlbmRFeHRlbnNpb24gLSB3aGV0aGVyIHRvIHRyeSBhcHBlbmRpbmcgYSBmaWxlIGV4dGVuc2lvbiAoLmxlc3Mgb3IgLmpzIGlmIHRoZSBwYXRoIGhhcyBubyBleHRlbnNpb24pXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBjdXJyZW50RmlsZUluZm8gLSB0aGUgY3VycmVudCBmaWxlIGluZm8gKHVzZWQgZm9yIGluc3RhbmNlIHRvIHdvcmsgb3V0IHJlbGF0aXZlIHBhdGhzKVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW1wb3J0T3B0aW9ucyAtIGltcG9ydCBvcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGNhbGxiYWNrIGZvciB3aGVuIGl0IGlzIGltcG9ydGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbXBvcnRNYW5hZ2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHBhdGgsIHRyeUFwcGVuZEV4dGVuc2lvbiwgY3VycmVudEZpbGVJbmZvLCBpbXBvcnRPcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydE1hbmFnZXIgPSB0aGlzLCBwbHVnaW5Mb2FkZXIgPSB0aGlzLmNvbnRleHQucGx1Z2luTWFuYWdlci5Mb2FkZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVBhcnNlZEZ1bmMgPSBmdW5jdGlvbiAoZSwgcm9vdCwgZnVsbFBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLnF1ZXVlLnNwbGljZShpbXBvcnRNYW5hZ2VyLnF1ZXVlLmluZGV4T2YocGF0aCksIDEpOyAvLyBSZW1vdmUgdGhlIHBhdGggZnJvbSB0aGUgcXVldWVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRFcXVhbHNSb290ID0gZnVsbFBhdGggPT09IGltcG9ydE1hbmFnZXIucm9vdEZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRPcHRpb25zLm9wdGlvbmFsICYmIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBydWxlczogW10gfSwgZmFsc2UsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcIlRoZSBmaWxlIFwiICsgZnVsbFBhdGggKyBcIiB3YXMgc2tpcHBlZCBiZWNhdXNlIGl0IHdhcyBub3QgZm91bmQgYW5kIHRoZSBpbXBvcnQgd2FzIG1hcmtlZCBvcHRpb25hbC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmxpbmUgaW1wb3J0cyBhcmVuJ3QgY2FjaGVkIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0IHRvIGNhY2hlIHRoZW0sIHBsZWFzZSBtYWtlIHN1cmUgdGhleSB3b24ndCBjb25mbGljdCB3aXRoIG5vbi1pbmxpbmUgaW1wb3J0cyBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBuYW1lIGFzIHRoZXkgdXNlZCB0byBkbyBiZWZvcmUgdGhpcyBjb21tZW50IGFuZCB0aGUgY29uZGl0aW9uIGJlbG93IGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRNYW5hZ2VyLmZpbGVzW2Z1bGxQYXRoXSAmJiAhaW1wb3J0T3B0aW9ucy5pbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydE1hbmFnZXIuZmlsZXNbZnVsbFBhdGhdID0geyByb290OiByb290LCBvcHRpb25zOiBpbXBvcnRPcHRpb25zIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgIWltcG9ydE1hbmFnZXIuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydE1hbmFnZXIuZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIHJvb3QsIGltcG9ydGVkRXF1YWxzUm9vdCwgZnVsbFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RmlsZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVVybHM6IHRoaXMuY29udGV4dC5yZXdyaXRlVXJscyxcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeVBhdGg6IGN1cnJlbnRGaWxlSW5mby5lbnRyeVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdHBhdGg6IGN1cnJlbnRGaWxlSW5mby5yb290cGF0aCxcclxuICAgICAgICAgICAgICAgICAgICByb290RmlsZW5hbWU6IGN1cnJlbnRGaWxlSW5mby5yb290RmlsZW5hbWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU1hbmFnZXIgPSBlbnZpcm9ubWVudC5nZXRGaWxlTWFuYWdlcihwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgdGhpcy5jb250ZXh0LCBlbnZpcm9ubWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGVNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMoeyBtZXNzYWdlOiBcIkNvdWxkIG5vdCBmaW5kIGEgZmlsZS1tYW5hZ2VyIGZvciBcIiArIHBhdGggfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxvYWRGaWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAobG9hZGVkRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkRmlsZW5hbWUgPSBsb2FkZWRGaWxlLmZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IGxvYWRlZEZpbGUuY29udGVudHMucmVwbGFjZSgvXlxcdUZFRkYvLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBvbiBhbiB1cGRhdGVkIHJvb3RwYXRoIGlmIHBhdGggb2YgaW1wb3J0ZWQgZmlsZSBpcyByZWxhdGl2ZSBhbmQgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGluIGEgKHN1YnxzdXApIGRpcmVjdG9yeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhhbXBsZXM6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJZiBwYXRoIG9mIGltcG9ydGVkIGZpbGUgaXMgJ21vZHVsZS9uYXYvbmF2Lmxlc3MnIGFuZCByb290cGF0aCBpcyAnbGVzcy8nLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhlbiByb290cGF0aCBzaG91bGQgYmVjb21lICdsZXNzL21vZHVsZS9uYXYvJ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSWYgcGF0aCBvZiBpbXBvcnRlZCBmaWxlIGlzICcuLi9taXhpbnMubGVzcycgYW5kIHJvb3RwYXRoIGlzICdsZXNzLycsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICB0aGVuIHJvb3RwYXRoIHNob3VsZCBiZWNvbWUgJ2xlc3MvLi4vJ1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnkgPSBmaWxlTWFuYWdlci5nZXRQYXRoKHJlc29sdmVkRmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdGaWxlSW5mby5yZXdyaXRlVXJscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yb290cGF0aCA9IGZpbGVNYW5hZ2VyLmpvaW4oKGltcG9ydE1hbmFnZXIuY29udGV4dC5yb290cGF0aCB8fCAnJyksIGZpbGVNYW5hZ2VyLnBhdGhEaWZmKG5ld0ZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIG5ld0ZpbGVJbmZvLmVudHJ5UGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVNYW5hZ2VyLmlzUGF0aEFic29sdXRlKG5ld0ZpbGVJbmZvLnJvb3RwYXRoKSAmJiBmaWxlTWFuYWdlci5hbHdheXNNYWtlUGF0aHNBYnNvbHV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5yb290cGF0aCA9IGZpbGVNYW5hZ2VyLmpvaW4obmV3RmlsZUluZm8uZW50cnlQYXRoLCBuZXdGaWxlSW5mby5yb290cGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RmlsZUluZm8uZmlsZW5hbWUgPSByZXNvbHZlZEZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbnYgPSBuZXcgY29udGV4dHMuUGFyc2UoaW1wb3J0TWFuYWdlci5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFbnYucHJvY2Vzc0ltcG9ydHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLmNvbnRlbnRzW3Jlc29sdmVkRmlsZW5hbWVdID0gY29udGVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxlSW5mby5yZWZlcmVuY2UgfHwgaW1wb3J0T3B0aW9ucy5yZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucmVmZXJlbmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydE9wdGlvbnMuaXNQbHVnaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gcGx1Z2luTG9hZGVyLmV2YWxQbHVnaW4oY29udGVudHMsIG5ld0VudiwgaW1wb3J0TWFuYWdlciwgaW1wb3J0T3B0aW9ucy5wbHVnaW5BcmdzLCBuZXdGaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4gaW5zdGFuY2VvZiBMZXNzRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKHBsdWdpbiwgbnVsbCwgcmVzb2x2ZWRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhudWxsLCBwbHVnaW4sIHJlc29sdmVkRmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGltcG9ydE9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKG51bGwsIGNvbnRlbnRzLCByZXNvbHZlZEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCAobXVsdGlwbGUpIHBhcnNlIHRyZWVzIGFwcGFyZW50bHkgZ2V0IGFsdGVyZWQgYW5kIGNhbid0IGJlIGNhY2hlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2h5IHRoaXMgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydE1hbmFnZXIuZmlsZXNbcmVzb2x2ZWRGaWxlbmFtZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFpbXBvcnRNYW5hZ2VyLmZpbGVzW3Jlc29sdmVkRmlsZW5hbWVdLm9wdGlvbnMubXVsdGlwbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFpbXBvcnRPcHRpb25zLm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhudWxsLCBpbXBvcnRNYW5hZ2VyLmZpbGVzW3Jlc29sdmVkRmlsZW5hbWVdLnJvb3QsIHJlc29sdmVkRmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhcnNlcihuZXdFbnYsIGltcG9ydE1hbmFnZXIsIG5ld0ZpbGVJbmZvKS5wYXJzZShjb250ZW50cywgZnVuY3Rpb24gKGUsIHJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhlLCByb290LCByZXNvbHZlZEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2FkZWRGaWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNsb25lKHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJ5QXBwZW5kRXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5leHQgPSBpbXBvcnRPcHRpb25zLmlzUGx1Z2luID8gJy5qcycgOiAnLmxlc3MnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydE9wdGlvbnMuaXNQbHVnaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1pbWUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3luY0ltcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWRGaWxlID0gcGx1Z2luTG9hZGVyLmxvYWRQbHVnaW5TeW5jKHBhdGgsIGN1cnJlbnRGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCBjb250ZXh0LCBlbnZpcm9ubWVudCwgZmlsZU1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHBsdWdpbkxvYWRlci5sb2FkUGx1Z2luKHBhdGgsIGN1cnJlbnRGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCBjb250ZXh0LCBlbnZpcm9ubWVudCwgZmlsZU1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN5bmNJbXBvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkRmlsZSA9IGZpbGVNYW5hZ2VyLmxvYWRGaWxlU3luYyhwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGZpbGVNYW5hZ2VyLmxvYWRGaWxlKHBhdGgsIGN1cnJlbnRGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCBjb250ZXh0LCBlbnZpcm9ubWVudCwgZnVuY3Rpb24gKGVyciwgbG9hZGVkRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkRmlsZS5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhsb2FkZWRGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRGaWxlQ2FsbGJhY2sobG9hZGVkRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihsb2FkRmlsZUNhbGxiYWNrLCBmaWxlUGFyc2VkRnVuYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBJbXBvcnRNYW5hZ2VyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcmV0dXJuIEltcG9ydE1hbmFnZXI7XHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQYXJzZSAoZW52aXJvbm1lbnQsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlcikge1xyXG4gICAgICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gY29weU9wdGlvbnModGhpcy5vcHRpb25zLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gY29weU9wdGlvbnModGhpcy5vcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZl8xID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2UuY2FsbChzZWxmXzEsIGlucHV0LCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRfMTtcclxuICAgICAgICAgICAgICAgIHZhciByb290RmlsZUluZm8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luTWFuYWdlcl8xID0gbmV3IFBsdWdpbk1hbmFnZXJGYWN0b3J5KHRoaXMsICFvcHRpb25zLnJlVXNlUGx1Z2luTWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBsdWdpbk1hbmFnZXIgPSBwbHVnaW5NYW5hZ2VyXzE7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0XzEgPSBuZXcgY29udGV4dHMuUGFyc2Uob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yb290RmlsZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICByb290RmlsZUluZm8gPSBvcHRpb25zLnJvb3RGaWxlSW5mbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWUgfHwgJ2lucHV0JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnlQYXRoID0gZmlsZW5hbWUucmVwbGFjZSgvW15cXC9cXFxcXSokLywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RGaWxlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlVXJsczogY29udGV4dF8xLnJld3JpdGVVcmxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290cGF0aDogY29udGV4dF8xLnJvb3RwYXRoIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0b3J5OiBlbnRyeVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5UGF0aDogZW50cnlQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290RmlsZW5hbWU6IGZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaW4gYSBtaXNzaW5nIHRyYWlsaW5nIHNsYXNoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RGaWxlSW5mby5yb290cGF0aCAmJiByb290RmlsZUluZm8ucm9vdHBhdGguc2xpY2UoLTEpICE9PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvLnJvb3RwYXRoICs9ICcvJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0c18xID0gbmV3IEltcG9ydE1hbmFnZXIodGhpcywgY29udGV4dF8xLCByb290RmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRNYW5hZ2VyID0gaW1wb3J0c18xO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWxsb3cgdGhlIHBsdWdpbnMgdG8gYmUganVzdCBhIGxpc3Qgb2YgcGF0aHMgb3IgbmFtZXNcclxuICAgICAgICAgICAgICAgIC8vIERvIGFuIGFzeW5jIHBsdWdpbiBxdWV1ZSBsaWtlIGxlc3NjXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZhbFJlc3VsdCwgY29udGVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uZmlsZUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gcGx1Z2luLmZpbGVDb250ZW50LnJlcGxhY2UoL15cXHVGRUZGLywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbFJlc3VsdCA9IHBsdWdpbk1hbmFnZXJfMS5Mb2FkZXIuZXZhbFBsdWdpbihjb250ZW50cywgY29udGV4dF8xLCBpbXBvcnRzXzEsIHBsdWdpbi5vcHRpb25zLCBwbHVnaW4uZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWxSZXN1bHQgaW5zdGFuY2VvZiBMZXNzRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZhbFJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW5NYW5hZ2VyXzEuYWRkUGx1Z2luKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ldyBQYXJzZXIoY29udGV4dF8xLCBpbXBvcnRzXzEsIHJvb3RGaWxlSW5mbylcclxuICAgICAgICAgICAgICAgICAgICAucGFyc2UoaW5wdXQsIGZ1bmN0aW9uIChlLCByb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByb290LCBpbXBvcnRzXzEsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwYXJzZTtcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlbmRlciAoZW52aXJvbm1lbnQsIFBhcnNlVHJlZSwgSW1wb3J0TWFuYWdlcikge1xyXG4gICAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvcHlPcHRpb25zKHRoaXMub3B0aW9ucywge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvcHlPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlci5jYWxsKHNlbGZfMSwgaW5wdXQsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIG91dHB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlKGlucHV0LCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCByb290LCBpbXBvcnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VUcmVlID0gbmV3IFBhcnNlVHJlZShyb290LCBpbXBvcnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VUcmVlLnRvQ1NTKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZW5kZXI7XHJcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IFwiNC4xLjFcIjtcblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9kZVZlcnNpb24odmVyc2lvbikge1xuICAgICAgdmFyIG1hdGNoID0gdmVyc2lvbi5tYXRjaCgvXnYoXFxkezEsMn0pXFwuKFxcZHsxLDJ9KVxcLihcXGR7MSwyfSkoPzotKFswLTlBLVphLXotLl0rKSk/KD86XFwrKFswLTlBLVphLXotLl0rKSk/JC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2U6ICcgKyB2ZXJzaW9uKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbWFqb3I6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgICAgIG1pbm9yOiBwYXJzZUludChtYXRjaFsyXSwgMTApLFxuICAgICAgICBwYXRjaDogcGFyc2VJbnQobWF0Y2hbM10sIDEwKSxcbiAgICAgICAgcHJlOiBtYXRjaFs0XSB8fCAnJyxcbiAgICAgICAgYnVpbGQ6IG1hdGNoWzVdIHx8ICcnLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VOb2RlVmVyc2lvbl8xID0gcGFyc2VOb2RlVmVyc2lvbjtcblxuICAgIGZ1bmN0aW9uIGxlc3NSb290IChlbnZpcm9ubWVudCwgZmlsZU1hbmFnZXJzKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZU1hcE91dHB1dCwgc291cmNlTWFwQnVpbGRlciwgcGFyc2VUcmVlLCBpbXBvcnRNYW5hZ2VyO1xyXG4gICAgICAgIGVudmlyb25tZW50ID0gbmV3IEVudmlyb25tZW50KGVudmlyb25tZW50LCBmaWxlTWFuYWdlcnMpO1xyXG4gICAgICAgIHNvdXJjZU1hcE91dHB1dCA9IFNvdXJjZU1hcE91dHB1dChlbnZpcm9ubWVudCk7XHJcbiAgICAgICAgc291cmNlTWFwQnVpbGRlciA9IFNvdXJjZU1hcEJ1aWxkZXIoc291cmNlTWFwT3V0cHV0LCBlbnZpcm9ubWVudCk7XHJcbiAgICAgICAgcGFyc2VUcmVlID0gUGFyc2VUcmVlKHNvdXJjZU1hcEJ1aWxkZXIpO1xyXG4gICAgICAgIGltcG9ydE1hbmFnZXIgPSBJbXBvcnRNYW5hZ2VyKGVudmlyb25tZW50KTtcclxuICAgICAgICB2YXIgcmVuZGVyID0gUmVuZGVyKGVudmlyb25tZW50LCBwYXJzZVRyZWUpO1xyXG4gICAgICAgIHZhciBwYXJzZSA9IFBhcnNlKGVudmlyb25tZW50LCBwYXJzZVRyZWUsIGltcG9ydE1hbmFnZXIpO1xyXG4gICAgICAgIHZhciB2ID0gcGFyc2VOb2RlVmVyc2lvbl8xKFwidlwiICsgdmVyc2lvbik7XHJcbiAgICAgICAgdmFyIGluaXRpYWwgPSB7XHJcbiAgICAgICAgICAgIHZlcnNpb246IFt2Lm1ham9yLCB2Lm1pbm9yLCB2LnBhdGNoXSxcclxuICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgdHJlZTogdHJlZSxcclxuICAgICAgICAgICAgRW52aXJvbm1lbnQ6IEVudmlyb25tZW50LFxyXG4gICAgICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyOiBBYnN0cmFjdEZpbGVNYW5hZ2VyLFxyXG4gICAgICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlcjogQWJzdHJhY3RQbHVnaW5Mb2FkZXIsXHJcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgdmlzaXRvcnM6IHZpc2l0b3JzLFxyXG4gICAgICAgICAgICBQYXJzZXI6IFBhcnNlcixcclxuICAgICAgICAgICAgZnVuY3Rpb25zOiBmdW5jdGlvbnMoZW52aXJvbm1lbnQpLFxyXG4gICAgICAgICAgICBjb250ZXh0czogY29udGV4dHMsXHJcbiAgICAgICAgICAgIFNvdXJjZU1hcE91dHB1dDogc291cmNlTWFwT3V0cHV0LFxyXG4gICAgICAgICAgICBTb3VyY2VNYXBCdWlsZGVyOiBzb3VyY2VNYXBCdWlsZGVyLFxyXG4gICAgICAgICAgICBQYXJzZVRyZWU6IHBhcnNlVHJlZSxcclxuICAgICAgICAgICAgSW1wb3J0TWFuYWdlcjogaW1wb3J0TWFuYWdlcixcclxuICAgICAgICAgICAgcmVuZGVyOiByZW5kZXIsXHJcbiAgICAgICAgICAgIHBhcnNlOiBwYXJzZSxcclxuICAgICAgICAgICAgTGVzc0Vycm9yOiBMZXNzRXJyb3IsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVRyZWU6IHRyYW5zZm9ybVRyZWUsXHJcbiAgICAgICAgICAgIHV0aWxzOiB1dGlscyxcclxuICAgICAgICAgICAgUGx1Z2luTWFuYWdlcjogUGx1Z2luTWFuYWdlckZhY3RvcnksXHJcbiAgICAgICAgICAgIGxvZ2dlcjogbG9nZ2VyXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBwdWJsaWMgQVBJXHJcbiAgICAgICAgdmFyIGN0b3IgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgdC5hcHBseShvYmosIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0O1xyXG4gICAgICAgIHZhciBhcGkgPSBPYmplY3QuY3JlYXRlKGluaXRpYWwpO1xyXG4gICAgICAgIGZvciAodmFyIG4gaW4gaW5pdGlhbC50cmVlKSB7XHJcbiAgICAgICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cclxuICAgICAgICAgICAgdCA9IGluaXRpYWwudHJlZVtuXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBhcGlbbi50b0xvd2VyQ2FzZSgpXSA9IGN0b3IodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcGlbbl0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbyBpbiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGFwaVtuXVtvLnRvTG93ZXJDYXNlKCldID0gY3Rvcih0W29dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb21lIG9mIHRoZSBmdW5jdGlvbnMgYXNzdW1lIGEgYHRoaXNgIGNvbnRleHQgb2YgdGhlIEFQSSBvYmplY3QsXHJcbiAgICAgICAgICogd2hpY2ggY2F1c2VzIGl0IHRvIGZhaWwgd2hlbiB3cmFwcGVkIGZvciBFUzYgaW1wb3J0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFuIGFzc3VtZWQgYHRoaXNgIHNob3VsZCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdGlhbC5wYXJzZSA9IGluaXRpYWwucGFyc2UuYmluZChhcGkpO1xyXG4gICAgICAgIGluaXRpYWwucmVuZGVyID0gaW5pdGlhbC5yZW5kZXIuYmluZChhcGkpO1xyXG4gICAgICAgIHJldHVybiBhcGk7XHJcbiAgICB9XG5cbiAgICAvKiBnbG9iYWwgd2luZG93LCBYTUxIdHRwUmVxdWVzdCAqL1xyXG4gICAgdmFyIG9wdGlvbnM7XHJcbiAgICB2YXIgbG9nZ2VyJDE7XHJcbiAgICB2YXIgZmlsZUNhY2hlID0ge307XHJcbiAgICAvLyBUT0RPUyAtIG1vdmUgbG9nIHNvbWV3aGVyZS4gcGF0aERpZmYgYW5kIGRvaW5nIHNvbWV0aGluZyBzaW1pbGFyIGluIG5vZGUuIHVzZSBwYXRoRGlmZiBpbiB0aGUgb3RoZXIgYnJvd3NlciBmaWxlIGZvciB0aGUgaW5pdGlhbCBsb2FkXHJcbiAgICB2YXIgRmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBGaWxlTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBBYnN0cmFjdEZpbGVNYW5hZ2VyKCksIHtcclxuICAgICAgICBhbHdheXNNYWtlUGF0aHNBYnNvbHV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGpvaW46IGZ1bmN0aW9uIChiYXNlUGF0aCwgbGF0ZXJQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmICghYmFzZVBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYXRlclBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdFVybFBhcnRzKGxhdGVyUGF0aCwgYmFzZVBhdGgpLnBhdGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkb1hIUjogZnVuY3Rpb24gKHVybCwgdHlwZSwgY2FsbGJhY2ssIGVycmJhY2spIHtcclxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB2YXIgYXN5bmMgPSBvcHRpb25zLmlzRmlsZVByb3RvY29sID8gb3B0aW9ucy5maWxlQXN5bmMgOiB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHhoci5vdmVycmlkZU1pbWVUeXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9jc3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2dnZXIkMS5kZWJ1ZyhcIlhIUjogR2V0dGluZyAnXCIgKyB1cmwgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcclxuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsIHR5cGUgfHwgJ3RleHQveC1sZXNzLCB0ZXh0L2NzczsgcT0wLjksICovKjsgcT0wLjUnKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHhociwgY2FsbGJhY2ssIGVycmJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCwgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdMYXN0LU1vZGlmaWVkJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVycmJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJiYWNrKHhoci5zdGF0dXMsIHVybCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgJiYgIW9wdGlvbnMuZmlsZUFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCB8fCAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycmJhY2soeGhyLnN0YXR1cywgdXJsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhc3luYykge1xyXG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXNwb25zZSh4aHIsIGNhbGxiYWNrLCBlcnJiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UoeGhyLCBjYWxsYmFjaywgZXJyYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJGaWxlQ2FjaGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZmlsZUNhY2hlID0ge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2FkRmlsZTogZnVuY3Rpb24gKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgcHJlZml4IHN1cHBvcnQgbGlrZSBsZXNzLW5vZGU/XHJcbiAgICAgICAgICAgIC8vIFdoYXQgYWJvdXQgbXVsdGlwbGUgcGF0aHM/XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGlyZWN0b3J5ICYmICF0aGlzLmlzUGF0aEFic29sdXRlKGZpbGVuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBjdXJyZW50RGlyZWN0b3J5ICsgZmlsZW5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlsZW5hbWUgPSBvcHRpb25zLmV4dCA/IHRoaXMudHJ5QXBwZW5kRXh0ZW5zaW9uKGZpbGVuYW1lLCBvcHRpb25zLmV4dCkgOiBmaWxlbmFtZTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIC8vIHNoZWV0IG1heSBiZSBzZXQgdG8gdGhlIHN0eWxlc2hlZXQgZm9yIHRoZSBpbml0aWFsIGxvYWQgb3IgYSBjb2xsZWN0aW9uIG9mIHByb3BlcnRpZXMgaW5jbHVkaW5nXHJcbiAgICAgICAgICAgIC8vIHNvbWUgY29udGV4dCB2YXJpYWJsZXMgZm9yIGltcG9ydHNcclxuICAgICAgICAgICAgdmFyIGhyZWZQYXJ0cyA9IHRoaXMuZXh0cmFjdFVybFBhcnRzKGZpbGVuYW1lLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICAgICAgICAgIHZhciBocmVmID0gaHJlZlBhcnRzLnVybDtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlRmlsZUNhY2hlICYmIGZpbGVDYWNoZVtocmVmXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXNzVGV4dCA9IGZpbGVDYWNoZVtocmVmXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBjb250ZW50czogbGVzc1RleHQsIGZpbGVuYW1lOiBocmVmLCB3ZWJJbmZvOiB7IGxhc3RNb2RpZmllZDogbmV3IERhdGUoKSB9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHsgZmlsZW5hbWU6IGhyZWYsIG1lc3NhZ2U6IFwiRXJyb3IgbG9hZGluZyBmaWxlIFwiICsgaHJlZiArIFwiIGVycm9yIHdhcyBcIiArIGUubWVzc2FnZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRvWEhSKGhyZWYsIG9wdGlvbnMubWltZSwgZnVuY3Rpb24gZG9YSFJDYWxsYmFjayhkYXRhLCBsYXN0TW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwZXIgZmlsZSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVDYWNoZVtocmVmXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHJlbW90ZSBjb3B5IChyZS1wYXJzZSlcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgY29udGVudHM6IGRhdGEsIGZpbGVuYW1lOiBocmVmLCB3ZWJJbmZvOiB7IGxhc3RNb2RpZmllZDogbGFzdE1vZGlmaWVkIH0gfSk7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBkb1hIUkVycm9yKHN0YXR1cywgdXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgdHlwZTogJ0ZpbGUnLCBtZXNzYWdlOiBcIidcIiArIHVybCArIFwiJyB3YXNuJ3QgZm91bmQgKFwiICsgc3RhdHVzICsgXCIpXCIsIGhyZWY6IGhyZWYgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgRk0gPSAoZnVuY3Rpb24gKG9wdHMsIGxvZykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRzO1xyXG4gICAgICAgIGxvZ2dlciQxID0gbG9nO1xyXG4gICAgICAgIHJldHVybiBGaWxlTWFuYWdlcjtcclxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogQWRkIHRlc3RzIGZvciBicm93c2VyIEBwbHVnaW5cclxuICAgIC8qKlxyXG4gICAgICogQnJvd3NlciBQbHVnaW4gTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHZhciBQbHVnaW5Mb2FkZXIgPSBmdW5jdGlvbiAobGVzcykge1xyXG4gICAgICAgIHRoaXMubGVzcyA9IGxlc3M7XHJcbiAgICAgICAgLy8gU2hvdWxkIHdlIHNoaW0gdGhpcy5yZXF1aXJlIGZvciBicm93c2VyPyBQcm9iYWJseSBub3Q/XHJcbiAgICB9O1xyXG4gICAgUGx1Z2luTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IEFic3RyYWN0UGx1Z2luTG9hZGVyKCksIHtcclxuICAgICAgICBsb2FkUGx1Z2luOiBmdW5jdGlvbiAoZmlsZW5hbWUsIGJhc2VQYXRoLCBjb250ZXh0LCBlbnZpcm9ubWVudCwgZmlsZU1hbmFnZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VyLmxvYWRGaWxlKGZpbGVuYW1lLCBiYXNlUGF0aCwgY29udGV4dCwgZW52aXJvbm1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVsZmlsbCkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgTG9nTGlzdGVuZXIgPSAoZnVuY3Rpb24gKGxlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgbG9nTGV2ZWxfZGVidWcgPSA0O1xyXG4gICAgICAgIHZhciBsb2dMZXZlbF9pbmZvID0gMztcclxuICAgICAgICB2YXIgbG9nTGV2ZWxfd2FybiA9IDI7XHJcbiAgICAgICAgdmFyIGxvZ0xldmVsX2Vycm9yID0gMTtcclxuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIGxvZ2dpbmcgaW4gdGhlIGphdmFzY3JpcHQgY29uc29sZS5cclxuICAgICAgICAvLyAzIC0gRGVidWcsIGluZm9ybWF0aW9uIGFuZCBlcnJvcnNcclxuICAgICAgICAvLyAyIC0gSW5mb3JtYXRpb24gYW5kIGVycm9yc1xyXG4gICAgICAgIC8vIDEgLSBFcnJvcnNcclxuICAgICAgICAvLyAwIC0gTm9uZVxyXG4gICAgICAgIC8vIERlZmF1bHRzIHRvIDJcclxuICAgICAgICBvcHRpb25zLmxvZ0xldmVsID0gdHlwZW9mIG9wdGlvbnMubG9nTGV2ZWwgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2dMZXZlbCA6IChvcHRpb25zLmVudiA9PT0gJ2RldmVsb3BtZW50JyA/IGxvZ0xldmVsX2luZm8gOiBsb2dMZXZlbF9lcnJvcik7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmxvZ2dlcnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXJzID0gW3tcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF9kZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF9pbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB3YXJuOiBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ0xldmVsID49IGxvZ0xldmVsX3dhcm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF9lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sb2dnZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxlc3MubG9nZ2VyLmFkZExpc3RlbmVyKG9wdGlvbnMubG9nZ2Vyc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgRXJyb3JSZXBvcnRpbmcgPSAoZnVuY3Rpb24gKHdpbmRvdywgbGVzcywgb3B0aW9ucykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGVycm9ySFRNTChlLCByb290SHJlZikge1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBcImxlc3MtZXJyb3ItbWVzc2FnZTpcIiArIGV4dHJhY3RJZChyb290SHJlZiB8fCAnJyk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9ICc8bGk+PGxhYmVsPntsaW5lfTwvbGFiZWw+PHByZSBjbGFzcz1cIntjbGFzc31cIj57Y29udGVudH08L3ByZT48L2xpPic7XHJcbiAgICAgICAgICAgIHZhciBlbGVtID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICB2YXIgdGltZXI7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50O1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGUuZmlsZW5hbWUgfHwgcm9vdEhyZWY7XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZU5vUGF0aCA9IGZpbGVuYW1lLm1hdGNoKC8oW15cXC9dKyhcXD8uKik/KSQvKVsxXTtcclxuICAgICAgICAgICAgZWxlbS5pZCA9IGlkO1xyXG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9ICdsZXNzLWVycm9yLW1lc3NhZ2UnO1xyXG4gICAgICAgICAgICBjb250ZW50ID0gXCI8aDM+XCIgKyAoZS50eXBlIHx8ICdTeW50YXgnKSArIFwiRXJyb3I6IFwiICsgKGUubWVzc2FnZSB8fCAnVGhlcmUgaXMgYW4gZXJyb3IgaW4geW91ciAubGVzcyBmaWxlJykgK1xyXG4gICAgICAgICAgICAgICAgKFwiPC9oMz48cD5pbiA8YSBocmVmPVxcXCJcIiArIGZpbGVuYW1lICsgXCJcXFwiPlwiICsgZmlsZW5hbWVOb1BhdGggKyBcIjwvYT4gXCIpO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JsaW5lID0gZnVuY3Rpb24gKGUsIGksIGNsYXNzbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuZXh0cmFjdFtpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGVtcGxhdGUucmVwbGFjZSgvXFx7bGluZVxcfS8sIChwYXJzZUludChlLmxpbmUsIDEwKSB8fCAwKSArIChpIC0gMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjbGFzc1xcfS8sIGNsYXNzbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce2NvbnRlbnRcXH0vLCBlLmV4dHJhY3RbaV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGUubGluZSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDAsICcnKTtcclxuICAgICAgICAgICAgICAgIGVycm9ybGluZShlLCAxLCAnbGluZScpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDIsICcnKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCJvbiBsaW5lIFwiICsgZS5saW5lICsgXCIsIGNvbHVtbiBcIiArIChlLmNvbHVtbiArIDEpICsgXCI6PC9wPjx1bD5cIiArIGVycm9ycy5qb2luKCcnKSArIFwiPC91bD5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZS5zdGFjayAmJiAoZS5leHRyYWN0IHx8IG9wdGlvbnMubG9nTGV2ZWwgPj0gNCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCI8YnIvPlN0YWNrIFRyYWNlPC9iciAvPlwiICsgZS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignPGJyLz4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIC8vIENTUyBmb3IgZXJyb3IgbWVzc2FnZXNcclxuICAgICAgICAgICAgYnJvd3Nlci5jcmVhdGVDU1Mod2luZG93LmRvY3VtZW50LCBbXHJcbiAgICAgICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSB1bCwgLmxlc3MtZXJyb3ItbWVzc2FnZSBsaSB7JyxcclxuICAgICAgICAgICAgICAgICdsaXN0LXN0eWxlLXR5cGU6IG5vbmU7JyxcclxuICAgICAgICAgICAgICAgICdtYXJnaW4tcmlnaHQ6IDE1cHg7JyxcclxuICAgICAgICAgICAgICAgICdwYWRkaW5nOiA0cHggMDsnLFxyXG4gICAgICAgICAgICAgICAgJ21hcmdpbjogMDsnLFxyXG4gICAgICAgICAgICAgICAgJ30nLFxyXG4gICAgICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgbGFiZWwgeycsXHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplOiAxMnB4OycsXHJcbiAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0OiAxNXB4OycsXHJcbiAgICAgICAgICAgICAgICAncGFkZGluZzogNHB4IDA7JyxcclxuICAgICAgICAgICAgICAgICdjb2xvcjogI2NjNzc3NzsnLFxyXG4gICAgICAgICAgICAgICAgJ30nLFxyXG4gICAgICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgcHJlIHsnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZGQ2NjY2OycsXHJcbiAgICAgICAgICAgICAgICAncGFkZGluZzogNHB4IDA7JyxcclxuICAgICAgICAgICAgICAgICdtYXJnaW46IDA7JyxcclxuICAgICAgICAgICAgICAgICdkaXNwbGF5OiBpbmxpbmUtYmxvY2s7JyxcclxuICAgICAgICAgICAgICAgICd9JyxcclxuICAgICAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIHByZS5saW5lIHsnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmYwMDAwOycsXHJcbiAgICAgICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBoMyB7JyxcclxuICAgICAgICAgICAgICAgICdmb250LXNpemU6IDIwcHg7JyxcclxuICAgICAgICAgICAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxyXG4gICAgICAgICAgICAgICAgJ3BhZGRpbmc6IDE1cHggMCA1cHggMDsnLFxyXG4gICAgICAgICAgICAgICAgJ21hcmdpbjogMDsnLFxyXG4gICAgICAgICAgICAgICAgJ30nLFxyXG4gICAgICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgYSB7JyxcclxuICAgICAgICAgICAgICAgICdjb2xvcjogIzEwYScsXHJcbiAgICAgICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSAuZXJyb3IgeycsXHJcbiAgICAgICAgICAgICAgICAnY29sb3I6IHJlZDsnLFxyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0OiBib2xkOycsXHJcbiAgICAgICAgICAgICAgICAncGFkZGluZy1ib3R0b206IDJweDsnLFxyXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1ib3R0b206IDFweCBkYXNoZWQgcmVkOycsXHJcbiAgICAgICAgICAgICAgICAnfSdcclxuICAgICAgICAgICAgXS5qb2luKCdcXG4nKSwgeyB0aXRsZTogJ2Vycm9yLW1lc3NhZ2UnIH0pO1xyXG4gICAgICAgICAgICBlbGVtLnN0eWxlLmNzc1RleHQgPSBbXHJcbiAgICAgICAgICAgICAgICAnZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmJyxcclxuICAgICAgICAgICAgICAgICdib3JkZXI6IDFweCBzb2xpZCAjZTAwJyxcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlJyxcclxuICAgICAgICAgICAgICAgICdib3JkZXItcmFkaXVzOiA1cHgnLFxyXG4gICAgICAgICAgICAgICAgJy13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4JyxcclxuICAgICAgICAgICAgICAgICctbW96LWJvcmRlci1yYWRpdXM6IDVweCcsXHJcbiAgICAgICAgICAgICAgICAnY29sb3I6ICNlMDAnLFxyXG4gICAgICAgICAgICAgICAgJ3BhZGRpbmc6IDE1cHgnLFxyXG4gICAgICAgICAgICAgICAgJ21hcmdpbi1ib3R0b206IDE1cHgnXHJcbiAgICAgICAgICAgIF0uam9pbignOycpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbnYgPT09ICdkZXZlbG9wbWVudCcpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5yZXBsYWNlQ2hpbGQoZWxlbSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGVsZW0sIGJvZHkuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVycm9ySFRNTChwYXRoKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGVzcy1lcnJvci1tZXNzYWdlOlwiICsgZXh0cmFjdElkKHBhdGgpKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFcnJvcihwYXRoKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5lcnJvclJlcG9ydGluZyB8fCBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnaHRtbCcpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUVycm9ySFRNTChwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnY29uc29sZScpIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcoJ3JlbW92ZScsIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGVycm9yQ29uc29sZShlLCByb290SHJlZikge1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSAne2xpbmV9IHtjb250ZW50fSc7XHJcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGUuZmlsZW5hbWUgfHwgcm9vdEhyZWY7XHJcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAoZS50eXBlIHx8ICdTeW50YXgnKSArIFwiRXJyb3I6IFwiICsgKGUubWVzc2FnZSB8fCAnVGhlcmUgaXMgYW4gZXJyb3IgaW4geW91ciAubGVzcyBmaWxlJykgKyBcIiBpbiBcIiArIGZpbGVuYW1lO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JsaW5lID0gZnVuY3Rpb24gKGUsIGksIGNsYXNzbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuZXh0cmFjdFtpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGVtcGxhdGUucmVwbGFjZSgvXFx7bGluZVxcfS8sIChwYXJzZUludChlLmxpbmUsIDEwKSB8fCAwKSArIChpIC0gMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjbGFzc1xcfS8sIGNsYXNzbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce2NvbnRlbnRcXH0vLCBlLmV4dHJhY3RbaV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGUubGluZSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDAsICcnKTtcclxuICAgICAgICAgICAgICAgIGVycm9ybGluZShlLCAxLCAnbGluZScpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JsaW5lKGUsIDIsICcnKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCIgb24gbGluZSBcIiArIGUubGluZSArIFwiLCBjb2x1bW4gXCIgKyAoZS5jb2x1bW4gKyAxKSArIFwiOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlLnN0YWNrICYmIChlLmV4dHJhY3QgfHwgb3B0aW9ucy5sb2dMZXZlbCA+PSA0KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBcIlxcblN0YWNrIFRyYWNlXFxuXCIgKyBlLnN0YWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlc3MubG9nZ2VyLmVycm9yKGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBlcnJvcihlLCByb290SHJlZikge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgfHwgb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2h0bWwnKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvckhUTUwoZSwgcm9vdEhyZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdjb25zb2xlJykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JDb25zb2xlKGUsIHJvb3RIcmVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvclJlcG9ydGluZygnYWRkJywgZSwgcm9vdEhyZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFkZDogZXJyb3IsXHJcbiAgICAgICAgICAgIHJlbW92ZTogcmVtb3ZlRXJyb3JcclxuICAgICAgICB9O1xyXG4gICAgfSk7XG5cbiAgICAvLyBDYWNoZSBzeXN0ZW0gaXMgYSBiaXQgb3V0ZGF0ZWQgYW5kIGNvdWxkIGRvIHdpdGggd29ya1xyXG4gICAgdmFyIENhY2hlID0gKGZ1bmN0aW9uICh3aW5kb3csIG9wdGlvbnMsIGxvZ2dlcikge1xyXG4gICAgICAgIHZhciBjYWNoZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZW52ICE9PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZSA9ICh0eXBlb2Ygd2luZG93LmxvY2FsU3RvcmFnZSA9PT0gJ3VuZGVmaW5lZCcpID8gbnVsbCA6IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRDU1M6IGZ1bmN0aW9uIChwYXRoLCBsYXN0TW9kaWZpZWQsIG1vZGlmeVZhcnMsIHN0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzYXZpbmcgXCIgKyBwYXRoICsgXCIgdG8gY2FjaGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEl0ZW0ocGF0aCwgc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbShwYXRoICsgXCI6dGltZXN0YW1wXCIsIGxhc3RNb2RpZmllZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnlWYXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGggKyBcIjp2YXJzXCIsIEpTT04uc3RyaW5naWZ5KG1vZGlmeVZhcnMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gY291bGQgZG8gd2l0aCBhZGRpbmcgbW9yZSByb2J1c3QgZXJyb3IgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiZmFpbGVkIHRvIHNhdmUgXFxcIlwiICsgcGF0aCArIFwiXFxcIiB0byBsb2NhbCBzdG9yYWdlIGZvciBjYWNoaW5nLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldENTUzogZnVuY3Rpb24gKHBhdGgsIHdlYkluZm8sIG1vZGlmeVZhcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjc3MgPSBjYWNoZSAmJiBjYWNoZS5nZXRJdGVtKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGNhY2hlICYmIGNhY2hlLmdldEl0ZW0ocGF0aCArIFwiOnRpbWVzdGFtcFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJzID0gY2FjaGUgJiYgY2FjaGUuZ2V0SXRlbShwYXRoICsgXCI6dmFyc1wiKTtcclxuICAgICAgICAgICAgICAgIG1vZGlmeVZhcnMgPSBtb2RpZnlWYXJzIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFycyA9IHZhcnMgfHwgXCJ7fVwiOyAvLyBpZiBub3Qgc2V0LCB0cmVhdCBhcyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBlbXB0eSBvYmplY3RcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgJiYgd2ViSW5mby5sYXN0TW9kaWZpZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAobmV3IERhdGUod2ViSW5mby5sYXN0TW9kaWZpZWQpLnZhbHVlT2YoKSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUodGltZXN0YW1wKS52YWx1ZU9mKCkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobW9kaWZ5VmFycykgPT09IHZhcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgbG9jYWwgY29weVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XG5cbiAgICB2YXIgSW1hZ2VTaXplID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBpbWFnZVNpemUoKSB7XHJcbiAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdSdW50aW1lJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbWFnZSBzaXplIGZ1bmN0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2YgbGVzcydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGltYWdlRnVuY3Rpb25zID0ge1xyXG4gICAgICAgICAgICAnaW1hZ2Utc2l6ZSc6IGZ1bmN0aW9uIChmaWxlUGF0aE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnaW1hZ2Utd2lkdGgnOiBmdW5jdGlvbiAoZmlsZVBhdGhOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ2ltYWdlLWhlaWdodCc6IGZ1bmN0aW9uIChmaWxlUGF0aE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGltYWdlRnVuY3Rpb25zKTtcclxuICAgIH0pO1xuXG4gICAgLy9cclxuICAgIHZhciByb290ID0gKGZ1bmN0aW9uICh3aW5kb3csIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XHJcbiAgICAgICAgdmFyIGxlc3MgPSBsZXNzUm9vdCgpO1xyXG4gICAgICAgIGxlc3Mub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdmFyIGVudmlyb25tZW50ID0gbGVzcy5lbnZpcm9ubWVudDtcclxuICAgICAgICB2YXIgRmlsZU1hbmFnZXIgPSBGTShvcHRpb25zLCBsZXNzLmxvZ2dlcik7XHJcbiAgICAgICAgdmFyIGZpbGVNYW5hZ2VyID0gbmV3IEZpbGVNYW5hZ2VyKCk7XHJcbiAgICAgICAgZW52aXJvbm1lbnQuYWRkRmlsZU1hbmFnZXIoZmlsZU1hbmFnZXIpO1xyXG4gICAgICAgIGxlc3MuRmlsZU1hbmFnZXIgPSBGaWxlTWFuYWdlcjtcclxuICAgICAgICBsZXNzLlBsdWdpbkxvYWRlciA9IFBsdWdpbkxvYWRlcjtcclxuICAgICAgICBMb2dMaXN0ZW5lcihsZXNzLCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgZXJyb3JzID0gRXJyb3JSZXBvcnRpbmcod2luZG93LCBsZXNzLCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY2FjaGUgPSBsZXNzLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBDYWNoZSh3aW5kb3csIG9wdGlvbnMsIGxlc3MubG9nZ2VyKTtcclxuICAgICAgICBJbWFnZVNpemUobGVzcy5lbnZpcm9ubWVudCk7XHJcbiAgICAgICAgLy8gU2V0dXAgdXNlciBmdW5jdGlvbnMgLSBEZXByZWNhdGU/XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGxlc3MuZnVuY3Rpb25zLmZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUob3B0aW9ucy5mdW5jdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdHlwZVBhdHRlcm4gPSAvXnRleHRcXC8oeC0pP2xlc3MkLztcclxuICAgICAgICBmdW5jdGlvbiBjbG9uZShvYmopIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lZCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZFtwcm9wXSA9IG9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmx5IHJlYWxseSBuZWVkZWQgZm9yIHBoYW50b21cclxuICAgICAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJ5QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGN1cnJ5QXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZFN0eWxlcyhtb2RpZnlWYXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKTtcclxuICAgICAgICAgICAgdmFyIHN0eWxlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudHlwZS5tYXRjaCh0eXBlUGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VPcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLm1vZGlmeVZhcnMgPSBtb2RpZnlWYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXNzVGV4dCA9IHN0eWxlLmlubmVySFRNTCB8fCAnJztcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMuZmlsZW5hbWUgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKiQvLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgY2xvc3VyZSB0byBzdG9yZSBjdXJyZW50IHN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGVzcy5yZW5kZXIobGVzc1RleHQsIGluc3RhbmNlT3B0aW9ucywgYmluZChmdW5jdGlvbiAoc3R5bGUsIGUsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFkZChlLCAnaW5saW5lJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVzdWx0LmNzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmlubmVySFRNTCA9IHJlc3VsdC5jc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCBudWxsLCBzdHlsZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRTdHlsZVNoZWV0KHNoZWV0LCBjYWxsYmFjaywgcmVsb2FkLCByZW1haW5pbmcsIG1vZGlmeVZhcnMpIHtcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlT3B0aW9ucyA9IGNsb25lKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBhZGREYXRhQXR0cihpbnN0YW5jZU9wdGlvbnMsIHNoZWV0KTtcclxuICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLm1pbWUgPSBzaGVldC50eXBlO1xyXG4gICAgICAgICAgICBpZiAobW9kaWZ5VmFycykge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLm1vZGlmeVZhcnMgPSBtb2RpZnlWYXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRJbml0aWFsRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbG9hZGVkRmlsZS5jb250ZW50cztcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gbG9hZGVkRmlsZS5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciB3ZWJJbmZvID0gbG9hZGVkRmlsZS53ZWJJbmZvO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpbGVJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXJlY3Rvcnk6IGZpbGVNYW5hZ2VyLmdldFBhdGgocGF0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHJld3JpdGVVcmxzOiBpbnN0YW5jZU9wdGlvbnMucmV3cml0ZVVybHNcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5lbnRyeVBhdGggPSBuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5O1xyXG4gICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBpbnN0YW5jZU9wdGlvbnMucm9vdHBhdGggfHwgbmV3RmlsZUluZm8uY3VycmVudERpcmVjdG9yeTtcclxuICAgICAgICAgICAgICAgIGlmICh3ZWJJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViSW5mby5yZW1haW5pbmcgPSByZW1haW5pbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IGNhY2hlLmdldENTUyhwYXRoLCB3ZWJJbmZvLCBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxvYWQgJiYgY3NzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYkluZm8ubG9jYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjc3MsIGRhdGEsIHNoZWV0LCB3ZWJJbmZvLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRlc3RzIGFyb3VuZCBob3cgdGhpcyBiZWhhdmVzIHdoZW4gcmVsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucmVtb3ZlKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLnJvb3RGaWxlSW5mbyA9IG5ld0ZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgbGVzcy5yZW5kZXIoZGF0YSwgaW5zdGFuY2VPcHRpb25zLCBmdW5jdGlvbiAoZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5ocmVmID0gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRDU1Moc2hlZXQuaHJlZiwgd2ViSW5mby5sYXN0TW9kaWZpZWQsIGluc3RhbmNlT3B0aW9ucy5tb2RpZnlWYXJzLCByZXN1bHQuY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LmNzcywgZGF0YSwgc2hlZXQsIHdlYkluZm8sIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbGVNYW5hZ2VyLmxvYWRGaWxlKHNoZWV0LmhyZWYsIG51bGwsIGluc3RhbmNlT3B0aW9ucywgZW52aXJvbm1lbnQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9hZGVkRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgbG9hZEluaXRpYWxGaWxlQ2FsbGJhY2sobG9hZGVkRmlsZSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbG9hZFN0eWxlU2hlZXRzKGNhbGxiYWNrLCByZWxvYWQsIG1vZGlmeVZhcnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXNzLnNoZWV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbG9hZFN0eWxlU2hlZXQobGVzcy5zaGVldHNbaV0sIGNhbGxiYWNrLCByZWxvYWQsIGxlc3Muc2hlZXRzLmxlbmd0aCAtIChpICsgMSksIG1vZGlmeVZhcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGluaXRSdW5uaW5nTW9kZSgpIHtcclxuICAgICAgICAgICAgaWYgKGxlc3MuZW52ID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXNzLndhdGNoVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlc3Mud2F0Y2hNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VyLmNsZWFyRmlsZUNhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0cyhmdW5jdGlvbiAoZSwgY3NzLCBfLCBzaGVldCwgd2ViSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsIGUuaHJlZiB8fCBzaGVldC5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY3JlYXRlQ1NTKHdpbmRvdy5kb2N1bWVudCwgY3NzLCBzaGVldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMucG9sbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXYXRjaCBtb2RlXHJcbiAgICAgICAgLy9cclxuICAgICAgICBsZXNzLndhdGNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWxlc3Mud2F0Y2hNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXNzLmVudiA9ICdkZXZlbG9wbWVudCc7XHJcbiAgICAgICAgICAgICAgICBpbml0UnVubmluZ01vZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndhdGNoTW9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGVzcy51bndhdGNoID0gZnVuY3Rpb24gKCkgeyBjbGVhckludGVydmFsKGxlc3Mud2F0Y2hUaW1lcik7IHRoaXMud2F0Y2hNb2RlID0gZmFsc2U7IHJldHVybiBmYWxzZTsgfTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFN5bmNocm9ub3VzbHkgZ2V0IGFsbCA8bGluaz4gdGFncyB3aXRoIHRoZSAncmVsJyBhdHRyaWJ1dGUgc2V0IHRvXHJcbiAgICAgICAgLy8gXCJzdHlsZXNoZWV0L2xlc3NcIi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGxlc3MucmVnaXN0ZXJTdHlsZXNoZWV0c0ltbWVkaWF0ZWx5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xyXG4gICAgICAgICAgICBsZXNzLnNoZWV0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlua3NbaV0ucmVsID09PSAnc3R5bGVzaGVldC9sZXNzJyB8fCAobGlua3NbaV0ucmVsLm1hdGNoKC9zdHlsZXNoZWV0LykgJiZcclxuICAgICAgICAgICAgICAgICAgICAobGlua3NbaV0udHlwZS5tYXRjaCh0eXBlUGF0dGVybikpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlc3Muc2hlZXRzLnB1c2gobGlua3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEFzeW5jaHJvbm91c2x5IGdldCBhbGwgPGxpbms+IHRhZ3Mgd2l0aCB0aGUgJ3JlbCcgYXR0cmlidXRlIHNldCB0b1xyXG4gICAgICAgIC8vIFwic3R5bGVzaGVldC9sZXNzXCIsIHJldHVybmluZyBhIFByb21pc2UuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGxlc3MucmVnaXN0ZXJTdHlsZXNoZWV0c0ltbWVkaWF0ZWx5KCk7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTsgfTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdpdGggdGhpcyBmdW5jdGlvbiwgaXQncyBwb3NzaWJsZSB0byBhbHRlciB2YXJpYWJsZXMgYW5kIHJlLXJlbmRlclxyXG4gICAgICAgIC8vIENTUyB3aXRob3V0IHJlbG9hZGluZyBsZXNzLWZpbGVzXHJcbiAgICAgICAgLy9cclxuICAgICAgICBsZXNzLm1vZGlmeVZhcnMgPSBmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBsZXNzLnJlZnJlc2godHJ1ZSwgcmVjb3JkLCBmYWxzZSk7IH07XHJcbiAgICAgICAgbGVzcy5yZWZyZXNoID0gZnVuY3Rpb24gKHJlbG9hZCwgbW9kaWZ5VmFycywgY2xlYXJGaWxlQ2FjaGUpIHtcclxuICAgICAgICAgICAgaWYgKChyZWxvYWQgfHwgY2xlYXJGaWxlQ2FjaGUpICYmIGNsZWFyRmlsZUNhY2hlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZU1hbmFnZXIuY2xlYXJGaWxlQ2FjaGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRUaW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsTWlsbGlzZWNvbmRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZ1NoZWV0cztcclxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGNvdW50ZXIgZm9yIHJlbWFpbmluZyB1bnByb2Nlc3NlZCBzaGVldHNcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ1NoZWV0cyA9IGxlc3Muc2hlZXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdTaGVldHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kcyA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbygnTGVzcyBoYXMgZmluaXNoZWQgYW5kIG5vIHNoZWV0cyB3ZXJlIGxvYWRlZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTWlsbGlzZWNvbmRzOiB0b3RhbE1pbGxpc2Vjb25kcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRzOiBsZXNzLnNoZWV0cy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGllcyBvbiBsZXNzLnNoZWV0cyBhcnJheSwgY2FsbGJhY2sgc2VlbXMgdG8gYmUgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgZm9yIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZFN0eWxlU2hlZXRzKGZ1bmN0aW9uIChlLCBjc3MsIF8sIHNoZWV0LCB3ZWJJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYWRkKGUsIGUuaHJlZiB8fCBzaGVldC5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2ViSW5mby5sb2NhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbyhcIkxvYWRpbmcgXCIgKyBzaGVldC5ocmVmICsgXCIgZnJvbSBjYWNoZS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiUmVuZGVyZWQgXCIgKyBzaGVldC5ocmVmICsgXCIgc3VjY2Vzc2Z1bGx5LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLmNyZWF0ZUNTUyh3aW5kb3cuZG9jdW1lbnQsIGNzcywgc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiQ1NTIGZvciBcIiArIHNoZWV0LmhyZWYgKyBcIiBnZW5lcmF0ZWQgaW4gXCIgKyAobmV3IERhdGUoKSAtIGVuZFRpbWUpICsgXCJtc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgY29tcGxldGVkIHNoZWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ1NoZWV0cy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGFzdCByZW1haW5pbmcgc2hlZXQgd2FzIHByb2Nlc3NlZCBhbmQgdGhlbiBjYWxsIHRoZSBwcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdTaGVldHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTWlsbGlzZWNvbmRzID0gbmV3IERhdGUoKSAtIHN0YXJ0VGltZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oXCJMZXNzIGhhcyBmaW5pc2hlZC4gQ1NTIGdlbmVyYXRlZCBpbiBcIiArIHRvdGFsTWlsbGlzZWNvbmRzICsgXCJtc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWU6IGVuZFRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxNaWxsaXNlY29uZHM6IHRvdGFsTWlsbGlzZWNvbmRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0czogbGVzcy5zaGVldHMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCByZWxvYWQsIG1vZGlmeVZhcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9hZFN0eWxlcyhtb2RpZnlWYXJzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXNzLnJlZnJlc2hTdHlsZXMgPSBsb2FkU3R5bGVzO1xyXG4gICAgICAgIHJldHVybiBsZXNzO1xyXG4gICAgfSk7XG5cbiAgICAvKipcclxuICAgICAqIEtpY2tzIG9mZiBsZXNzIGFuZCBjb21waWxlcyBhbnkgc3R5bGVzaGVldHNcclxuICAgICAqIHVzZWQgaW4gdGhlIGJyb3dzZXIgZGlzdHJpYnV0ZWQgdmVyc2lvbiBvZiBsZXNzXHJcbiAgICAgKiB0byBraWNrLXN0YXJ0IGxlc3MgdXNpbmcgdGhlIGJyb3dzZXIgYXBpXHJcbiAgICAgKi9cclxuICAgIHZhciBvcHRpb25zJDEgPSBkZWZhdWx0T3B0aW9ucygpO1xyXG4gICAgaWYgKHdpbmRvdy5sZXNzKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHdpbmRvdy5sZXNzKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cubGVzcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zJDFba2V5XSA9IHdpbmRvdy5sZXNzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGREZWZhdWx0T3B0aW9ucyh3aW5kb3csIG9wdGlvbnMkMSk7XHJcbiAgICBvcHRpb25zJDEucGx1Z2lucyA9IG9wdGlvbnMkMS5wbHVnaW5zIHx8IFtdO1xyXG4gICAgaWYgKHdpbmRvdy5MRVNTX1BMVUdJTlMpIHtcclxuICAgICAgICBvcHRpb25zJDEucGx1Z2lucyA9IG9wdGlvbnMkMS5wbHVnaW5zLmNvbmNhdCh3aW5kb3cuTEVTU19QTFVHSU5TKTtcclxuICAgIH1cclxuICAgIHZhciBsZXNzID0gcm9vdCh3aW5kb3csIG9wdGlvbnMkMSk7XHJcbiAgICB3aW5kb3cubGVzcyA9IGxlc3M7XHJcbiAgICB2YXIgY3NzO1xyXG4gICAgdmFyIGhlYWQ7XHJcbiAgICB2YXIgc3R5bGU7XHJcbiAgICAvLyBBbHdheXMgcmVzdG9yZSBwYWdlIHZpc2liaWxpdHlcclxuICAgIGZ1bmN0aW9uIHJlc29sdmVPclJlamVjdChkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEuZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdGlvbnMkMS5hc3luYykge1xyXG4gICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucyQxLm9uUmVhZHkpIHtcclxuICAgICAgICBpZiAoLyF3YXRjaC8udGVzdCh3aW5kb3cubG9jYXRpb24uaGFzaCkpIHtcclxuICAgICAgICAgICAgbGVzcy53YXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW11bGF0ZSBzeW5jaHJvbm91cyBzdHlsZXNoZWV0IGxvYWRpbmcgYnkgaGlkaW5nIHBhZ2UgcmVuZGVyaW5nXHJcbiAgICAgICAgaWYgKCFvcHRpb25zJDEuYXN5bmMpIHtcclxuICAgICAgICAgICAgY3NzID0gJ2JvZHkgeyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQgfSc7XHJcbiAgICAgICAgICAgIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XHJcbiAgICAgICAgICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVzcy5yZWdpc3RlclN0eWxlc2hlZXRzSW1tZWRpYXRlbHkoKTtcclxuICAgICAgICBsZXNzLnBhZ2VMb2FkRmluaXNoZWQgPSBsZXNzLnJlZnJlc2gobGVzcy5lbnYgPT09ICdkZXZlbG9wbWVudCcpLnRoZW4ocmVzb2x2ZU9yUmVqZWN0LCByZXNvbHZlT3JSZWplY3QpO1xyXG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3M7XG5cbn0pKSk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IGltYWdlQ29tcHJlc3Npb24sIGVuc3VyZUFsbEltYWdlc0xvYWRlZCB9IGZyb20gXCIuL3BhZ2VTZXR1cC5qc1wiO1xuaW1wb3J0IHsgZHluYW1pY1JlcGxhY2UgfSBmcm9tIFwiLi9yZXBsYWNlLmpzXCI7XG5pbXBvcnQgc2V0dXBQbGFjZWhvbGRlciBmcm9tIFwiLi9wbGFjZWhvbGRlci5qc1wiO1xuaW1wb3J0IHRleHRGaXQgZnJvbSBcIi4vdGV4dEZpdC5qc1wiO1xuaW1wb3J0IHsgc2V0dXBNVE8gfSBmcm9tIFwiLi9tdG8uanNcIjtcbmltcG9ydCB7IGRlZmF1bHRzUmVtb3ZlZCwgZW1pdCwgbG9hZExFU1MsIHdpbkxvYWQsIGRvbVJlYWR5LCBoaWdoZXN0Wiwgc2V0QnJvd3NlclR5cGUsIHNldFNpemUsIGZvbnRzTG9hZGVkLCBhZGRDcm9wLCBzZXRPdXRmaXRTdGF0ZSB9IGZyb20gXCIuL3V0aWxpdGllcy5qc1wiO1xuaW1wb3J0IHtcbiAgY2hhckxpbWl0LFxuICBkeW5hbWljQXNzaWduLFxuICBtaW5MaW5lQ2hlY2ssXG4gIG1heEhlaWdodENoZWNrLFxuICBtYXhMaW5lQ2hlY2ssXG4gIGdldEhlaWdodCxcbiAgZ2V0V2lkdGgsXG4gIGNvdW50TGluZXMsXG4gIGxpbmVDbGFtcCxcbiAgY2FsY3VsYXRlVGV4dE1ldHJpY3MsXG59IGZyb20gXCIuL2xpbWl0ZXJzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGJvaWxlcnBsYXRlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGZvbnRzID0gW10sXG4gICAgZW5zdXJlSW1hZ2VzTG9hZCA9IHRydWUsXG4gICAgYWxsb3dMZWdhY3lSZW5kZXJpbmcgPSBmYWxzZSxcbiAgICBleHBvcnRSZWR1Y2VGb250ID0gMCxcbiAgICB3YWl0Rm9ySW1hZ2VzID0gZmFsc2UsXG4gICAgdHJpbU1hcmtzID0gZmFsc2UsXG4gICAgYWxsb3dOb01ldGFEYXRhID0gZmFsc2UsXG4gICAgY3NzVmFyaWFibGVzID0gXCJcIixcbiAgICBydW5BZGRDcm9wID0gdHJ1ZSxcbiAgICB0ZW1wbGF0ZVByb3BzID0gJ3t9JyxcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5mb250cyA9IGZvbnRzIHx8IFwiXCI7XG4gICAgdGhpcy53YWl0Rm9ySW1hZ2VzID0gd2FpdEZvckltYWdlcztcbiAgICB0aGlzLmVuc3VyZUltYWdlc0xvYWQgPSBlbnN1cmVJbWFnZXNMb2FkO1xuICAgIHRoaXMuYWxsb3dMZWdhY3lSZW5kZXJpbmcgPSBhbGxvd0xlZ2FjeVJlbmRlcmluZztcbiAgICB0aGlzLmV4cG9ydFJlZHVjZUZvbnQgPSBleHBvcnRSZWR1Y2VGb250O1xuICAgIHRoaXMudHJpbU1hcmtzID0gdHJpbU1hcmtzO1xuICAgIHRoaXMuYWxsb3dOb01ldGFEYXRhID0gYWxsb3dOb01ldGFEYXRhO1xuICAgIHRoaXMub3ZlcmZsb3dzID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IHNldE91dGZpdFN0YXRlKHRyaW1NYXJrcyk7XG4gICAgdGhpcy5icm93c2VyID0gc2V0QnJvd3NlclR5cGUoKTtcbiAgICB0aGlzLmFkZFN0eWxlKGA6cm9vdHske2Nzc1ZhcmlhYmxlc319YCk7XG4gICAgaWYgKHJ1bkFkZENyb3ApIHtcbiAgICAgIGFkZENyb3AodHJpbU1hcmtzLCBhbGxvd0xlZ2FjeVJlbmRlcmluZyk7XG4gICAgfVxuICAgIHNldFNpemUodHJpbU1hcmtzLCBleHBvcnRSZWR1Y2VGb250KTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudGVtcGxhdGVQcm9wcyA9IEpTT04ucGFyc2UodGVtcGxhdGVQcm9wcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZVByb3BzID0ge307XG4gICAgICBjb25zb2xlLmxvZyhgdGVtcGxhdGVQcm9wcyBpcyBub3QgYSB2YWxpZCBKU09OIG9iamVjdGApO1xuICAgIH1cbiAgfVxuICBzdGFydCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gYWxsIHRoZXNlIGNoZWNrcyBuZWVkIHRvIGJlIGRvbmUgYmVmb3JlIHRoZSB0ZW1wYWx0ZSBjb2RlIGNhbiBiZSBydW5cbiAgICAgIGxldCBjaGVja0xpc3QgPSBbXG4gICAgICAgIGRvbVJlYWR5LFxuICAgICAgICBsb2FkTEVTUygpLFxuICAgICAgICBmb250c0xvYWRlZCh0aGlzLmZvbnRzKSxcbiAgICAgIF07XG4gICAgICBpZiAodGhpcy53YWl0Rm9ySW1hZ2VzKSB7XG4gICAgICAgIGNoZWNrTGlzdC5wdXNoKGVuc3VyZUFsbEltYWdlc0xvYWRlZCgpKTtcbiAgICAgIH1cbiAgICAgIFByb21pc2UuYWxsKGNoZWNrTGlzdClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdChcImlucHV0c0NoYW5nZVwiLCB0aGlzLnRlbXBsYXRlUHJvcHMpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm9uVGV4dENoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB3aW5kb3cub25UZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBzZXRTaXplKFxuICAgICAgICAgICAgICB0aGlzLnRyaW1NYXJrcyxcbiAgICAgICAgICAgICAgdGhpcy5leHBvcnRSZWR1Y2VGb250XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBcInByZXZpZXdcIikge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJpbnB1dHNDaGFuZ2VcIik7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm9uVGV4dENoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9uVGV4dENoYW5nZShcInJlc2l6ZVwiLCB0aGlzLnRlbXBsYXRlUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIC8vICAgdGhpcy5nZXRPdmVyZmxvd3MoKTtcbiAgICAgICAgICAvLyB9LCAxMDAwKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICBpbWFnZUNvbXByZXNzaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIC8vIG9uIGNyZWF0ZXMgYSBjYWxsYmFjayBldmVudFxuICBvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW25hbWVdKSB7XG4gICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvLyByZW1vdmVMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lclRvUmVtb3ZlKSB7XG4gIC8vICAgaWYgKCF0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgLy8gICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcmVtb3ZlIGEgbGlzdGVuZXIuIEV2ZW50IFwiJHtuYW1lfVwiIGRvZXNuJ3QgZXhpdHMuYCk7XG4gIC8vICAgfVxuXG4gIC8vICAgY29uc3QgZmlsdGVyTGlzdGVuZXJzID0gKGxpc3RlbmVyKSA9PiBsaXN0ZW5lciAhPT0gbGlzdGVuZXJUb1JlbW92ZTtcblxuICAvLyAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHRoaXMuX2V2ZW50c1tuYW1lXS5maWx0ZXIoZmlsdGVyTGlzdGVuZXJzKTtcbiAgLy8gfVxuICBcbiAgLy8gZW1pdCBzZW5kcyBhIG1lc3NhZ2UgdG8gYSBjYWxsYmFja1xuICBlbWl0KG5hbWUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRzW25hbWVdKSB7XG4gICAgICBjb25zdCBmaXJlQ2FsbGJhY2tzID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZXZlbnRzW25hbWVdLmZvckVhY2goZmlyZUNhbGxiYWNrcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGV4dFZhbGlkYXRpb24oY2FsbGJhY2spXG4gIGFkZFN0eWxlKHN0eWxlcyA9IFwiXCIpIHtcbiAgICB2YXIgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGNzcy5jbGFzc0xpc3QgPSBcImluamVjdGVkU3R5bGVcIjtcbiAgICBpZiAoY3NzLnN0eWxlU2hlZXQpIHtcbiAgICAgIGNzcy5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKGNzcyk7XG4gIH1cbiAgLy8gc2VuZCBhIGV2ZW50IHRvIHN0b3AgYSByZW5kZXJcbiAgY29tcGxldGVSZW5kZXIoKSB7XG4gICAgbGV0IGNoZWNrTGlzdCA9IFt3aW5Mb2FkXTtcbiAgICBpZiAodGhpcy5lbnN1cmVJbWFnZXNMb2FkKSB7XG4gICAgICBjaGVja0xpc3QucHVzaChlbnN1cmVBbGxJbWFnZXNMb2FkZWQpO1xuICAgIH1cbiAgICBQcm9taXNlLmFsbChjaGVja0xpc3QpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmdldE92ZXJmbG93cygpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgIGAlYyBUaGlzIHdpbGwgZXhwb3J0IHdpdGggb3ZlcmZsb3cgZXJyb3JzYCwgJ2JhY2tncm91bmQ6ICMxRjJBNDQ7IGNvbG9yOiB3aGl0ZSdcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb2FkVGltZSA9IERhdGUubm93KCkgLSB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICAgICAgY29uc29sZS5pbmZvKGBEb2N1bWVudCBoYXMgZmluaXNoZWQgcmVuZGVyaW5nIGluICR7bG9hZFRpbWV9bXNgKTtcbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcmludHJlYWR5XCIpKTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IFwiZG9jdW1lbnRcIiB8fCBzdGF0ZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgICAgLy8gc2V0IHRpbWVvdXQgaXMgdXNlZCBoZXJlIHRvIHB1c2ggdGhpcyB0byB0aGUgZW5kIG9mIHRoZSBoZWFwIHdoaWNoIG1lYW5zIGl0IHdpbGwgbG9hZCBhZnRlciBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd05vTWV0YURhdGEpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdHNSZW1vdmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMjAwMClcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHRocm93IFwi4pqg77iPIFJlbmRlciBmYWlsZWQgZm9yIGxvZ2dlZCByZWFzb24g4qS077iPXCI7XG4gICAgICB9KTtcbiAgfVxuXG4gIGhvdFJlbG9hZE9uQ2hhbmdlKCkge1xuICAgIGlmICgodGhpcy5zdGF0ZSA9PT0gXCJkb2N1bWVudFwiIHx8IHN0YXRlID09PSBcInRlbXBsYXRlXCIpICYmIHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFwiZnMtc3luY1wiKTtcbiAgICAgIGJjLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICBpZiAoIXdpbmRvdy50b3AucmVsb2FkaW5nKSB7XG4gICAgICAgICAgd2luZG93LnRvcC5yZWxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIHdpbmRvdy50b3AubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGdldE92ZXJmbG93cyAoKSB7XG4gICAgbGV0IG92ZXJmbG93cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIub3ZlcmZsb3csIFtkYXRhLW92ZXJmbG93XVwiKTtcbiAgICBpZiAob3ZlcmZsb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMub3ZlcmZsb3dzID0gb3ZlcmZsb3dzXG4gICAgICB0aGlzLmVtaXQoXCJvdmVyZmxvd1wiLCBvdmVyZmxvd3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm92ZXJmbG93cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vdmVyZmxvd3M7XG4gIH1cbiAgZHluYW1pY1JlcGxhY2UoKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNSZXBsYWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgc2V0dXBQbGFjZWhvbGRlcigpIHtcbiAgICByZXR1cm4gc2V0dXBQbGFjZWhvbGRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHRleHRGaXQoKSB7XG4gICAgdGV4dEZpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZ2V0T3ZlcmZsb3dzKCk7XG4gIH1cbiAgbWF4TGluZUNoZWNrKCkge1xuICAgIG1heExpbmVDaGVjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZ2V0T3ZlcmZsb3dzKCk7XG4gIH1cbiAgbWluTGluZUNoZWNrKCkge1xuICAgIG1pbkxpbmVDaGVjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZ2V0T3ZlcmZsb3dzKCk7XG4gIH1cbiAgbWF4SGVpZ2h0Q2hlY2soKSB7XG4gICAgbWF4SGVpZ2h0Q2hlY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmdldE92ZXJmbG93cygpO1xuICB9XG4gIGNoYXJMaW1pdCgpIHtcbiAgICBjaGFyTGltaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmdldE92ZXJmbG93cygpO1xuICB9XG4gIGhpZ2hlc3RaaW5kZXgoKSB7XG4gICAgcmV0dXJuIGhpZ2hlc3RaKCk7XG4gIH1cbiAgZW5zdXJlQWxsSW1hZ2VzTG9hZGVkKCkge1xuICAgIHJldHVybiBlbnN1cmVBbGxJbWFnZXNMb2FkZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBzZXR1cE1UTygpIHtcbiAgICByZXR1cm4gc2V0dXBNVE8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gZ2V0V2lkdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIGdldEhlaWdodC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGNvdW50TGluZXMoKSB7XG4gICAgcmV0dXJuIGNvdW50TGluZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBjYWxjdWxhdGVUZXh0TWV0cmljcygpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlVGV4dE1ldHJpY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBsaW5lQ2xhbXAoKSB7XG4gICAgcmV0dXJuIGxpbmVDbGFtcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9