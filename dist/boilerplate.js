(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["boilerplate"] = factory();
	else
		root["boilerplate"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./modules/fontfaceobserver.js":
/*!*************************************!*\
  !*** ./modules/fontfaceobserver.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* Font Face Observer v2.1.0 - Â© Bram Stein. License: BSD-3-Clause */
(function () {
  "use strict";

  var f,
      g = [];

  function l(a) {
    g.push(a);
    1 == g.length && f();
  }

  function m() {
    for (; g.length;) g[0](), g.shift();
  }

  f = function () {
    setTimeout(m);
  };

  function n(a) {
    this.a = p;
    this.b = void 0;
    this.f = [];
    var b = this;

    try {
      a(function (a) {
        q(b, a);
      }, function (a) {
        r(b, a);
      });
    } catch (c) {
      r(b, c);
    }
  }

  var p = 2;

  function t(a) {
    return new n(function (b, c) {
      c(a);
    });
  }

  function u(a) {
    return new n(function (b) {
      b(a);
    });
  }

  function q(a, b) {
    if (a.a == p) {
      if (b == a) throw new TypeError();
      var c = !1;

      try {
        var d = b && b.then;

        if (null != b && "object" == typeof b && "function" == typeof d) {
          d.call(b, function (b) {
            c || q(a, b);
            c = !0;
          }, function (b) {
            c || r(a, b);
            c = !0;
          });
          return;
        }
      } catch (e) {
        c || r(a, e);
        return;
      }

      a.a = 0;
      a.b = b;
      v(a);
    }
  }

  function r(a, b) {
    if (a.a == p) {
      if (b == a) throw new TypeError();
      a.a = 1;
      a.b = b;
      v(a);
    }
  }

  function v(a) {
    l(function () {
      if (a.a != p) for (; a.f.length;) {
        var b = a.f.shift(),
            c = b[0],
            d = b[1],
            e = b[2],
            b = b[3];

        try {
          0 == a.a ? "function" == typeof c ? e(c.call(void 0, a.b)) : e(a.b) : 1 == a.a && ("function" == typeof d ? e(d.call(void 0, a.b)) : b(a.b));
        } catch (h) {
          b(h);
        }
      }
    });
  }

  n.prototype.g = function (a) {
    return this.c(void 0, a);
  };

  n.prototype.c = function (a, b) {
    var c = this;
    return new n(function (d, e) {
      c.f.push([a, b, d, e]);
      v(c);
    });
  };

  function w(a) {
    return new n(function (b, c) {
      function d(c) {
        return function (d) {
          h[c] = d;
          e += 1;
          e == a.length && b(h);
        };
      }

      var e = 0,
          h = [];
      0 == a.length && b(h);

      for (var k = 0; k < a.length; k += 1) u(a[k]).c(d(k), c);
    });
  }

  function x(a) {
    return new n(function (b, c) {
      for (var d = 0; d < a.length; d += 1) u(a[d]).c(b, c);
    });
  }

  window.Promise || (window.Promise = n, window.Promise.resolve = u, window.Promise.reject = t, window.Promise.race = x, window.Promise.all = w, window.Promise.prototype.then = n.prototype.c, window.Promise.prototype["catch"] = n.prototype.g);
})();

function l(a, b) {
  document.addEventListener ? a.addEventListener("scroll", b, !1) : a.attachEvent("scroll", b);
}

function m(a) {
  document.body ? a() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function c() {
    document.removeEventListener("DOMContentLoaded", c);
    a();
  }) : document.attachEvent("onreadystatechange", function k() {
    if ("interactive" == document.readyState || "complete" == document.readyState) document.detachEvent("onreadystatechange", k), a();
  });
}

function t(a) {
  this.a = document.createElement("div");
  this.a.setAttribute("aria-hidden", "true");
  this.a.appendChild(document.createTextNode(a));
  this.b = document.createElement("span");
  this.c = document.createElement("span");
  this.h = document.createElement("span");
  this.f = document.createElement("span");
  this.g = -1;
  this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
  this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
  this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
  this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";
  this.b.appendChild(this.h);
  this.c.appendChild(this.f);
  this.a.appendChild(this.b);
  this.a.appendChild(this.c);
}

function u(a, b) {
  a.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + b + ";";
}

function z(a) {
  var b = a.a.offsetWidth,
      c = b + 100;
  a.f.style.width = c + "px";
  a.c.scrollLeft = c;
  a.b.scrollLeft = a.b.scrollWidth + 100;
  return a.g !== b ? (a.g = b, !0) : !1;
}

function A(a, b) {
  function c() {
    var a = k;
    z(a) && a.a.parentNode && b(a.g);
  }

  var k = a;
  l(a.b, c);
  l(a.c, c);
  z(a);
}

function B(a, b) {
  var c = b || {};
  this.family = a;
  this.style = c.style || "normal";
  this.weight = c.weight || "normal";
  this.stretch = c.stretch || "normal";

  this.load = function (a, b) {
    var c = this,
        k = a || "BESbswy",
        r = 0,
        n = b || 3e3,
        H = new Date().getTime();
    return new Promise(function (a, b) {
      if (J() && !G()) {
        var M = new Promise(function (a, b) {
          function e() {
            new Date().getTime() - H >= n ? b(Error("" + n + "ms timeout exceeded loading fonts")) : document.fonts.load(L(c, '"' + c.family + '"'), k).then(function (c) {
              1 <= c.length ? a() : setTimeout(e, 25);
            }, b);
          }

          e();
        }),
            N = new Promise(function (a, c) {
          r = setTimeout(function () {
            c(Error("" + n + "ms timeout exceeded loading fonts"));
          }, n);
        });
        Promise.race([N, M]).then(function () {
          clearTimeout(r);
          a(c);
        }, b);
      } else m(function () {
        function v() {
          var b;
          if (b = -1 != f && -1 != g || -1 != f && -1 != h || -1 != g && -1 != h) (b = f != g && f != h && g != h) || (null === C && (b = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), C = !!b && (536 > parseInt(b[1], 10) || 536 === parseInt(b[1], 10) && 11 >= parseInt(b[2], 10))), b = C && (f == w && g == w && h == w || f == x && g == x && h == x || f == y && g == y && h == y)), b = !b;
          b && (d.parentNode && d.parentNode.removeChild(d), clearTimeout(r), a(c));
        }

        function I() {
          if (new Date().getTime() - H >= n) d.parentNode && d.parentNode.removeChild(d), b(Error("" + n + "ms timeout exceeded loading fonts"));else {
            var a = document.hidden;
            if (!0 === a || void 0 === a) f = e.a.offsetWidth, g = p.a.offsetWidth, h = q.a.offsetWidth, v();
            r = setTimeout(I, 50);
          }
        }

        var e = new t(k),
            p = new t(k),
            q = new t(k),
            f = -1,
            g = -1,
            h = -1,
            w = -1,
            x = -1,
            y = -1,
            d = document.createElement("div");
        d.dir = "ltr";
        u(e, L(c, "sans-serif"));
        u(p, L(c, "serif"));
        u(q, L(c, "monospace"));
        d.appendChild(e.a);
        d.appendChild(p.a);
        d.appendChild(q.a);
        document.body.appendChild(d);
        w = e.a.offsetWidth;
        x = p.a.offsetWidth;
        y = q.a.offsetWidth;
        I();
        A(e, function (a) {
          f = a;
          v();
        });
        u(e, L(c, '"' + c.family + '",sans-serif'));
        A(p, function (a) {
          g = a;
          v();
        });
        u(p, L(c, '"' + c.family + '",serif'));
        A(q, function (a) {
          h = a;
          v();
        });
        u(q, L(c, '"' + c.family + '",monospace'));
      });
    });
  };
}

var C = null,
    D = null,
    E = null,
    F = null;

function G() {
  if (null === D) if (J() && /Apple/.test(window.navigator.vendor)) {
    var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);
    D = !!a && 603 > parseInt(a[1], 10);
  } else D = !1;
  return D;
}

function J() {
  null === F && (F = !!document.fonts);
  return F;
}

function K() {
  if (null === E) {
    var a = document.createElement("div");

    try {
      a.style.font = "condensed 100px sans-serif";
    } catch (b) {}

    E = "" !== a.style.font;
  }

  return E;
}

function L(a, b) {
  return [a.style, a.weight, K() ? a.stretch : "", "100px", b].join(" ");
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (B);

/***/ }),

/***/ "./modules/limiters.js":
/*!*****************************!*\
  !*** ./modules/limiters.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "charLimit": () => (/* binding */ charLimit),
/* harmony export */   "dynamicAssign": () => (/* binding */ dynamicAssign),
/* harmony export */   "maxHeightCheck": () => (/* binding */ maxHeightCheck),
/* harmony export */   "maxLineCheck": () => (/* binding */ maxLineCheck),
/* harmony export */   "getWidth": () => (/* binding */ getWidth),
/* harmony export */   "getHeight": () => (/* binding */ getHeight),
/* harmony export */   "countLines": () => (/* binding */ countLines),
/* harmony export */   "calculateTextMetrics": () => (/* binding */ calculateTextMetrics),
/* harmony export */   "lineClamp": () => (/* binding */ lineClamp)
/* harmony export */ });
/* harmony import */ var _lineClamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lineClamp.js */ "./modules/lineClamp.js");


function inlineBlock(el) {
  if (!['inline', 'inline-block'].includes(window.getComputedStyle(el).display) || el.classList.contains('textFitted')) {
    return el;
  }

  return false;
} // find all text nodes under a given element


function textNodesUnder(el) {
  var n,
      a = [],
      walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);

  while (n = walk.nextNode()) {
    if (n.textContent.trim()) {
      if (inlineBlock(n.parentElement) && !a.includes(n.parentElement)) {
        a.push(n.parentElement);
      }
    }
  }

  return a;
} // some elemnets don't have height values set correctly so we need to drill down 


function findTextNode(target) {
  // if (child && ['SPAN','TOKEN-VALUE','STRONG','P','EM',''].includes(child.tagName)) {
  if (target.firstElementChild && !['BR'].includes(target.firstElementChild.tagName)) {
    target = findTextNode(target.firstElementChild);
  }

  return target;
} // not so simple rounding for line counting purposes


function simpleRounding(num) {
  if (num > 10) {
    return Math.round(num); // return num.toFixed(0).replace(/(\.0+|0+)$/, '');
  }

  return Math.round(num); //.replace(/(\.0+|0+)$/, '');
} // count the number of lines inside of the current direct element


function countLines(elements) {
  var elType = Object.prototype.toString.call(elements);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    elements = [elements];
  }

  let result = [...elements].map(target => {
    // if (1 == 2) {
    //   target.classList.add('countingLines');
    //   let testBox = document.createElement("div");
    //   let counterTarget = findTextNode(target)
    //   console.log(counterTarget)
    //   // let targetFix = target.firstChild ? target.firstChild.classList === "textFitted" ? target.firstChild : target : target; 
    //   testBox.classList = "lineCounter";
    //   // testBox.style.fontFamily = "-webkit-pictograph";
    //   // testBox.style.display = "block";
    //   // testBox.style.fontSize = targetFix.style.fontSize;
    //   testBox.innerText = "â";
    //   counterTarget.insertAdjacentElement('afterbegin', testBox) 
    //   let oneLineHeight = getHeight(testBox);
    //   testBox.remove();
    //   let lineCount = getHeight(target) / oneLineHeight;
    //   target.classList.remove('countingLines')
    //   let lineCountRounded = simpleRounding(lineCount)
    //   target.dataset.calculatedLinesCount = lineCountRounded; // adds property for CSS targeting
    //   target.dataset.rawLinesCount = lineCount; // adds property for CSS targeting
    //   return lineCountRounded;
    // } else {
    let muiltCount = 0;
    let textNodes = textNodesUnder(target); // let test = textNodes.forEach((s) => {
    //   console.log(s)
    // })

    console.log(textNodes, 'textNodes');
    textNodes.forEach(el => {
      // let inlineElement = 
      // if (el.nodeName ==)
      // let displayType = window.getComputedStyle(el).display;
      // if (displayType == "inline" || displayType == "inline-block") {
      //   el = el.parentElement
      // }
      // if (inlineBlock(el)) {
      let metrics = calculateTextMetrics(el);
      let line = simpleRounding(metrics.lineCount);
      console.log(el, line);

      if (line) {
        el.dataset.rawLinesCount = line;
        muiltCount += line;
      } // }

    }); // console.log(target.innerText.substring(0, 10), muiltCount)

    let lineCountRounded = simpleRounding(muiltCount);
    target.dataset.calculatedLinesCount = lineCountRounded; // adds property for CSS targeting

    return lineCountRounded; // let metrics = calculateTextMetrics(target);
    // if (metrics.lineCount) {
    //   let lineCountRounded = simpleRounding(metrics.lineCount)
    //   target.dataset.calculatedLinesCount = lineCountRounded // adds property for CSS targeting
    //   target.dataset.rawLinesCount = metrics.lineCount; // adds property for CSS targeting
    //   return lineCountRounded
    // }
    // return null
    // }
  });

  if (result.length == 1) {
    return result[0];
  }

  return result;
}

let clampDefaults = {
  maxLines: 1,
  minFontSize: 18,
  useSoftClamp: true,
  ellipsis: '...'
};

function lineClamp(elements, config) {
  config = { ...clampDefaults,
    ...config
  };
  var elType = Object.prototype.toString.call(elements);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    elements = [elements];
  }

  return [...elements].map(element => {
    const clamp = new _lineClamp_js__WEBPACK_IMPORTED_MODULE_0__.default(element, config);
    clamp.apply();
    clamp.watch();
    return clamp;
  });
} // returns lineCount and line hieght info from this libaray https://github.com/tvanc/lineclamp


function calculateTextMetrics(elements, config) {
  var elType = Object.prototype.toString.call(elements);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    elements = [elements];
  }

  let result = [...elements].map(element => {
    return new _lineClamp_js__WEBPACK_IMPORTED_MODULE_0__.default(element, config).calculateTextMetrics();
  });

  if (result.length == 1) {
    return result[0];
  }

  return result;
} // Calculate height without padding.


function getHeight(el) {
  var style = window.getComputedStyle(el, null);
  var height = parseFloat(style.getPropertyValue("height"));
  var box_sizing = style.getPropertyValue("box-sizing");

  if (box_sizing === "border-box") {
    var padding_top = parseFloat(style.getPropertyValue("padding-top"));
    var padding_bottom = parseFloat(style.getPropertyValue("padding-bottom"));
    var border_top = parseFloat(style.getPropertyValue("border-top-width"));
    var border_bottom = parseFloat(style.getPropertyValue("border-bottom-width"));
    height = height - padding_top - padding_bottom - border_top - border_bottom;
  }

  el.dataset.calculatedHeight = height; // adds property for debuging

  return height;
} // Calculate width without padding.


function getWidth(el) {
  var style = window.getComputedStyle(el, null);
  var width = parseFloat(style.getPropertyValue("width"));
  var box_sizing = style.getPropertyValue("box-sizing");

  if (box_sizing === "border-box") {
    var padding_left = parseFloat(style.getPropertyValue("padding-left"));
    var padding_right = parseFloat(style.getPropertyValue("padding-right"));
    var border_left = parseFloat(style.getPropertyValue("border-left-width"));
    var border_right = parseFloat(style.getPropertyValue("border-right-width"));
    width = width - padding_left - padding_right - border_left - border_right;
  }

  el.dataset.calculatedWidth = width; // adds property for debuging

  return width;
}

function maxLineCheck(element = null) {
  const isExportMode = window.location.href.indexOf("exports") > -1;
  const isLocalDev = window.location.href.indexOf("localhost") > -1;
  const preventExportOverflow = document.body.dataset.preventExportOverflow === "true";
  const isProjectKit = isLocalDev ? undefined : window.parent.document.querySelector(".preview-frame");
  if (isExportMode && preventExportOverflow || isProjectKit) return;
  const blocks = document.querySelectorAll("[data-max-line]");
  blocks.forEach(block => {
    const lineCount = countLines(block); // Getting the data-max-line attribute value (max number of lines allowed) 

    const maxLine = block.dataset.maxLineAlt || block.dataset.maxLine;
    lineCount > maxLine ? block.classList.add("overflow") : block.classList.remove("overflow");
  });
  return true;
}
/**
*Detailed instruction can be found here:
 https://github.com/aleks-frontend/max-height-check
*/


function maxHeightCheck(element = null) {
  const isExportMode = window.location.href.indexOf("exports") > -1;
  const isLocalDev = window.location.href.indexOf("localhost") > -1;
  const preventExportOverflow = document.body.dataset.preventExportOverflow === "true";
  const isProjectKit = isLocalDev ? undefined : window.parent.document.querySelector(".preview-frame");
  if (isExportMode && preventExportOverflow || isProjectKit) return;
  const blocks = document.querySelectorAll("[data-max-height]");
  blocks.forEach(block => {
    if (block.dataset.maxHeight === "dynamic" || block.dataset.maxHeightDynamic === "true") {
      dynamicAssign(block);
    }

    const blockHeight = getHeight(block);
    const maxHeight = block.dataset.maxHeight; // TODO improve this 

    if (block.dataset.maxHeight === "css") {
      const computedBlockStyle = window.getComputedStyle(block);
      const cssMaxHeight = parseFloat(computedBlockStyle.maxHeight);

      if (!cssMaxHeight) {
        console.error('There needs to be a max height set on the element if you want to use data-max-height="css"');
      }

      maxHeight = cssMaxHeight;
    } else {
      // Setting the element's max-height
      block.style.maxHeight = maxHeight + block.dataset.maxHeightUnit || "px"; // Recalculating maxHeight in case 'rem' is set as a unit

      if (block.dataset.maxHeightUnit === "rem") {
        maxHeight = maxHeight * parseFloat(window.getComputedStyle(document.body).fontSize);
      }
    } // Adding an 'overflow' class to an element if it's offset height exceedes the max-line-height


    blockHeight > maxHeight ? block.classList.add("overflow") : block.classList.remove("overflow");
  });
}

function dynamicAssign(element = null) {
  const container = element.parentNode;
  container.style.overflow = "hidden"; // const containerComputed = {
  //   height: parseFloat(window.getComputedStyle(container).height),
  //   top: parseFloat(window.getComputedStyle(container).paddingTop),
  //   bottom: parseFloat(window.getComputedStyle(container).paddingBottom),
  // };
  // const containerHeight = Math.floor(
  //   containerComputed.height - containerComputed.top - containerComputed.bottom
  // );

  const containerHeight = getHeight(container); // TODO work out what subtrahend is 

  const subtrahends = [...container.querySelectorAll(".js-subtrahend")];
  const subtrahendsHeight = subtrahends.reduce((totalHeight, subtrahend) => {
    const subtrahendMargins = {
      top: parseFloat(window.getComputedStyle(subtrahend).marginTop),
      bottom: parseFloat(window.getComputedStyle(subtrahend).marginBottom)
    };
    return totalHeight + subtrahend.offsetHeight + subtrahendMargins.top + subtrahendMargins.bottom;
  }, 0);
  const dynamicHeight = containerHeight - subtrahendsHeight;
  element.dataset.maxHeightDynamic = "true";
  element.dataset.maxHeight = dynamicHeight;
  container.style.overflow = "visible";
} // Adding limit for the word length


function charLimit(element = null) {
  const blocks = document.querySelectorAll("[data-char-limit]");
  blocks.forEach(element => {
    const limit = element.dataset.charLimit;

    if (element === null) {
      return;
    }

    var tokenValue = element.querySelectorAll(".token-value");

    if (tokenValue.length != 0) {
      element = tokenValue.item(0);
    }

    var code = element.innerText;

    if (code.length > limit) {
      // Check Token Again
      if (tokenValue.length != 0) {
        element.parentNode.classList.add("overflow");
      } else {
        element.classList.add("overflow");
      }
    } else {
      // Check Token Again
      if (tokenValue.length != 0) {
        element.parentNode.classList.remove("overflow");
      } else {
        element.classList.remove("overflow");
      }
    }
  });
}



/***/ }),

/***/ "./modules/lineClamp.js":
/*!******************************!*\
  !*** ./modules/lineClamp.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineClamp)
/* harmony export */ });
/* harmony import */ var _limiters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limiters.js */ "./modules/limiters.js");

/**
 * Reduces font size or trims text to make it fit within specified bounds.
 *
 * Supports clamping by number of lines or text height.
 *
 * Known limitations:
 * 1. Characters that distort line heights (emojis, zalgo) may cause
 * unexpected results.
 * 2. Calling {@see hardClamp()} wipes child elements. Future updates may allow
 * inline child elements to be preserved.
 *
 * @todo Split text metrics into own library
 * @todo Test non-LTR text
 */

class LineClamp {
  /**
   * @param {HTMLElement} element
   * The element to clamp.
   *
   * @param {Object} [options]
   * Options to govern clamping behavior.
   *
   * @param {number} [options.maxLines]
   * The maximum number of lines to allow. Defaults to 1.
   * To set a maximum height instead, use {@see options.maxHeight}
   *
   * @param {number} [options.maxHeight]
   * The maximum height (in pixels) of text in an element.
   * This option is undefined by default. Once set, it takes precedence over
   * {@see options.maxLines}. Note that this applies to the height of the text, not
   * the element itself. Restricting the height of the element can be achieved
   * with CSS <code>max-height</code>.
   *
   * @param {boolean} [options.useSoftClamp]
   * If true, reduce font size (soft clamp) to at least {@see options.minFontSize}
   * before resorting to trimming text. Defaults to false.
   *
   * @param {boolean} [options.hardClampAsFallback]
   * If true, resort to hard clamping if soft clamping reaches the minimum font size
   * and still doesn't fit within the max height or number of lines.
   * Defaults to true.
   *
   * @param {string} [options.ellipsis]
   * The character with which to represent clipped trailing text.
   * This option takes effect when "hard" clamping is used.
   *
   * @param {number} [options.minFontSize]
   * The lowest font size, in pixels, to try before resorting to removing
   * trailing text (hard clamping). Defaults to 1.
   *
   * @param {number} [options.maxFontSize]
   * The maximum font size in pixels. We'll start with this font size then
   * reduce until text fits constraints, or font size is equal to
   * {@see options.minFontSize}. Defaults to the element's initial computed font size.
   */
  constructor(element, {
    maxLines = undefined,
    maxHeight = undefined,
    useSoftClamp = false,
    hardClampAsFallback = true,
    minFontSize = 1,
    maxFontSize = undefined,
    ellipsis = "â¦"
  } = {}) {
    Object.defineProperty(this, "originalWords", {
      writable: false,
      value: element.textContent.match(/\S+\s*/g) || []
    });
    Object.defineProperty(this, "updateHandler", {
      writable: false,
      value: () => this.apply()
    });
    Object.defineProperty(this, "observer", {
      writable: false,
      value: new MutationObserver(this.updateHandler)
    });

    if (undefined === maxFontSize) {
      maxFontSize = parseInt(window.getComputedStyle(element).fontSize, 10);
    }

    this.element = element;
    this.maxLines = maxLines;
    this.maxHeight = maxHeight;
    this.useSoftClamp = useSoftClamp;
    this.hardClampAsFallback = hardClampAsFallback;
    this.minFontSize = minFontSize;
    this.maxFontSize = maxFontSize;
    this.ellipsis = ellipsis;
  }
  /**
   * Gather metrics about the layout of the element's text.
   * This is a somewhat expensive operation - call with care.
   *
   * @returns {TextMetrics}
   * Layout metrics for the clamped element's text.
   */


  calculateTextMetrics() {
    const element = this.element;
    const clone = element.cloneNode(true);
    const style = clone.style; // Append, don't replace

    style.cssText += ";min-height:0!important;max-height:none!important";
    element.replaceWith(clone);
    const naturalHeight = clone.offsetHeight; // Clear to measure empty height. textContent faster than innerHTML

    clone.textContent = "";
    const naturalHeightWithoutText = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone); // clone.offsetHeight

    const textHeight = naturalHeight - naturalHeightWithoutText; // Fill element with single non-breaking space to find height of one line

    clone.textContent = "\xa0"; // Get height of element with only one line of text

    const naturalHeightWithOneLine = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone); // clone.offsetHeight

    const firstLineHeight = naturalHeightWithOneLine - naturalHeightWithoutText; // Add line (<br> + nbsp). appendChild() faster than innerHTML

    clone.appendChild(document.createElement("br"));
    clone.appendChild(document.createTextNode("\xa0"));
    const additionalLineHeight = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(clone) - naturalHeightWithOneLine; // clone.offsetHeight - naturalHeightWithOneLine

    const lineCount = 1 + (naturalHeight - naturalHeightWithOneLine) / additionalLineHeight; // Restore original content

    clone.replaceWith(element);
    /**
     * @typedef {Object} TextMetrics
     *
     * @property {textHeight}
     * The vertical space required to display the element's current text.
     * This is <em>not</em> necessarily the same as the height of the element.
     * This number may even be greater than the element's height in cases
     * where the text overflows the element's block axis.
     *
     * @property {naturalHeightWithOneLine}
     * The height of the element with only one line of text and without
     * minimum or maximum heights. This information may be helpful when
     * dealing with inline elements (and potentially other scenarios), where
     * the first line of text does not increase the element's height.
     *
     * @property {firstLineHeight}
     * The height that the first line of text adds to the element, i.e., the
     * difference between the height of the element while empty and the height
     * of the element while it contains one line of text. This number may be
     * zero for inline elements because the first line of text does not
     * increase the height of inline elements.
      * @property {additionalLineHeight}
     * The height that each line of text after the first adds to the element.
     *
     * @property {lineCount}
     * The number of lines of text the element contains.
     */

    return {
      textHeight,
      naturalHeightWithOneLine,
      firstLineHeight,
      additionalLineHeight,
      lineCount,
      naturalHeight
    };
  }
  /**
   * Watch for changes that may affect layout. Respond by reclamping if
   * necessary.
   */


  watch() {
    if (!this._watching) {
      window.addEventListener("resize", this.updateHandler); // Minimum required to detect changes to text nodes,
      // and wholesale replacement via innerHTML

      this.observer.observe(this.element, {
        characterData: true,
        subtree: true,
        childList: true,
        attributes: true
      });
      this._watching = true;
    }

    return this;
  }
  /**
   * Stop watching for layout changes.
   *
   * @returns {LineClamp}
   */


  unwatch() {
    this.observer.disconnect();
    window.removeEventListener("resize", this.updateHandler);
    this._watching = false;
    return this;
  }
  /**
   * Conduct either soft clamping or hard clamping, according to the value of
   * property {@see LineClamp.useSoftClamp}.
   */


  apply() {
    if (this.element.offsetHeight) {
      const previouslyWatching = this._watching; // Ignore internally started mutations, lest we recurse into oblivion

      this.unwatch();
      this.element.textContent = this.originalWords.join("");

      if (this.useSoftClamp) {
        this.softClamp();
      } else {
        this.hardClamp();
      } // Resume observation if previously watching


      if (previouslyWatching) {
        this.watch(false);
      }
    }

    return this;
  }
  /**
   * Trims text until it fits within constraints
   * (maximum height or number of lines).
   *
   * @see {LineClamp.maxLines}
   * @see {LineClamp.maxHeight}
   */


  hardClamp(skipCheck = true) {
    if (skipCheck || this.shouldClamp()) {
      let currentText;
      findBoundary(1, this.originalWords.length, val => {
        currentText = this.originalWords.slice(0, val).join(" ");
        this.element.textContent = currentText;
        return this.shouldClamp();
      }, (val, min, max) => {
        // Add one more word if not on max
        if (val > min) {
          currentText = this.originalWords.slice(0, max).join(" ");
        } // Then trim letters until it fits


        do {
          currentText = currentText.slice(0, -1);
          this.element.textContent = currentText + this.ellipsis;
        } while (this.shouldClamp()); // Broadcast more specific hardClamp event first


        emit(this, "lineclamp.hardclamp");
        emit(this, "lineclamp.clamp");
      });
    }

    return this;
  }
  /**
   * Reduces font size until text fits within the specified height or number of
   * lines. Resorts to using {@see hardClamp()} if text still exceeds clamp
   * parameters.
   */


  softClamp() {
    const style = this.element.style;
    const startSize = window.getComputedStyle(this.element).fontSize;
    style.fontSize = "";
    let done = false;
    let shouldClamp;
    findBoundary(this.minFontSize, this.maxFontSize, val => {
      style.fontSize = val + "px";
      shouldClamp = this.shouldClamp();
      return shouldClamp;
    }, (val, min) => {
      if (val > min) {
        style.fontSize = min + "px";
        shouldClamp = this.shouldClamp();
      }

      done = !shouldClamp;
    });
    const changed = style.fontSize !== startSize; // Emit specific softClamp event first

    if (changed) {
      emit(this, "lineclamp.softclamp");
    } // Don't emit `lineclamp.clamp` event twice.


    if (!done && this.hardClampAsFallback) {
      this.hardClamp(false);
    } else if (changed) {
      // hardClamp emits `lineclamp.clamp` too. Only emit from here if we're
      // not also hard clamping.
      emit(this, "lineclamp.clamp");
    }

    return this;
  }
  /**
   * @returns {boolean}
   * Whether height of text or number of lines exceed constraints.
   *
   * @see LineClamp.maxHeight
   * @see LineClamp.maxLines
   */


  shouldClamp() {
    const {
      lineCount,
      textHeight
    } = this.calculateTextMetrics();

    if (undefined !== this.maxHeight && undefined !== this.maxLines) {
      return textHeight > this.maxHeight || lineCount > this.maxLines;
    }

    if (undefined !== this.maxHeight) {
      return textHeight > this.maxHeight;
    }

    if (undefined !== this.maxLines) {
      return lineCount > this.maxLines;
    }

    throw new Error("maxLines or maxHeight must be set before calling shouldClamp().");
  }

}
/**
 * Performs a binary search for the point in a contigous range where a given
 * test callback will go from returning true to returning false.
 *
 * Since this uses a binary-search algorithm this is an O(log n) function,
 * where n = max - min.
 *
 * @param {Number} min
 * The lower boundary of the range.
 *
 * @param {Number} max
 * The upper boundary of the range.
 *
 * @param test
 * A callback that receives the current value in the range and returns a truthy or falsy value.
 *
 * @param done
 * A function to perform when complete. Receives the following parameters
 * - cursor
 * - maxPassingValue
 * - minFailingValue
 */

function findBoundary(min, max, test, done) {
  // start halfway through the range
  let cursor = (min + max) / 2;

  while (max > min) {
    if (test(cursor)) {
      max = cursor;
    } else {
      min = cursor;
    }

    if (max - min === 1) {
      done(cursor, min, max);
      break;
    }

    cursor = Math.floor((min + max) / 2);
  }
}

function emit(instance, type) {
  instance.element.dispatchEvent(new CustomEvent(type));
}

/***/ }),

/***/ "./modules/mto.js":
/*!************************!*\
  !*** ./modules/mto.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setupMTO": () => (/* binding */ setupMTO),
/* harmony export */   "getSidebar": () => (/* binding */ getSidebar)
/* harmony export */ });
// get sidebar element on the current page
const getSidebar = () => {
  let sidebar = window.top.document.querySelectorAll(".sidebar .current-list");

  if (sidebar.length > 0) {
    return [...sidebar].pop();
  } else {
    return undefined;
  }
};

const hideInput = inputValue => {
  getSidebar().querySelectorAll(".sidebar-items").forEach(input => {
    if (input.querySelector(".field-variable-tag").innerText === inputValue) {
      input.style.display = 'none';
    }
  });
};

const setupMTO = (teamMetadata, teamsAllowed = '', inputName = 'Team metadata') => {
  return new Promise((resolve, reject) => {
    try {
      // const sidebar = getSidebar();
      // state isn't global in v2 so this line is needed for that version but shouldn't be included in v3
      // const state = document.body.getAttribute("document-state");
      if (!state) {
        reject('please set the state attribute');
      } // if we are on any other page then we don't need to do anything to the sidebar and we can skip everything


      if (state === "template") {
        let mtoNotSupported = () => {
          if (getSidebar().firstChild.firstChild.lastChild.innerText == inputName) {
            getSidebar().querySelector('.choice-variable').innerHTML = `<p>${inputName} functionality is not available on a template level.</p>`;
          }
        };

        setInterval(() => mtoNotSupported(), 500);
      }

      if (state === "document") {
        // turn teamsAllowed from string into array
        teamsAllowed = teamsAllowed.toLowerCase().split("_").join(" ").split(',').filter(n => n);

        let hideTeamsThatAreNotAllowed = () => {
          if (teamsAllowed.length > 0) {
            // if we are only allowing the user to select some of the teams then we should remove the ones that the user hasn't got access to. 
            if (getSidebar().firstChild.firstChild.lastChild.innerText == inputName) {
              getSidebar().querySelectorAll('.search-bar-wrapper').forEach(el => el.remove());
              getSidebar().querySelectorAll('.action-buttons').forEach(el => el.remove());
              getSidebar().querySelectorAll('.choice-variable .multichoice-edit-row').forEach(inputOption => {
                if (!teamsAllowed.includes(inputOption.querySelector("input").value)) {
                  inputOption.remove();
                } else {
                  let span = inputOption.querySelector("span"); // remove 4 digit number from start of input

                  if (span.innerText.match(/^[0-9]{4}/g)) {
                    span.innerText = span.innerText.substring(7);
                  }
                }
              });
            } else {// This means we are not on the MTO sidebar 
            }
          } else {
            // getSidebar().querySelector('.choice-variable').innerHTML = `<p>${inputName} is not available for your team. Please click back to continue editing your document.</p>`;
            hideInput(inputName);
          }
        };

        setInterval(() => hideTeamsThatAreNotAllowed(), 500);
        hideTeamsThatAreNotAllowed();
      }

      if (state === "template") {
        getSidebar().querySelectorAll('.choice-variable').innerHTML = `<p>${inputName} is only available on the edit page.</p>`;
      }

      if (['document', 'export', 'preview'].includes(state)) {
        if (typeof window.handleMTOData === 'function') {
          window.handleMTOData(teamMetadata);
        }

        resolve(teamMetadata);
      }
    } catch (error) {
      console.error("An MTO error has occurred. Please try again later. If the issue still persists please contact Outfit Support");
      reject(error);
    }
  });
};



/***/ }),

/***/ "./modules/pageSetup.js":
/*!******************************!*\
  !*** ./modules/pageSetup.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "imageCompression": () => (/* binding */ imageCompression),
/* harmony export */   "ensureAllImagesLoaded": () => (/* binding */ ensureAllImagesLoaded)
/* harmony export */ });
const imageCompression = () => {
  var imageCompressEl = document.querySelectorAll("[data-custom-compression]");
  var editorString = "?qual=editor";

  function checkURL(editorString, url) {
    if (url.includes(editorString) || url.includes(".svg")) return false;
    return true;
  }

  imageCompressEl.forEach(el => {
    //Non Repo Images with data-custom-compression on img element itself
    var imgSrc = el.getAttribute("src");
    console.log(imgSrc);

    if (imgSrc) {
      //src attribute exists assume that this is an <img> element
      if (!checkURL(editorString, imgSrc)) return;
      el.setAttribute("src", imgSrc + editorString);
    } else {
      var imgEl = el.querySelector("img");
      if (!imgEl) return;
      var imgURL = imgEl.getAttribute("src");
      if (!checkURL(editorString, imgURL)) return;
      imgEl.setAttribute("src", imgURL + editorString);
      var bkgImgEl = el.querySelector(".outfit-resizable-background");
      if (!bkgImgEl) return;
      var bkgUrl = bkgImgEl.style.backgroundImage.slice(4, -1).replace(/"/g, "");
      if (!checkURL(editorString, bkgUrl)) return;
      bkgImgEl.style.backgroundImage = `url("${bkgUrl}${editorString}")`;
    }
  });
}; // https://blog.crimx.com/2017/03/09/get-all-images-in-dom-including-background-en/
// time out is set to 60 seconds as that is as long as the platform timeout


const ensureAllImagesLoaded = (doc = document, timeout = 6e4) => {
  return new Promise((resolve, reject) => {
    loadAllImages(Array.from(searchDOM(doc)), timeout).then(resolve, reject);
  });
};

const searchDOM = doc => {
  const srcChecker = /url\(\s*?['"]?\s*?(\S+?)\s*?["']?\s*?\)/i;
  return Array.from(doc.querySelectorAll('*')).reduce((collection, node) => {
    // bg src
    let prop = window.getComputedStyle(node, null).getPropertyValue('background-image'); // match `url(...)`

    let match = srcChecker.exec(prop);

    if (match) {
      collection.add(match[1]);
    }

    if (/^img$/i.test(node.tagName)) {
      // src from img tag
      collection.add(node.src);
    } else if (/^frame$/i.test(node.tagName)) {
      // iframe
      try {
        searchDOM(node.contentDocument || node.contentWindow.document).forEach(img => {
          if (img) {
            collection.add(img);
          }
        });
      } catch (e) {}
    }

    return collection;
  }, new Set());
};

const loadImage = (src, timeout = 5000) => {
  var imgPromise = new Promise((resolve, reject) => {
    let img = new Image();

    img.onload = () => {
      resolve({
        src: src,
        width: img.naturalWidth,
        height: img.naturalHeight
      });
    };

    img.onerror = reject;
    img.src = src;
  });
  var timer = new Promise((resolve, reject) => {
    setTimeout(reject, timeout);
  });
  return Promise.race([imgPromise, timer]);
};

const loadAllImages = (imgList, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    Promise.all(imgList.map(src => loadImage(src, timeout)).map(p => p.catch(e => false))).then(results => resolve(results.filter(r => r)));
  });
};



/***/ }),

/***/ "./modules/placeholder.js":
/*!********************************!*\
  !*** ./modules/placeholder.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setupPlaceholder)
/* harmony export */ });
function setupPlaceholder(placeholderVisibility, placeholderImages) {
  // If array length < 1 or the first item is "" or null or undefined
  if (placeholderImages.length < 1 || placeholderImages[0] == "" || placeholderImages[0] == null || placeholderImages[0] == undefined || placeholderVisibility == "hide") return;
  var pages = document.querySelectorAll(".page .container");
  pages.forEach((page, index) => {
    let placeholderImage = placeholderImages[index];
    if (placeholderImage == "" || placeholderImage == null || placeholderImage == undefined) placeholderImage = placeholderImages[0];
    let placeholderStructure = `<div class="placeholderImage" style="background-image: url('${placeholderImage}')"></div>`;
    page.insertAdjacentHTML("afterbegin", placeholderStructure);
  });
}

/***/ }),

/***/ "./modules/replace.js":
/*!****************************!*\
  !*** ./modules/replace.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dynamicReplace": () => (/* binding */ dynamicReplace),
/* harmony export */   "dynamicReplaceSingle": () => (/* binding */ dynamicReplaceSingle),
/* harmony export */   "dynamicReplaceMulti": () => (/* binding */ dynamicReplaceMulti)
/* harmony export */ });
// render has an issue with replaceAll causing errors to be thrown which stops the render. This is a pollyfil for all renders
String.prototype.replaceAll = function (str, newStr) {
  // If a regex pattern
  if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
    return this.replace(str, newStr);
  } // If a string


  return this.split(str).join(newStr);
};

function dynamicReplace(selector = null, data = null) {
  if (selector != null && data != null) {
    dynamicReplaceMulti(selector, data);
  } else {
    dynamicReplaceSingle();
  }
}

function dynamicReplaceMulti(target, data) {
  const targets = document.querySelectorAll(target);
  if (targets.length === 0) return;
  targets.forEach(function (target) {
    data.forEach(function (item) {
      const inputValue = item[0];
      const lookup = item[1];

      if (target.innerText.includes(lookup) != -1 && (inputValue != "" || inputValue.length != 0)) {
        target.innerHTML = target.innerHTML.replaceAll(lookup, inputValue); //If found replace
      } else {
        let lookupSpan = `<span class='lookup-value'>${lookup}</span>`; // console.log(target.innerHTML);

        let temp = target.innerHTML.split(lookupSpan);
        temp = temp.map(x => x.replaceAll(lookup, lookupSpan));
        target.innerHTML = temp.join(lookupSpan);
      }
    });
  });
}

function dynamicReplaceSingle() {
  const elements = document.querySelectorAll("[data-replace-from]");
  if (elements.length === 0) return;
  elements.forEach(el => {
    const text = el.innerText;
    const html = el.innerHTML;
    const lookup = el.dataset.replaceFrom;
    const replace = el.dataset.replaceTo;

    if (text.search(lookup) != -1 && (replace != "" || replace.length != 0)) {
      el.innerHTML = html.replaceAll(lookup, replace);
    }
  });
}



/***/ }),

/***/ "./modules/textFit.js":
/*!****************************!*\
  !*** ./modules/textFit.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ textFit)
/* harmony export */ });
/* harmony import */ var _limiters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limiters.js */ "./modules/limiters.js");

/**
 * textFit v3.1.0
 * Previously known as jQuery.textFit
 * 11/2014 by STRML (strml.github.com)
 * MIT License
 *
 * To use: textFit(document.getElementById('target-div'), options);
 *
 * Will make the *text* content inside a container scale to fit the container
 * The container is required to have a set width and height
 * Uses binary search to fit text with minimal layout calls.
 * Version 2.0 does not use jQuery.
 */

/* global define:true, document:true, window:true, HTMLElement:true*/
// (function (root, factory) {
//   "use strict";
//   // UMD shim
//   if (typeof define === "function" && define.amd) {
//     // AMD
//     define([], factory);
//   } else if (typeof exports === "object") {
//     // Node/CommonJS
//     module.exports = factory();
//   } else {
//     // Browser
//     root.textFit = factory();
//   }
// })(typeof global === "object" ? global : this, function () {
//   "use strict";

var defaultSettings = {
  alignVert: false,
  // if true, textFit will align vertically using css tables
  alignHoriz: false,
  // if true, textFit will set text-align: center
  multiLine: false,
  // if true, textFit will not set white-space: no-wrap
  stopOverflow: false,
  // if true, a error we be thrown if the content is overflowing
  fontUnit: "rem",
  // what unit should the final font be. using rems or mm is sometimes useful
  fontChangeSize: 0.1,
  // how much should the font size by ajusted by each time. 0.1 and 0.01 is useful for when using a rem font unit
  minFontSize: 0.3,
  maxFontSize: 1,
  maxLine: false,
  reProcess: true,
  // if true, textFit will re-process already-fit nodes. Set to 'false' for better performance
  widthOnly: false,
  // if true, textFit will fit text to element width, regardless of text height
  alignVertWithFlexbox: false,
  // if true, textFit will use flexbox for vertical alignment
  display: "inline-block" // in case you need to change this

};
function textFit(els, options) {
  if (!options) options = {}; // Extend options.

  var settings = {};

  for (var key in defaultSettings) {
    if (options.hasOwnProperty(key)) {
      settings[key] = options[key];
    } else {
      settings[key] = defaultSettings[key];
    }
  } // Convert jQuery objects into arrays


  if (typeof els.toArray === "function") {
    els = els.toArray();
  } // Support passing a single el


  var elType = Object.prototype.toString.call(els);

  if (elType !== "[object Array]" && elType !== "[object NodeList]" && elType !== "[object HTMLCollection]") {
    els = [els];
  } // Process each el we've passed.


  for (var i = 0; i < els.length; i++) {
    try {
      processItem(els[i], settings);
    } catch (e) {
      throw e;
    }
  }
}
;
/**
 * The meat. Given an el, make the text inside it fit its parent.
 * @param  {DOMElement} el       Child el.
 * @param  {Object} settings     Options for fit.
 */

function processItem(el, settings) {
  if (!isElement(el) || !settings.reProcess && el.getAttribute("textFitted")) {
    return false;
  } // Set textFitted attribute so we know this was processed.


  if (!settings.reProcess) {
    el.setAttribute("textFitted", 1);
  }

  var innerSpan, originalHeight, originalHTML, originalWidth;
  var low, mid, high; // Get element data.

  originalHTML = el.innerHTML;
  originalWidth = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(el);
  originalHeight = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(el); // Don't process if we can't find box dimensions

  if (!originalWidth || !settings.widthOnly && !originalHeight) {
    if (!settings.widthOnly) throw new Error("Set a height and width on the target element " + el.outerHTML + " before using textFit!");else throw new Error("Set a width on the target element " + el.outerHTML + " before using textFit!");
  }

  let textFittedSpan = el.querySelector("span.textFitted"); // Add textFitted span inside this container.

  if (!textFittedSpan) {
    innerSpan = document.createElement("span");
    innerSpan.className = "textFitted"; // Inline block ensure it takes on the size of its contents, even if they are enclosed
    // in other tags like <p>

    innerSpan.style["display"] = settings.display;
    innerSpan.innerHTML = originalHTML;
    el.innerHTML = "";
    el.appendChild(innerSpan);
  } else {
    // Reprocessing.
    innerSpan = textFittedSpan; // Remove vertical align if we're reprocessing.

    if (innerSpan.classList.contains("textFitAlignVert")) {
      innerSpan.className = innerSpan.className.replace("textFitAlignVert", "");
      innerSpan.style["height"] = "";
      el.className.replace("textFitAlignVertFlex", "");
    }
  } // Prepare & set alignment


  if (settings.alignHoriz) {
    el.style["text-align"] = "center";
    innerSpan.style["text-align"] = "center";
  }

  var maxLine = parseInt(el.dataset.maxLine || settings.maxLine);
  console.log(maxLine, 'maxline');
  var startingSize = innerSpan.style.fontSize;
  low = settings.minFontSize;
  high = settings.maxFontSize; // Binary search for highest best fit

  var size = low;

  while (low <= high) {
    mid = parseFloat(((high + low) / 2).toFixed(2));
    innerSpan.style.fontSize = mid + settings.fontUnit;
    var scrollWidth = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(innerSpan) <= originalWidth;
    var scrollHeight = settings.widthOnly || (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(innerSpan) <= originalHeight; // check if too many lines and if it is then we need to adjust the font size accordingly

    var maxLines = false;

    if (Number.isInteger(maxLine)) {
      var lineCount = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.countLines)(innerSpan);
      maxLines = lineCount > maxLine;
    }

    if (scrollWidth && scrollHeight && !maxLines) {
      size = mid;
      low = mid + settings.fontChangeSize;
    } else {
      high = mid - settings.fontChangeSize;
    } // await injection point

  }

  if (startingSize !== size + settings.fontUnit) {
    console.log("textFit font changed to:", size + settings.fontUnit);
  } // updating font if differs:


  if (innerSpan.style.fontSize != size + settings.fontUnit) innerSpan.style.fontSize = size + settings.fontUnit; // add the required CSS in order to stop overflows

  if (Number.isInteger(maxLine) || settings.stopOverflow) {
    // if (!document.getElementById("overflowStyleSheet")) {
    //   var style = [".overflow > span {", "overflow: hidden;", "}"].join("");
    //   var css = document.createElement("style");
    //   css.type = "text/css";
    //   css.id = "overflowStyleSheet";
    //   css.innerHTML = style;
    //   document.body.appendChild(css);
    // }
    // detect if data max lines has been exceeded
    if (Number.isInteger(maxLine)) {
      el.classList.remove("overflow");
      delete el.dataset.customOverflowMessage;
      var lineCount = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.countLines)(innerSpan);
      el.dataset.lineCount = lineCount;

      if (lineCount > maxLine) {
        // el.dataset.customOverflowMessage = "Too much content has been added for the allowed space";
        el.classList.add("overflow");
      }
    } // detect if the content is larger than it's parent


    if (settings.stopOverflow) {
      var overflow = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(el) < (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(innerSpan);

      if (overflow) {
        el.classList.add("overflow");
      }
    }
  } // Our height is finalized. If we are aligning vertically, set that up.


  if (settings.alignVert) {
    // addStyleSheet();
    var height = (0,_limiters_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(innerSpan);

    if (window.getComputedStyle(el)["position"] === "static") {
      el.style["position"] = "relative";
    }

    if (!innerSpan.classList.contains("textFitAlignVert")) {
      innerSpan.className = innerSpan.className + " textFitAlignVert";
    }

    innerSpan.style["height"] = height + "px";

    if (settings.alignVertWithFlexbox && !el.classList.contains("textFitAlignVertFlex")) {
      el.className = el.className + " textFitAlignVertFlex";
    }
  }
} // Returns true if it is a DOM element


function isElement(o) {
  return typeof HTMLElement === "object" ? o instanceof HTMLElement //DOM2
  : o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
}

/***/ }),

/***/ "./node_modules/less/dist/less.js":
/*!****************************************!*\
  !*** ./node_modules/less/dist/less.js ***!
  \****************************************/
/***/ (function(module) {

/**
 * Less - Leaner CSS v4.1.1
 * http://lesscss.org
 * 
 * Copyright (c) 2009-2021, Alexis Sellier <self@cloudhead.net>
 * Licensed under the Apache-2.0 License.
 *
 * @license Apache-2.0
 */

(function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () { 'use strict';

    // Export a new default each time
    function defaultOptions () {
        return {
            /* Inline Javascript - @plugin still allowed */
            javascriptEnabled: false,
            /* Outputs a makefile import dependency list to stdout. */
            depends: false,
            /* (DEPRECATED) Compress using less built-in compression.
             * This does an okay job but does not utilise all the tricks of
             * dedicated css compression. */
            compress: false,
            /* Runs the less parser and just reports errors without any output. */
            lint: false,
            /* Sets available include paths.
             * If the file in an @import rule does not exist at that exact location,
             * less will look for it at the location(s) passed to this option.
             * You might use this for instance to specify a path to a library which
             * you want to be referenced simply and relatively in the less files. */
            paths: [],
            /* color output in the terminal */
            color: true,
            /* The strictImports controls whether the compiler will allow an @import inside of either
             * @media blocks or (a later addition) other selector blocks.
             * See: https://github.com/less/less.js/issues/656 */
            strictImports: false,
            /* Allow Imports from Insecure HTTPS Hosts */
            insecure: false,
            /* Allows you to add a path to every generated import and url in your css.
             * This does not affect less import statements that are processed, just ones
             * that are left in the output css. */
            rootpath: '',
            /* By default URLs are kept as-is, so if you import a file in a sub-directory
             * that references an image, exactly the same URL will be output in the css.
             * This option allows you to re-write URL's in imported files so that the
             * URL is always relative to the base imported file */
            rewriteUrls: false,
            /* How to process math
             *   0 always           - eagerly try to solve all operations
             *   1 parens-division  - require parens for division "/"
             *   2 parens | strict  - require parens for all operations
             *   3 strict-legacy    - legacy strict behavior (super-strict)
             */
            math: 1,
            /* Without this option, less attempts to guess at the output unit when it does maths. */
            strictUnits: false,
            /* Effectively the declaration is put at the top of your base Less file,
             * meaning it can be used but it also can be overridden if this variable
             * is defined in the file. */
            globalVars: null,
            /* As opposed to the global variable option, this puts the declaration at the
             * end of your base file, meaning it will override anything defined in your Less file. */
            modifyVars: null,
            /* This option allows you to specify a argument to go on to every URL.  */
            urlArgs: ''
        };
    }

    function extractId(href) {
        return href.replace(/^[a-z-]+:\/+?[^\/]+/, '') // Remove protocol & domain
            .replace(/[\?\&]livereload=\w+/, '') // Remove LiveReload cachebuster
            .replace(/^\//, '') // Remove root /
            .replace(/\.[a-zA-Z]+$/, '') // Remove simple extension
            .replace(/[^\.\w-]+/g, '-') // Replace illegal characters
            .replace(/\./g, ':'); // Replace dots with colons(for valid id)
    }
    function addDataAttr(options, tag) {
        for (var opt in tag.dataset) {
            if (tag.dataset.hasOwnProperty(opt)) {
                if (opt === 'env' || opt === 'dumpLineNumbers' || opt === 'rootpath' || opt === 'errorReporting') {
                    options[opt] = tag.dataset[opt];
                }
                else {
                    try {
                        options[opt] = JSON.parse(tag.dataset[opt]);
                    }
                    catch (_) { }
                }
            }
        }
    }

    var browser = {
        createCSS: function (document, styles, sheet) {
            // Strip the query-string
            var href = sheet.href || '';
            // If there is no title set, use the filename, minus the extension
            var id = "less:" + (sheet.title || extractId(href));
            // If this has already been inserted into the DOM, we may need to replace it
            var oldStyleNode = document.getElementById(id);
            var keepOldStyleNode = false;
            // Create a new stylesheet node for insertion or (if necessary) replacement
            var styleNode = document.createElement('style');
            styleNode.setAttribute('type', 'text/css');
            if (sheet.media) {
                styleNode.setAttribute('media', sheet.media);
            }
            styleNode.id = id;
            if (!styleNode.styleSheet) {
                styleNode.appendChild(document.createTextNode(styles));
                // If new contents match contents of oldStyleNode, don't replace oldStyleNode
                keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&
                    oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);
            }
            var head = document.getElementsByTagName('head')[0];
            // If there is no oldStyleNode, just append; otherwise, only append if we need
            // to replace oldStyleNode with an updated stylesheet
            if (oldStyleNode === null || keepOldStyleNode === false) {
                var nextEl = sheet && sheet.nextSibling || null;
                if (nextEl) {
                    nextEl.parentNode.insertBefore(styleNode, nextEl);
                }
                else {
                    head.appendChild(styleNode);
                }
            }
            if (oldStyleNode && keepOldStyleNode === false) {
                oldStyleNode.parentNode.removeChild(oldStyleNode);
            }
            // For IE.
            // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.
            // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head
            if (styleNode.styleSheet) {
                try {
                    styleNode.styleSheet.cssText = styles;
                }
                catch (e) {
                    throw new Error('Couldn\'t reassign styleSheet.cssText.');
                }
            }
        },
        currentScript: function (window) {
            var document = window.document;
            return document.currentScript || (function () {
                var scripts = document.getElementsByTagName('script');
                return scripts[scripts.length - 1];
            })();
        }
    };

    var addDefaultOptions = (function (window, options) {
        // use options from the current script tag data attribues
        addDataAttr(options, browser.currentScript(window));
        if (options.isFileProtocol === undefined) {
            options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);
        }
        // Load styles asynchronously (default: false)
        //
        // This is set to `false` by default, so that the body
        // doesn't start loading before the stylesheets are parsed.
        // Setting this to `true` can result in flickering.
        //
        options.async = options.async || false;
        options.fileAsync = options.fileAsync || false;
        // Interval between watch polls
        options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);
        options.env = options.env || (window.location.hostname == '127.0.0.1' ||
            window.location.hostname == '0.0.0.0' ||
            window.location.hostname == 'localhost' ||
            (window.location.port &&
                window.location.port.length > 0) ||
            options.isFileProtocol ? 'development'
            : 'production');
        var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);
        if (dumpLineNumbers) {
            options.dumpLineNumbers = dumpLineNumbers[1];
        }
        if (options.useFileCache === undefined) {
            options.useFileCache = true;
        }
        if (options.onReady === undefined) {
            options.onReady = true;
        }
        if (options.relativeUrls) {
            options.rewriteUrls = 'all';
        }
    });

    var logger = {
        error: function (msg) {
            this._fireEvent('error', msg);
        },
        warn: function (msg) {
            this._fireEvent('warn', msg);
        },
        info: function (msg) {
            this._fireEvent('info', msg);
        },
        debug: function (msg) {
            this._fireEvent('debug', msg);
        },
        addListener: function (listener) {
            this._listeners.push(listener);
        },
        removeListener: function (listener) {
            for (var i = 0; i < this._listeners.length; i++) {
                if (this._listeners[i] === listener) {
                    this._listeners.splice(i, 1);
                    return;
                }
            }
        },
        _fireEvent: function (type, msg) {
            for (var i = 0; i < this._listeners.length; i++) {
                var logFunction = this._listeners[i][type];
                if (logFunction) {
                    logFunction(msg);
                }
            }
        },
        _listeners: []
    };

    /**
     * @todo Document why this abstraction exists, and the relationship between
     *       environment, file managers, and plugin manager
     */
    var Environment = /** @class */ (function () {
        function Environment(externalEnvironment, fileManagers) {
            this.fileManagers = fileManagers || [];
            externalEnvironment = externalEnvironment || {};
            var optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];
            var requiredFunctions = [];
            var functions = requiredFunctions.concat(optionalFunctions);
            for (var i = 0; i < functions.length; i++) {
                var propName = functions[i];
                var environmentFunc = externalEnvironment[propName];
                if (environmentFunc) {
                    this[propName] = environmentFunc.bind(externalEnvironment);
                }
                else if (i < requiredFunctions.length) {
                    this.warn("missing required function in environment - " + propName);
                }
            }
        }
        Environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {
            if (!filename) {
                logger.warn('getFileManager called with no filename.. Please report this issue. continuing.');
            }
            if (currentDirectory == null) {
                logger.warn('getFileManager called with null directory.. Please report this issue. continuing.');
            }
            var fileManagers = this.fileManagers;
            if (options.pluginManager) {
                fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());
            }
            for (var i = fileManagers.length - 1; i >= 0; i--) {
                var fileManager = fileManagers[i];
                if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {
                    return fileManager;
                }
            }
            return null;
        };
        Environment.prototype.addFileManager = function (fileManager) {
            this.fileManagers.push(fileManager);
        };
        Environment.prototype.clearFileManagers = function () {
            this.fileManagers = [];
        };
        return Environment;
    }());

    var colors = {
        'aliceblue': '#f0f8ff',
        'antiquewhite': '#faebd7',
        'aqua': '#00ffff',
        'aquamarine': '#7fffd4',
        'azure': '#f0ffff',
        'beige': '#f5f5dc',
        'bisque': '#ffe4c4',
        'black': '#000000',
        'blanchedalmond': '#ffebcd',
        'blue': '#0000ff',
        'blueviolet': '#8a2be2',
        'brown': '#a52a2a',
        'burlywood': '#deb887',
        'cadetblue': '#5f9ea0',
        'chartreuse': '#7fff00',
        'chocolate': '#d2691e',
        'coral': '#ff7f50',
        'cornflowerblue': '#6495ed',
        'cornsilk': '#fff8dc',
        'crimson': '#dc143c',
        'cyan': '#00ffff',
        'darkblue': '#00008b',
        'darkcyan': '#008b8b',
        'darkgoldenrod': '#b8860b',
        'darkgray': '#a9a9a9',
        'darkgrey': '#a9a9a9',
        'darkgreen': '#006400',
        'darkkhaki': '#bdb76b',
        'darkmagenta': '#8b008b',
        'darkolivegreen': '#556b2f',
        'darkorange': '#ff8c00',
        'darkorchid': '#9932cc',
        'darkred': '#8b0000',
        'darksalmon': '#e9967a',
        'darkseagreen': '#8fbc8f',
        'darkslateblue': '#483d8b',
        'darkslategray': '#2f4f4f',
        'darkslategrey': '#2f4f4f',
        'darkturquoise': '#00ced1',
        'darkviolet': '#9400d3',
        'deeppink': '#ff1493',
        'deepskyblue': '#00bfff',
        'dimgray': '#696969',
        'dimgrey': '#696969',
        'dodgerblue': '#1e90ff',
        'firebrick': '#b22222',
        'floralwhite': '#fffaf0',
        'forestgreen': '#228b22',
        'fuchsia': '#ff00ff',
        'gainsboro': '#dcdcdc',
        'ghostwhite': '#f8f8ff',
        'gold': '#ffd700',
        'goldenrod': '#daa520',
        'gray': '#808080',
        'grey': '#808080',
        'green': '#008000',
        'greenyellow': '#adff2f',
        'honeydew': '#f0fff0',
        'hotpink': '#ff69b4',
        'indianred': '#cd5c5c',
        'indigo': '#4b0082',
        'ivory': '#fffff0',
        'khaki': '#f0e68c',
        'lavender': '#e6e6fa',
        'lavenderblush': '#fff0f5',
        'lawngreen': '#7cfc00',
        'lemonchiffon': '#fffacd',
        'lightblue': '#add8e6',
        'lightcoral': '#f08080',
        'lightcyan': '#e0ffff',
        'lightgoldenrodyellow': '#fafad2',
        'lightgray': '#d3d3d3',
        'lightgrey': '#d3d3d3',
        'lightgreen': '#90ee90',
        'lightpink': '#ffb6c1',
        'lightsalmon': '#ffa07a',
        'lightseagreen': '#20b2aa',
        'lightskyblue': '#87cefa',
        'lightslategray': '#778899',
        'lightslategrey': '#778899',
        'lightsteelblue': '#b0c4de',
        'lightyellow': '#ffffe0',
        'lime': '#00ff00',
        'limegreen': '#32cd32',
        'linen': '#faf0e6',
        'magenta': '#ff00ff',
        'maroon': '#800000',
        'mediumaquamarine': '#66cdaa',
        'mediumblue': '#0000cd',
        'mediumorchid': '#ba55d3',
        'mediumpurple': '#9370d8',
        'mediumseagreen': '#3cb371',
        'mediumslateblue': '#7b68ee',
        'mediumspringgreen': '#00fa9a',
        'mediumturquoise': '#48d1cc',
        'mediumvioletred': '#c71585',
        'midnightblue': '#191970',
        'mintcream': '#f5fffa',
        'mistyrose': '#ffe4e1',
        'moccasin': '#ffe4b5',
        'navajowhite': '#ffdead',
        'navy': '#000080',
        'oldlace': '#fdf5e6',
        'olive': '#808000',
        'olivedrab': '#6b8e23',
        'orange': '#ffa500',
        'orangered': '#ff4500',
        'orchid': '#da70d6',
        'palegoldenrod': '#eee8aa',
        'palegreen': '#98fb98',
        'paleturquoise': '#afeeee',
        'palevioletred': '#d87093',
        'papayawhip': '#ffefd5',
        'peachpuff': '#ffdab9',
        'peru': '#cd853f',
        'pink': '#ffc0cb',
        'plum': '#dda0dd',
        'powderblue': '#b0e0e6',
        'purple': '#800080',
        'rebeccapurple': '#663399',
        'red': '#ff0000',
        'rosybrown': '#bc8f8f',
        'royalblue': '#4169e1',
        'saddlebrown': '#8b4513',
        'salmon': '#fa8072',
        'sandybrown': '#f4a460',
        'seagreen': '#2e8b57',
        'seashell': '#fff5ee',
        'sienna': '#a0522d',
        'silver': '#c0c0c0',
        'skyblue': '#87ceeb',
        'slateblue': '#6a5acd',
        'slategray': '#708090',
        'slategrey': '#708090',
        'snow': '#fffafa',
        'springgreen': '#00ff7f',
        'steelblue': '#4682b4',
        'tan': '#d2b48c',
        'teal': '#008080',
        'thistle': '#d8bfd8',
        'tomato': '#ff6347',
        'turquoise': '#40e0d0',
        'violet': '#ee82ee',
        'wheat': '#f5deb3',
        'white': '#ffffff',
        'whitesmoke': '#f5f5f5',
        'yellow': '#ffff00',
        'yellowgreen': '#9acd32'
    };

    var unitConversions = {
        length: {
            'm': 1,
            'cm': 0.01,
            'mm': 0.001,
            'in': 0.0254,
            'px': 0.0254 / 96,
            'pt': 0.0254 / 72,
            'pc': 0.0254 / 72 * 12
        },
        duration: {
            's': 1,
            'ms': 0.001
        },
        angle: {
            'rad': 1 / (2 * Math.PI),
            'deg': 1 / 360,
            'grad': 1 / 400,
            'turn': 1
        }
    };

    var data = { colors: colors, unitConversions: unitConversions };

    /**
     * The reason why Node is a class and other nodes simply do not extend
     * from Node (since we're transpiling) is due to this issue:
     *
     * https://github.com/less/less.js/issues/3434
     */
    var Node = /** @class */ (function () {
        function Node() {
            this.parent = null;
            this.visibilityBlocks = undefined;
            this.nodeVisible = undefined;
            this.rootNode = null;
            this.parsed = null;
            var self = this;
            Object.defineProperty(this, 'currentFileInfo', {
                get: function () { return self.fileInfo(); }
            });
            Object.defineProperty(this, 'index', {
                get: function () { return self.getIndex(); }
            });
        }
        Node.prototype.setParent = function (nodes, parent) {
            function set(node) {
                if (node && node instanceof Node) {
                    node.parent = parent;
                }
            }
            if (Array.isArray(nodes)) {
                nodes.forEach(set);
            }
            else {
                set(nodes);
            }
        };
        Node.prototype.getIndex = function () {
            return this._index || (this.parent && this.parent.getIndex()) || 0;
        };
        Node.prototype.fileInfo = function () {
            return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};
        };
        Node.prototype.isRulesetLike = function () { return false; };
        Node.prototype.toCSS = function (context) {
            var strs = [];
            this.genCSS(context, {
                add: function (chunk, fileInfo, index) {
                    strs.push(chunk);
                },
                isEmpty: function () {
                    return strs.length === 0;
                }
            });
            return strs.join('');
        };
        Node.prototype.genCSS = function (context, output) {
            output.add(this.value);
        };
        Node.prototype.accept = function (visitor) {
            this.value = visitor.visit(this.value);
        };
        Node.prototype.eval = function () { return this; };
        Node.prototype._operate = function (context, op, a, b) {
            switch (op) {
                case '+': return a + b;
                case '-': return a - b;
                case '*': return a * b;
                case '/': return a / b;
            }
        };
        Node.prototype.fround = function (context, value) {
            var precision = context && context.numPrecision;
            // add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:
            return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;
        };
        Node.compare = function (a, b) {
            /* returns:
             -1: a < b
             0: a = b
             1: a > b
             and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */
            if ((a.compare) &&
                // for "symmetric results" force toCSS-based comparison
                // of Quoted or Anonymous if either value is one of those
                !(b.type === 'Quoted' || b.type === 'Anonymous')) {
                return a.compare(b);
            }
            else if (b.compare) {
                return -b.compare(a);
            }
            else if (a.type !== b.type) {
                return undefined;
            }
            a = a.value;
            b = b.value;
            if (!Array.isArray(a)) {
                return a === b ? 0 : undefined;
            }
            if (a.length !== b.length) {
                return undefined;
            }
            for (var i = 0; i < a.length; i++) {
                if (Node.compare(a[i], b[i]) !== 0) {
                    return undefined;
                }
            }
            return 0;
        };
        Node.numericCompare = function (a, b) {
            return a < b ? -1
                : a === b ? 0
                    : a > b ? 1 : undefined;
        };
        // Returns true if this node represents root of ast imported by reference
        Node.prototype.blocksVisibility = function () {
            if (this.visibilityBlocks == null) {
                this.visibilityBlocks = 0;
            }
            return this.visibilityBlocks !== 0;
        };
        Node.prototype.addVisibilityBlock = function () {
            if (this.visibilityBlocks == null) {
                this.visibilityBlocks = 0;
            }
            this.visibilityBlocks = this.visibilityBlocks + 1;
        };
        Node.prototype.removeVisibilityBlock = function () {
            if (this.visibilityBlocks == null) {
                this.visibilityBlocks = 0;
            }
            this.visibilityBlocks = this.visibilityBlocks - 1;
        };
        // Turns on node visibility - if called node will be shown in output regardless
        // of whether it comes from import by reference or not
        Node.prototype.ensureVisibility = function () {
            this.nodeVisible = true;
        };
        // Turns off node visibility - if called node will NOT be shown in output regardless
        // of whether it comes from import by reference or not
        Node.prototype.ensureInvisibility = function () {
            this.nodeVisible = false;
        };
        // return values:
        // false - the node must not be visible
        // true - the node must be visible
        // undefined or null - the node has the same visibility as its parent
        Node.prototype.isVisible = function () {
            return this.nodeVisible;
        };
        Node.prototype.visibilityInfo = function () {
            return {
                visibilityBlocks: this.visibilityBlocks,
                nodeVisible: this.nodeVisible
            };
        };
        Node.prototype.copyVisibilityInfo = function (info) {
            if (!info) {
                return;
            }
            this.visibilityBlocks = info.visibilityBlocks;
            this.nodeVisible = info.nodeVisible;
        };
        return Node;
    }());

    //
    // RGB Colors - #ff0014, #eee
    //
    var Color = function (rgb, a, originalForm) {
        var self = this;
        //
        // The end goal here, is to parse the arguments
        // into an integer triplet, such as `128, 255, 0`
        //
        // This facilitates operations and conversions.
        //
        if (Array.isArray(rgb)) {
            this.rgb = rgb;
        }
        else if (rgb.length >= 6) {
            this.rgb = [];
            rgb.match(/.{2}/g).map(function (c, i) {
                if (i < 3) {
                    self.rgb.push(parseInt(c, 16));
                }
                else {
                    self.alpha = (parseInt(c, 16)) / 255;
                }
            });
        }
        else {
            this.rgb = [];
            rgb.split('').map(function (c, i) {
                if (i < 3) {
                    self.rgb.push(parseInt(c + c, 16));
                }
                else {
                    self.alpha = (parseInt(c + c, 16)) / 255;
                }
            });
        }
        this.alpha = this.alpha || (typeof a === 'number' ? a : 1);
        if (typeof originalForm !== 'undefined') {
            this.value = originalForm;
        }
    };
    Color.prototype = Object.assign(new Node(), {
        type: 'Color',
        luma: function () {
            var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255;
            r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);
            g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);
            b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);
            return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        },
        genCSS: function (context, output) {
            output.add(this.toCSS(context));
        },
        toCSS: function (context, doNotCompress) {
            var compress = context && context.compress && !doNotCompress;
            var color;
            var alpha;
            var colorFunction;
            var args = [];
            // `value` is set if this color was originally
            // converted from a named color string so we need
            // to respect this and try to output named color too.
            alpha = this.fround(context, this.alpha);
            if (this.value) {
                if (this.value.indexOf('rgb') === 0) {
                    if (alpha < 1) {
                        colorFunction = 'rgba';
                    }
                }
                else if (this.value.indexOf('hsl') === 0) {
                    if (alpha < 1) {
                        colorFunction = 'hsla';
                    }
                    else {
                        colorFunction = 'hsl';
                    }
                }
                else {
                    return this.value;
                }
            }
            else {
                if (alpha < 1) {
                    colorFunction = 'rgba';
                }
            }
            switch (colorFunction) {
                case 'rgba':
                    args = this.rgb.map(function (c) {
                        return clamp(Math.round(c), 255);
                    }).concat(clamp(alpha, 1));
                    break;
                case 'hsla':
                    args.push(clamp(alpha, 1));
                case 'hsl':
                    color = this.toHSL();
                    args = [
                        this.fround(context, color.h),
                        this.fround(context, color.s * 100) + "%",
                        this.fround(context, color.l * 100) + "%"
                    ].concat(args);
            }
            if (colorFunction) {
                // Values are capped between `0` and `255`, rounded and zero-padded.
                return colorFunction + "(" + args.join("," + (compress ? '' : ' ')) + ")";
            }
            color = this.toRGB();
            if (compress) {
                var splitcolor = color.split('');
                // Convert color to short format
                if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
                    color = "#" + splitcolor[1] + splitcolor[3] + splitcolor[5];
                }
            }
            return color;
        },
        //
        // Operations have to be done per-channel, if not,
        // channels will spill onto each other. Once we have
        // our result, in the form of an integer triplet,
        // we create a new Color node to hold the result.
        //
        operate: function (context, op, other) {
            var rgb = new Array(3);
            var alpha = this.alpha * (1 - other.alpha) + other.alpha;
            for (var c = 0; c < 3; c++) {
                rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);
            }
            return new Color(rgb, alpha);
        },
        toRGB: function () {
            return toHex(this.rgb);
        },
        toHSL: function () {
            var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255, a = this.alpha;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h;
            var s;
            var l = (max + min) / 2;
            var d = max - min;
            if (max === min) {
                h = s = 0;
            }
            else {
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s, l: l, a: a };
        },
        // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        toHSV: function () {
            var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255, a = this.alpha;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h;
            var s;
            var v = max;
            var d = max - min;
            if (max === 0) {
                s = 0;
            }
            else {
                s = d / max;
            }
            if (max === min) {
                h = 0;
            }
            else {
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s, v: v, a: a };
        },
        toARGB: function () {
            return toHex([this.alpha * 255].concat(this.rgb));
        },
        compare: function (x) {
            return (x.rgb &&
                x.rgb[0] === this.rgb[0] &&
                x.rgb[1] === this.rgb[1] &&
                x.rgb[2] === this.rgb[2] &&
                x.alpha === this.alpha) ? 0 : undefined;
        }
    });
    Color.fromKeyword = function (keyword) {
        var c;
        var key = keyword.toLowerCase();
        if (colors.hasOwnProperty(key)) {
            c = new Color(colors[key].slice(1));
        }
        else if (key === 'transparent') {
            c = new Color([0, 0, 0], 0);
        }
        if (c) {
            c.value = keyword;
            return c;
        }
    };
    function clamp(v, max) {
        return Math.min(Math.max(v, 0), max);
    }
    function toHex(v) {
        return "#" + v.map(function (c) {
            c = clamp(Math.round(c), 255);
            return (c < 16 ? '0' : '') + c.toString(16);
        }).join('');
    }

    var Paren = function (node) {
        this.value = node;
    };
    Paren.prototype = Object.assign(new Node(), {
        type: 'Paren',
        genCSS: function (context, output) {
            output.add('(');
            this.value.genCSS(context, output);
            output.add(')');
        },
        eval: function (context) {
            return new Paren(this.value.eval(context));
        }
    });

    var _noSpaceCombinators = {
        '': true,
        ' ': true,
        '|': true
    };
    var Combinator = function (value) {
        if (value === ' ') {
            this.value = ' ';
            this.emptyOrWhitespace = true;
        }
        else {
            this.value = value ? value.trim() : '';
            this.emptyOrWhitespace = this.value === '';
        }
    };
    Combinator.prototype = Object.assign(new Node(), {
        type: 'Combinator',
        genCSS: function (context, output) {
            var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';
            output.add(spaceOrEmpty + this.value + spaceOrEmpty);
        }
    });

    var Element = function (combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {
        this.combinator = combinator instanceof Combinator ?
            combinator : new Combinator(combinator);
        if (typeof value === 'string') {
            this.value = value.trim();
        }
        else if (value) {
            this.value = value;
        }
        else {
            this.value = '';
        }
        this.isVariable = isVariable;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.copyVisibilityInfo(visibilityInfo);
        this.setParent(this.combinator, this);
    };
    Element.prototype = Object.assign(new Node(), {
        type: 'Element',
        accept: function (visitor) {
            var value = this.value;
            this.combinator = visitor.visit(this.combinator);
            if (typeof value === 'object') {
                this.value = visitor.visit(value);
            }
        },
        eval: function (context) {
            return new Element(this.combinator, this.value.eval ? this.value.eval(context) : this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        clone: function () {
            return new Element(this.combinator, this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        genCSS: function (context, output) {
            output.add(this.toCSS(context), this.fileInfo(), this.getIndex());
        },
        toCSS: function (context) {
            context = context || {};
            var value = this.value;
            var firstSelector = context.firstSelector;
            if (value instanceof Paren) {
                // selector in parens should not be affected by outer selector
                // flags (breaks only interpolated selectors - see #1973)
                context.firstSelector = true;
            }
            value = value.toCSS ? value.toCSS(context) : value;
            context.firstSelector = firstSelector;
            if (value === '' && this.combinator.value.charAt(0) === '&') {
                return '';
            }
            else {
                return this.combinator.toCSS(context) + value;
            }
        }
    });

    var Math$1 = {
        ALWAYS: 0,
        PARENS_DIVISION: 1,
        PARENS: 2
        // removed - STRICT_LEGACY: 3
    };
    var RewriteUrls = {
        OFF: 0,
        LOCAL: 1,
        ALL: 2
    };

    /**
     * Returns the object type of the given payload
     *
     * @param {*} payload
     * @returns {string}
     */
    function getType(payload) {
        return Object.prototype.toString.call(payload).slice(8, -1);
    }
    /**
     * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
     *
     * @param {*} payload
     * @returns {payload is Record<string, any>}
     */
    function isPlainObject(payload) {
        if (getType(payload) !== 'Object')
            return false;
        return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
    }
    /**
     * Returns whether the payload is an array
     *
     * @param {any} payload
     * @returns {payload is any[]}
     */
    function isArray(payload) {
        return getType(payload) === 'Array';
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
        var propType = {}.propertyIsEnumerable.call(originalObject, key)
            ? 'enumerable'
            : 'nonenumerable';
        if (propType === 'enumerable')
            carry[key] = newVal;
        if (includeNonenumerable && propType === 'nonenumerable') {
            Object.defineProperty(carry, key, {
                value: newVal,
                enumerable: false,
                writable: true,
                configurable: true,
            });
        }
    }
    /**
     * Copy (clone) an object and all its props recursively to get rid of any prop referenced of the original object. Arrays are also cloned, however objects inside arrays are still linked.
     *
     * @export
     * @template T
     * @param {T} target Target can be anything
     * @param {Options} [options={}] Options can be `props` or `nonenumerable`
     * @returns {T} the target with replaced values
     * @export
     */
    function copy(target, options) {
        if (options === void 0) { options = {}; }
        if (isArray(target))
            return target.map(function (i) { return copy(i, options); });
        if (!isPlainObject(target))
            return target;
        var props = Object.getOwnPropertyNames(target);
        var symbols = Object.getOwnPropertySymbols(target);
        return __spreadArrays(props, symbols).reduce(function (carry, key) {
            if (isArray(options.props) && !options.props.includes(key)) {
                return carry;
            }
            var val = target[key];
            var newVal = copy(val, options);
            assignProp(carry, key, newVal, target, options.nonenumerable);
            return carry;
        }, {});
    }

    /* jshint proto: true */
    function getLocation(index, inputStream) {
        var n = index + 1;
        var line = null;
        var column = -1;
        while (--n >= 0 && inputStream.charAt(n) !== '\n') {
            column++;
        }
        if (typeof index === 'number') {
            line = (inputStream.slice(0, index).match(/\n/g) || '').length;
        }
        return {
            line: line,
            column: column
        };
    }
    function copyArray(arr) {
        var i;
        var length = arr.length;
        var copy = new Array(length);
        for (i = 0; i < length; i++) {
            copy[i] = arr[i];
        }
        return copy;
    }
    function clone(obj) {
        var cloned = {};
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                cloned[prop] = obj[prop];
            }
        }
        return cloned;
    }
    function defaults(obj1, obj2) {
        var newObj = obj2 || {};
        if (!obj2._defaults) {
            newObj = {};
            var defaults_1 = copy(obj1);
            newObj._defaults = defaults_1;
            var cloned = obj2 ? copy(obj2) : {};
            Object.assign(newObj, defaults_1, cloned);
        }
        return newObj;
    }
    function copyOptions(obj1, obj2) {
        if (obj2 && obj2._defaults) {
            return obj2;
        }
        var opts = defaults(obj1, obj2);
        if (opts.strictMath) {
            opts.math = Math$1.PARENS;
        }
        // Back compat with changed relativeUrls option
        if (opts.relativeUrls) {
            opts.rewriteUrls = RewriteUrls.ALL;
        }
        if (typeof opts.math === 'string') {
            switch (opts.math.toLowerCase()) {
                case 'always':
                    opts.math = Math$1.ALWAYS;
                    break;
                case 'parens-division':
                    opts.math = Math$1.PARENS_DIVISION;
                    break;
                case 'strict':
                case 'parens':
                    opts.math = Math$1.PARENS;
                    break;
                default:
                    opts.math = Math$1.PARENS;
            }
        }
        if (typeof opts.rewriteUrls === 'string') {
            switch (opts.rewriteUrls.toLowerCase()) {
                case 'off':
                    opts.rewriteUrls = RewriteUrls.OFF;
                    break;
                case 'local':
                    opts.rewriteUrls = RewriteUrls.LOCAL;
                    break;
                case 'all':
                    opts.rewriteUrls = RewriteUrls.ALL;
                    break;
            }
        }
        return opts;
    }
    function merge(obj1, obj2) {
        for (var prop in obj2) {
            if (obj2.hasOwnProperty(prop)) {
                obj1[prop] = obj2[prop];
            }
        }
        return obj1;
    }
    function flattenArray(arr, result) {
        if (result === void 0) { result = []; }
        for (var i = 0, length_1 = arr.length; i < length_1; i++) {
            var value = arr[i];
            if (Array.isArray(value)) {
                flattenArray(value, result);
            }
            else {
                if (value !== undefined) {
                    result.push(value);
                }
            }
        }
        return result;
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getLocation: getLocation,
        copyArray: copyArray,
        clone: clone,
        defaults: defaults,
        copyOptions: copyOptions,
        merge: merge,
        flattenArray: flattenArray
    });

    var anonymousFunc = /(<anonymous>|Function):(\d+):(\d+)/;
    /**
     * This is a centralized class of any error that could be thrown internally (mostly by the parser).
     * Besides standard .message it keeps some additional data like a path to the file where the error
     * occurred along with line and column numbers.
     *
     * @class
     * @extends Error
     * @type {module.LessError}
     *
     * @prop {string} type
     * @prop {string} filename
     * @prop {number} index
     * @prop {number} line
     * @prop {number} column
     * @prop {number} callLine
     * @prop {number} callExtract
     * @prop {string[]} extract
     *
     * @param {Object} e              - An error object to wrap around or just a descriptive object
     * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?
     * @param {string} [currentFilename]
     */
    var LessError = function (e, fileContentMap, currentFilename) {
        Error.call(this);
        var filename = e.filename || currentFilename;
        this.message = e.message;
        this.stack = e.stack;
        if (fileContentMap && filename) {
            var input = fileContentMap.contents[filename];
            var loc = getLocation(e.index, input);
            var line = loc.line;
            var col = loc.column;
            var callLine = e.call && getLocation(e.call, input).line;
            var lines = input ? input.split('\n') : '';
            this.type = e.type || 'Syntax';
            this.filename = filename;
            this.index = e.index;
            this.line = typeof line === 'number' ? line + 1 : null;
            this.column = col;
            if (!this.line && this.stack) {
                var found = this.stack.match(anonymousFunc);
                /**
                 * We have to figure out how this environment stringifies anonymous functions
                 * so we can correctly map plugin errors.
                 *
                 * Note, in Node 8, the output of anonymous funcs varied based on parameters
                 * being present or not, so we inject dummy params.
                 */
                var func = new Function('a', 'throw new Error()');
                var lineAdjust = 0;
                try {
                    func();
                }
                catch (e) {
                    var match = e.stack.match(anonymousFunc);
                    var line = parseInt(match[2]);
                    lineAdjust = 1 - line;
                }
                if (found) {
                    if (found[2]) {
                        this.line = parseInt(found[2]) + lineAdjust;
                    }
                    if (found[3]) {
                        this.column = parseInt(found[3]);
                    }
                }
            }
            this.callLine = callLine + 1;
            this.callExtract = lines[callLine];
            this.extract = [
                lines[this.line - 2],
                lines[this.line - 1],
                lines[this.line]
            ];
        }
    };
    if (typeof Object.create === 'undefined') {
        var F = function () { };
        F.prototype = Error.prototype;
        LessError.prototype = new F();
    }
    else {
        LessError.prototype = Object.create(Error.prototype);
    }
    LessError.prototype.constructor = LessError;
    /**
     * An overridden version of the default Object.prototype.toString
     * which uses additional information to create a helpful message.
     *
     * @param {Object} options
     * @returns {string}
     */
    LessError.prototype.toString = function (options) {
        options = options || {};
        var message = '';
        var extract = this.extract || [];
        var error = [];
        var stylize = function (str) { return str; };
        if (options.stylize) {
            var type = typeof options.stylize;
            if (type !== 'function') {
                throw Error("options.stylize should be a function, got a " + type + "!");
            }
            stylize = options.stylize;
        }
        if (this.line !== null) {
            if (typeof extract[0] === 'string') {
                error.push(stylize(this.line - 1 + " " + extract[0], 'grey'));
            }
            if (typeof extract[1] === 'string') {
                var errorTxt = this.line + " ";
                if (extract[1]) {
                    errorTxt += extract[1].slice(0, this.column) +
                        stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +
                            extract[1].slice(this.column + 1), 'red'), 'inverse');
                }
                error.push(errorTxt);
            }
            if (typeof extract[2] === 'string') {
                error.push(stylize(this.line + 1 + " " + extract[2], 'grey'));
            }
            error = error.join('\n') + stylize('', 'reset') + "\n";
        }
        message += stylize(this.type + "Error: " + this.message, 'red');
        if (this.filename) {
            message += stylize(' in ', 'red') + this.filename;
        }
        if (this.line) {
            message += stylize(" on line " + this.line + ", column " + (this.column + 1) + ":", 'grey');
        }
        message += "\n" + error;
        if (this.callLine) {
            message += stylize('from ', 'red') + (this.filename || '') + "/n";
            message += stylize(this.callLine, 'grey') + " " + this.callExtract + "/n";
        }
        return message;
    };

    var Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {
        this.extendList = extendList;
        this.condition = condition;
        this.evaldCondition = !condition;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.elements = this.getElements(elements);
        this.mixinElements_ = undefined;
        this.copyVisibilityInfo(visibilityInfo);
        this.setParent(this.elements, this);
    };
    Selector.prototype = Object.assign(new Node(), {
        type: 'Selector',
        accept: function (visitor) {
            if (this.elements) {
                this.elements = visitor.visitArray(this.elements);
            }
            if (this.extendList) {
                this.extendList = visitor.visitArray(this.extendList);
            }
            if (this.condition) {
                this.condition = visitor.visit(this.condition);
            }
        },
        createDerived: function (elements, extendList, evaldCondition) {
            elements = this.getElements(elements);
            var newSelector = new Selector(elements, extendList || this.extendList, null, this.getIndex(), this.fileInfo(), this.visibilityInfo());
            newSelector.evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;
            newSelector.mediaEmpty = this.mediaEmpty;
            return newSelector;
        },
        getElements: function (els) {
            if (!els) {
                return [new Element('', '&', false, this._index, this._fileInfo)];
            }
            if (typeof els === 'string') {
                this.parse.parseNode(els, ['selector'], this._index, this._fileInfo, function (err, result) {
                    if (err) {
                        throw new LessError({
                            index: err.index,
                            message: err.message
                        }, this.parse.imports, this._fileInfo.filename);
                    }
                    els = result[0].elements;
                });
            }
            return els;
        },
        createEmptySelectors: function () {
            var el = new Element('', '&', false, this._index, this._fileInfo), sels = [new Selector([el], null, null, this._index, this._fileInfo)];
            sels[0].mediaEmpty = true;
            return sels;
        },
        match: function (other) {
            var elements = this.elements;
            var len = elements.length;
            var olen;
            var i;
            other = other.mixinElements();
            olen = other.length;
            if (olen === 0 || len < olen) {
                return 0;
            }
            else {
                for (i = 0; i < olen; i++) {
                    if (elements[i].value !== other[i]) {
                        return 0;
                    }
                }
            }
            return olen; // return number of matched elements
        },
        mixinElements: function () {
            if (this.mixinElements_) {
                return this.mixinElements_;
            }
            var elements = this.elements.map(function (v) {
                return v.combinator.value + (v.value.value || v.value);
            }).join('').match(/[,&#\*\.\w-]([\w-]|(\\.))*/g);
            if (elements) {
                if (elements[0] === '&') {
                    elements.shift();
                }
            }
            else {
                elements = [];
            }
            return (this.mixinElements_ = elements);
        },
        isJustParentSelector: function () {
            return !this.mediaEmpty &&
                this.elements.length === 1 &&
                this.elements[0].value === '&' &&
                (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');
        },
        eval: function (context) {
            var evaldCondition = this.condition && this.condition.eval(context);
            var elements = this.elements;
            var extendList = this.extendList;
            elements = elements && elements.map(function (e) { return e.eval(context); });
            extendList = extendList && extendList.map(function (extend) { return extend.eval(context); });
            return this.createDerived(elements, extendList, evaldCondition);
        },
        genCSS: function (context, output) {
            var i, element;
            if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {
                output.add(' ', this.fileInfo(), this.getIndex());
            }
            for (i = 0; i < this.elements.length; i++) {
                element = this.elements[i];
                element.genCSS(context, output);
            }
        },
        getIsOutput: function () {
            return this.evaldCondition;
        }
    });

    var Value = function (value) {
        if (!value) {
            throw new Error('Value requires an array argument');
        }
        if (!Array.isArray(value)) {
            this.value = [value];
        }
        else {
            this.value = value;
        }
    };
    Value.prototype = Object.assign(new Node(), {
        type: 'Value',
        accept: function (visitor) {
            if (this.value) {
                this.value = visitor.visitArray(this.value);
            }
        },
        eval: function (context) {
            if (this.value.length === 1) {
                return this.value[0].eval(context);
            }
            else {
                return new Value(this.value.map(function (v) {
                    return v.eval(context);
                }));
            }
        },
        genCSS: function (context, output) {
            var i;
            for (i = 0; i < this.value.length; i++) {
                this.value[i].genCSS(context, output);
                if (i + 1 < this.value.length) {
                    output.add((context && context.compress) ? ',' : ', ');
                }
            }
        }
    });

    var Keyword = function (value) {
        this.value = value;
    };
    Keyword.prototype = Object.assign(new Node(), {
        type: 'Keyword',
        genCSS: function (context, output) {
            if (this.value === '%') {
                throw { type: 'Syntax', message: 'Invalid % without number' };
            }
            output.add(this.value);
        }
    });
    Keyword.True = new Keyword('true');
    Keyword.False = new Keyword('false');

    var Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
        this.value = value;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.mapLines = mapLines;
        this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;
        this.allowRoot = true;
        this.copyVisibilityInfo(visibilityInfo);
    };
    Anonymous.prototype = Object.assign(new Node(), {
        type: 'Anonymous',
        eval: function () {
            return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
        },
        compare: function (other) {
            return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
        },
        isRulesetLike: function () {
            return this.rulesetLike;
        },
        genCSS: function (context, output) {
            this.nodeVisible = Boolean(this.value);
            if (this.nodeVisible) {
                output.add(this.value, this._fileInfo, this._index, this.mapLines);
            }
        }
    });

    var MATH = Math$1;
    function evalName(context, name) {
        var value = '';
        var i;
        var n = name.length;
        var output = { add: function (s) { value += s; } };
        for (i = 0; i < n; i++) {
            name[i].eval(context).genCSS(context, output);
        }
        return value;
    }
    var Declaration = function (name, value, important, merge, index, currentFileInfo, inline, variable) {
        this.name = name;
        this.value = (value instanceof Node) ? value : new Value([value ? new Anonymous(value) : null]);
        this.important = important ? " " + important.trim() : '';
        this.merge = merge;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.inline = inline || false;
        this.variable = (variable !== undefined) ? variable
            : (name.charAt && (name.charAt(0) === '@'));
        this.allowRoot = true;
        this.setParent(this.value, this);
    };
    Declaration.prototype = Object.assign(new Node(), {
        type: 'Declaration',
        genCSS: function (context, output) {
            output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());
            try {
                this.value.genCSS(context, output);
            }
            catch (e) {
                e.index = this._index;
                e.filename = this._fileInfo.filename;
                throw e;
            }
            output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);
        },
        eval: function (context) {
            var mathBypass = false, prevMath, name = this.name, evaldValue, variable = this.variable;
            if (typeof name !== 'string') {
                // expand 'primitive' name directly to get
                // things faster (~10% for benchmark.less):
                name = (name.length === 1) && (name[0] instanceof Keyword) ?
                    name[0].value : evalName(context, name);
                variable = false; // never treat expanded interpolation as new variable name
            }
            // @todo remove when parens-division is default
            if (name === 'font' && context.math === MATH.ALWAYS) {
                mathBypass = true;
                prevMath = context.math;
                context.math = MATH.PARENS_DIVISION;
            }
            try {
                context.importantScope.push({});
                evaldValue = this.value.eval(context);
                if (!this.variable && evaldValue.type === 'DetachedRuleset') {
                    throw { message: 'Rulesets cannot be evaluated on a property.',
                        index: this.getIndex(), filename: this.fileInfo().filename };
                }
                var important = this.important;
                var importantResult = context.importantScope.pop();
                if (!important && importantResult.important) {
                    important = importantResult.important;
                }
                return new Declaration(name, evaldValue, important, this.merge, this.getIndex(), this.fileInfo(), this.inline, variable);
            }
            catch (e) {
                if (typeof e.index !== 'number') {
                    e.index = this.getIndex();
                    e.filename = this.fileInfo().filename;
                }
                throw e;
            }
            finally {
                if (mathBypass) {
                    context.math = prevMath;
                }
            }
        },
        makeImportant: function () {
            return new Declaration(this.name, this.value, '!important', this.merge, this.getIndex(), this.fileInfo(), this.inline);
        }
    });

    var debugInfo = /** @class */ (function () {
        function debugInfo(context, ctx, lineSeparator) {
            var result = '';
            if (context.dumpLineNumbers && !context.compress) {
                switch (context.dumpLineNumbers) {
                    case 'comments':
                        result = debugInfo.asComment(ctx);
                        break;
                    case 'mediaquery':
                        result = debugInfo.asMediaQuery(ctx);
                        break;
                    case 'all':
                        result = debugInfo.asComment(ctx) + (lineSeparator || '') + debugInfo.asMediaQuery(ctx);
                        break;
                }
            }
            return result;
        }
        debugInfo.asComment = function (ctx) {
            return "/* line " + ctx.debugInfo.lineNumber + ", " + ctx.debugInfo.fileName + " */\n";
        };
        debugInfo.asMediaQuery = function (ctx) {
            var filenameWithProtocol = ctx.debugInfo.fileName;
            if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
                filenameWithProtocol = "file://" + filenameWithProtocol;
            }
            return "@media -sass-debug-info{filename{font-family:" + filenameWithProtocol.replace(/([.:\/\\])/g, function (a) {
                if (a == '\\') {
                    a = '\/';
                }
                return "\\" + a;
            }) + "}line{font-family:\\00003" + ctx.debugInfo.lineNumber + "}}\n";
        };
        return debugInfo;
    }());

    var Comment = function (value, isLineComment, index, currentFileInfo) {
        this.value = value;
        this.isLineComment = isLineComment;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.allowRoot = true;
    };
    Comment.prototype = Object.assign(new Node(), {
        type: 'Comment',
        genCSS: function (context, output) {
            if (this.debugInfo) {
                output.add(debugInfo(context, this), this.fileInfo(), this.getIndex());
            }
            output.add(this.value);
        },
        isSilent: function (context) {
            var isCompressed = context.compress && this.value[2] !== '!';
            return this.isLineComment || isCompressed;
        }
    });

    var contexts = {};
    var copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {
        if (!original) {
            return;
        }
        for (var i = 0; i < propertiesToCopy.length; i++) {
            if (original.hasOwnProperty(propertiesToCopy[i])) {
                destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];
            }
        }
    };
    /*
     parse is used whilst parsing
     */
    var parseCopyProperties = [
        // options
        'paths',
        'rewriteUrls',
        'rootpath',
        'strictImports',
        'insecure',
        'dumpLineNumbers',
        'compress',
        'syncImport',
        'chunkInput',
        'mime',
        'useFileCache',
        // context
        'processImports',
        // Used by the import manager to stop multiple import visitors being created.
        'pluginManager' // Used as the plugin manager for the session
    ];
    contexts.Parse = function (options) {
        copyFromOriginal(options, this, parseCopyProperties);
        if (typeof this.paths === 'string') {
            this.paths = [this.paths];
        }
    };
    var evalCopyProperties = [
        'paths',
        'compress',
        'math',
        'strictUnits',
        'sourceMap',
        'importMultiple',
        'urlArgs',
        'javascriptEnabled',
        'pluginManager',
        'importantScope',
        'rewriteUrls' // option - whether to adjust URL's to be relative
    ];
    contexts.Eval = function (options, frames) {
        copyFromOriginal(options, this, evalCopyProperties);
        if (typeof this.paths === 'string') {
            this.paths = [this.paths];
        }
        this.frames = frames || [];
        this.importantScope = this.importantScope || [];
    };
    contexts.Eval.prototype.enterCalc = function () {
        if (!this.calcStack) {
            this.calcStack = [];
        }
        this.calcStack.push(true);
        this.inCalc = true;
    };
    contexts.Eval.prototype.exitCalc = function () {
        this.calcStack.pop();
        if (!this.calcStack.length) {
            this.inCalc = false;
        }
    };
    contexts.Eval.prototype.inParenthesis = function () {
        if (!this.parensStack) {
            this.parensStack = [];
        }
        this.parensStack.push(true);
    };
    contexts.Eval.prototype.outOfParenthesis = function () {
        this.parensStack.pop();
    };
    contexts.Eval.prototype.inCalc = false;
    contexts.Eval.prototype.mathOn = true;
    contexts.Eval.prototype.isMathOn = function (op) {
        if (!this.mathOn) {
            return false;
        }
        if (op === '/' && this.math !== Math$1.ALWAYS && (!this.parensStack || !this.parensStack.length)) {
            return false;
        }
        if (this.math > Math$1.PARENS_DIVISION) {
            return this.parensStack && this.parensStack.length;
        }
        return true;
    };
    contexts.Eval.prototype.pathRequiresRewrite = function (path) {
        var isRelative = this.rewriteUrls === RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;
        return isRelative(path);
    };
    contexts.Eval.prototype.rewritePath = function (path, rootpath) {
        var newPath;
        rootpath = rootpath || '';
        newPath = this.normalizePath(rootpath + path);
        // If a path was explicit relative and the rootpath was not an absolute path
        // we must ensure that the new path is also explicit relative.
        if (isPathLocalRelative(path) &&
            isPathRelative(rootpath) &&
            isPathLocalRelative(newPath) === false) {
            newPath = "./" + newPath;
        }
        return newPath;
    };
    contexts.Eval.prototype.normalizePath = function (path) {
        var segments = path.split('/').reverse();
        var segment;
        path = [];
        while (segments.length !== 0) {
            segment = segments.pop();
            switch (segment) {
                case '.':
                    break;
                case '..':
                    if ((path.length === 0) || (path[path.length - 1] === '..')) {
                        path.push(segment);
                    }
                    else {
                        path.pop();
                    }
                    break;
                default:
                    path.push(segment);
                    break;
            }
        }
        return path.join('/');
    };
    function isPathRelative(path) {
        return !/^(?:[a-z-]+:|\/|#)/i.test(path);
    }
    function isPathLocalRelative(path) {
        return path.charAt(0) === '.';
    }
    // todo - do the same for the toCSS ?

    function makeRegistry(base) {
        return {
            _data: {},
            add: function (name, func) {
                // precautionary case conversion, as later querying of
                // the registry by function-caller uses lower case as well.
                name = name.toLowerCase();
                if (this._data.hasOwnProperty(name)) ;
                this._data[name] = func;
            },
            addMultiple: function (functions) {
                var _this = this;
                Object.keys(functions).forEach(function (name) {
                    _this.add(name, functions[name]);
                });
            },
            get: function (name) {
                return this._data[name] || (base && base.get(name));
            },
            getLocalFunctions: function () {
                return this._data;
            },
            inherit: function () {
                return makeRegistry(this);
            },
            create: function (base) {
                return makeRegistry(base);
            }
        };
    }
    var functionRegistry = makeRegistry(null);

    var defaultFunc = {
        eval: function () {
            var v = this.value_;
            var e = this.error_;
            if (e) {
                throw e;
            }
            if (v != null) {
                return v ? Keyword.True : Keyword.False;
            }
        },
        value: function (v) {
            this.value_ = v;
        },
        error: function (e) {
            this.error_ = e;
        },
        reset: function () {
            this.value_ = this.error_ = null;
        }
    };

    var Ruleset = function (selectors, rules, strictImports, visibilityInfo) {
        this.selectors = selectors;
        this.rules = rules;
        this._lookups = {};
        this._variables = null;
        this._properties = null;
        this.strictImports = strictImports;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
        this.setParent(this.selectors, this);
        this.setParent(this.rules, this);
    };
    Ruleset.prototype = Object.assign(new Node(), {
        type: 'Ruleset',
        isRuleset: true,
        isRulesetLike: function () { return true; },
        accept: function (visitor) {
            if (this.paths) {
                this.paths = visitor.visitArray(this.paths, true);
            }
            else if (this.selectors) {
                this.selectors = visitor.visitArray(this.selectors);
            }
            if (this.rules && this.rules.length) {
                this.rules = visitor.visitArray(this.rules);
            }
        },
        eval: function (context) {
            var selectors;
            var selCnt;
            var selector;
            var i;
            var hasVariable;
            var hasOnePassingSelector = false;
            if (this.selectors && (selCnt = this.selectors.length)) {
                selectors = new Array(selCnt);
                defaultFunc.error({
                    type: 'Syntax',
                    message: 'it is currently only allowed in parametric mixin guards,'
                });
                for (i = 0; i < selCnt; i++) {
                    selector = this.selectors[i].eval(context);
                    for (var j = 0; j < selector.elements.length; j++) {
                        if (selector.elements[j].isVariable) {
                            hasVariable = true;
                            break;
                        }
                    }
                    selectors[i] = selector;
                    if (selector.evaldCondition) {
                        hasOnePassingSelector = true;
                    }
                }
                if (hasVariable) {
                    var toParseSelectors = new Array(selCnt);
                    for (i = 0; i < selCnt; i++) {
                        selector = selectors[i];
                        toParseSelectors[i] = selector.toCSS(context);
                    }
                    this.parse.parseNode(toParseSelectors.join(','), ["selectors"], selectors[0].getIndex(), selectors[0].fileInfo(), function (err, result) {
                        if (result) {
                            selectors = flattenArray(result);
                        }
                    });
                }
                defaultFunc.reset();
            }
            else {
                hasOnePassingSelector = true;
            }
            var rules = this.rules ? copyArray(this.rules) : null;
            var ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());
            var rule;
            var subRule;
            ruleset.originalRuleset = this;
            ruleset.root = this.root;
            ruleset.firstRoot = this.firstRoot;
            ruleset.allowImports = this.allowImports;
            if (this.debugInfo) {
                ruleset.debugInfo = this.debugInfo;
            }
            if (!hasOnePassingSelector) {
                rules.length = 0;
            }
            // inherit a function registry from the frames stack when possible;
            // otherwise from the global registry
            ruleset.functionRegistry = (function (frames) {
                var i = 0;
                var n = frames.length;
                var found;
                for (; i !== n; ++i) {
                    found = frames[i].functionRegistry;
                    if (found) {
                        return found;
                    }
                }
                return functionRegistry;
            }(context.frames)).inherit();
            // push the current ruleset to the frames stack
            var ctxFrames = context.frames;
            ctxFrames.unshift(ruleset);
            // currrent selectors
            var ctxSelectors = context.selectors;
            if (!ctxSelectors) {
                context.selectors = ctxSelectors = [];
            }
            ctxSelectors.unshift(this.selectors);
            // Evaluate imports
            if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {
                ruleset.evalImports(context);
            }
            // Store the frames around mixin definitions,
            // so they can be evaluated like closures when the time comes.
            var rsRules = ruleset.rules;
            for (i = 0; (rule = rsRules[i]); i++) {
                if (rule.evalFirst) {
                    rsRules[i] = rule.eval(context);
                }
            }
            var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;
            // Evaluate mixin calls.
            for (i = 0; (rule = rsRules[i]); i++) {
                if (rule.type === 'MixinCall') {
                    /* jshint loopfunc:true */
                    rules = rule.eval(context).filter(function (r) {
                        if ((r instanceof Declaration) && r.variable) {
                            // do not pollute the scope if the variable is
                            // already there. consider returning false here
                            // but we need a way to "return" variable from mixins
                            return !(ruleset.variable(r.name));
                        }
                        return true;
                    });
                    rsRules.splice.apply(rsRules, [i, 1].concat(rules));
                    i += rules.length - 1;
                    ruleset.resetCache();
                }
                else if (rule.type === 'VariableCall') {
                    /* jshint loopfunc:true */
                    rules = rule.eval(context).rules.filter(function (r) {
                        if ((r instanceof Declaration) && r.variable) {
                            // do not pollute the scope at all
                            return false;
                        }
                        return true;
                    });
                    rsRules.splice.apply(rsRules, [i, 1].concat(rules));
                    i += rules.length - 1;
                    ruleset.resetCache();
                }
            }
            // Evaluate everything else
            for (i = 0; (rule = rsRules[i]); i++) {
                if (!rule.evalFirst) {
                    rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;
                }
            }
            // Evaluate everything else
            for (i = 0; (rule = rsRules[i]); i++) {
                // for rulesets, check if it is a css guard and can be removed
                if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
                    // check if it can be folded in (e.g. & where)
                    if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {
                        rsRules.splice(i--, 1);
                        for (var j = 0; (subRule = rule.rules[j]); j++) {
                            if (subRule instanceof Node) {
                                subRule.copyVisibilityInfo(rule.visibilityInfo());
                                if (!(subRule instanceof Declaration) || !subRule.variable) {
                                    rsRules.splice(++i, 0, subRule);
                                }
                            }
                        }
                    }
                }
            }
            // Pop the stack
            ctxFrames.shift();
            ctxSelectors.shift();
            if (context.mediaBlocks) {
                for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {
                    context.mediaBlocks[i].bubbleSelectors(selectors);
                }
            }
            return ruleset;
        },
        evalImports: function (context) {
            var rules = this.rules;
            var i;
            var importRules;
            if (!rules) {
                return;
            }
            for (i = 0; i < rules.length; i++) {
                if (rules[i].type === 'Import') {
                    importRules = rules[i].eval(context);
                    if (importRules && (importRules.length || importRules.length === 0)) {
                        rules.splice.apply(rules, [i, 1].concat(importRules));
                        i += importRules.length - 1;
                    }
                    else {
                        rules.splice(i, 1, importRules);
                    }
                    this.resetCache();
                }
            }
        },
        makeImportant: function () {
            var result = new Ruleset(this.selectors, this.rules.map(function (r) {
                if (r.makeImportant) {
                    return r.makeImportant();
                }
                else {
                    return r;
                }
            }), this.strictImports, this.visibilityInfo());
            return result;
        },
        matchArgs: function (args) {
            return !args || args.length === 0;
        },
        // lets you call a css selector with a guard
        matchCondition: function (args, context) {
            var lastSelector = this.selectors[this.selectors.length - 1];
            if (!lastSelector.evaldCondition) {
                return false;
            }
            if (lastSelector.condition &&
                !lastSelector.condition.eval(new contexts.Eval(context, context.frames))) {
                return false;
            }
            return true;
        },
        resetCache: function () {
            this._rulesets = null;
            this._variables = null;
            this._properties = null;
            this._lookups = {};
        },
        variables: function () {
            if (!this._variables) {
                this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {
                    if (r instanceof Declaration && r.variable === true) {
                        hash[r.name] = r;
                    }
                    // when evaluating variables in an import statement, imports have not been eval'd
                    // so we need to go inside import statements.
                    // guard against root being a string (in the case of inlined less)
                    if (r.type === 'Import' && r.root && r.root.variables) {
                        var vars = r.root.variables();
                        for (var name_1 in vars) {
                            if (vars.hasOwnProperty(name_1)) {
                                hash[name_1] = r.root.variable(name_1);
                            }
                        }
                    }
                    return hash;
                }, {});
            }
            return this._variables;
        },
        properties: function () {
            if (!this._properties) {
                this._properties = !this.rules ? {} : this.rules.reduce(function (hash, r) {
                    if (r instanceof Declaration && r.variable !== true) {
                        var name_2 = (r.name.length === 1) && (r.name[0] instanceof Keyword) ?
                            r.name[0].value : r.name;
                        // Properties don't overwrite as they can merge
                        if (!hash["$" + name_2]) {
                            hash["$" + name_2] = [r];
                        }
                        else {
                            hash["$" + name_2].push(r);
                        }
                    }
                    return hash;
                }, {});
            }
            return this._properties;
        },
        variable: function (name) {
            var decl = this.variables()[name];
            if (decl) {
                return this.parseValue(decl);
            }
        },
        property: function (name) {
            var decl = this.properties()[name];
            if (decl) {
                return this.parseValue(decl);
            }
        },
        lastDeclaration: function () {
            for (var i = this.rules.length; i > 0; i--) {
                var decl = this.rules[i - 1];
                if (decl instanceof Declaration) {
                    return this.parseValue(decl);
                }
            }
        },
        parseValue: function (toParse) {
            var self = this;
            function transformDeclaration(decl) {
                if (decl.value instanceof Anonymous && !decl.parsed) {
                    if (typeof decl.value.value === 'string') {
                        this.parse.parseNode(decl.value.value, ['value', 'important'], decl.value.getIndex(), decl.fileInfo(), function (err, result) {
                            if (err) {
                                decl.parsed = true;
                            }
                            if (result) {
                                decl.value = result[0];
                                decl.important = result[1] || '';
                                decl.parsed = true;
                            }
                        });
                    }
                    else {
                        decl.parsed = true;
                    }
                    return decl;
                }
                else {
                    return decl;
                }
            }
            if (!Array.isArray(toParse)) {
                return transformDeclaration.call(self, toParse);
            }
            else {
                var nodes_1 = [];
                toParse.forEach(function (n) {
                    nodes_1.push(transformDeclaration.call(self, n));
                });
                return nodes_1;
            }
        },
        rulesets: function () {
            if (!this.rules) {
                return [];
            }
            var filtRules = [];
            var rules = this.rules;
            var i;
            var rule;
            for (i = 0; (rule = rules[i]); i++) {
                if (rule.isRuleset) {
                    filtRules.push(rule);
                }
            }
            return filtRules;
        },
        prependRule: function (rule) {
            var rules = this.rules;
            if (rules) {
                rules.unshift(rule);
            }
            else {
                this.rules = [rule];
            }
            this.setParent(rule, this);
        },
        find: function (selector, self, filter) {
            self = self || this;
            var rules = [];
            var match;
            var foundMixins;
            var key = selector.toCSS();
            if (key in this._lookups) {
                return this._lookups[key];
            }
            this.rulesets().forEach(function (rule) {
                if (rule !== self) {
                    for (var j = 0; j < rule.selectors.length; j++) {
                        match = selector.match(rule.selectors[j]);
                        if (match) {
                            if (selector.elements.length > match) {
                                if (!filter || filter(rule)) {
                                    foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);
                                    for (var i = 0; i < foundMixins.length; ++i) {
                                        foundMixins[i].path.push(rule);
                                    }
                                    Array.prototype.push.apply(rules, foundMixins);
                                }
                            }
                            else {
                                rules.push({ rule: rule, path: [] });
                            }
                            break;
                        }
                    }
                }
            });
            this._lookups[key] = rules;
            return rules;
        },
        genCSS: function (context, output) {
            var i;
            var j;
            var charsetRuleNodes = [];
            var ruleNodes = [];
            var // Line number debugging
            debugInfo$1;
            var rule;
            var path;
            context.tabLevel = (context.tabLevel || 0);
            if (!this.root) {
                context.tabLevel++;
            }
            var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');
            var tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');
            var sep;
            var charsetNodeIndex = 0;
            var importNodeIndex = 0;
            for (i = 0; (rule = this.rules[i]); i++) {
                if (rule instanceof Comment) {
                    if (importNodeIndex === i) {
                        importNodeIndex++;
                    }
                    ruleNodes.push(rule);
                }
                else if (rule.isCharset && rule.isCharset()) {
                    ruleNodes.splice(charsetNodeIndex, 0, rule);
                    charsetNodeIndex++;
                    importNodeIndex++;
                }
                else if (rule.type === 'Import') {
                    ruleNodes.splice(importNodeIndex, 0, rule);
                    importNodeIndex++;
                }
                else {
                    ruleNodes.push(rule);
                }
            }
            ruleNodes = charsetRuleNodes.concat(ruleNodes);
            // If this is the root node, we don't render
            // a selector, or {}.
            if (!this.root) {
                debugInfo$1 = debugInfo(context, this, tabSetStr);
                if (debugInfo$1) {
                    output.add(debugInfo$1);
                    output.add(tabSetStr);
                }
                var paths = this.paths;
                var pathCnt = paths.length;
                var pathSubCnt = void 0;
                sep = context.compress ? ',' : (",\n" + tabSetStr);
                for (i = 0; i < pathCnt; i++) {
                    path = paths[i];
                    if (!(pathSubCnt = path.length)) {
                        continue;
                    }
                    if (i > 0) {
                        output.add(sep);
                    }
                    context.firstSelector = true;
                    path[0].genCSS(context, output);
                    context.firstSelector = false;
                    for (j = 1; j < pathSubCnt; j++) {
                        path[j].genCSS(context, output);
                    }
                }
                output.add((context.compress ? '{' : ' {\n') + tabRuleStr);
            }
            // Compile rules and rulesets
            for (i = 0; (rule = ruleNodes[i]); i++) {
                if (i + 1 === ruleNodes.length) {
                    context.lastRule = true;
                }
                var currentLastRule = context.lastRule;
                if (rule.isRulesetLike(rule)) {
                    context.lastRule = false;
                }
                if (rule.genCSS) {
                    rule.genCSS(context, output);
                }
                else if (rule.value) {
                    output.add(rule.value.toString());
                }
                context.lastRule = currentLastRule;
                if (!context.lastRule && rule.isVisible()) {
                    output.add(context.compress ? '' : ("\n" + tabRuleStr));
                }
                else {
                    context.lastRule = false;
                }
            }
            if (!this.root) {
                output.add((context.compress ? '}' : "\n" + tabSetStr + "}"));
                context.tabLevel--;
            }
            if (!output.isEmpty() && !context.compress && this.firstRoot) {
                output.add('\n');
            }
        },
        joinSelectors: function (paths, context, selectors) {
            for (var s = 0; s < selectors.length; s++) {
                this.joinSelector(paths, context, selectors[s]);
            }
        },
        joinSelector: function (paths, context, selector) {
            function createParenthesis(elementsToPak, originalElement) {
                var replacementParen, j;
                if (elementsToPak.length === 0) {
                    replacementParen = new Paren(elementsToPak[0]);
                }
                else {
                    var insideParent = new Array(elementsToPak.length);
                    for (j = 0; j < elementsToPak.length; j++) {
                        insideParent[j] = new Element(null, elementsToPak[j], originalElement.isVariable, originalElement._index, originalElement._fileInfo);
                    }
                    replacementParen = new Paren(new Selector(insideParent));
                }
                return replacementParen;
            }
            function createSelector(containedElement, originalElement) {
                var element, selector;
                element = new Element(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);
                selector = new Selector([element]);
                return selector;
            }
            // joins selector path from `beginningPath` with selector path in `addPath`
            // `replacedElement` contains element that is being replaced by `addPath`
            // returns concatenated path
            function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
                var newSelectorPath, lastSelector, newJoinedSelector;
                // our new selector path
                newSelectorPath = [];
                // construct the joined selector - if & is the first thing this will be empty,
                // if not newJoinedSelector will be the last set of elements in the selector
                if (beginningPath.length > 0) {
                    newSelectorPath = copyArray(beginningPath);
                    lastSelector = newSelectorPath.pop();
                    newJoinedSelector = originalSelector.createDerived(copyArray(lastSelector.elements));
                }
                else {
                    newJoinedSelector = originalSelector.createDerived([]);
                }
                if (addPath.length > 0) {
                    // /deep/ is a CSS4 selector - (removed, so should deprecate)
                    // that is valid without anything in front of it
                    // so if the & does not have a combinator that is "" or " " then
                    // and there is a combinator on the parent, then grab that.
                    // this also allows + a { & .b { .a & { ... though not sure why you would want to do that
                    var combinator = replacedElement.combinator;
                    var parentEl = addPath[0].elements[0];
                    if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
                        combinator = parentEl.combinator;
                    }
                    // join the elements so far with the first part of the parent
                    newJoinedSelector.elements.push(new Element(combinator, parentEl.value, replacedElement.isVariable, replacedElement._index, replacedElement._fileInfo));
                    newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
                }
                // now add the joined selector - but only if it is not empty
                if (newJoinedSelector.elements.length !== 0) {
                    newSelectorPath.push(newJoinedSelector);
                }
                // put together the parent selectors after the join (e.g. the rest of the parent)
                if (addPath.length > 1) {
                    var restOfPath = addPath.slice(1);
                    restOfPath = restOfPath.map(function (selector) {
                        return selector.createDerived(selector.elements, []);
                    });
                    newSelectorPath = newSelectorPath.concat(restOfPath);
                }
                return newSelectorPath;
            }
            // joins selector path from `beginningPath` with every selector path in `addPaths` array
            // `replacedElement` contains element that is being replaced by `addPath`
            // returns array with all concatenated paths
            function addAllReplacementsIntoPath(beginningPath, addPaths, replacedElement, originalSelector, result) {
                var j;
                for (j = 0; j < beginningPath.length; j++) {
                    var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);
                    result.push(newSelectorPath);
                }
                return result;
            }
            function mergeElementsOnToSelectors(elements, selectors) {
                var i, sel;
                if (elements.length === 0) {
                    return;
                }
                if (selectors.length === 0) {
                    selectors.push([new Selector(elements)]);
                    return;
                }
                for (i = 0; (sel = selectors[i]); i++) {
                    // if the previous thing in sel is a parent this needs to join on to it
                    if (sel.length > 0) {
                        sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
                    }
                    else {
                        sel.push(new Selector(elements));
                    }
                }
            }
            // replace all parent selectors inside `inSelector` by content of `context` array
            // resulting selectors are returned inside `paths` array
            // returns true if `inSelector` contained at least one parent selector
            function replaceParentSelector(paths, context, inSelector) {
                // The paths are [[Selector]]
                // The first list is a list of comma separated selectors
                // The inner list is a list of inheritance separated selectors
                // e.g.
                // .a, .b {
                //   .c {
                //   }
                // }
                // == [[.a] [.c]] [[.b] [.c]]
                //
                var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;
                function findNestedSelector(element) {
                    var maybeSelector;
                    if (!(element.value instanceof Paren)) {
                        return null;
                    }
                    maybeSelector = element.value.value;
                    if (!(maybeSelector instanceof Selector)) {
                        return null;
                    }
                    return maybeSelector;
                }
                // the elements from the current selector so far
                currentElements = [];
                // the current list of new selectors to add to the path.
                // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors
                // by the parents
                newSelectors = [
                    []
                ];
                for (i = 0; (el = inSelector.elements[i]); i++) {
                    // non parent reference elements just get added
                    if (el.value !== '&') {
                        var nestedSelector = findNestedSelector(el);
                        if (nestedSelector != null) {
                            // merge the current list of non parent selector elements
                            // on to the current list of selectors to add
                            mergeElementsOnToSelectors(currentElements, newSelectors);
                            var nestedPaths = [];
                            var replaced = void 0;
                            var replacedNewSelectors = [];
                            replaced = replaceParentSelector(nestedPaths, context, nestedSelector);
                            hadParentSelector = hadParentSelector || replaced;
                            // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors
                            for (k = 0; k < nestedPaths.length; k++) {
                                var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);
                                addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);
                            }
                            newSelectors = replacedNewSelectors;
                            currentElements = [];
                        }
                        else {
                            currentElements.push(el);
                        }
                    }
                    else {
                        hadParentSelector = true;
                        // the new list of selectors to add
                        selectorsMultiplied = [];
                        // merge the current list of non parent selector elements
                        // on to the current list of selectors to add
                        mergeElementsOnToSelectors(currentElements, newSelectors);
                        // loop through our current selectors
                        for (j = 0; j < newSelectors.length; j++) {
                            sel = newSelectors[j];
                            // if we don't have any parent paths, the & might be in a mixin so that it can be used
                            // whether there are parents or not
                            if (context.length === 0) {
                                // the combinator used on el should now be applied to the next element instead so that
                                // it is not lost
                                if (sel.length > 0) {
                                    sel[0].elements.push(new Element(el.combinator, '', el.isVariable, el._index, el._fileInfo));
                                }
                                selectorsMultiplied.push(sel);
                            }
                            else {
                                // and the parent selectors
                                for (k = 0; k < context.length; k++) {
                                    // We need to put the current selectors
                                    // then join the last selector's elements on to the parents selectors
                                    var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);
                                    // add that to our new set of selectors
                                    selectorsMultiplied.push(newSelectorPath);
                                }
                            }
                        }
                        // our new selectors has been multiplied, so reset the state
                        newSelectors = selectorsMultiplied;
                        currentElements = [];
                    }
                }
                // if we have any elements left over (e.g. .a& .b == .b)
                // add them on to all the current selectors
                mergeElementsOnToSelectors(currentElements, newSelectors);
                for (i = 0; i < newSelectors.length; i++) {
                    length = newSelectors[i].length;
                    if (length > 0) {
                        paths.push(newSelectors[i]);
                        lastSelector = newSelectors[i][length - 1];
                        newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
                    }
                }
                return hadParentSelector;
            }
            function deriveSelector(visibilityInfo, deriveFrom) {
                var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
                newSelector.copyVisibilityInfo(visibilityInfo);
                return newSelector;
            }
            // joinSelector code follows
            var i, newPaths, hadParentSelector;
            newPaths = [];
            hadParentSelector = replaceParentSelector(newPaths, context, selector);
            if (!hadParentSelector) {
                if (context.length > 0) {
                    newPaths = [];
                    for (i = 0; i < context.length; i++) {
                        var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));
                        concatenated.push(selector);
                        newPaths.push(concatenated);
                    }
                }
                else {
                    newPaths = [[selector]];
                }
            }
            for (i = 0; i < newPaths.length; i++) {
                paths.push(newPaths[i]);
            }
        }
    });

    var AtRule = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {
        var i;
        this.name = name;
        this.value = (value instanceof Node) ? value : (value ? new Anonymous(value) : value);
        if (rules) {
            if (Array.isArray(rules)) {
                this.rules = rules;
            }
            else {
                this.rules = [rules];
                this.rules[0].selectors = (new Selector([], null, null, index, currentFileInfo)).createEmptySelectors();
            }
            for (i = 0; i < this.rules.length; i++) {
                this.rules[i].allowImports = true;
            }
            this.setParent(this.rules, this);
        }
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.debugInfo = debugInfo;
        this.isRooted = isRooted || false;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
    };
    AtRule.prototype = Object.assign(new Node(), {
        type: 'AtRule',
        accept: function (visitor) {
            var value = this.value, rules = this.rules;
            if (rules) {
                this.rules = visitor.visitArray(rules);
            }
            if (value) {
                this.value = visitor.visit(value);
            }
        },
        isRulesetLike: function () {
            return this.rules || !this.isCharset();
        },
        isCharset: function () {
            return '@charset' === this.name;
        },
        genCSS: function (context, output) {
            var value = this.value, rules = this.rules;
            output.add(this.name, this.fileInfo(), this.getIndex());
            if (value) {
                output.add(' ');
                value.genCSS(context, output);
            }
            if (rules) {
                this.outputRuleset(context, output, rules);
            }
            else {
                output.add(';');
            }
        },
        eval: function (context) {
            var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;
            // media stored inside other atrule should not bubble over it
            // backpup media bubbling information
            mediaPathBackup = context.mediaPath;
            mediaBlocksBackup = context.mediaBlocks;
            // deleted media bubbling information
            context.mediaPath = [];
            context.mediaBlocks = [];
            if (value) {
                value = value.eval(context);
            }
            if (rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                rules = [rules[0].eval(context)];
                rules[0].root = true;
            }
            // restore media bubbling information
            context.mediaPath = mediaPathBackup;
            context.mediaBlocks = mediaBlocksBackup;
            return new AtRule(this.name, value, rules, this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());
        },
        variable: function (name) {
            if (this.rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                return Ruleset.prototype.variable.call(this.rules[0], name);
            }
        },
        find: function () {
            if (this.rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                return Ruleset.prototype.find.apply(this.rules[0], arguments);
            }
        },
        rulesets: function () {
            if (this.rules) {
                // assuming that there is only one rule at this point - that is how parser constructs the rule
                return Ruleset.prototype.rulesets.apply(this.rules[0]);
            }
        },
        outputRuleset: function (context, output, rules) {
            var ruleCnt = rules.length;
            var i;
            context.tabLevel = (context.tabLevel | 0) + 1;
            // Compressed
            if (context.compress) {
                output.add('{');
                for (i = 0; i < ruleCnt; i++) {
                    rules[i].genCSS(context, output);
                }
                output.add('}');
                context.tabLevel--;
                return;
            }
            // Non-compressed
            var tabSetStr = "\n" + Array(context.tabLevel).join('  '), tabRuleStr = tabSetStr + "  ";
            if (!ruleCnt) {
                output.add(" {" + tabSetStr + "}");
            }
            else {
                output.add(" {" + tabRuleStr);
                rules[0].genCSS(context, output);
                for (i = 1; i < ruleCnt; i++) {
                    output.add(tabRuleStr);
                    rules[i].genCSS(context, output);
                }
                output.add(tabSetStr + "}");
            }
            context.tabLevel--;
        }
    });

    var DetachedRuleset = function (ruleset, frames) {
        this.ruleset = ruleset;
        this.frames = frames;
        this.setParent(this.ruleset, this);
    };
    DetachedRuleset.prototype = Object.assign(new Node(), {
        type: 'DetachedRuleset',
        evalFirst: true,
        accept: function (visitor) {
            this.ruleset = visitor.visit(this.ruleset);
        },
        eval: function (context) {
            var frames = this.frames || copyArray(context.frames);
            return new DetachedRuleset(this.ruleset, frames);
        },
        callEval: function (context) {
            return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);
        }
    });

    var Unit = function (numerator, denominator, backupUnit) {
        this.numerator = numerator ? copyArray(numerator).sort() : [];
        this.denominator = denominator ? copyArray(denominator).sort() : [];
        if (backupUnit) {
            this.backupUnit = backupUnit;
        }
        else if (numerator && numerator.length) {
            this.backupUnit = numerator[0];
        }
    };
    Unit.prototype = Object.assign(new Node(), {
        type: 'Unit',
        clone: function () {
            return new Unit(copyArray(this.numerator), copyArray(this.denominator), this.backupUnit);
        },
        genCSS: function (context, output) {
            // Dimension checks the unit is singular and throws an error if in strict math mode.
            var strictUnits = context && context.strictUnits;
            if (this.numerator.length === 1) {
                output.add(this.numerator[0]); // the ideal situation
            }
            else if (!strictUnits && this.backupUnit) {
                output.add(this.backupUnit);
            }
            else if (!strictUnits && this.denominator.length) {
                output.add(this.denominator[0]);
            }
        },
        toString: function () {
            var i, returnStr = this.numerator.join('*');
            for (i = 0; i < this.denominator.length; i++) {
                returnStr += "/" + this.denominator[i];
            }
            return returnStr;
        },
        compare: function (other) {
            return this.is(other.toString()) ? 0 : undefined;
        },
        is: function (unitString) {
            return this.toString().toUpperCase() === unitString.toUpperCase();
        },
        isLength: function () {
            return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());
        },
        isEmpty: function () {
            return this.numerator.length === 0 && this.denominator.length === 0;
        },
        isSingular: function () {
            return this.numerator.length <= 1 && this.denominator.length === 0;
        },
        map: function (callback) {
            var i;
            for (i = 0; i < this.numerator.length; i++) {
                this.numerator[i] = callback(this.numerator[i], false);
            }
            for (i = 0; i < this.denominator.length; i++) {
                this.denominator[i] = callback(this.denominator[i], true);
            }
        },
        usedUnits: function () {
            var group;
            var result = {};
            var mapUnit;
            var groupName;
            mapUnit = function (atomicUnit) {
                /* jshint loopfunc:true */
                if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
                    result[groupName] = atomicUnit;
                }
                return atomicUnit;
            };
            for (groupName in unitConversions) {
                if (unitConversions.hasOwnProperty(groupName)) {
                    group = unitConversions[groupName];
                    this.map(mapUnit);
                }
            }
            return result;
        },
        cancel: function () {
            var counter = {};
            var atomicUnit;
            var i;
            for (i = 0; i < this.numerator.length; i++) {
                atomicUnit = this.numerator[i];
                counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
            }
            for (i = 0; i < this.denominator.length; i++) {
                atomicUnit = this.denominator[i];
                counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
            }
            this.numerator = [];
            this.denominator = [];
            for (atomicUnit in counter) {
                if (counter.hasOwnProperty(atomicUnit)) {
                    var count = counter[atomicUnit];
                    if (count > 0) {
                        for (i = 0; i < count; i++) {
                            this.numerator.push(atomicUnit);
                        }
                    }
                    else if (count < 0) {
                        for (i = 0; i < -count; i++) {
                            this.denominator.push(atomicUnit);
                        }
                    }
                }
            }
            this.numerator.sort();
            this.denominator.sort();
        }
    });

    //
    // A number with a unit
    //
    var Dimension = function (value, unit) {
        this.value = parseFloat(value);
        if (isNaN(this.value)) {
            throw new Error('Dimension is not a number.');
        }
        this.unit = (unit && unit instanceof Unit) ? unit :
            new Unit(unit ? [unit] : undefined);
        this.setParent(this.unit, this);
    };
    Dimension.prototype = Object.assign(new Node(), {
        type: 'Dimension',
        accept: function (visitor) {
            this.unit = visitor.visit(this.unit);
        },
        eval: function (context) {
            return this;
        },
        toColor: function () {
            return new Color([this.value, this.value, this.value]);
        },
        genCSS: function (context, output) {
            if ((context && context.strictUnits) && !this.unit.isSingular()) {
                throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: " + this.unit.toString());
            }
            var value = this.fround(context, this.value);
            var strValue = String(value);
            if (value !== 0 && value < 0.000001 && value > -0.000001) {
                // would be output 1e-6 etc.
                strValue = value.toFixed(20).replace(/0+$/, '');
            }
            if (context && context.compress) {
                // Zero values doesn't need a unit
                if (value === 0 && this.unit.isLength()) {
                    output.add(strValue);
                    return;
                }
                // Float values doesn't need a leading zero
                if (value > 0 && value < 1) {
                    strValue = (strValue).substr(1);
                }
            }
            output.add(strValue);
            this.unit.genCSS(context, output);
        },
        // In an operation between two Dimensions,
        // we default to the first Dimension's unit,
        // so `1px + 2` will yield `3px`.
        operate: function (context, op, other) {
            /* jshint noempty:false */
            var value = this._operate(context, op, this.value, other.value);
            var unit = this.unit.clone();
            if (op === '+' || op === '-') {
                if (unit.numerator.length === 0 && unit.denominator.length === 0) {
                    unit = other.unit.clone();
                    if (this.unit.backupUnit) {
                        unit.backupUnit = this.unit.backupUnit;
                    }
                }
                else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) ;
                else {
                    other = other.convertTo(this.unit.usedUnits());
                    if (context.strictUnits && other.unit.toString() !== unit.toString()) {
                        throw new Error("Incompatible units. Change the units or use the unit function. "
                            + ("Bad units: '" + unit.toString() + "' and '" + other.unit.toString() + "'."));
                    }
                    value = this._operate(context, op, this.value, other.value);
                }
            }
            else if (op === '*') {
                unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
                unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
                unit.cancel();
            }
            else if (op === '/') {
                unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
                unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
                unit.cancel();
            }
            return new Dimension(value, unit);
        },
        compare: function (other) {
            var a, b;
            if (!(other instanceof Dimension)) {
                return undefined;
            }
            if (this.unit.isEmpty() || other.unit.isEmpty()) {
                a = this;
                b = other;
            }
            else {
                a = this.unify();
                b = other.unify();
                if (a.unit.compare(b.unit) !== 0) {
                    return undefined;
                }
            }
            return Node.numericCompare(a.value, b.value);
        },
        unify: function () {
            return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });
        },
        convertTo: function (conversions) {
            var value = this.value;
            var unit = this.unit.clone();
            var i;
            var groupName;
            var group;
            var targetUnit;
            var derivedConversions = {};
            var applyUnit;
            if (typeof conversions === 'string') {
                for (i in unitConversions) {
                    if (unitConversions[i].hasOwnProperty(conversions)) {
                        derivedConversions = {};
                        derivedConversions[i] = conversions;
                    }
                }
                conversions = derivedConversions;
            }
            applyUnit = function (atomicUnit, denominator) {
                /* jshint loopfunc:true */
                if (group.hasOwnProperty(atomicUnit)) {
                    if (denominator) {
                        value = value / (group[atomicUnit] / group[targetUnit]);
                    }
                    else {
                        value = value * (group[atomicUnit] / group[targetUnit]);
                    }
                    return targetUnit;
                }
                return atomicUnit;
            };
            for (groupName in conversions) {
                if (conversions.hasOwnProperty(groupName)) {
                    targetUnit = conversions[groupName];
                    group = unitConversions[groupName];
                    unit.map(applyUnit);
                }
            }
            unit.cancel();
            return new Dimension(value, unit);
        }
    });

    var MATH$1 = Math$1;
    var Operation = function (op, operands, isSpaced) {
        this.op = op.trim();
        this.operands = operands;
        this.isSpaced = isSpaced;
    };
    Operation.prototype = Object.assign(new Node(), {
        type: 'Operation',
        accept: function (visitor) {
            this.operands = visitor.visitArray(this.operands);
        },
        eval: function (context) {
            var a = this.operands[0].eval(context), b = this.operands[1].eval(context), op;
            if (context.isMathOn(this.op)) {
                op = this.op === './' ? '/' : this.op;
                if (a instanceof Dimension && b instanceof Color) {
                    a = a.toColor();
                }
                if (b instanceof Dimension && a instanceof Color) {
                    b = b.toColor();
                }
                if (!a.operate || !b.operate) {
                    if ((a instanceof Operation || b instanceof Operation)
                        && a.op === '/' && context.math === MATH$1.PARENS_DIVISION) {
                        return new Operation(this.op, [a, b], this.isSpaced);
                    }
                    throw { type: 'Operation',
                        message: 'Operation on an invalid type' };
                }
                return a.operate(context, op, b);
            }
            else {
                return new Operation(this.op, [a, b], this.isSpaced);
            }
        },
        genCSS: function (context, output) {
            this.operands[0].genCSS(context, output);
            if (this.isSpaced) {
                output.add(' ');
            }
            output.add(this.op);
            if (this.isSpaced) {
                output.add(' ');
            }
            this.operands[1].genCSS(context, output);
        }
    });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArrays$1() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var Expression = function (value, noSpacing) {
        this.value = value;
        this.noSpacing = noSpacing;
        if (!value) {
            throw new Error('Expression requires an array parameter');
        }
    };
    Expression.prototype = Object.assign(new Node(), {
        type: 'Expression',
        accept: function (visitor) {
            this.value = visitor.visitArray(this.value);
        },
        eval: function (context) {
            var returnValue;
            var mathOn = context.isMathOn();
            var inParenthesis = this.parens;
            var doubleParen = false;
            if (inParenthesis) {
                context.inParenthesis();
            }
            if (this.value.length > 1) {
                returnValue = new Expression(this.value.map(function (e) {
                    if (!e.eval) {
                        return e;
                    }
                    return e.eval(context);
                }), this.noSpacing);
            }
            else if (this.value.length === 1) {
                if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {
                    doubleParen = true;
                }
                returnValue = this.value[0].eval(context);
            }
            else {
                returnValue = this;
            }
            if (inParenthesis) {
                context.outOfParenthesis();
            }
            if (this.parens && this.parensInOp && !mathOn && !doubleParen
                && (!(returnValue instanceof Dimension))) {
                returnValue = new Paren(returnValue);
            }
            return returnValue;
        },
        genCSS: function (context, output) {
            for (var i = 0; i < this.value.length; i++) {
                this.value[i].genCSS(context, output);
                if (!this.noSpacing && i + 1 < this.value.length) {
                    output.add(' ');
                }
            }
        },
        throwAwayComments: function () {
            this.value = this.value.filter(function (v) {
                return !(v instanceof Comment);
            });
        }
    });

    var functionCaller = /** @class */ (function () {
        function functionCaller(name, context, index, currentFileInfo) {
            this.name = name.toLowerCase();
            this.index = index;
            this.context = context;
            this.currentFileInfo = currentFileInfo;
            this.func = context.frames[0].functionRegistry.get(this.name);
        }
        functionCaller.prototype.isValid = function () {
            return Boolean(this.func);
        };
        functionCaller.prototype.call = function (args) {
            var _this = this;
            if (!(Array.isArray(args))) {
                args = [args];
            }
            var evalArgs = this.func.evalArgs;
            if (evalArgs !== false) {
                args = args.map(function (a) { return a.eval(_this.context); });
            }
            var commentFilter = function (item) { return !(item.type === 'Comment'); };
            // This code is terrible and should be replaced as per this issue...
            // https://github.com/less/less.js/issues/2477
            args = args
                .filter(commentFilter)
                .map(function (item) {
                if (item.type === 'Expression') {
                    var subNodes = item.value.filter(commentFilter);
                    if (subNodes.length === 1) {
                        return subNodes[0];
                    }
                    else {
                        return new Expression(subNodes);
                    }
                }
                return item;
            });
            if (evalArgs === false) {
                return this.func.apply(this, __spreadArrays$1([this.context], args));
            }
            return this.func.apply(this, args);
        };
        return functionCaller;
    }());

    //
    // A function call node.
    //
    var Call = function (name, args, index, currentFileInfo) {
        this.name = name;
        this.args = args;
        this.calc = name === 'calc';
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    Call.prototype = Object.assign(new Node(), {
        type: 'Call',
        accept: function (visitor) {
            if (this.args) {
                this.args = visitor.visitArray(this.args);
            }
        },
        //
        // When evaluating a function call,
        // we either find the function in the functionRegistry,
        // in which case we call it, passing the  evaluated arguments,
        // if this returns null or we cannot find the function, we
        // simply print it out as it appeared originally [2].
        //
        // The reason why we evaluate the arguments, is in the case where
        // we try to pass a variable to a function, like: `saturate(@color)`.
        // The function should receive the value, not the variable.
        //
        eval: function (context) {
            var _this = this;
            /**
             * Turn off math for calc(), and switch back on for evaluating nested functions
             */
            var currentMathContext = context.mathOn;
            context.mathOn = !this.calc;
            if (this.calc || context.inCalc) {
                context.enterCalc();
            }
            var exitCalc = function () {
                if (_this.calc || context.inCalc) {
                    context.exitCalc();
                }
                context.mathOn = currentMathContext;
            };
            var result;
            var funcCaller = new functionCaller(this.name, context, this.getIndex(), this.fileInfo());
            if (funcCaller.isValid()) {
                try {
                    result = funcCaller.call(this.args);
                    exitCalc();
                }
                catch (e) {
                    if (e.hasOwnProperty('line') && e.hasOwnProperty('column')) {
                        throw e;
                    }
                    throw {
                        type: e.type || 'Runtime',
                        message: "Error evaluating function `" + this.name + "`" + (e.message ? ": " + e.message : ''),
                        index: this.getIndex(),
                        filename: this.fileInfo().filename,
                        line: e.lineNumber,
                        column: e.columnNumber
                    };
                }
            }
            if (result !== null && result !== undefined) {
                // Results that that are not nodes are cast as Anonymous nodes
                // Falsy values or booleans are returned as empty nodes
                if (!(result instanceof Node)) {
                    if (!result || result === true) {
                        result = new Anonymous(null);
                    }
                    else {
                        result = new Anonymous(result.toString());
                    }
                }
                result._index = this._index;
                result._fileInfo = this._fileInfo;
                return result;
            }
            var args = this.args.map(function (a) { return a.eval(context); });
            exitCalc();
            return new Call(this.name, args, this.getIndex(), this.fileInfo());
        },
        genCSS: function (context, output) {
            output.add(this.name + "(", this.fileInfo(), this.getIndex());
            for (var i = 0; i < this.args.length; i++) {
                this.args[i].genCSS(context, output);
                if (i + 1 < this.args.length) {
                    output.add(', ');
                }
            }
            output.add(')');
        }
    });

    var Variable = function (name, index, currentFileInfo) {
        this.name = name;
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    Variable.prototype = Object.assign(new Node(), {
        type: 'Variable',
        eval: function (context) {
            var variable, name = this.name;
            if (name.indexOf('@@') === 0) {
                name = "@" + new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value;
            }
            if (this.evaluating) {
                throw { type: 'Name', message: "Recursive variable definition for " + name, filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            this.evaluating = true;
            variable = this.find(context.frames, function (frame) {
                var v = frame.variable(name);
                if (v) {
                    if (v.important) {
                        var importantScope = context.importantScope[context.importantScope.length - 1];
                        importantScope.important = v.important;
                    }
                    // If in calc, wrap vars in a function call to cascade evaluate args first
                    if (context.inCalc) {
                        return (new Call('_SELF', [v.value])).eval(context);
                    }
                    else {
                        return v.value.eval(context);
                    }
                }
            });
            if (variable) {
                this.evaluating = false;
                return variable;
            }
            else {
                throw { type: 'Name', message: "variable " + name + " is undefined", filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
        },
        find: function (obj, fun) {
            for (var i = 0, r = void 0; i < obj.length; i++) {
                r = fun.call(obj, obj[i]);
                if (r) {
                    return r;
                }
            }
            return null;
        }
    });

    var Property = function (name, index, currentFileInfo) {
        this.name = name;
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    Property.prototype = Object.assign(new Node(), {
        type: 'Property',
        eval: function (context) {
            var property;
            var name = this.name;
            // TODO: shorten this reference
            var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;
            if (this.evaluating) {
                throw { type: 'Name', message: "Recursive property reference for " + name, filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            this.evaluating = true;
            property = this.find(context.frames, function (frame) {
                var v;
                var vArr = frame.property(name);
                if (vArr) {
                    for (var i = 0; i < vArr.length; i++) {
                        v = vArr[i];
                        vArr[i] = new Declaration(v.name, v.value, v.important, v.merge, v.index, v.currentFileInfo, v.inline, v.variable);
                    }
                    mergeRules(vArr);
                    v = vArr[vArr.length - 1];
                    if (v.important) {
                        var importantScope = context.importantScope[context.importantScope.length - 1];
                        importantScope.important = v.important;
                    }
                    v = v.value.eval(context);
                    return v;
                }
            });
            if (property) {
                this.evaluating = false;
                return property;
            }
            else {
                throw { type: 'Name', message: "Property '" + name + "' is undefined", filename: this.currentFileInfo.filename,
                    index: this.index };
            }
        },
        find: function (obj, fun) {
            for (var i = 0, r = void 0; i < obj.length; i++) {
                r = fun.call(obj, obj[i]);
                if (r) {
                    return r;
                }
            }
            return null;
        }
    });

    var Attribute = function (key, op, value) {
        this.key = key;
        this.op = op;
        this.value = value;
    };
    Attribute.prototype = Object.assign(new Node(), {
        type: 'Attribute',
        eval: function (context) {
            return new Attribute(this.key.eval ? this.key.eval(context) : this.key, this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);
        },
        genCSS: function (context, output) {
            output.add(this.toCSS(context));
        },
        toCSS: function (context) {
            var value = this.key.toCSS ? this.key.toCSS(context) : this.key;
            if (this.op) {
                value += this.op;
                value += (this.value.toCSS ? this.value.toCSS(context) : this.value);
            }
            return "[" + value + "]";
        }
    });

    var Quoted = function (str, content, escaped, index, currentFileInfo) {
        this.escaped = (escaped == null) ? true : escaped;
        this.value = content || '';
        this.quote = str.charAt(0);
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.variableRegex = /@\{([\w-]+)\}/g;
        this.propRegex = /\$\{([\w-]+)\}/g;
        this.allowRoot = escaped;
    };
    Quoted.prototype = Object.assign(new Node(), {
        type: 'Quoted',
        genCSS: function (context, output) {
            if (!this.escaped) {
                output.add(this.quote, this.fileInfo(), this.getIndex());
            }
            output.add(this.value);
            if (!this.escaped) {
                output.add(this.quote);
            }
        },
        containsVariables: function () {
            return this.value.match(this.variableRegex);
        },
        eval: function (context) {
            var that = this;
            var value = this.value;
            var variableReplacement = function (_, name) {
                var v = new Variable("@" + name, that.getIndex(), that.fileInfo()).eval(context, true);
                return (v instanceof Quoted) ? v.value : v.toCSS();
            };
            var propertyReplacement = function (_, name) {
                var v = new Property("$" + name, that.getIndex(), that.fileInfo()).eval(context, true);
                return (v instanceof Quoted) ? v.value : v.toCSS();
            };
            function iterativeReplace(value, regexp, replacementFnc) {
                var evaluatedValue = value;
                do {
                    value = evaluatedValue.toString();
                    evaluatedValue = value.replace(regexp, replacementFnc);
                } while (value !== evaluatedValue);
                return evaluatedValue;
            }
            value = iterativeReplace(value, this.variableRegex, variableReplacement);
            value = iterativeReplace(value, this.propRegex, propertyReplacement);
            return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());
        },
        compare: function (other) {
            // when comparing quoted strings allow the quote to differ
            if (other.type === 'Quoted' && !this.escaped && !other.escaped) {
                return Node.numericCompare(this.value, other.value);
            }
            else {
                return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
            }
        }
    });

    function escapePath(path) {
        return path.replace(/[\(\)'"\s]/g, function (match) { return "\\" + match; });
    }
    var URL = function (val, index, currentFileInfo, isEvald) {
        this.value = val;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.isEvald = isEvald;
    };
    URL.prototype = Object.assign(new Node(), {
        type: 'Url',
        accept: function (visitor) {
            this.value = visitor.visit(this.value);
        },
        genCSS: function (context, output) {
            output.add('url(');
            this.value.genCSS(context, output);
            output.add(')');
        },
        eval: function (context) {
            var val = this.value.eval(context);
            var rootpath;
            if (!this.isEvald) {
                // Add the rootpath if the URL requires a rewrite
                rootpath = this.fileInfo() && this.fileInfo().rootpath;
                if (typeof rootpath === 'string' &&
                    typeof val.value === 'string' &&
                    context.pathRequiresRewrite(val.value)) {
                    if (!val.quote) {
                        rootpath = escapePath(rootpath);
                    }
                    val.value = context.rewritePath(val.value, rootpath);
                }
                else {
                    val.value = context.normalizePath(val.value);
                }
                // Add url args if enabled
                if (context.urlArgs) {
                    if (!val.value.match(/^\s*data:/)) {
                        var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';
                        var urlArgs = delimiter + context.urlArgs;
                        if (val.value.indexOf('#') !== -1) {
                            val.value = val.value.replace('#', urlArgs + "#");
                        }
                        else {
                            val.value += urlArgs;
                        }
                    }
                }
            }
            return new URL(val, this.getIndex(), this.fileInfo(), true);
        }
    });

    var Media = function (value, features, index, currentFileInfo, visibilityInfo) {
        this._index = index;
        this._fileInfo = currentFileInfo;
        var selectors = (new Selector([], null, null, this._index, this._fileInfo)).createEmptySelectors();
        this.features = new Value(features);
        this.rules = [new Ruleset(selectors, value)];
        this.rules[0].allowImports = true;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
        this.setParent(selectors, this);
        this.setParent(this.features, this);
        this.setParent(this.rules, this);
    };
    Media.prototype = Object.assign(new AtRule(), {
        type: 'Media',
        isRulesetLike: function () {
            return true;
        },
        accept: function (visitor) {
            if (this.features) {
                this.features = visitor.visit(this.features);
            }
            if (this.rules) {
                this.rules = visitor.visitArray(this.rules);
            }
        },
        genCSS: function (context, output) {
            output.add('@media ', this._fileInfo, this._index);
            this.features.genCSS(context, output);
            this.outputRuleset(context, output, this.rules);
        },
        eval: function (context) {
            if (!context.mediaBlocks) {
                context.mediaBlocks = [];
                context.mediaPath = [];
            }
            var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());
            if (this.debugInfo) {
                this.rules[0].debugInfo = this.debugInfo;
                media.debugInfo = this.debugInfo;
            }
            media.features = this.features.eval(context);
            context.mediaPath.push(media);
            context.mediaBlocks.push(media);
            this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
            context.frames.unshift(this.rules[0]);
            media.rules = [this.rules[0].eval(context)];
            context.frames.shift();
            context.mediaPath.pop();
            return context.mediaPath.length === 0 ? media.evalTop(context) :
                media.evalNested(context);
        },
        evalTop: function (context) {
            var result = this;
            // Render all dependent Media blocks.
            if (context.mediaBlocks.length > 1) {
                var selectors = (new Selector([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();
                result = new Ruleset(selectors, context.mediaBlocks);
                result.multiMedia = true;
                result.copyVisibilityInfo(this.visibilityInfo());
                this.setParent(result, this);
            }
            delete context.mediaBlocks;
            delete context.mediaPath;
            return result;
        },
        evalNested: function (context) {
            var i;
            var value;
            var path = context.mediaPath.concat([this]);
            // Extract the media-query conditions separated with `,` (OR).
            for (i = 0; i < path.length; i++) {
                value = path[i].features instanceof Value ?
                    path[i].features.value : path[i].features;
                path[i] = Array.isArray(value) ? value : [value];
            }
            // Trace all permutations to generate the resulting media-query.
            //
            // (a, b and c) with nested (d, e) ->
            //    a and d
            //    a and e
            //    b and c and d
            //    b and c and e
            this.features = new Value(this.permute(path).map(function (path) {
                path = path.map(function (fragment) { return fragment.toCSS ? fragment : new Anonymous(fragment); });
                for (i = path.length - 1; i > 0; i--) {
                    path.splice(i, 0, new Anonymous('and'));
                }
                return new Expression(path);
            }));
            this.setParent(this.features, this);
            // Fake a tree-node that doesn't output anything.
            return new Ruleset([], []);
        },
        permute: function (arr) {
            if (arr.length === 0) {
                return [];
            }
            else if (arr.length === 1) {
                return arr[0];
            }
            else {
                var result = [];
                var rest = this.permute(arr.slice(1));
                for (var i = 0; i < rest.length; i++) {
                    for (var j = 0; j < arr[0].length; j++) {
                        result.push([arr[0][j]].concat(rest[i]));
                    }
                }
                return result;
            }
        },
        bubbleSelectors: function (selectors) {
            if (!selectors) {
                return;
            }
            this.rules = [new Ruleset(copyArray(selectors), [this.rules[0]])];
            this.setParent(this.rules, this);
        }
    });

    //
    // CSS @import node
    //
    // The general strategy here is that we don't want to wait
    // for the parsing to be completed, before we start importing
    // the file. That's because in the context of a browser,
    // most of the time will be spent waiting for the server to respond.
    //
    // On creation, we push the import path to our import queue, though
    // `import,push`, we also pass it a callback, which it'll call once
    // the file has been fetched, and parsed.
    //
    var Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {
        this.options = options;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.path = path;
        this.features = features;
        this.allowRoot = true;
        if (this.options.less !== undefined || this.options.inline) {
            this.css = !this.options.less || this.options.inline;
        }
        else {
            var pathValue = this.getPath();
            if (pathValue && /[#\.\&\?]css([\?;].*)?$/.test(pathValue)) {
                this.css = true;
            }
        }
        this.copyVisibilityInfo(visibilityInfo);
        this.setParent(this.features, this);
        this.setParent(this.path, this);
    };
    Import.prototype = Object.assign(new Node(), {
        type: 'Import',
        accept: function (visitor) {
            if (this.features) {
                this.features = visitor.visit(this.features);
            }
            this.path = visitor.visit(this.path);
            if (!this.options.isPlugin && !this.options.inline && this.root) {
                this.root = visitor.visit(this.root);
            }
        },
        genCSS: function (context, output) {
            if (this.css && this.path._fileInfo.reference === undefined) {
                output.add('@import ', this._fileInfo, this._index);
                this.path.genCSS(context, output);
                if (this.features) {
                    output.add(' ');
                    this.features.genCSS(context, output);
                }
                output.add(';');
            }
        },
        getPath: function () {
            return (this.path instanceof URL) ?
                this.path.value.value : this.path.value;
        },
        isVariableImport: function () {
            var path = this.path;
            if (path instanceof URL) {
                path = path.value;
            }
            if (path instanceof Quoted) {
                return path.containsVariables();
            }
            return true;
        },
        evalForImport: function (context) {
            var path = this.path;
            if (path instanceof URL) {
                path = path.value;
            }
            return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());
        },
        evalPath: function (context) {
            var path = this.path.eval(context);
            var fileInfo = this._fileInfo;
            if (!(path instanceof URL)) {
                // Add the rootpath if the URL requires a rewrite
                var pathValue = path.value;
                if (fileInfo &&
                    pathValue &&
                    context.pathRequiresRewrite(pathValue)) {
                    path.value = context.rewritePath(pathValue, fileInfo.rootpath);
                }
                else {
                    path.value = context.normalizePath(path.value);
                }
            }
            return path;
        },
        eval: function (context) {
            var result = this.doEval(context);
            if (this.options.reference || this.blocksVisibility()) {
                if (result.length || result.length === 0) {
                    result.forEach(function (node) {
                        node.addVisibilityBlock();
                    });
                }
                else {
                    result.addVisibilityBlock();
                }
            }
            return result;
        },
        doEval: function (context) {
            var ruleset;
            var registry;
            var features = this.features && this.features.eval(context);
            if (this.options.isPlugin) {
                if (this.root && this.root.eval) {
                    try {
                        this.root.eval(context);
                    }
                    catch (e) {
                        e.message = 'Plugin error during evaluation';
                        throw new LessError(e, this.root.imports, this.root.filename);
                    }
                }
                registry = context.frames[0] && context.frames[0].functionRegistry;
                if (registry && this.root && this.root.functions) {
                    registry.addMultiple(this.root.functions);
                }
                return [];
            }
            if (this.skip) {
                if (typeof this.skip === 'function') {
                    this.skip = this.skip();
                }
                if (this.skip) {
                    return [];
                }
            }
            if (this.options.inline) {
                var contents = new Anonymous(this.root, 0, {
                    filename: this.importedFilename,
                    reference: this.path._fileInfo && this.path._fileInfo.reference
                }, true, true);
                return this.features ? new Media([contents], this.features.value) : [contents];
            }
            else if (this.css) {
                var newImport = new Import(this.evalPath(context), features, this.options, this._index);
                if (!newImport.css && this.error) {
                    throw this.error;
                }
                return newImport;
            }
            else if (this.root) {
                ruleset = new Ruleset(null, copyArray(this.root.rules));
                ruleset.evalImports(context);
                return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;
            }
            else {
                return [];
            }
        }
    });

    var JsEvalNode = function () { };
    JsEvalNode.prototype = Object.assign(new Node(), {
        evaluateJavaScript: function (expression, context) {
            var result;
            var that = this;
            var evalContext = {};
            if (!context.javascriptEnabled) {
                throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',
                    filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            expression = expression.replace(/@\{([\w-]+)\}/g, function (_, name) {
                return that.jsify(new Variable("@" + name, that.getIndex(), that.fileInfo()).eval(context));
            });
            try {
                expression = new Function("return (" + expression + ")");
            }
            catch (e) {
                throw { message: "JavaScript evaluation error: " + e.message + " from `" + expression + "`", filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            var variables = context.frames[0].variables();
            for (var k in variables) {
                if (variables.hasOwnProperty(k)) {
                    /* jshint loopfunc:true */
                    evalContext[k.slice(1)] = {
                        value: variables[k].value,
                        toJS: function () {
                            return this.value.eval(context).toCSS();
                        }
                    };
                }
            }
            try {
                result = expression.call(evalContext);
            }
            catch (e) {
                throw { message: "JavaScript evaluation error: '" + e.name + ": " + e.message.replace(/["]/g, '\'') + "'", filename: this.fileInfo().filename,
                    index: this.getIndex() };
            }
            return result;
        },
        jsify: function (obj) {
            if (Array.isArray(obj.value) && (obj.value.length > 1)) {
                return "[" + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + "]";
            }
            else {
                return obj.toCSS();
            }
        }
    });

    var JavaScript = function (string, escaped, index, currentFileInfo) {
        this.escaped = escaped;
        this.expression = string;
        this._index = index;
        this._fileInfo = currentFileInfo;
    };
    JavaScript.prototype = Object.assign(new JsEvalNode(), {
        type: 'JavaScript',
        eval: function (context) {
            var result = this.evaluateJavaScript(this.expression, context);
            var type = typeof result;
            if (type === 'number' && !isNaN(result)) {
                return new Dimension(result);
            }
            else if (type === 'string') {
                return new Quoted("\"" + result + "\"", result, this.escaped, this._index);
            }
            else if (Array.isArray(result)) {
                return new Anonymous(result.join(', '));
            }
            else {
                return new Anonymous(result);
            }
        }
    });

    var Assignment = function (key, val) {
        this.key = key;
        this.value = val;
    };
    Assignment.prototype = Object.assign(new Node(), {
        type: 'Assignment',
        accept: function (visitor) {
            this.value = visitor.visit(this.value);
        },
        eval: function (context) {
            if (this.value.eval) {
                return new Assignment(this.key, this.value.eval(context));
            }
            return this;
        },
        genCSS: function (context, output) {
            output.add(this.key + "=");
            if (this.value.genCSS) {
                this.value.genCSS(context, output);
            }
            else {
                output.add(this.value);
            }
        }
    });

    var Condition = function (op, l, r, i, negate) {
        this.op = op.trim();
        this.lvalue = l;
        this.rvalue = r;
        this._index = i;
        this.negate = negate;
    };
    Condition.prototype = Object.assign(new Node(), {
        type: 'Condition',
        accept: function (visitor) {
            this.lvalue = visitor.visit(this.lvalue);
            this.rvalue = visitor.visit(this.rvalue);
        },
        eval: function (context) {
            var result = (function (op, a, b) {
                switch (op) {
                    case 'and': return a && b;
                    case 'or': return a || b;
                    default:
                        switch (Node.compare(a, b)) {
                            case -1:
                                return op === '<' || op === '=<' || op === '<=';
                            case 0:
                                return op === '=' || op === '>=' || op === '=<' || op === '<=';
                            case 1:
                                return op === '>' || op === '>=';
                            default:
                                return false;
                        }
                }
            })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));
            return this.negate ? !result : result;
        }
    });

    var UnicodeDescriptor = function (value) {
        this.value = value;
    };
    UnicodeDescriptor.prototype = Object.assign(new Node(), {
        type: 'UnicodeDescriptor'
    });

    var Negative = function (node) {
        this.value = node;
    };
    Negative.prototype = Object.assign(new Node(), {
        type: 'Negative',
        genCSS: function (context, output) {
            output.add('-');
            this.value.genCSS(context, output);
        },
        eval: function (context) {
            if (context.isMathOn()) {
                return (new Operation('*', [new Dimension(-1), this.value])).eval(context);
            }
            return new Negative(this.value.eval(context));
        }
    });

    var Extend = function (selector, option, index, currentFileInfo, visibilityInfo) {
        this.selector = selector;
        this.option = option;
        this.object_id = Extend.next_id++;
        this.parent_ids = [this.object_id];
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
        switch (option) {
            case 'all':
                this.allowBefore = true;
                this.allowAfter = true;
                break;
            default:
                this.allowBefore = false;
                this.allowAfter = false;
                break;
        }
        this.setParent(this.selector, this);
    };
    Extend.prototype = Object.assign(new Node(), {
        type: 'Extend',
        accept: function (visitor) {
            this.selector = visitor.visit(this.selector);
        },
        eval: function (context) {
            return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        clone: function (context) {
            return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        },
        // it concatenates (joins) all selectors in selector array
        findSelfSelectors: function (selectors) {
            var selfElements = [], i, selectorElements;
            for (i = 0; i < selectors.length; i++) {
                selectorElements = selectors[i].elements;
                // duplicate the logic in genCSS function inside the selector node.
                // future TODO - move both logics into the selector joiner visitor
                if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {
                    selectorElements[0].combinator.value = ' ';
                }
                selfElements = selfElements.concat(selectors[i].elements);
            }
            this.selfSelectors = [new Selector(selfElements)];
            this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
        }
    });
    Extend.next_id = 0;

    var VariableCall = function (variable, index, currentFileInfo) {
        this.variable = variable;
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.allowRoot = true;
    };
    VariableCall.prototype = Object.assign(new Node(), {
        type: 'VariableCall',
        eval: function (context) {
            var rules;
            var detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context);
            var error = new LessError({ message: "Could not evaluate variable call " + this.variable });
            if (!detachedRuleset.ruleset) {
                if (detachedRuleset.rules) {
                    rules = detachedRuleset;
                }
                else if (Array.isArray(detachedRuleset)) {
                    rules = new Ruleset('', detachedRuleset);
                }
                else if (Array.isArray(detachedRuleset.value)) {
                    rules = new Ruleset('', detachedRuleset.value);
                }
                else {
                    throw error;
                }
                detachedRuleset = new DetachedRuleset(rules);
            }
            if (detachedRuleset.ruleset) {
                return detachedRuleset.callEval(context);
            }
            throw error;
        }
    });

    var NamespaceValue = function (ruleCall, lookups, index, fileInfo) {
        this.value = ruleCall;
        this.lookups = lookups;
        this._index = index;
        this._fileInfo = fileInfo;
    };
    NamespaceValue.prototype = Object.assign(new Node(), {
        type: 'NamespaceValue',
        eval: function (context) {
            var i, name, rules = this.value.eval(context);
            for (i = 0; i < this.lookups.length; i++) {
                name = this.lookups[i];
                /**
                 * Eval'd DRs return rulesets.
                 * Eval'd mixins return rules, so let's make a ruleset if we need it.
                 * We need to do this because of late parsing of values
                 */
                if (Array.isArray(rules)) {
                    rules = new Ruleset([new Selector()], rules);
                }
                if (name === '') {
                    rules = rules.lastDeclaration();
                }
                else if (name.charAt(0) === '@') {
                    if (name.charAt(1) === '@') {
                        name = "@" + new Variable(name.substr(1)).eval(context).value;
                    }
                    if (rules.variables) {
                        rules = rules.variable(name);
                    }
                    if (!rules) {
                        throw { type: 'Name', message: "variable " + name + " not found", filename: this.fileInfo().filename,
                            index: this.getIndex() };
                    }
                }
                else {
                    if (name.substring(0, 2) === '$@') {
                        name = "$" + new Variable(name.substr(1)).eval(context).value;
                    }
                    else {
                        name = name.charAt(0) === '$' ? name : "$" + name;
                    }
                    if (rules.properties) {
                        rules = rules.property(name);
                    }
                    if (!rules) {
                        throw { type: 'Name', message: "property \"" + name.substr(1) + "\" not found", filename: this.fileInfo().filename,
                            index: this.getIndex() };
                    }
                    // Properties are an array of values, since a ruleset can have multiple props.
                    // We pick the last one (the "cascaded" value)
                    rules = rules[rules.length - 1];
                }
                if (rules.value) {
                    rules = rules.eval(context).value;
                }
                if (rules.ruleset) {
                    rules = rules.ruleset.eval(context);
                }
            }
            return rules;
        }
    });

    var Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {
        this.name = name || 'anonymous mixin';
        this.selectors = [new Selector([new Element(null, name, false, this._index, this._fileInfo)])];
        this.params = params;
        this.condition = condition;
        this.variadic = variadic;
        this.arity = params.length;
        this.rules = rules;
        this._lookups = {};
        var optionalParameters = [];
        this.required = params.reduce(function (count, p) {
            if (!p.name || (p.name && !p.value)) {
                return count + 1;
            }
            else {
                optionalParameters.push(p.name);
                return count;
            }
        }, 0);
        this.optionalParameters = optionalParameters;
        this.frames = frames;
        this.copyVisibilityInfo(visibilityInfo);
        this.allowRoot = true;
    };
    Definition.prototype = Object.assign(new Ruleset(), {
        type: 'MixinDefinition',
        evalFirst: true,
        accept: function (visitor) {
            if (this.params && this.params.length) {
                this.params = visitor.visitArray(this.params);
            }
            this.rules = visitor.visitArray(this.rules);
            if (this.condition) {
                this.condition = visitor.visit(this.condition);
            }
        },
        evalParams: function (context, mixinEnv, args, evaldArguments) {
            /* jshint boss:true */
            var frame = new Ruleset(null, null);
            var varargs;
            var arg;
            var params = copyArray(this.params);
            var i;
            var j;
            var val;
            var name;
            var isNamedFound;
            var argIndex;
            var argsLength = 0;
            if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
                frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
            }
            mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));
            if (args) {
                args = copyArray(args);
                argsLength = args.length;
                for (i = 0; i < argsLength; i++) {
                    arg = args[i];
                    if (name = (arg && arg.name)) {
                        isNamedFound = false;
                        for (j = 0; j < params.length; j++) {
                            if (!evaldArguments[j] && name === params[j].name) {
                                evaldArguments[j] = arg.value.eval(context);
                                frame.prependRule(new Declaration(name, arg.value.eval(context)));
                                isNamedFound = true;
                                break;
                            }
                        }
                        if (isNamedFound) {
                            args.splice(i, 1);
                            i--;
                            continue;
                        }
                        else {
                            throw { type: 'Runtime', message: "Named argument for " + this.name + " " + args[i].name + " not found" };
                        }
                    }
                }
            }
            argIndex = 0;
            for (i = 0; i < params.length; i++) {
                if (evaldArguments[i]) {
                    continue;
                }
                arg = args && args[argIndex];
                if (name = params[i].name) {
                    if (params[i].variadic) {
                        varargs = [];
                        for (j = argIndex; j < argsLength; j++) {
                            varargs.push(args[j].value.eval(context));
                        }
                        frame.prependRule(new Declaration(name, new Expression(varargs).eval(context)));
                    }
                    else {
                        val = arg && arg.value;
                        if (val) {
                            // This was a mixin call, pass in a detached ruleset of it's eval'd rules
                            if (Array.isArray(val)) {
                                val = new DetachedRuleset(new Ruleset('', val));
                            }
                            else {
                                val = val.eval(context);
                            }
                        }
                        else if (params[i].value) {
                            val = params[i].value.eval(mixinEnv);
                            frame.resetCache();
                        }
                        else {
                            throw { type: 'Runtime', message: "wrong number of arguments for " + this.name + " (" + argsLength + " for " + this.arity + ")" };
                        }
                        frame.prependRule(new Declaration(name, val));
                        evaldArguments[i] = val;
                    }
                }
                if (params[i].variadic && args) {
                    for (j = argIndex; j < argsLength; j++) {
                        evaldArguments[j] = args[j].value.eval(context);
                    }
                }
                argIndex++;
            }
            return frame;
        },
        makeImportant: function () {
            var rules = !this.rules ? this.rules : this.rules.map(function (r) {
                if (r.makeImportant) {
                    return r.makeImportant(true);
                }
                else {
                    return r;
                }
            });
            var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);
            return result;
        },
        eval: function (context) {
            return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || copyArray(context.frames));
        },
        evalCall: function (context, args, important) {
            var _arguments = [];
            var mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;
            var frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments);
            var rules;
            var ruleset;
            frame.prependRule(new Declaration('@arguments', new Expression(_arguments).eval(context)));
            rules = copyArray(this.rules);
            ruleset = new Ruleset(null, rules);
            ruleset.originalRuleset = this;
            ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));
            if (important) {
                ruleset = ruleset.makeImportant();
            }
            return ruleset;
        },
        matchCondition: function (args, context) {
            if (this.condition && !this.condition.eval(new contexts.Eval(context, [this.evalParams(context, /* the parameter variables */ new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]
                .concat(this.frames || []) // the parent namespace/mixin frames
                .concat(context.frames)))) { // the current environment frames
                return false;
            }
            return true;
        },
        matchArgs: function (args, context) {
            var allArgsCnt = (args && args.length) || 0;
            var len;
            var optionalParameters = this.optionalParameters;
            var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {
                if (optionalParameters.indexOf(p.name) < 0) {
                    return count + 1;
                }
                else {
                    return count;
                }
            }, 0);
            if (!this.variadic) {
                if (requiredArgsCnt < this.required) {
                    return false;
                }
                if (allArgsCnt > this.params.length) {
                    return false;
                }
            }
            else {
                if (requiredArgsCnt < (this.required - 1)) {
                    return false;
                }
            }
            // check patterns
            len = Math.min(requiredArgsCnt, this.arity);
            for (var i = 0; i < len; i++) {
                if (!this.params[i].name && !this.params[i].variadic) {
                    if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {
                        return false;
                    }
                }
            }
            return true;
        }
    });

    var MixinCall = function (elements, args, index, currentFileInfo, important) {
        this.selector = new Selector(elements);
        this.arguments = args || [];
        this._index = index;
        this._fileInfo = currentFileInfo;
        this.important = important;
        this.allowRoot = true;
        this.setParent(this.selector, this);
    };
    MixinCall.prototype = Object.assign(new Node(), {
        type: 'MixinCall',
        accept: function (visitor) {
            if (this.selector) {
                this.selector = visitor.visit(this.selector);
            }
            if (this.arguments.length) {
                this.arguments = visitor.visitArray(this.arguments);
            }
        },
        eval: function (context) {
            var mixins;
            var mixin;
            var mixinPath;
            var args = [];
            var arg;
            var argValue;
            var rules = [];
            var match = false;
            var i;
            var m;
            var f;
            var isRecursive;
            var isOneFound;
            var candidates = [];
            var candidate;
            var conditionResult = [];
            var defaultResult;
            var defFalseEitherCase = -1;
            var defNone = 0;
            var defTrue = 1;
            var defFalse = 2;
            var count;
            var originalRuleset;
            var noArgumentsFilter;
            this.selector = this.selector.eval(context);
            function calcDefGroup(mixin, mixinPath) {
                var f, p, namespace;
                for (f = 0; f < 2; f++) {
                    conditionResult[f] = true;
                    defaultFunc.value(f);
                    for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {
                        namespace = mixinPath[p];
                        if (namespace.matchCondition) {
                            conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);
                        }
                    }
                    if (mixin.matchCondition) {
                        conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);
                    }
                }
                if (conditionResult[0] || conditionResult[1]) {
                    if (conditionResult[0] != conditionResult[1]) {
                        return conditionResult[1] ?
                            defTrue : defFalse;
                    }
                    return defNone;
                }
                return defFalseEitherCase;
            }
            for (i = 0; i < this.arguments.length; i++) {
                arg = this.arguments[i];
                argValue = arg.value.eval(context);
                if (arg.expand && Array.isArray(argValue.value)) {
                    argValue = argValue.value;
                    for (m = 0; m < argValue.length; m++) {
                        args.push({ value: argValue[m] });
                    }
                }
                else {
                    args.push({ name: arg.name, value: argValue });
                }
            }
            noArgumentsFilter = function (rule) { return rule.matchArgs(null, context); };
            for (i = 0; i < context.frames.length; i++) {
                if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {
                    isOneFound = true;
                    // To make `default()` function independent of definition order we have two "subpasses" here.
                    // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),
                    // and build candidate list with corresponding flags. Then, when we know all possible matches,
                    // we make a final decision.
                    for (m = 0; m < mixins.length; m++) {
                        mixin = mixins[m].rule;
                        mixinPath = mixins[m].path;
                        isRecursive = false;
                        for (f = 0; f < context.frames.length; f++) {
                            if ((!(mixin instanceof Definition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {
                                isRecursive = true;
                                break;
                            }
                        }
                        if (isRecursive) {
                            continue;
                        }
                        if (mixin.matchArgs(args, context)) {
                            candidate = { mixin: mixin, group: calcDefGroup(mixin, mixinPath) };
                            if (candidate.group !== defFalseEitherCase) {
                                candidates.push(candidate);
                            }
                            match = true;
                        }
                    }
                    defaultFunc.reset();
                    count = [0, 0, 0];
                    for (m = 0; m < candidates.length; m++) {
                        count[candidates[m].group]++;
                    }
                    if (count[defNone] > 0) {
                        defaultResult = defFalse;
                    }
                    else {
                        defaultResult = defTrue;
                        if ((count[defTrue] + count[defFalse]) > 1) {
                            throw { type: 'Runtime', message: "Ambiguous use of `default()` found when matching for `" + this.format(args) + "`", index: this.getIndex(), filename: this.fileInfo().filename };
                        }
                    }
                    for (m = 0; m < candidates.length; m++) {
                        candidate = candidates[m].group;
                        if ((candidate === defNone) || (candidate === defaultResult)) {
                            try {
                                mixin = candidates[m].mixin;
                                if (!(mixin instanceof Definition)) {
                                    originalRuleset = mixin.originalRuleset || mixin;
                                    mixin = new Definition('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
                                    mixin.originalRuleset = originalRuleset;
                                }
                                var newRules = mixin.evalCall(context, args, this.important).rules;
                                this._setVisibilityToReplacement(newRules);
                                Array.prototype.push.apply(rules, newRules);
                            }
                            catch (e) {
                                throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };
                            }
                        }
                    }
                    if (match) {
                        return rules;
                    }
                }
            }
            if (isOneFound) {
                throw { type: 'Runtime', message: "No matching definition was found for `" + this.format(args) + "`", index: this.getIndex(), filename: this.fileInfo().filename };
            }
            else {
                throw { type: 'Name', message: this.selector.toCSS().trim() + " is undefined", index: this.getIndex(), filename: this.fileInfo().filename };
            }
        },
        _setVisibilityToReplacement: function (replacement) {
            var i, rule;
            if (this.blocksVisibility()) {
                for (i = 0; i < replacement.length; i++) {
                    rule = replacement[i];
                    rule.addVisibilityBlock();
                }
            }
        },
        format: function (args) {
            return this.selector.toCSS().trim() + "(" + (args ? args.map(function (a) {
                var argValue = '';
                if (a.name) {
                    argValue += a.name + ":";
                }
                if (a.value.toCSS) {
                    argValue += a.value.toCSS();
                }
                else {
                    argValue += '???';
                }
                return argValue;
            }).join(', ') : '') + ")";
        }
    });

    var tree = {
        Node: Node, Color: Color, AtRule: AtRule, DetachedRuleset: DetachedRuleset, Operation: Operation,
        Dimension: Dimension, Unit: Unit, Keyword: Keyword, Variable: Variable, Property: Property,
        Ruleset: Ruleset, Element: Element, Attribute: Attribute, Combinator: Combinator, Selector: Selector,
        Quoted: Quoted, Expression: Expression, Declaration: Declaration, Call: Call, URL: URL, Import: Import,
        Comment: Comment, Anonymous: Anonymous, Value: Value, JavaScript: JavaScript, Assignment: Assignment,
        Condition: Condition, Paren: Paren, Media: Media, UnicodeDescriptor: UnicodeDescriptor, Negative: Negative,
        Extend: Extend, VariableCall: VariableCall, NamespaceValue: NamespaceValue,
        mixin: {
            Call: MixinCall,
            Definition: Definition
        }
    };

    var AbstractFileManager = /** @class */ (function () {
        function AbstractFileManager() {
        }
        AbstractFileManager.prototype.getPath = function (filename) {
            var j = filename.lastIndexOf('?');
            if (j > 0) {
                filename = filename.slice(0, j);
            }
            j = filename.lastIndexOf('/');
            if (j < 0) {
                j = filename.lastIndexOf('\\');
            }
            if (j < 0) {
                return '';
            }
            return filename.slice(0, j + 1);
        };
        AbstractFileManager.prototype.tryAppendExtension = function (path, ext) {
            return /(\.[a-z]*$)|([\?;].*)$/.test(path) ? path : path + ext;
        };
        AbstractFileManager.prototype.tryAppendLessExtension = function (path) {
            return this.tryAppendExtension(path, '.less');
        };
        AbstractFileManager.prototype.supportsSync = function () {
            return false;
        };
        AbstractFileManager.prototype.alwaysMakePathsAbsolute = function () {
            return false;
        };
        AbstractFileManager.prototype.isPathAbsolute = function (filename) {
            return (/^(?:[a-z-]+:|\/|\\|#)/i).test(filename);
        };
        // TODO: pull out / replace?
        AbstractFileManager.prototype.join = function (basePath, laterPath) {
            if (!basePath) {
                return laterPath;
            }
            return basePath + laterPath;
        };
        AbstractFileManager.prototype.pathDiff = function (url, baseUrl) {
            // diff between two paths to create a relative path
            var urlParts = this.extractUrlParts(url);
            var baseUrlParts = this.extractUrlParts(baseUrl);
            var i;
            var max;
            var urlDirectories;
            var baseUrlDirectories;
            var diff = '';
            if (urlParts.hostPart !== baseUrlParts.hostPart) {
                return '';
            }
            max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
            for (i = 0; i < max; i++) {
                if (baseUrlParts.directories[i] !== urlParts.directories[i]) {
                    break;
                }
            }
            baseUrlDirectories = baseUrlParts.directories.slice(i);
            urlDirectories = urlParts.directories.slice(i);
            for (i = 0; i < baseUrlDirectories.length - 1; i++) {
                diff += '../';
            }
            for (i = 0; i < urlDirectories.length - 1; i++) {
                diff += urlDirectories[i] + "/";
            }
            return diff;
        };
        // helper function, not part of API
        AbstractFileManager.prototype.extractUrlParts = function (url, baseUrl) {
            // urlParts[1] = protocol://hostname/ OR /
            // urlParts[2] = / if path relative to host base
            // urlParts[3] = directories
            // urlParts[4] = filename
            // urlParts[5] = parameters
            var urlPartsRegex = /^((?:[a-z-]+:)?\/{2}(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/i;
            var urlParts = url.match(urlPartsRegex);
            var returner = {};
            var rawDirectories = [];
            var directories = [];
            var i;
            var baseUrlParts;
            if (!urlParts) {
                throw new Error("Could not parse sheet href - '" + url + "'");
            }
            // Stylesheets in IE don't always return the full path
            if (baseUrl && (!urlParts[1] || urlParts[2])) {
                baseUrlParts = baseUrl.match(urlPartsRegex);
                if (!baseUrlParts) {
                    throw new Error("Could not parse page url - '" + baseUrl + "'");
                }
                urlParts[1] = urlParts[1] || baseUrlParts[1] || '';
                if (!urlParts[2]) {
                    urlParts[3] = baseUrlParts[3] + urlParts[3];
                }
            }
            if (urlParts[3]) {
                rawDirectories = urlParts[3].replace(/\\/g, '/').split('/');
                // collapse '..' and skip '.'
                for (i = 0; i < rawDirectories.length; i++) {
                    if (rawDirectories[i] === '..') {
                        directories.pop();
                    }
                    else if (rawDirectories[i] !== '.') {
                        directories.push(rawDirectories[i]);
                    }
                }
            }
            returner.hostPart = urlParts[1];
            returner.directories = directories;
            returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');
            returner.path = (urlParts[1] || '') + directories.join('/');
            returner.filename = urlParts[4];
            returner.fileUrl = returner.path + (urlParts[4] || '');
            returner.url = returner.fileUrl + (urlParts[5] || '');
            return returner;
        };
        return AbstractFileManager;
    }());

    var AbstractPluginLoader = /** @class */ (function () {
        function AbstractPluginLoader() {
            // Implemented by Node.js plugin loader
            this.require = function () {
                return null;
            };
        }
        AbstractPluginLoader.prototype.evalPlugin = function (contents, context, imports, pluginOptions, fileInfo) {
            var loader, registry, pluginObj, localModule, pluginManager, filename, result;
            pluginManager = context.pluginManager;
            if (fileInfo) {
                if (typeof fileInfo === 'string') {
                    filename = fileInfo;
                }
                else {
                    filename = fileInfo.filename;
                }
            }
            var shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;
            if (filename) {
                pluginObj = pluginManager.get(filename);
                if (pluginObj) {
                    result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                    if (result) {
                        return result;
                    }
                    try {
                        if (pluginObj.use) {
                            pluginObj.use.call(this.context, pluginObj);
                        }
                    }
                    catch (e) {
                        e.message = e.message || 'Error during @plugin call';
                        return new LessError(e, imports, filename);
                    }
                    return pluginObj;
                }
            }
            localModule = {
                exports: {},
                pluginManager: pluginManager,
                fileInfo: fileInfo
            };
            registry = functionRegistry.create();
            var registerPlugin = function (obj) {
                pluginObj = obj;
            };
            try {
                loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);
                loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);
            }
            catch (e) {
                return new LessError(e, imports, filename);
            }
            if (!pluginObj) {
                pluginObj = localModule.exports;
            }
            pluginObj = this.validatePlugin(pluginObj, filename, shortname);
            if (pluginObj instanceof LessError) {
                return pluginObj;
            }
            if (pluginObj) {
                pluginObj.imports = imports;
                pluginObj.filename = filename;
                // For < 3.x (or unspecified minVersion) - setOptions() before install()
                if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {
                    result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                    if (result) {
                        return result;
                    }
                }
                // Run on first load
                pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);
                pluginObj.functions = registry.getLocalFunctions();
                // Need to call setOptions again because the pluginObj might have functions
                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                if (result) {
                    return result;
                }
                // Run every @plugin call
                try {
                    if (pluginObj.use) {
                        pluginObj.use.call(this.context, pluginObj);
                    }
                }
                catch (e) {
                    e.message = e.message || 'Error during @plugin call';
                    return new LessError(e, imports, filename);
                }
            }
            else {
                return new LessError({ message: 'Not a valid plugin' }, imports, filename);
            }
            return pluginObj;
        };
        AbstractPluginLoader.prototype.trySetOptions = function (plugin, filename, name, options) {
            if (options && !plugin.setOptions) {
                return new LessError({
                    message: "Options have been provided but the plugin " + name + " does not support any options."
                });
            }
            try {
                plugin.setOptions && plugin.setOptions(options);
            }
            catch (e) {
                return new LessError(e);
            }
        };
        AbstractPluginLoader.prototype.validatePlugin = function (plugin, filename, name) {
            if (plugin) {
                // support plugins being a function
                // so that the plugin can be more usable programmatically
                if (typeof plugin === 'function') {
                    plugin = new plugin();
                }
                if (plugin.minVersion) {
                    if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {
                        return new LessError({
                            message: "Plugin " + name + " requires version " + this.versionToString(plugin.minVersion)
                        });
                    }
                }
                return plugin;
            }
            return null;
        };
        AbstractPluginLoader.prototype.compareVersion = function (aVersion, bVersion) {
            if (typeof aVersion === 'string') {
                aVersion = aVersion.match(/^(\d+)\.?(\d+)?\.?(\d+)?/);
                aVersion.shift();
            }
            for (var i = 0; i < aVersion.length; i++) {
                if (aVersion[i] !== bVersion[i]) {
                    return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;
                }
            }
            return 0;
        };
        AbstractPluginLoader.prototype.versionToString = function (version) {
            var versionString = '';
            for (var i = 0; i < version.length; i++) {
                versionString += (versionString ? '.' : '') + version[i];
            }
            return versionString;
        };
        AbstractPluginLoader.prototype.printUsage = function (plugins) {
            for (var i = 0; i < plugins.length; i++) {
                var plugin = plugins[i];
                if (plugin.printUsage) {
                    plugin.printUsage();
                }
            }
        };
        return AbstractPluginLoader;
    }());

    var _visitArgs = { visitDeeper: true };
    var _hasIndexed = false;
    function _noop(node) {
        return node;
    }
    function indexNodeTypes(parent, ticker) {
        // add .typeIndex to tree node types for lookup table
        var key, child;
        for (key in parent) {
            /* eslint guard-for-in: 0 */
            child = parent[key];
            switch (typeof child) {
                case 'function':
                    // ignore bound functions directly on tree which do not have a prototype
                    // or aren't nodes
                    if (child.prototype && child.prototype.type) {
                        child.prototype.typeIndex = ticker++;
                    }
                    break;
                case 'object':
                    ticker = indexNodeTypes(child, ticker);
                    break;
            }
        }
        return ticker;
    }
    var Visitor = /** @class */ (function () {
        function Visitor(implementation) {
            this._implementation = implementation;
            this._visitInCache = {};
            this._visitOutCache = {};
            if (!_hasIndexed) {
                indexNodeTypes(tree, 1);
                _hasIndexed = true;
            }
        }
        Visitor.prototype.visit = function (node) {
            if (!node) {
                return node;
            }
            var nodeTypeIndex = node.typeIndex;
            if (!nodeTypeIndex) {
                // MixinCall args aren't a node type?
                if (node.value && node.value.typeIndex) {
                    this.visit(node.value);
                }
                return node;
            }
            var impl = this._implementation;
            var func = this._visitInCache[nodeTypeIndex];
            var funcOut = this._visitOutCache[nodeTypeIndex];
            var visitArgs = _visitArgs;
            var fnName;
            visitArgs.visitDeeper = true;
            if (!func) {
                fnName = "visit" + node.type;
                func = impl[fnName] || _noop;
                funcOut = impl[fnName + "Out"] || _noop;
                this._visitInCache[nodeTypeIndex] = func;
                this._visitOutCache[nodeTypeIndex] = funcOut;
            }
            if (func !== _noop) {
                var newNode = func.call(impl, node, visitArgs);
                if (node && impl.isReplacing) {
                    node = newNode;
                }
            }
            if (visitArgs.visitDeeper && node) {
                if (node.length) {
                    for (var i = 0, cnt = node.length; i < cnt; i++) {
                        if (node[i].accept) {
                            node[i].accept(this);
                        }
                    }
                }
                else if (node.accept) {
                    node.accept(this);
                }
            }
            if (funcOut != _noop) {
                funcOut.call(impl, node);
            }
            return node;
        };
        Visitor.prototype.visitArray = function (nodes, nonReplacing) {
            if (!nodes) {
                return nodes;
            }
            var cnt = nodes.length;
            var i;
            // Non-replacing
            if (nonReplacing || !this._implementation.isReplacing) {
                for (i = 0; i < cnt; i++) {
                    this.visit(nodes[i]);
                }
                return nodes;
            }
            // Replacing
            var out = [];
            for (i = 0; i < cnt; i++) {
                var evald = this.visit(nodes[i]);
                if (evald === undefined) {
                    continue;
                }
                if (!evald.splice) {
                    out.push(evald);
                }
                else if (evald.length) {
                    this.flatten(evald, out);
                }
            }
            return out;
        };
        Visitor.prototype.flatten = function (arr, out) {
            if (!out) {
                out = [];
            }
            var cnt, i, item, nestedCnt, j, nestedItem;
            for (i = 0, cnt = arr.length; i < cnt; i++) {
                item = arr[i];
                if (item === undefined) {
                    continue;
                }
                if (!item.splice) {
                    out.push(item);
                    continue;
                }
                for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {
                    nestedItem = item[j];
                    if (nestedItem === undefined) {
                        continue;
                    }
                    if (!nestedItem.splice) {
                        out.push(nestedItem);
                    }
                    else if (nestedItem.length) {
                        this.flatten(nestedItem, out);
                    }
                }
            }
            return out;
        };
        return Visitor;
    }());

    var ImportSequencer = /** @class */ (function () {
        function ImportSequencer(onSequencerEmpty) {
            this.imports = [];
            this.variableImports = [];
            this._onSequencerEmpty = onSequencerEmpty;
            this._currentDepth = 0;
        }
        ImportSequencer.prototype.addImport = function (callback) {
            var importSequencer = this, importItem = {
                callback: callback,
                args: null,
                isReady: false
            };
            this.imports.push(importItem);
            return function () {
                importItem.args = Array.prototype.slice.call(arguments, 0);
                importItem.isReady = true;
                importSequencer.tryRun();
            };
        };
        ImportSequencer.prototype.addVariableImport = function (callback) {
            this.variableImports.push(callback);
        };
        ImportSequencer.prototype.tryRun = function () {
            this._currentDepth++;
            try {
                while (true) {
                    while (this.imports.length > 0) {
                        var importItem = this.imports[0];
                        if (!importItem.isReady) {
                            return;
                        }
                        this.imports = this.imports.slice(1);
                        importItem.callback.apply(null, importItem.args);
                    }
                    if (this.variableImports.length === 0) {
                        break;
                    }
                    var variableImport = this.variableImports[0];
                    this.variableImports = this.variableImports.slice(1);
                    variableImport();
                }
            }
            finally {
                this._currentDepth--;
            }
            if (this._currentDepth === 0 && this._onSequencerEmpty) {
                this._onSequencerEmpty();
            }
        };
        return ImportSequencer;
    }());

    var ImportVisitor = function (importer, finish) {
        this._visitor = new Visitor(this);
        this._importer = importer;
        this._finish = finish;
        this.context = new contexts.Eval();
        this.importCount = 0;
        this.onceFileDetectionMap = {};
        this.recursionDetector = {};
        this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));
    };
    ImportVisitor.prototype = {
        isReplacing: false,
        run: function (root) {
            try {
                // process the contents
                this._visitor.visit(root);
            }
            catch (e) {
                this.error = e;
            }
            this.isFinished = true;
            this._sequencer.tryRun();
        },
        _onSequencerEmpty: function () {
            if (!this.isFinished) {
                return;
            }
            this._finish(this.error);
        },
        visitImport: function (importNode, visitArgs) {
            var inlineCSS = importNode.options.inline;
            if (!importNode.css || inlineCSS) {
                var context = new contexts.Eval(this.context, copyArray(this.context.frames));
                var importParent = context.frames[0];
                this.importCount++;
                if (importNode.isVariableImport()) {
                    this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
                }
                else {
                    this.processImportNode(importNode, context, importParent);
                }
            }
            visitArgs.visitDeeper = false;
        },
        processImportNode: function (importNode, context, importParent) {
            var evaldImportNode;
            var inlineCSS = importNode.options.inline;
            try {
                evaldImportNode = importNode.evalForImport(context);
            }
            catch (e) {
                if (!e.filename) {
                    e.index = importNode.getIndex();
                    e.filename = importNode.fileInfo().filename;
                }
                // attempt to eval properly and treat as css
                importNode.css = true;
                // if that fails, this error will be thrown
                importNode.error = e;
            }
            if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {
                if (evaldImportNode.options.multiple) {
                    context.importMultiple = true;
                }
                // try appending if we haven't determined if it is css or not
                var tryAppendLessExtension = evaldImportNode.css === undefined;
                for (var i = 0; i < importParent.rules.length; i++) {
                    if (importParent.rules[i] === importNode) {
                        importParent.rules[i] = evaldImportNode;
                        break;
                    }
                }
                var onImported = this.onImported.bind(this, evaldImportNode, context), sequencedOnImported = this._sequencer.addImport(onImported);
                this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(), evaldImportNode.options, sequencedOnImported);
            }
            else {
                this.importCount--;
                if (this.isFinished) {
                    this._sequencer.tryRun();
                }
            }
        },
        onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {
            if (e) {
                if (!e.filename) {
                    e.index = importNode.getIndex();
                    e.filename = importNode.fileInfo().filename;
                }
                this.error = e;
            }
            var importVisitor = this, inlineCSS = importNode.options.inline, isPlugin = importNode.options.isPlugin, isOptional = importNode.options.optional, duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;
            if (!context.importMultiple) {
                if (duplicateImport) {
                    importNode.skip = true;
                }
                else {
                    importNode.skip = function () {
                        if (fullPath in importVisitor.onceFileDetectionMap) {
                            return true;
                        }
                        importVisitor.onceFileDetectionMap[fullPath] = true;
                        return false;
                    };
                }
            }
            if (!fullPath && isOptional) {
                importNode.skip = true;
            }
            if (root) {
                importNode.root = root;
                importNode.importedFilename = fullPath;
                if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
                    importVisitor.recursionDetector[fullPath] = true;
                    var oldContext = this.context;
                    this.context = context;
                    try {
                        this._visitor.visit(root);
                    }
                    catch (e) {
                        this.error = e;
                    }
                    this.context = oldContext;
                }
            }
            importVisitor.importCount--;
            if (importVisitor.isFinished) {
                importVisitor._sequencer.tryRun();
            }
        },
        visitDeclaration: function (declNode, visitArgs) {
            if (declNode.value.type === 'DetachedRuleset') {
                this.context.frames.unshift(declNode);
            }
            else {
                visitArgs.visitDeeper = false;
            }
        },
        visitDeclarationOut: function (declNode) {
            if (declNode.value.type === 'DetachedRuleset') {
                this.context.frames.shift();
            }
        },
        visitAtRule: function (atRuleNode, visitArgs) {
            this.context.frames.unshift(atRuleNode);
        },
        visitAtRuleOut: function (atRuleNode) {
            this.context.frames.shift();
        },
        visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
            this.context.frames.unshift(mixinDefinitionNode);
        },
        visitMixinDefinitionOut: function (mixinDefinitionNode) {
            this.context.frames.shift();
        },
        visitRuleset: function (rulesetNode, visitArgs) {
            this.context.frames.unshift(rulesetNode);
        },
        visitRulesetOut: function (rulesetNode) {
            this.context.frames.shift();
        },
        visitMedia: function (mediaNode, visitArgs) {
            this.context.frames.unshift(mediaNode.rules[0]);
        },
        visitMediaOut: function (mediaNode) {
            this.context.frames.shift();
        }
    };

    var SetTreeVisibilityVisitor = /** @class */ (function () {
        function SetTreeVisibilityVisitor(visible) {
            this.visible = visible;
        }
        SetTreeVisibilityVisitor.prototype.run = function (root) {
            this.visit(root);
        };
        SetTreeVisibilityVisitor.prototype.visitArray = function (nodes) {
            if (!nodes) {
                return nodes;
            }
            var cnt = nodes.length;
            var i;
            for (i = 0; i < cnt; i++) {
                this.visit(nodes[i]);
            }
            return nodes;
        };
        SetTreeVisibilityVisitor.prototype.visit = function (node) {
            if (!node) {
                return node;
            }
            if (node.constructor === Array) {
                return this.visitArray(node);
            }
            if (!node.blocksVisibility || node.blocksVisibility()) {
                return node;
            }
            if (this.visible) {
                node.ensureVisibility();
            }
            else {
                node.ensureInvisibility();
            }
            node.accept(this);
            return node;
        };
        return SetTreeVisibilityVisitor;
    }());

    /* jshint loopfunc:true */
    var ExtendFinderVisitor = /** @class */ (function () {
        function ExtendFinderVisitor() {
            this._visitor = new Visitor(this);
            this.contexts = [];
            this.allExtendsStack = [[]];
        }
        ExtendFinderVisitor.prototype.run = function (root) {
            root = this._visitor.visit(root);
            root.allExtends = this.allExtendsStack[0];
            return root;
        };
        ExtendFinderVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ExtendFinderVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ExtendFinderVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
            if (rulesetNode.root) {
                return;
            }
            var i;
            var j;
            var extend;
            var allSelectorsExtendList = [];
            var extendList;
            // get &:extend(.a); rules which apply to all selectors in this ruleset
            var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;
            for (i = 0; i < ruleCnt; i++) {
                if (rulesetNode.rules[i] instanceof tree.Extend) {
                    allSelectorsExtendList.push(rules[i]);
                    rulesetNode.extendOnEveryPath = true;
                }
            }
            // now find every selector and apply the extends that apply to all extends
            // and the ones which apply to an individual extend
            var paths = rulesetNode.paths;
            for (i = 0; i < paths.length; i++) {
                var selectorPath = paths[i], selector = selectorPath[selectorPath.length - 1], selExtendList = selector.extendList;
                extendList = selExtendList ? copyArray(selExtendList).concat(allSelectorsExtendList)
                    : allSelectorsExtendList;
                if (extendList) {
                    extendList = extendList.map(function (allSelectorsExtend) {
                        return allSelectorsExtend.clone();
                    });
                }
                for (j = 0; j < extendList.length; j++) {
                    this.foundExtends = true;
                    extend = extendList[j];
                    extend.findSelfSelectors(selectorPath);
                    extend.ruleset = rulesetNode;
                    if (j === 0) {
                        extend.firstExtendOnThisSelectorPath = true;
                    }
                    this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);
                }
            }
            this.contexts.push(rulesetNode.selectors);
        };
        ExtendFinderVisitor.prototype.visitRulesetOut = function (rulesetNode) {
            if (!rulesetNode.root) {
                this.contexts.length = this.contexts.length - 1;
            }
        };
        ExtendFinderVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
            mediaNode.allExtends = [];
            this.allExtendsStack.push(mediaNode.allExtends);
        };
        ExtendFinderVisitor.prototype.visitMediaOut = function (mediaNode) {
            this.allExtendsStack.length = this.allExtendsStack.length - 1;
        };
        ExtendFinderVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
            atRuleNode.allExtends = [];
            this.allExtendsStack.push(atRuleNode.allExtends);
        };
        ExtendFinderVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
            this.allExtendsStack.length = this.allExtendsStack.length - 1;
        };
        return ExtendFinderVisitor;
    }());
    var ProcessExtendsVisitor = /** @class */ (function () {
        function ProcessExtendsVisitor() {
            this._visitor = new Visitor(this);
        }
        ProcessExtendsVisitor.prototype.run = function (root) {
            var extendFinder = new ExtendFinderVisitor();
            this.extendIndices = {};
            extendFinder.run(root);
            if (!extendFinder.foundExtends) {
                return root;
            }
            root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));
            this.allExtendsStack = [root.allExtends];
            var newRoot = this._visitor.visit(root);
            this.checkExtendsForNonMatched(root.allExtends);
            return newRoot;
        };
        ProcessExtendsVisitor.prototype.checkExtendsForNonMatched = function (extendList) {
            var indices = this.extendIndices;
            extendList.filter(function (extend) {
                return !extend.hasFoundMatches && extend.parent_ids.length == 1;
            }).forEach(function (extend) {
                var selector = '_unknown_';
                try {
                    selector = extend.selector.toCSS({});
                }
                catch (_) { }
                if (!indices[extend.index + " " + selector]) {
                    indices[extend.index + " " + selector] = true;
                    logger.warn("extend '" + selector + "' has no matches");
                }
            });
        };
        ProcessExtendsVisitor.prototype.doExtendChaining = function (extendsList, extendsListTarget, iterationCount) {
            //
            // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering
            // and pasting the selector we would do normally, but we are also adding an extend with the same target selector
            // this means this new extend can then go and alter other extends
            //
            // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors
            // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already
            // processed if we look at each selector at a time, as is done in visitRuleset
            var extendIndex;
            var targetExtendIndex;
            var matches;
            var extendsToAdd = [];
            var newSelector;
            var extendVisitor = this;
            var selectorPath;
            var extend;
            var targetExtend;
            var newExtend;
            iterationCount = iterationCount || 0;
            // loop through comparing every extend with every target extend.
            // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place
            // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one
            // and the second is the target.
            // the separation into two lists allows us to process a subset of chains with a bigger set, as is the
            // case when processing media queries
            for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
                for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {
                    extend = extendsList[extendIndex];
                    targetExtend = extendsListTarget[targetExtendIndex];
                    // look for circular references
                    if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {
                        continue;
                    }
                    // find a match in the target extends self selector (the bit before :extend)
                    selectorPath = [targetExtend.selfSelectors[0]];
                    matches = extendVisitor.findMatch(extend, selectorPath);
                    if (matches.length) {
                        extend.hasFoundMatches = true;
                        // we found a match, so for each self selector..
                        extend.selfSelectors.forEach(function (selfSelector) {
                            var info = targetExtend.visibilityInfo();
                            // process the extend as usual
                            newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());
                            // but now we create a new extend from it
                            newExtend = new (tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);
                            newExtend.selfSelectors = newSelector;
                            // add the extend onto the list of extends for that selector
                            newSelector[newSelector.length - 1].extendList = [newExtend];
                            // record that we need to add it.
                            extendsToAdd.push(newExtend);
                            newExtend.ruleset = targetExtend.ruleset;
                            // remember its parents for circular references
                            newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);
                            // only process the selector once.. if we have :extend(.a,.b) then multiple
                            // extends will look at the same selector path, so when extending
                            // we know that any others will be duplicates in terms of what is added to the css
                            if (targetExtend.firstExtendOnThisSelectorPath) {
                                newExtend.firstExtendOnThisSelectorPath = true;
                                targetExtend.ruleset.paths.push(newSelector);
                            }
                        });
                    }
                }
            }
            if (extendsToAdd.length) {
                // try to detect circular references to stop a stack overflow.
                // may no longer be needed.
                this.extendChainCount++;
                if (iterationCount > 100) {
                    var selectorOne = '{unable to calculate}';
                    var selectorTwo = '{unable to calculate}';
                    try {
                        selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
                        selectorTwo = extendsToAdd[0].selector.toCSS();
                    }
                    catch (e) { }
                    throw { message: "extend circular reference detected. One of the circular extends is currently:" + selectorOne + ":extend(" + selectorTwo + ")" };
                }
                // now process the new extends on the existing rules so that we can handle a extending b extending c extending
                // d extending e...
                return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
            }
            else {
                return extendsToAdd;
            }
        };
        ProcessExtendsVisitor.prototype.visitDeclaration = function (ruleNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ProcessExtendsVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ProcessExtendsVisitor.prototype.visitSelector = function (selectorNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        ProcessExtendsVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
            if (rulesetNode.root) {
                return;
            }
            var matches;
            var pathIndex;
            var extendIndex;
            var allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];
            var selectorsToAdd = [];
            var extendVisitor = this;
            var selectorPath;
            // look at each selector path in the ruleset, find any extend matches and then copy, find and replace
            for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
                for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
                    selectorPath = rulesetNode.paths[pathIndex];
                    // extending extends happens initially, before the main pass
                    if (rulesetNode.extendOnEveryPath) {
                        continue;
                    }
                    var extendList = selectorPath[selectorPath.length - 1].extendList;
                    if (extendList && extendList.length) {
                        continue;
                    }
                    matches = this.findMatch(allExtends[extendIndex], selectorPath);
                    if (matches.length) {
                        allExtends[extendIndex].hasFoundMatches = true;
                        allExtends[extendIndex].selfSelectors.forEach(function (selfSelector) {
                            var extendedSelectors;
                            extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
                            selectorsToAdd.push(extendedSelectors);
                        });
                    }
                }
            }
            rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
        };
        ProcessExtendsVisitor.prototype.findMatch = function (extend, haystackSelectorPath) {
            //
            // look through the haystack selector path to try and find the needle - extend.selector
            // returns an array of selector matches that can then be replaced
            //
            var haystackSelectorIndex;
            var hackstackSelector;
            var hackstackElementIndex;
            var haystackElement;
            var targetCombinator;
            var i;
            var extendVisitor = this;
            var needleElements = extend.selector.elements;
            var potentialMatches = [];
            var potentialMatch;
            var matches = [];
            // loop through the haystack elements
            for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
                hackstackSelector = haystackSelectorPath[haystackSelectorIndex];
                for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {
                    haystackElement = hackstackSelector.elements[hackstackElementIndex];
                    // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.
                    if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {
                        potentialMatches.push({ pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,
                            initialCombinator: haystackElement.combinator });
                    }
                    for (i = 0; i < potentialMatches.length; i++) {
                        potentialMatch = potentialMatches[i];
                        // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don't
                        // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to
                        // work out what the resulting combinator will be
                        targetCombinator = haystackElement.combinator.value;
                        if (targetCombinator === '' && hackstackElementIndex === 0) {
                            targetCombinator = ' ';
                        }
                        // if we don't match, null our match to indicate failure
                        if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||
                            (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {
                            potentialMatch = null;
                        }
                        else {
                            potentialMatch.matched++;
                        }
                        // if we are still valid and have finished, test whether we have elements after and whether these are allowed
                        if (potentialMatch) {
                            potentialMatch.finished = potentialMatch.matched === needleElements.length;
                            if (potentialMatch.finished &&
                                (!extend.allowAfter &&
                                    (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {
                                potentialMatch = null;
                            }
                        }
                        // if null we remove, if not, we are still valid, so either push as a valid match or continue
                        if (potentialMatch) {
                            if (potentialMatch.finished) {
                                potentialMatch.length = needleElements.length;
                                potentialMatch.endPathIndex = haystackSelectorIndex;
                                potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match
                                potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again
                                matches.push(potentialMatch);
                            }
                        }
                        else {
                            potentialMatches.splice(i, 1);
                            i--;
                        }
                    }
                }
            }
            return matches;
        };
        ProcessExtendsVisitor.prototype.isElementValuesEqual = function (elementValue1, elementValue2) {
            if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {
                return elementValue1 === elementValue2;
            }
            if (elementValue1 instanceof tree.Attribute) {
                if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
                    return false;
                }
                if (!elementValue1.value || !elementValue2.value) {
                    if (elementValue1.value || elementValue2.value) {
                        return false;
                    }
                    return true;
                }
                elementValue1 = elementValue1.value.value || elementValue1.value;
                elementValue2 = elementValue2.value.value || elementValue2.value;
                return elementValue1 === elementValue2;
            }
            elementValue1 = elementValue1.value;
            elementValue2 = elementValue2.value;
            if (elementValue1 instanceof tree.Selector) {
                if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
                    return false;
                }
                for (var i = 0; i < elementValue1.elements.length; i++) {
                    if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {
                        if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {
                            return false;
                        }
                    }
                    if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        ProcessExtendsVisitor.prototype.extendSelector = function (matches, selectorPath, replacementSelector, isVisible) {
            // for a set of matches, replace each match with the replacement selector
            var currentSelectorPathIndex = 0, currentSelectorPathElementIndex = 0, path = [], matchIndex, selector, firstElement, match, newElements;
            for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
                match = matches[matchIndex];
                selector = selectorPath[match.pathIndex];
                firstElement = new tree.Element(match.initialCombinator, replacementSelector.elements[0].value, replacementSelector.elements[0].isVariable, replacementSelector.elements[0].getIndex(), replacementSelector.elements[0].fileInfo());
                if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
                    path[path.length - 1].elements = path[path.length - 1]
                        .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
                    currentSelectorPathElementIndex = 0;
                    currentSelectorPathIndex++;
                }
                newElements = selector.elements
                    .slice(currentSelectorPathElementIndex, match.index)
                    .concat([firstElement])
                    .concat(replacementSelector.elements.slice(1));
                if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
                    path[path.length - 1].elements =
                        path[path.length - 1].elements.concat(newElements);
                }
                else {
                    path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));
                    path.push(new tree.Selector(newElements));
                }
                currentSelectorPathIndex = match.endPathIndex;
                currentSelectorPathElementIndex = match.endPathElementIndex;
                if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
                    currentSelectorPathElementIndex = 0;
                    currentSelectorPathIndex++;
                }
            }
            if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
                path[path.length - 1].elements = path[path.length - 1]
                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
                currentSelectorPathIndex++;
            }
            path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
            path = path.map(function (currentValue) {
                // we can re-use elements here, because the visibility property matters only for selectors
                var derived = currentValue.createDerived(currentValue.elements);
                if (isVisible) {
                    derived.ensureVisibility();
                }
                else {
                    derived.ensureInvisibility();
                }
                return derived;
            });
            return path;
        };
        ProcessExtendsVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
            var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
            newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
            this.allExtendsStack.push(newAllExtends);
        };
        ProcessExtendsVisitor.prototype.visitMediaOut = function (mediaNode) {
            var lastIndex = this.allExtendsStack.length - 1;
            this.allExtendsStack.length = lastIndex;
        };
        ProcessExtendsVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
            var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
            newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));
            this.allExtendsStack.push(newAllExtends);
        };
        ProcessExtendsVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
            var lastIndex = this.allExtendsStack.length - 1;
            this.allExtendsStack.length = lastIndex;
        };
        return ProcessExtendsVisitor;
    }());

    var JoinSelectorVisitor = /** @class */ (function () {
        function JoinSelectorVisitor() {
            this.contexts = [[]];
            this._visitor = new Visitor(this);
        }
        JoinSelectorVisitor.prototype.run = function (root) {
            return this._visitor.visit(root);
        };
        JoinSelectorVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        JoinSelectorVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
            visitArgs.visitDeeper = false;
        };
        JoinSelectorVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
            var context = this.contexts[this.contexts.length - 1];
            var paths = [];
            var selectors;
            this.contexts.push(paths);
            if (!rulesetNode.root) {
                selectors = rulesetNode.selectors;
                if (selectors) {
                    selectors = selectors.filter(function (selector) { return selector.getIsOutput(); });
                    rulesetNode.selectors = selectors.length ? selectors : (selectors = null);
                    if (selectors) {
                        rulesetNode.joinSelectors(paths, context, selectors);
                    }
                }
                if (!selectors) {
                    rulesetNode.rules = null;
                }
                rulesetNode.paths = paths;
            }
        };
        JoinSelectorVisitor.prototype.visitRulesetOut = function (rulesetNode) {
            this.contexts.length = this.contexts.length - 1;
        };
        JoinSelectorVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
            var context = this.contexts[this.contexts.length - 1];
            mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);
        };
        JoinSelectorVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
            var context = this.contexts[this.contexts.length - 1];
            if (atRuleNode.rules && atRuleNode.rules.length) {
                atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);
            }
        };
        return JoinSelectorVisitor;
    }());

    var CSSVisitorUtils = /** @class */ (function () {
        function CSSVisitorUtils(context) {
            this._visitor = new Visitor(this);
            this._context = context;
        }
        CSSVisitorUtils.prototype.containsSilentNonBlockedChild = function (bodyRules) {
            var rule;
            if (!bodyRules) {
                return false;
            }
            for (var r = 0; r < bodyRules.length; r++) {
                rule = bodyRules[r];
                if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
                    // the atrule contains something that was referenced (likely by extend)
                    // therefore it needs to be shown in output too
                    return true;
                }
            }
            return false;
        };
        CSSVisitorUtils.prototype.keepOnlyVisibleChilds = function (owner) {
            if (owner && owner.rules) {
                owner.rules = owner.rules.filter(function (thing) { return thing.isVisible(); });
            }
        };
        CSSVisitorUtils.prototype.isEmpty = function (owner) {
            return (owner && owner.rules)
                ? (owner.rules.length === 0) : true;
        };
        CSSVisitorUtils.prototype.hasVisibleSelector = function (rulesetNode) {
            return (rulesetNode && rulesetNode.paths)
                ? (rulesetNode.paths.length > 0) : false;
        };
        CSSVisitorUtils.prototype.resolveVisibility = function (node, originalRules) {
            if (!node.blocksVisibility()) {
                if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {
                    return;
                }
                return node;
            }
            var compiledRulesBody = node.rules[0];
            this.keepOnlyVisibleChilds(compiledRulesBody);
            if (this.isEmpty(compiledRulesBody)) {
                return;
            }
            node.ensureVisibility();
            node.removeVisibilityBlock();
            return node;
        };
        CSSVisitorUtils.prototype.isVisibleRuleset = function (rulesetNode) {
            if (rulesetNode.firstRoot) {
                return true;
            }
            if (this.isEmpty(rulesetNode)) {
                return false;
            }
            if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
                return false;
            }
            return true;
        };
        return CSSVisitorUtils;
    }());
    var ToCSSVisitor = function (context) {
        this._visitor = new Visitor(this);
        this._context = context;
        this.utils = new CSSVisitorUtils(context);
    };
    ToCSSVisitor.prototype = {
        isReplacing: true,
        run: function (root) {
            return this._visitor.visit(root);
        },
        visitDeclaration: function (declNode, visitArgs) {
            if (declNode.blocksVisibility() || declNode.variable) {
                return;
            }
            return declNode;
        },
        visitMixinDefinition: function (mixinNode, visitArgs) {
            // mixin definitions do not get eval'd - this means they keep state
            // so we have to clear that state here so it isn't used if toCSS is called twice
            mixinNode.frames = [];
        },
        visitExtend: function (extendNode, visitArgs) {
        },
        visitComment: function (commentNode, visitArgs) {
            if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
                return;
            }
            return commentNode;
        },
        visitMedia: function (mediaNode, visitArgs) {
            var originalRules = mediaNode.rules[0].rules;
            mediaNode.accept(this._visitor);
            visitArgs.visitDeeper = false;
            return this.utils.resolveVisibility(mediaNode, originalRules);
        },
        visitImport: function (importNode, visitArgs) {
            if (importNode.blocksVisibility()) {
                return;
            }
            return importNode;
        },
        visitAtRule: function (atRuleNode, visitArgs) {
            if (atRuleNode.rules && atRuleNode.rules.length) {
                return this.visitAtRuleWithBody(atRuleNode, visitArgs);
            }
            else {
                return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);
            }
        },
        visitAnonymous: function (anonymousNode, visitArgs) {
            if (!anonymousNode.blocksVisibility()) {
                anonymousNode.accept(this._visitor);
                return anonymousNode;
            }
        },
        visitAtRuleWithBody: function (atRuleNode, visitArgs) {
            // if there is only one nested ruleset and that one has no path, then it is
            // just fake ruleset
            function hasFakeRuleset(atRuleNode) {
                var bodyRules = atRuleNode.rules;
                return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
            }
            function getBodyRules(atRuleNode) {
                var nodeRules = atRuleNode.rules;
                if (hasFakeRuleset(atRuleNode)) {
                    return nodeRules[0].rules;
                }
                return nodeRules;
            }
            // it is still true that it is only one ruleset in array
            // this is last such moment
            // process childs
            var originalRules = getBodyRules(atRuleNode);
            atRuleNode.accept(this._visitor);
            visitArgs.visitDeeper = false;
            if (!this.utils.isEmpty(atRuleNode)) {
                this._mergeRules(atRuleNode.rules[0].rules);
            }
            return this.utils.resolveVisibility(atRuleNode, originalRules);
        },
        visitAtRuleWithoutBody: function (atRuleNode, visitArgs) {
            if (atRuleNode.blocksVisibility()) {
                return;
            }
            if (atRuleNode.name === '@charset') {
                // Only output the debug info together with subsequent @charset definitions
                // a comment (or @media statement) before the actual @charset atrule would
                // be considered illegal css as it has to be on the first line
                if (this.charset) {
                    if (atRuleNode.debugInfo) {
                        var comment = new tree.Comment("/* " + atRuleNode.toCSS(this._context).replace(/\n/g, '') + " */\n");
                        comment.debugInfo = atRuleNode.debugInfo;
                        return this._visitor.visit(comment);
                    }
                    return;
                }
                this.charset = true;
            }
            return atRuleNode;
        },
        checkValidNodes: function (rules, isRoot) {
            if (!rules) {
                return;
            }
            for (var i = 0; i < rules.length; i++) {
                var ruleNode = rules[i];
                if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {
                    throw { message: 'Properties must be inside selector blocks. They cannot be in the root',
                        index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
                }
                if (ruleNode instanceof tree.Call) {
                    throw { message: "Function '" + ruleNode.name + "' did not return a root node", index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
                }
                if (ruleNode.type && !ruleNode.allowRoot) {
                    throw { message: ruleNode.type + " node returned by a function is not valid here", index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
                }
            }
        },
        visitRuleset: function (rulesetNode, visitArgs) {
            // at this point rulesets are nested into each other
            var rule;
            var rulesets = [];
            this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);
            if (!rulesetNode.root) {
                // remove invisible paths
                this._compileRulesetPaths(rulesetNode);
                // remove rulesets from this ruleset body and compile them separately
                var nodeRules = rulesetNode.rules;
                var nodeRuleCnt = nodeRules ? nodeRules.length : 0;
                for (var i = 0; i < nodeRuleCnt;) {
                    rule = nodeRules[i];
                    if (rule && rule.rules) {
                        // visit because we are moving them out from being a child
                        rulesets.push(this._visitor.visit(rule));
                        nodeRules.splice(i, 1);
                        nodeRuleCnt--;
                        continue;
                    }
                    i++;
                }
                // accept the visitor to remove rules and refactor itself
                // then we can decide nogw whether we want it or not
                // compile body
                if (nodeRuleCnt > 0) {
                    rulesetNode.accept(this._visitor);
                }
                else {
                    rulesetNode.rules = null;
                }
                visitArgs.visitDeeper = false;
            }
            else { // if (! rulesetNode.root) {
                rulesetNode.accept(this._visitor);
                visitArgs.visitDeeper = false;
            }
            if (rulesetNode.rules) {
                this._mergeRules(rulesetNode.rules);
                this._removeDuplicateRules(rulesetNode.rules);
            }
            // now decide whether we keep the ruleset
            if (this.utils.isVisibleRuleset(rulesetNode)) {
                rulesetNode.ensureVisibility();
                rulesets.splice(0, 0, rulesetNode);
            }
            if (rulesets.length === 1) {
                return rulesets[0];
            }
            return rulesets;
        },
        _compileRulesetPaths: function (rulesetNode) {
            if (rulesetNode.paths) {
                rulesetNode.paths = rulesetNode.paths
                    .filter(function (p) {
                    var i;
                    if (p[0].elements[0].combinator.value === ' ') {
                        p[0].elements[0].combinator = new (tree.Combinator)('');
                    }
                    for (i = 0; i < p.length; i++) {
                        if (p[i].isVisible() && p[i].getIsOutput()) {
                            return true;
                        }
                    }
                    return false;
                });
            }
        },
        _removeDuplicateRules: function (rules) {
            if (!rules) {
                return;
            }
            // remove duplicates
            var ruleCache = {};
            var ruleList;
            var rule;
            var i;
            for (i = rules.length - 1; i >= 0; i--) {
                rule = rules[i];
                if (rule instanceof tree.Declaration) {
                    if (!ruleCache[rule.name]) {
                        ruleCache[rule.name] = rule;
                    }
                    else {
                        ruleList = ruleCache[rule.name];
                        if (ruleList instanceof tree.Declaration) {
                            ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
                        }
                        var ruleCSS = rule.toCSS(this._context);
                        if (ruleList.indexOf(ruleCSS) !== -1) {
                            rules.splice(i, 1);
                        }
                        else {
                            ruleList.push(ruleCSS);
                        }
                    }
                }
            }
        },
        _mergeRules: function (rules) {
            if (!rules) {
                return;
            }
            var groups = {};
            var groupsArr = [];
            for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (rule.merge) {
                    var key = rule.name;
                    groups[key] ? rules.splice(i--, 1) :
                        groupsArr.push(groups[key] = []);
                    groups[key].push(rule);
                }
            }
            groupsArr.forEach(function (group) {
                if (group.length > 0) {
                    var result_1 = group[0];
                    var space_1 = [];
                    var comma_1 = [new tree.Expression(space_1)];
                    group.forEach(function (rule) {
                        if ((rule.merge === '+') && (space_1.length > 0)) {
                            comma_1.push(new tree.Expression(space_1 = []));
                        }
                        space_1.push(rule.value);
                        result_1.important = result_1.important || rule.important;
                    });
                    result_1.value = new tree.Value(comma_1);
                }
            });
        }
    };

    var visitors = {
        Visitor: Visitor,
        ImportVisitor: ImportVisitor,
        MarkVisibleSelectorsVisitor: SetTreeVisibilityVisitor,
        ExtendVisitor: ProcessExtendsVisitor,
        JoinSelectorVisitor: JoinSelectorVisitor,
        ToCSSVisitor: ToCSSVisitor
    };

    // Split the input into chunks.
    function chunker (input, fail) {
        var len = input.length;
        var level = 0;
        var parenLevel = 0;
        var lastOpening;
        var lastOpeningParen;
        var lastMultiComment;
        var lastMultiCommentEndBrace;
        var chunks = [];
        var emitFrom = 0;
        var chunkerCurrentIndex;
        var currentChunkStartIndex;
        var cc;
        var cc2;
        var matched;
        function emitChunk(force) {
            var len = chunkerCurrentIndex - emitFrom;
            if (((len < 512) && !force) || !len) {
                return;
            }
            chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
            emitFrom = chunkerCurrentIndex + 1;
        }
        for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
            cc = input.charCodeAt(chunkerCurrentIndex);
            if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {
                // a-z or whitespace
                continue;
            }
            switch (cc) {
                case 40: // (
                    parenLevel++;
                    lastOpeningParen = chunkerCurrentIndex;
                    continue;
                case 41: // )
                    if (--parenLevel < 0) {
                        return fail('missing opening `(`', chunkerCurrentIndex);
                    }
                    continue;
                case 59: // ;
                    if (!parenLevel) {
                        emitChunk();
                    }
                    continue;
                case 123: // {
                    level++;
                    lastOpening = chunkerCurrentIndex;
                    continue;
                case 125: // }
                    if (--level < 0) {
                        return fail('missing opening `{`', chunkerCurrentIndex);
                    }
                    if (!level && !parenLevel) {
                        emitChunk();
                    }
                    continue;
                case 92: // \
                    if (chunkerCurrentIndex < len - 1) {
                        chunkerCurrentIndex++;
                        continue;
                    }
                    return fail('unescaped `\\`', chunkerCurrentIndex);
                case 34:
                case 39:
                case 96: // ", ' and `
                    matched = 0;
                    currentChunkStartIndex = chunkerCurrentIndex;
                    for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                        cc2 = input.charCodeAt(chunkerCurrentIndex);
                        if (cc2 > 96) {
                            continue;
                        }
                        if (cc2 == cc) {
                            matched = 1;
                            break;
                        }
                        if (cc2 == 92) { // \
                            if (chunkerCurrentIndex == len - 1) {
                                return fail('unescaped `\\`', chunkerCurrentIndex);
                            }
                            chunkerCurrentIndex++;
                        }
                    }
                    if (matched) {
                        continue;
                    }
                    return fail("unmatched `" + String.fromCharCode(cc) + "`", currentChunkStartIndex);
                case 47: // /, check for comment
                    if (parenLevel || (chunkerCurrentIndex == len - 1)) {
                        continue;
                    }
                    cc2 = input.charCodeAt(chunkerCurrentIndex + 1);
                    if (cc2 == 47) {
                        // //, find lnfeed
                        for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                            cc2 = input.charCodeAt(chunkerCurrentIndex);
                            if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) {
                                break;
                            }
                        }
                    }
                    else if (cc2 == 42) {
                        // /*, find */
                        lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
                        for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
                            cc2 = input.charCodeAt(chunkerCurrentIndex);
                            if (cc2 == 125) {
                                lastMultiCommentEndBrace = chunkerCurrentIndex;
                            }
                            if (cc2 != 42) {
                                continue;
                            }
                            if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
                                break;
                            }
                        }
                        if (chunkerCurrentIndex == len - 1) {
                            return fail('missing closing `*/`', currentChunkStartIndex);
                        }
                        chunkerCurrentIndex++;
                    }
                    continue;
                case 42: // *, check for unmatched */
                    if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {
                        return fail('unmatched `/*`', chunkerCurrentIndex);
                    }
                    continue;
            }
        }
        if (level !== 0) {
            if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {
                return fail('missing closing `}` or `*/`', lastOpening);
            }
            else {
                return fail('missing closing `}`', lastOpening);
            }
        }
        else if (parenLevel !== 0) {
            return fail('missing closing `)`', lastOpeningParen);
        }
        emitChunk(true);
        return chunks;
    }

    var getParserInput = (function () {
        var // Less input string
        input;
        var // current chunk
        j;
        var // holds state for backtracking
        saveStack = [];
        var // furthest index the parser has gone to
        furthest;
        var // if this is furthest we got to, this is the probably cause
        furthestPossibleErrorMessage;
        var // chunkified input
        chunks;
        var // current chunk
        current;
        var // index of current chunk, in `input`
        currentPos;
        var parserInput = {};
        var CHARCODE_SPACE = 32;
        var CHARCODE_TAB = 9;
        var CHARCODE_LF = 10;
        var CHARCODE_CR = 13;
        var CHARCODE_PLUS = 43;
        var CHARCODE_COMMA = 44;
        var CHARCODE_FORWARD_SLASH = 47;
        var CHARCODE_9 = 57;
        function skipWhitespace(length) {
            var oldi = parserInput.i;
            var oldj = j;
            var curr = parserInput.i - currentPos;
            var endIndex = parserInput.i + current.length - curr;
            var mem = (parserInput.i += length);
            var inp = input;
            var c;
            var nextChar;
            var comment;
            for (; parserInput.i < endIndex; parserInput.i++) {
                c = inp.charCodeAt(parserInput.i);
                if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {
                    nextChar = inp.charAt(parserInput.i + 1);
                    if (nextChar === '/') {
                        comment = { index: parserInput.i, isLineComment: true };
                        var nextNewLine = inp.indexOf('\n', parserInput.i + 2);
                        if (nextNewLine < 0) {
                            nextNewLine = endIndex;
                        }
                        parserInput.i = nextNewLine;
                        comment.text = inp.substr(comment.index, parserInput.i - comment.index);
                        parserInput.commentStore.push(comment);
                        continue;
                    }
                    else if (nextChar === '*') {
                        var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);
                        if (nextStarSlash >= 0) {
                            comment = {
                                index: parserInput.i,
                                text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
                                isLineComment: false
                            };
                            parserInput.i += comment.text.length - 1;
                            parserInput.commentStore.push(comment);
                            continue;
                        }
                    }
                    break;
                }
                if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {
                    break;
                }
            }
            current = current.slice(length + parserInput.i - mem + curr);
            currentPos = parserInput.i;
            if (!current.length) {
                if (j < chunks.length - 1) {
                    current = chunks[++j];
                    skipWhitespace(0); // skip space at the beginning of a chunk
                    return true; // things changed
                }
                parserInput.finished = true;
            }
            return oldi !== parserInput.i || oldj !== j;
        }
        parserInput.save = function () {
            currentPos = parserInput.i;
            saveStack.push({ current: current, i: parserInput.i, j: j });
        };
        parserInput.restore = function (possibleErrorMessage) {
            if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {
                furthest = parserInput.i;
                furthestPossibleErrorMessage = possibleErrorMessage;
            }
            var state = saveStack.pop();
            current = state.current;
            currentPos = parserInput.i = state.i;
            j = state.j;
        };
        parserInput.forget = function () {
            saveStack.pop();
        };
        parserInput.isWhitespace = function (offset) {
            var pos = parserInput.i + (offset || 0);
            var code = input.charCodeAt(pos);
            return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);
        };
        // Specialization of $(tok)
        parserInput.$re = function (tok) {
            if (parserInput.i > currentPos) {
                current = current.slice(parserInput.i - currentPos);
                currentPos = parserInput.i;
            }
            var m = tok.exec(current);
            if (!m) {
                return null;
            }
            skipWhitespace(m[0].length);
            if (typeof m === 'string') {
                return m;
            }
            return m.length === 1 ? m[0] : m;
        };
        parserInput.$char = function (tok) {
            if (input.charAt(parserInput.i) !== tok) {
                return null;
            }
            skipWhitespace(1);
            return tok;
        };
        parserInput.$str = function (tok) {
            var tokLength = tok.length;
            // https://jsperf.com/string-startswith/21
            for (var i = 0; i < tokLength; i++) {
                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
                    return null;
                }
            }
            skipWhitespace(tokLength);
            return tok;
        };
        parserInput.$quoted = function (loc) {
            var pos = loc || parserInput.i;
            var startChar = input.charAt(pos);
            if (startChar !== '\'' && startChar !== '"') {
                return;
            }
            var length = input.length;
            var currentPosition = pos;
            for (var i = 1; i + currentPosition < length; i++) {
                var nextChar = input.charAt(i + currentPosition);
                switch (nextChar) {
                    case '\\':
                        i++;
                        continue;
                    case '\r':
                    case '\n':
                        break;
                    case startChar:
                        var str = input.substr(currentPosition, i + 1);
                        if (!loc && loc !== 0) {
                            skipWhitespace(i + 1);
                            return str;
                        }
                        return [startChar, str];
                }
            }
            return null;
        };
        /**
         * Permissive parsing. Ignores everything except matching {} [] () and quotes
         * until matching token (outside of blocks)
         */
        parserInput.$parseUntil = function (tok) {
            var quote = '';
            var returnVal = null;
            var inComment = false;
            var blockDepth = 0;
            var blockStack = [];
            var parseGroups = [];
            var length = input.length;
            var startPos = parserInput.i;
            var lastPos = parserInput.i;
            var i = parserInput.i;
            var loop = true;
            var testChar;
            if (typeof tok === 'string') {
                testChar = function (char) { return char === tok; };
            }
            else {
                testChar = function (char) { return tok.test(char); };
            }
            do {
                var nextChar = input.charAt(i);
                if (blockDepth === 0 && testChar(nextChar)) {
                    returnVal = input.substr(lastPos, i - lastPos);
                    if (returnVal) {
                        parseGroups.push(returnVal);
                    }
                    else {
                        parseGroups.push(' ');
                    }
                    returnVal = parseGroups;
                    skipWhitespace(i - startPos);
                    loop = false;
                }
                else {
                    if (inComment) {
                        if (nextChar === '*' &&
                            input.charAt(i + 1) === '/') {
                            i++;
                            blockDepth--;
                            inComment = false;
                        }
                        i++;
                        continue;
                    }
                    switch (nextChar) {
                        case '\\':
                            i++;
                            nextChar = input.charAt(i);
                            parseGroups.push(input.substr(lastPos, i - lastPos + 1));
                            lastPos = i + 1;
                            break;
                        case '/':
                            if (input.charAt(i + 1) === '*') {
                                i++;
                                inComment = true;
                                blockDepth++;
                            }
                            break;
                        case '\'':
                        case '"':
                            quote = parserInput.$quoted(i);
                            if (quote) {
                                parseGroups.push(input.substr(lastPos, i - lastPos), quote);
                                i += quote[1].length - 1;
                                lastPos = i + 1;
                            }
                            else {
                                skipWhitespace(i - startPos);
                                returnVal = nextChar;
                                loop = false;
                            }
                            break;
                        case '{':
                            blockStack.push('}');
                            blockDepth++;
                            break;
                        case '(':
                            blockStack.push(')');
                            blockDepth++;
                            break;
                        case '[':
                            blockStack.push(']');
                            blockDepth++;
                            break;
                        case '}':
                        case ')':
                        case ']':
                            var expected = blockStack.pop();
                            if (nextChar === expected) {
                                blockDepth--;
                            }
                            else {
                                // move the parser to the error and return expected
                                skipWhitespace(i - startPos);
                                returnVal = expected;
                                loop = false;
                            }
                    }
                    i++;
                    if (i > length) {
                        loop = false;
                    }
                }
            } while (loop);
            return returnVal ? returnVal : null;
        };
        parserInput.autoCommentAbsorb = true;
        parserInput.commentStore = [];
        parserInput.finished = false;
        // Same as $(), but don't change the state of the parser,
        // just return the match.
        parserInput.peek = function (tok) {
            if (typeof tok === 'string') {
                // https://jsperf.com/string-startswith/21
                for (var i = 0; i < tok.length; i++) {
                    if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
                        return false;
                    }
                }
                return true;
            }
            else {
                return tok.test(current);
            }
        };
        // Specialization of peek()
        // TODO remove or change some currentChar calls to peekChar
        parserInput.peekChar = function (tok) { return input.charAt(parserInput.i) === tok; };
        parserInput.currentChar = function () { return input.charAt(parserInput.i); };
        parserInput.prevChar = function () { return input.charAt(parserInput.i - 1); };
        parserInput.getInput = function () { return input; };
        parserInput.peekNotNumeric = function () {
            var c = input.charCodeAt(parserInput.i);
            // Is the first char of the dimension 0-9, '.', '+' or '-'
            return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;
        };
        parserInput.start = function (str, chunkInput, failFunction) {
            input = str;
            parserInput.i = j = currentPos = furthest = 0;
            // chunking apparently makes things quicker (but my tests indicate
            // it might actually make things slower in node at least)
            // and it is a non-perfect parse - it can't recognise
            // unquoted urls, meaning it can't distinguish comments
            // meaning comments with quotes or {}() in them get 'counted'
            // and then lead to parse errors.
            // In addition if the chunking chunks in the wrong place we might
            // not be able to parse a parser statement in one go
            // this is officially deprecated but can be switched on via an option
            // in the case it causes too much performance issues.
            if (chunkInput) {
                chunks = chunker(str, failFunction);
            }
            else {
                chunks = [str];
            }
            current = chunks[0];
            skipWhitespace(0);
        };
        parserInput.end = function () {
            var message;
            var isFinished = parserInput.i >= input.length;
            if (parserInput.i < furthest) {
                message = furthestPossibleErrorMessage;
                parserInput.i = furthest;
            }
            return {
                isFinished: isFinished,
                furthest: parserInput.i,
                furthestPossibleErrorMessage: message,
                furthestReachedEnd: parserInput.i >= input.length - 1,
                furthestChar: input[parserInput.i]
            };
        };
        return parserInput;
    });

    //
    // less.js - parser
    //
    //    A relatively straight-forward predictive parser.
    //    There is no tokenization/lexing stage, the input is parsed
    //    in one sweep.
    //
    //    To make the parser fast enough to run in the browser, several
    //    optimization had to be made:
    //
    //    - Matching and slicing on a huge input is often cause of slowdowns.
    //      The solution is to chunkify the input into smaller strings.
    //      The chunks are stored in the `chunks` var,
    //      `j` holds the current chunk index, and `currentPos` holds
    //      the index of the current chunk in relation to `input`.
    //      This gives us an almost 4x speed-up.
    //
    //    - In many cases, we don't need to match individual tokens;
    //      for example, if a value doesn't hold any variables, operations
    //      or dynamic references, the parser can effectively 'skip' it,
    //      treating it as a literal.
    //      An example would be '1px solid #000' - which evaluates to itself,
    //      we don't need to know what the individual components are.
    //      The drawback, of course is that you don't get the benefits of
    //      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
    //      and a smaller speed-up in the code-gen.
    //
    //
    //    Token matching is done with the `$` function, which either takes
    //    a terminal string or regexp, or a non-terminal function to call.
    //    It also takes care of moving all the indices forwards.
    //
    var Parser = function Parser(context, imports, fileInfo) {
        var parsers;
        var parserInput = getParserInput();
        function error(msg, type) {
            throw new LessError({
                index: parserInput.i,
                filename: fileInfo.filename,
                type: type || 'Syntax',
                message: msg
            }, imports);
        }
        function expect(arg, msg) {
            // some older browsers return typeof 'function' for RegExp
            var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);
            if (result) {
                return result;
            }
            error(msg || (typeof arg === 'string'
                ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'"
                : 'unexpected token'));
        }
        // Specialization of expect()
        function expectChar(arg, msg) {
            if (parserInput.$char(arg)) {
                return arg;
            }
            error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
        }
        function getDebugInfo(index) {
            var filename = fileInfo.filename;
            return {
                lineNumber: getLocation(index, parserInput.getInput()).line + 1,
                fileName: filename
            };
        }
        /**
         *  Used after initial parsing to create nodes on the fly
         *
         *  @param {String} str          - string to parse
         *  @param {Array}  parseList    - array of parsers to run input through e.g. ["value", "important"]
         *  @param {Number} currentIndex - start number to begin indexing
         *  @param {Object} fileInfo     - fileInfo to attach to created nodes
         */
        function parseNode(str, parseList, currentIndex, fileInfo, callback) {
            var result;
            var returnNodes = [];
            var parser = parserInput;
            try {
                parser.start(str, false, function fail(msg, index) {
                    callback({
                        message: msg,
                        index: index + currentIndex
                    });
                });
                for (var x = 0, p = void 0, i = void 0; (p = parseList[x]); x++) {
                    i = parser.i;
                    result = parsers[p]();
                    if (result) {
                        try {
                            result._index = i + currentIndex;
                            result._fileInfo = fileInfo;
                        }
                        catch (e) { }
                        returnNodes.push(result);
                    }
                    else {
                        returnNodes.push(null);
                    }
                }
                var endInfo = parser.end();
                if (endInfo.isFinished) {
                    callback(null, returnNodes);
                }
                else {
                    callback(true, null);
                }
            }
            catch (e) {
                throw new LessError({
                    index: e.index + currentIndex,
                    message: e.message
                }, imports, fileInfo.filename);
            }
        }
        //
        // The Parser
        //
        return {
            parserInput: parserInput,
            imports: imports,
            fileInfo: fileInfo,
            parseNode: parseNode,
            //
            // Parse an input string into an abstract syntax tree,
            // @param str A string containing 'less' markup
            // @param callback call `callback` when done.
            // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
            //
            parse: function (str, callback, additionalData) {
                var root;
                var error = null;
                var globalVars;
                var modifyVars;
                var ignored;
                var preText = '';
                globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + "\n" : '';
                modifyVars = (additionalData && additionalData.modifyVars) ? "\n" + Parser.serializeVars(additionalData.modifyVars) : '';
                if (context.pluginManager) {
                    var preProcessors = context.pluginManager.getPreProcessors();
                    for (var i = 0; i < preProcessors.length; i++) {
                        str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });
                    }
                }
                if (globalVars || (additionalData && additionalData.banner)) {
                    preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;
                    ignored = imports.contentsIgnoredChars;
                    ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
                    ignored[fileInfo.filename] += preText.length;
                }
                str = str.replace(/\r\n?/g, '\n');
                // Remove potential UTF Byte Order Mark
                str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
                imports.contents[fileInfo.filename] = str;
                // Start with the primary rule.
                // The whole syntax tree is held under a Ruleset node,
                // with the `root` property set to true, so no `{}` are
                // output. The callback is called when the input is parsed.
                try {
                    parserInput.start(str, context.chunkInput, function fail(msg, index) {
                        throw new LessError({
                            index: index,
                            type: 'Parse',
                            message: msg,
                            filename: fileInfo.filename
                        }, imports);
                    });
                    tree.Node.prototype.parse = this;
                    root = new tree.Ruleset(null, this.parsers.primary());
                    tree.Node.prototype.rootNode = root;
                    root.root = true;
                    root.firstRoot = true;
                    root.functionRegistry = functionRegistry.inherit();
                }
                catch (e) {
                    return callback(new LessError(e, imports, fileInfo.filename));
                }
                // If `i` is smaller than the `input.length - 1`,
                // it means the parser wasn't able to parse the whole
                // string, so we've got a parsing error.
                //
                // We try to extract a \n delimited string,
                // showing the line where the parse error occurred.
                // We split it up into two parts (the part which parsed,
                // and the part which didn't), so we can color them differently.
                var endInfo = parserInput.end();
                if (!endInfo.isFinished) {
                    var message = endInfo.furthestPossibleErrorMessage;
                    if (!message) {
                        message = 'Unrecognised input';
                        if (endInfo.furthestChar === '}') {
                            message += '. Possibly missing opening \'{\'';
                        }
                        else if (endInfo.furthestChar === ')') {
                            message += '. Possibly missing opening \'(\'';
                        }
                        else if (endInfo.furthestReachedEnd) {
                            message += '. Possibly missing something';
                        }
                    }
                    error = new LessError({
                        type: 'Parse',
                        message: message,
                        index: endInfo.furthest,
                        filename: fileInfo.filename
                    }, imports);
                }
                var finish = function (e) {
                    e = error || e || imports.error;
                    if (e) {
                        if (!(e instanceof LessError)) {
                            e = new LessError(e, imports, fileInfo.filename);
                        }
                        return callback(e);
                    }
                    else {
                        return callback(null, root);
                    }
                };
                if (context.processImports !== false) {
                    new visitors.ImportVisitor(imports, finish)
                        .run(root);
                }
                else {
                    return finish();
                }
            },
            //
            // Here in, the parsing rules/functions
            //
            // The basic structure of the syntax tree generated is as follows:
            //
            //   Ruleset ->  Declaration -> Value -> Expression -> Entity
            //
            // Here's some Less code:
            //
            //    .class {
            //      color: #fff;
            //      border: 1px solid #000;
            //      width: @w + 4px;
            //      > .child {...}
            //    }
            //
            // And here's what the parse tree might look like:
            //
            //     Ruleset (Selector '.class', [
            //         Declaration ("color",  Value ([Expression [Color #fff]]))
            //         Declaration ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
            //         Declaration ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
            //         Ruleset (Selector [Element '>', '.child'], [...])
            //     ])
            //
            //  In general, most rules will try to parse a token with the `$re()` function, and if the return
            //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
            //  first, before parsing, that's when we use `peek()`.
            //
            parsers: parsers = {
                //
                // The `primary` rule is the *entry* and *exit* point of the parser.
                // The rules here can appear at any level of the parse tree.
                //
                // The recursive nature of the grammar is an interplay between the `block`
                // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
                // as represented by this simplified grammar:
                //
                //     primary  â  (ruleset | declaration)+
                //     ruleset  â  selector+ block
                //     block    â  '{' primary '}'
                //
                // Only at one point is the primary rule not called from the
                // block rule: at the root level.
                //
                primary: function () {
                    var mixin = this.mixin;
                    var root = [];
                    var node;
                    while (true) {
                        while (true) {
                            node = this.comment();
                            if (!node) {
                                break;
                            }
                            root.push(node);
                        }
                        // always process comments before deciding if finished
                        if (parserInput.finished) {
                            break;
                        }
                        if (parserInput.peek('}')) {
                            break;
                        }
                        node = this.extendRule();
                        if (node) {
                            root = root.concat(node);
                            continue;
                        }
                        node = mixin.definition() || this.declaration() || mixin.call(false, false) ||
                            this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();
                        if (node) {
                            root.push(node);
                        }
                        else {
                            var foundSemiColon = false;
                            while (parserInput.$char(';')) {
                                foundSemiColon = true;
                            }
                            if (!foundSemiColon) {
                                break;
                            }
                        }
                    }
                    return root;
                },
                // comments are collected by the main parsing mechanism and then assigned to nodes
                // where the current structure allows it
                comment: function () {
                    if (parserInput.commentStore.length) {
                        var comment = parserInput.commentStore.shift();
                        return new (tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);
                    }
                },
                //
                // Entities are tokens which can be found inside an Expression
                //
                entities: {
                    mixinLookup: function () {
                        return parsers.mixin.call(true, true);
                    },
                    //
                    // A string, which supports escaping " and '
                    //
                    //     "milky way" 'he\'s the one!'
                    //
                    quoted: function (forceEscaped) {
                        var str;
                        var index = parserInput.i;
                        var isEscaped = false;
                        parserInput.save();
                        if (parserInput.$char('~')) {
                            isEscaped = true;
                        }
                        else if (forceEscaped) {
                            parserInput.restore();
                            return;
                        }
                        str = parserInput.$quoted();
                        if (!str) {
                            parserInput.restore();
                            return;
                        }
                        parserInput.forget();
                        return new (tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);
                    },
                    //
                    // A catch-all word, such as:
                    //
                    //     black border-collapse
                    //
                    keyword: function () {
                        var k = parserInput.$char('%') || parserInput.$re(/^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]?/);
                        if (k) {
                            return tree.Color.fromKeyword(k) || new (tree.Keyword)(k);
                        }
                    },
                    //
                    // A function call
                    //
                    //     rgb(255, 0, 255)
                    //
                    // The arguments are parsed with the `entities.arguments` parser.
                    //
                    call: function () {
                        var name;
                        var args;
                        var func;
                        var index = parserInput.i;
                        // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                        if (parserInput.peek(/^url\(/i)) {
                            return;
                        }
                        parserInput.save();
                        name = parserInput.$re(/^([\w-]+|%|~|progid:[\w\.]+)\(/);
                        if (!name) {
                            parserInput.forget();
                            return;
                        }
                        name = name[1];
                        func = this.customFuncCall(name);
                        if (func) {
                            args = func.parse();
                            if (args && func.stop) {
                                parserInput.forget();
                                return args;
                            }
                        }
                        args = this.arguments(args);
                        if (!parserInput.$char(')')) {
                            parserInput.restore('Could not parse call arguments or missing \')\'');
                            return;
                        }
                        parserInput.forget();
                        return new (tree.Call)(name, args, index, fileInfo);
                    },
                    //
                    // Parsing rules for functions with non-standard args, e.g.:
                    //
                    //     boolean(not(2 > 1))
                    //
                    //     This is a quick prototype, to be modified/improved when
                    //     more custom-parsed funcs come (e.g. `selector(...)`)
                    //
                    customFuncCall: function (name) {
                        /* Ideally the table is to be moved out of here for faster perf.,
                           but it's quite tricky since it relies on all these `parsers`
                           and `expect` available only here */
                        return {
                            alpha: f(parsers.ieAlpha, true),
                            boolean: f(condition),
                            'if': f(condition)
                        }[name.toLowerCase()];
                        function f(parse, stop) {
                            return {
                                parse: parse,
                                stop: stop // when true - stop after parse() and return its result, 
                                // otherwise continue for plain args
                            };
                        }
                        function condition() {
                            return [expect(parsers.condition, 'expected condition')];
                        }
                    },
                    arguments: function (prevArgs) {
                        var argsComma = prevArgs || [];
                        var argsSemiColon = [];
                        var isSemiColonSeparated;
                        var value;
                        parserInput.save();
                        while (true) {
                            if (prevArgs) {
                                prevArgs = false;
                            }
                            else {
                                value = parsers.detachedRuleset() || this.assignment() || parsers.expression();
                                if (!value) {
                                    break;
                                }
                                if (value.value && value.value.length == 1) {
                                    value = value.value[0];
                                }
                                argsComma.push(value);
                            }
                            if (parserInput.$char(',')) {
                                continue;
                            }
                            if (parserInput.$char(';') || isSemiColonSeparated) {
                                isSemiColonSeparated = true;
                                value = (argsComma.length < 1) ? argsComma[0]
                                    : new tree.Value(argsComma);
                                argsSemiColon.push(value);
                                argsComma = [];
                            }
                        }
                        parserInput.forget();
                        return isSemiColonSeparated ? argsSemiColon : argsComma;
                    },
                    literal: function () {
                        return this.dimension() ||
                            this.color() ||
                            this.quoted() ||
                            this.unicodeDescriptor();
                    },
                    // Assignments are argument entities for calls.
                    // They are present in ie filter properties as shown below.
                    //
                    //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
                    //
                    assignment: function () {
                        var key;
                        var value;
                        parserInput.save();
                        key = parserInput.$re(/^\w+(?=\s?=)/i);
                        if (!key) {
                            parserInput.restore();
                            return;
                        }
                        if (!parserInput.$char('=')) {
                            parserInput.restore();
                            return;
                        }
                        value = parsers.entity();
                        if (value) {
                            parserInput.forget();
                            return new (tree.Assignment)(key, value);
                        }
                        else {
                            parserInput.restore();
                        }
                    },
                    //
                    // Parse url() tokens
                    //
                    // We use a specific rule for urls, because they don't really behave like
                    // standard function calls. The difference is that the argument doesn't have
                    // to be enclosed within a string, so it can't be parsed as an Expression.
                    //
                    url: function () {
                        var value;
                        var index = parserInput.i;
                        parserInput.autoCommentAbsorb = false;
                        if (!parserInput.$str('url(')) {
                            parserInput.autoCommentAbsorb = true;
                            return;
                        }
                        value = this.quoted() || this.variable() || this.property() ||
                            parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || '';
                        parserInput.autoCommentAbsorb = true;
                        expectChar(')');
                        return new (tree.URL)((value.value != null ||
                            value instanceof tree.Variable ||
                            value instanceof tree.Property) ?
                            value : new (tree.Anonymous)(value, index), index, fileInfo);
                    },
                    //
                    // A Variable entity, such as `@fink`, in
                    //
                    //     width: @fink + 2px
                    //
                    // We use a different parser for variable definitions,
                    // see `parsers.variable`.
                    //
                    variable: function () {
                        var ch;
                        var name;
                        var index = parserInput.i;
                        parserInput.save();
                        if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\w-]+/))) {
                            ch = parserInput.currentChar();
                            if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\s/)) {
                                // this may be a VariableCall lookup
                                var result = parsers.variableCall(name);
                                if (result) {
                                    parserInput.forget();
                                    return result;
                                }
                            }
                            parserInput.forget();
                            return new (tree.Variable)(name, index, fileInfo);
                        }
                        parserInput.restore();
                    },
                    // A variable entity using the protective {} e.g. @{var}
                    variableCurly: function () {
                        var curly;
                        var index = parserInput.i;
                        if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
                            return new (tree.Variable)("@" + curly[1], index, fileInfo);
                        }
                    },
                    //
                    // A Property accessor, such as `$color`, in
                    //
                    //     background-color: $color
                    //
                    property: function () {
                        var name;
                        var index = parserInput.i;
                        if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\$[\w-]+/))) {
                            return new (tree.Property)(name, index, fileInfo);
                        }
                    },
                    // A property entity useing the protective {} e.g. ${prop}
                    propertyCurly: function () {
                        var curly;
                        var index = parserInput.i;
                        if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\$\{([\w-]+)\}/))) {
                            return new (tree.Property)("$" + curly[1], index, fileInfo);
                        }
                    },
                    //
                    // A Hexadecimal color
                    //
                    //     #4F3C2F
                    //
                    // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
                    //
                    color: function () {
                        var rgb;
                        parserInput.save();
                        if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\w.#\[])?/))) {
                            if (!rgb[2]) {
                                parserInput.forget();
                                return new (tree.Color)(rgb[1], undefined, rgb[0]);
                            }
                        }
                        parserInput.restore();
                    },
                    colorKeyword: function () {
                        parserInput.save();
                        var autoCommentAbsorb = parserInput.autoCommentAbsorb;
                        parserInput.autoCommentAbsorb = false;
                        var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
                        parserInput.autoCommentAbsorb = autoCommentAbsorb;
                        if (!k) {
                            parserInput.forget();
                            return;
                        }
                        parserInput.restore();
                        var color = tree.Color.fromKeyword(k);
                        if (color) {
                            parserInput.$str(k);
                            return color;
                        }
                    },
                    //
                    // A Dimension, that is, a number and a unit
                    //
                    //     0.5em 95%
                    //
                    dimension: function () {
                        if (parserInput.peekNotNumeric()) {
                            return;
                        }
                        var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
                        if (value) {
                            return new (tree.Dimension)(value[1], value[2]);
                        }
                    },
                    //
                    // A unicode descriptor, as is used in unicode-range
                    //
                    // U+0??  or U+00A1-00A9
                    //
                    unicodeDescriptor: function () {
                        var ud;
                        ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
                        if (ud) {
                            return new (tree.UnicodeDescriptor)(ud[0]);
                        }
                    },
                    //
                    // JavaScript code to be evaluated
                    //
                    //     `window.location.href`
                    //
                    javascript: function () {
                        var js;
                        var index = parserInput.i;
                        parserInput.save();
                        var escape = parserInput.$char('~');
                        var jsQuote = parserInput.$char('`');
                        if (!jsQuote) {
                            parserInput.restore();
                            return;
                        }
                        js = parserInput.$re(/^[^`]*`/);
                        if (js) {
                            parserInput.forget();
                            return new (tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);
                        }
                        parserInput.restore('invalid javascript definition');
                    }
                },
                //
                // The variable part of a variable definition. Used in the `rule` parser
                //
                //     @fink:
                //
                variable: function () {
                    var name;
                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*:/))) {
                        return name[1];
                    }
                },
                //
                // Call a variable value to retrieve a detached ruleset
                // or a value from a detached ruleset's rules.
                //
                //     @fink();
                //     @fink;
                //     color: @fink[@color];
                //
                variableCall: function (parsedName) {
                    var lookups;
                    var i = parserInput.i;
                    var inValue = !!parsedName;
                    var name = parsedName;
                    parserInput.save();
                    if (name || (parserInput.currentChar() === '@'
                        && (name = parserInput.$re(/^(@[\w-]+)(\(\s*\))?/)))) {
                        lookups = this.mixin.ruleLookups();
                        if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {
                            parserInput.restore('Missing \'[...]\' lookup in variable call');
                            return;
                        }
                        if (!inValue) {
                            name = name[1];
                        }
                        var call = new tree.VariableCall(name, i, fileInfo);
                        if (!inValue && parsers.end()) {
                            parserInput.forget();
                            return call;
                        }
                        else {
                            parserInput.forget();
                            return new tree.NamespaceValue(call, lookups, i, fileInfo);
                        }
                    }
                    parserInput.restore();
                },
                //
                // extend syntax - used to extend selectors
                //
                extend: function (isRule) {
                    var elements;
                    var e;
                    var index = parserInput.i;
                    var option;
                    var extendList;
                    var extend;
                    if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {
                        return;
                    }
                    do {
                        option = null;
                        elements = null;
                        while (!(option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
                            e = this.element();
                            if (!e) {
                                break;
                            }
                            if (elements) {
                                elements.push(e);
                            }
                            else {
                                elements = [e];
                            }
                        }
                        option = option && option[1];
                        if (!elements) {
                            error('Missing target selector for :extend().');
                        }
                        extend = new (tree.Extend)(new (tree.Selector)(elements), option, index, fileInfo);
                        if (extendList) {
                            extendList.push(extend);
                        }
                        else {
                            extendList = [extend];
                        }
                    } while (parserInput.$char(','));
                    expect(/^\)/);
                    if (isRule) {
                        expect(/^;/);
                    }
                    return extendList;
                },
                //
                // extendRule - used in a rule to extend all the parent selectors
                //
                extendRule: function () {
                    return this.extend(true);
                },
                //
                // Mixins
                //
                mixin: {
                    //
                    // A Mixin call, with an optional argument list
                    //
                    //     #mixins > .square(#fff);
                    //     #mixins.square(#fff);
                    //     .rounded(4px, black);
                    //     .button;
                    //
                    // We can lookup / return a value using the lookup syntax:
                    //
                    //     color: #mixin.square(#fff)[@color];
                    //
                    // The `while` loop is there because mixins can be
                    // namespaced, but we only support the child and descendant
                    // selector for now.
                    //
                    call: function (inValue, getLookup) {
                        var s = parserInput.currentChar();
                        var important = false;
                        var lookups;
                        var index = parserInput.i;
                        var elements;
                        var args;
                        var hasParens;
                        if (s !== '.' && s !== '#') {
                            return;
                        }
                        parserInput.save(); // stop us absorbing part of an invalid selector
                        elements = this.elements();
                        if (elements) {
                            if (parserInput.$char('(')) {
                                args = this.args(true).args;
                                expectChar(')');
                                hasParens = true;
                            }
                            if (getLookup !== false) {
                                lookups = this.ruleLookups();
                            }
                            if (getLookup === true && !lookups) {
                                parserInput.restore();
                                return;
                            }
                            if (inValue && !lookups && !hasParens) {
                                // This isn't a valid in-value mixin call
                                parserInput.restore();
                                return;
                            }
                            if (!inValue && parsers.important()) {
                                important = true;
                            }
                            if (inValue || parsers.end()) {
                                parserInput.forget();
                                var mixin = new (tree.mixin.Call)(elements, args, index, fileInfo, !lookups && important);
                                if (lookups) {
                                    return new tree.NamespaceValue(mixin, lookups);
                                }
                                else {
                                    return mixin;
                                }
                            }
                        }
                        parserInput.restore();
                    },
                    /**
                     * Matching elements for mixins
                     * (Start with . or # and can have > )
                     */
                    elements: function () {
                        var elements;
                        var e;
                        var c;
                        var elem;
                        var elemIndex;
                        var re = /^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;
                        while (true) {
                            elemIndex = parserInput.i;
                            e = parserInput.$re(re);
                            if (!e) {
                                break;
                            }
                            elem = new (tree.Element)(c, e, false, elemIndex, fileInfo);
                            if (elements) {
                                elements.push(elem);
                            }
                            else {
                                elements = [elem];
                            }
                            c = parserInput.$char('>');
                        }
                        return elements;
                    },
                    args: function (isCall) {
                        var entities = parsers.entities;
                        var returner = { args: null, variadic: false };
                        var expressions = [];
                        var argsSemiColon = [];
                        var argsComma = [];
                        var isSemiColonSeparated;
                        var expressionContainsNamed;
                        var name;
                        var nameLoop;
                        var value;
                        var arg;
                        var expand;
                        var hasSep = true;
                        parserInput.save();
                        while (true) {
                            if (isCall) {
                                arg = parsers.detachedRuleset() || parsers.expression();
                            }
                            else {
                                parserInput.commentStore.length = 0;
                                if (parserInput.$str('...')) {
                                    returner.variadic = true;
                                    if (parserInput.$char(';') && !isSemiColonSeparated) {
                                        isSemiColonSeparated = true;
                                    }
                                    (isSemiColonSeparated ? argsSemiColon : argsComma)
                                        .push({ variadic: true });
                                    break;
                                }
                                arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);
                            }
                            if (!arg || !hasSep) {
                                break;
                            }
                            nameLoop = null;
                            if (arg.throwAwayComments) {
                                arg.throwAwayComments();
                            }
                            value = arg;
                            var val = null;
                            if (isCall) {
                                // Variable
                                if (arg.value && arg.value.length == 1) {
                                    val = arg.value[0];
                                }
                            }
                            else {
                                val = arg;
                            }
                            if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {
                                if (parserInput.$char(':')) {
                                    if (expressions.length > 0) {
                                        if (isSemiColonSeparated) {
                                            error('Cannot mix ; and , as delimiter types');
                                        }
                                        expressionContainsNamed = true;
                                    }
                                    value = parsers.detachedRuleset() || parsers.expression();
                                    if (!value) {
                                        if (isCall) {
                                            error('could not understand value for named argument');
                                        }
                                        else {
                                            parserInput.restore();
                                            returner.args = [];
                                            return returner;
                                        }
                                    }
                                    nameLoop = (name = val.name);
                                }
                                else if (parserInput.$str('...')) {
                                    if (!isCall) {
                                        returner.variadic = true;
                                        if (parserInput.$char(';') && !isSemiColonSeparated) {
                                            isSemiColonSeparated = true;
                                        }
                                        (isSemiColonSeparated ? argsSemiColon : argsComma)
                                            .push({ name: arg.name, variadic: true });
                                        break;
                                    }
                                    else {
                                        expand = true;
                                    }
                                }
                                else if (!isCall) {
                                    name = nameLoop = val.name;
                                    value = null;
                                }
                            }
                            if (value) {
                                expressions.push(value);
                            }
                            argsComma.push({ name: nameLoop, value: value, expand: expand });
                            if (parserInput.$char(',')) {
                                hasSep = true;
                                continue;
                            }
                            hasSep = parserInput.$char(';') === ';';
                            if (hasSep || isSemiColonSeparated) {
                                if (expressionContainsNamed) {
                                    error('Cannot mix ; and , as delimiter types');
                                }
                                isSemiColonSeparated = true;
                                if (expressions.length > 1) {
                                    value = new (tree.Value)(expressions);
                                }
                                argsSemiColon.push({ name: name, value: value, expand: expand });
                                name = null;
                                expressions = [];
                                expressionContainsNamed = false;
                            }
                        }
                        parserInput.forget();
                        returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
                        return returner;
                    },
                    //
                    // A Mixin definition, with a list of parameters
                    //
                    //     .rounded (@radius: 2px, @color) {
                    //        ...
                    //     }
                    //
                    // Until we have a finer grained state-machine, we have to
                    // do a look-ahead, to make sure we don't have a mixin call.
                    // See the `rule` function for more information.
                    //
                    // We start by matching `.rounded (`, and then proceed on to
                    // the argument list, which has optional default values.
                    // We store the parameters in `params`, with a `value` key,
                    // if there is a value, such as in the case of `@radius`.
                    //
                    // Once we've got our params list, and a closing `)`, we parse
                    // the `{...}` block.
                    //
                    definition: function () {
                        var name;
                        var params = [];
                        var match;
                        var ruleset;
                        var cond;
                        var variadic = false;
                        if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||
                            parserInput.peek(/^[^{]*\}/)) {
                            return;
                        }
                        parserInput.save();
                        match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
                        if (match) {
                            name = match[1];
                            var argInfo = this.args(false);
                            params = argInfo.args;
                            variadic = argInfo.variadic;
                            // .mixincall("@{a}");
                            // looks a bit like a mixin definition..
                            // also
                            // .mixincall(@a: {rule: set;});
                            // so we have to be nice and restore
                            if (!parserInput.$char(')')) {
                                parserInput.restore('Missing closing \')\'');
                                return;
                            }
                            parserInput.commentStore.length = 0;
                            if (parserInput.$str('when')) { // Guard
                                cond = expect(parsers.conditions, 'expected condition');
                            }
                            ruleset = parsers.block();
                            if (ruleset) {
                                parserInput.forget();
                                return new (tree.mixin.Definition)(name, params, ruleset, cond, variadic);
                            }
                            else {
                                parserInput.restore();
                            }
                        }
                        else {
                            parserInput.restore();
                        }
                    },
                    ruleLookups: function () {
                        var rule;
                        var lookups = [];
                        if (parserInput.currentChar() !== '[') {
                            return;
                        }
                        while (true) {
                            parserInput.save();
                            rule = this.lookupValue();
                            if (!rule && rule !== '') {
                                parserInput.restore();
                                break;
                            }
                            lookups.push(rule);
                            parserInput.forget();
                        }
                        if (lookups.length > 0) {
                            return lookups;
                        }
                    },
                    lookupValue: function () {
                        parserInput.save();
                        if (!parserInput.$char('[')) {
                            parserInput.restore();
                            return;
                        }
                        var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);
                        if (!parserInput.$char(']')) {
                            parserInput.restore();
                            return;
                        }
                        if (name || name === '') {
                            parserInput.forget();
                            return name;
                        }
                        parserInput.restore();
                    }
                },
                //
                // Entities are the smallest recognized token,
                // and can be found inside a rule's value.
                //
                entity: function () {
                    var entities = this.entities;
                    return this.comment() || entities.literal() || entities.variable() || entities.url() ||
                        entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||
                        entities.javascript();
                },
                //
                // A Declaration terminator. Note that we use `peek()` to check for '}',
                // because the `block` rule will be expecting it, but we still need to make sure
                // it's there, if ';' was omitted.
                //
                end: function () {
                    return parserInput.$char(';') || parserInput.peek('}');
                },
                //
                // IE's alpha function
                //
                //     alpha(opacity=88)
                //
                ieAlpha: function () {
                    var value;
                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                    if (!parserInput.$re(/^opacity=/i)) {
                        return;
                    }
                    value = parserInput.$re(/^\d+/);
                    if (!value) {
                        value = expect(parsers.entities.variable, 'Could not parse alpha');
                        value = "@{" + value.name.slice(1) + "}";
                    }
                    expectChar(')');
                    return new tree.Quoted('', "alpha(opacity=" + value + ")");
                },
                //
                // A Selector Element
                //
                //     div
                //     + h1
                //     #socks
                //     input[type="text"]
                //
                // Elements are the building blocks for Selectors,
                // they are made out of a `Combinator` (see combinator rule),
                // and an element name, such as a tag a class, or `*`.
                //
                element: function () {
                    var e;
                    var c;
                    var v;
                    var index = parserInput.i;
                    c = this.combinator();
                    e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
                        parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||
                        parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||
                        parserInput.$re(/^\([^&()@]+\)/) || parserInput.$re(/^[\.#:](?=@)/) ||
                        this.entities.variableCurly();
                    if (!e) {
                        parserInput.save();
                        if (parserInput.$char('(')) {
                            if ((v = this.selector(false)) && parserInput.$char(')')) {
                                e = new (tree.Paren)(v);
                                parserInput.forget();
                            }
                            else {
                                parserInput.restore('Missing closing \')\'');
                            }
                        }
                        else {
                            parserInput.forget();
                        }
                    }
                    if (e) {
                        return new (tree.Element)(c, e, e instanceof tree.Variable, index, fileInfo);
                    }
                },
                //
                // Combinators combine elements together, in a Selector.
                //
                // Because our parser isn't white-space sensitive, special care
                // has to be taken, when parsing the descendant combinator, ` `,
                // as it's an empty space. We have to check the previous character
                // in the input, to see if it's a ` ` character. More info on how
                // we deal with this in *combinator.js*.
                //
                combinator: function () {
                    var c = parserInput.currentChar();
                    if (c === '/') {
                        parserInput.save();
                        var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
                        if (slashedCombinator) {
                            parserInput.forget();
                            return new (tree.Combinator)(slashedCombinator);
                        }
                        parserInput.restore();
                    }
                    if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
                        parserInput.i++;
                        if (c === '^' && parserInput.currentChar() === '^') {
                            c = '^^';
                            parserInput.i++;
                        }
                        while (parserInput.isWhitespace()) {
                            parserInput.i++;
                        }
                        return new (tree.Combinator)(c);
                    }
                    else if (parserInput.isWhitespace(-1)) {
                        return new (tree.Combinator)(' ');
                    }
                    else {
                        return new (tree.Combinator)(null);
                    }
                },
                //
                // A CSS Selector
                // with less extensions e.g. the ability to extend and guard
                //
                //     .class > div + h1
                //     li a:hover
                //
                // Selectors are made out of one or more Elements, see above.
                //
                selector: function (isLess) {
                    var index = parserInput.i;
                    var elements;
                    var extendList;
                    var c;
                    var e;
                    var allExtends;
                    var when;
                    var condition;
                    isLess = isLess !== false;
                    while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {
                        if (when) {
                            condition = expect(this.conditions, 'expected condition');
                        }
                        else if (condition) {
                            error('CSS guard can only be used at the end of selector');
                        }
                        else if (extendList) {
                            if (allExtends) {
                                allExtends = allExtends.concat(extendList);
                            }
                            else {
                                allExtends = extendList;
                            }
                        }
                        else {
                            if (allExtends) {
                                error('Extend can only be used at the end of selector');
                            }
                            c = parserInput.currentChar();
                            if (elements) {
                                elements.push(e);
                            }
                            else {
                                elements = [e];
                            }
                            e = null;
                        }
                        if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
                            break;
                        }
                    }
                    if (elements) {
                        return new (tree.Selector)(elements, allExtends, condition, index, fileInfo);
                    }
                    if (allExtends) {
                        error('Extend must be used to extend a selector, it cannot be used on its own');
                    }
                },
                selectors: function () {
                    var s;
                    var selectors;
                    while (true) {
                        s = this.selector();
                        if (!s) {
                            break;
                        }
                        if (selectors) {
                            selectors.push(s);
                        }
                        else {
                            selectors = [s];
                        }
                        parserInput.commentStore.length = 0;
                        if (s.condition && selectors.length > 1) {
                            error("Guards are only currently allowed on a single selector.");
                        }
                        if (!parserInput.$char(',')) {
                            break;
                        }
                        if (s.condition) {
                            error("Guards are only currently allowed on a single selector.");
                        }
                        parserInput.commentStore.length = 0;
                    }
                    return selectors;
                },
                attribute: function () {
                    if (!parserInput.$char('[')) {
                        return;
                    }
                    var entities = this.entities;
                    var key;
                    var val;
                    var op;
                    if (!(key = entities.variableCurly())) {
                        key = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
                    }
                    op = parserInput.$re(/^[|~*$^]?=/);
                    if (op) {
                        val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
                    }
                    expectChar(']');
                    return new (tree.Attribute)(key, op, val);
                },
                //
                // The `block` rule is used by `ruleset` and `mixin.definition`.
                // It's a wrapper around the `primary` rule, with added `{}`.
                //
                block: function () {
                    var content;
                    if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {
                        return content;
                    }
                },
                blockRuleset: function () {
                    var block = this.block();
                    if (block) {
                        block = new tree.Ruleset(null, block);
                    }
                    return block;
                },
                detachedRuleset: function () {
                    var argInfo;
                    var params;
                    var variadic;
                    parserInput.save();
                    if (parserInput.$re(/^[.#]\(/)) {
                        /**
                         * DR args currently only implemented for each() function, and not
                         * yet settable as `@dr: #(@arg) {}`
                         * This should be done when DRs are merged with mixins.
                         * See: https://github.com/less/less-meta/issues/16
                         */
                        argInfo = this.mixin.args(false);
                        params = argInfo.args;
                        variadic = argInfo.variadic;
                        if (!parserInput.$char(')')) {
                            parserInput.restore();
                            return;
                        }
                    }
                    var blockRuleset = this.blockRuleset();
                    if (blockRuleset) {
                        parserInput.forget();
                        if (params) {
                            return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);
                        }
                        return new tree.DetachedRuleset(blockRuleset);
                    }
                    parserInput.restore();
                },
                //
                // div, .class, body > p {...}
                //
                ruleset: function () {
                    var selectors;
                    var rules;
                    var debugInfo;
                    parserInput.save();
                    if (context.dumpLineNumbers) {
                        debugInfo = getDebugInfo(parserInput.i);
                    }
                    selectors = this.selectors();
                    if (selectors && (rules = this.block())) {
                        parserInput.forget();
                        var ruleset = new (tree.Ruleset)(selectors, rules, context.strictImports);
                        if (context.dumpLineNumbers) {
                            ruleset.debugInfo = debugInfo;
                        }
                        return ruleset;
                    }
                    else {
                        parserInput.restore();
                    }
                },
                declaration: function () {
                    var name;
                    var value;
                    var index = parserInput.i;
                    var hasDR;
                    var c = parserInput.currentChar();
                    var important;
                    var merge;
                    var isVariable;
                    if (c === '.' || c === '#' || c === '&' || c === ':') {
                        return;
                    }
                    parserInput.save();
                    name = this.variable() || this.ruleProperty();
                    if (name) {
                        isVariable = typeof name === 'string';
                        if (isVariable) {
                            value = this.detachedRuleset();
                            if (value) {
                                hasDR = true;
                            }
                        }
                        parserInput.commentStore.length = 0;
                        if (!value) {
                            // a name returned by this.ruleProperty() is always an array of the form:
                            // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
                            // where each item is a tree.Keyword or tree.Variable
                            merge = !isVariable && name.length > 1 && name.pop().value;
                            // Custom property values get permissive parsing
                            if (name[0].value && name[0].value.slice(0, 2) === '--') {
                                value = this.permissiveValue();
                            }
                            // Try to store values as anonymous
                            // If we need the value later we'll re-parse it in ruleset.parseValue
                            else {
                                value = this.anonymousValue();
                            }
                            if (value) {
                                parserInput.forget();
                                // anonymous values absorb the end ';' which is required for them to work
                                return new (tree.Declaration)(name, value, false, merge, index, fileInfo);
                            }
                            if (!value) {
                                value = this.value();
                            }
                            if (value) {
                                important = this.important();
                            }
                            else if (isVariable) {
                                // As a last resort, try permissiveValue
                                value = this.permissiveValue();
                            }
                        }
                        if (value && (this.end() || hasDR)) {
                            parserInput.forget();
                            return new (tree.Declaration)(name, value, important, merge, index, fileInfo);
                        }
                        else {
                            parserInput.restore();
                        }
                    }
                    else {
                        parserInput.restore();
                    }
                },
                anonymousValue: function () {
                    var index = parserInput.i;
                    var match = parserInput.$re(/^([^.#@\$+\/'"*`(;{}-]*);/);
                    if (match) {
                        return new (tree.Anonymous)(match[1], index);
                    }
                },
                /**
                 * Used for custom properties, at-rules, and variables (as fallback)
                 * Parses almost anything inside of {} [] () "" blocks
                 * until it reaches outer-most tokens.
                 *
                 * First, it will try to parse comments and entities to reach
                 * the end. This is mostly like the Expression parser except no
                 * math is allowed.
                 */
                permissiveValue: function (untilTokens) {
                    var i;
                    var e;
                    var done;
                    var value;
                    var tok = untilTokens || ';';
                    var index = parserInput.i;
                    var result = [];
                    function testCurrentChar() {
                        var char = parserInput.currentChar();
                        if (typeof tok === 'string') {
                            return char === tok;
                        }
                        else {
                            return tok.test(char);
                        }
                    }
                    if (testCurrentChar()) {
                        return;
                    }
                    value = [];
                    do {
                        e = this.comment();
                        if (e) {
                            value.push(e);
                            continue;
                        }
                        e = this.entity();
                        if (e) {
                            value.push(e);
                        }
                    } while (e);
                    done = testCurrentChar();
                    if (value.length > 0) {
                        value = new (tree.Expression)(value);
                        if (done) {
                            return value;
                        }
                        else {
                            result.push(value);
                        }
                        // Preserve space before $parseUntil as it will not
                        if (parserInput.prevChar() === ' ') {
                            result.push(new tree.Anonymous(' ', index));
                        }
                    }
                    parserInput.save();
                    value = parserInput.$parseUntil(tok);
                    if (value) {
                        if (typeof value === 'string') {
                            error("Expected '" + value + "'", 'Parse');
                        }
                        if (value.length === 1 && value[0] === ' ') {
                            parserInput.forget();
                            return new tree.Anonymous('', index);
                        }
                        var item = void 0;
                        for (i = 0; i < value.length; i++) {
                            item = value[i];
                            if (Array.isArray(item)) {
                                // Treat actual quotes as normal quoted values
                                result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));
                            }
                            else {
                                if (i === value.length - 1) {
                                    item = item.trim();
                                }
                                // Treat like quoted values, but replace vars like unquoted expressions
                                var quote = new tree.Quoted('\'', item, true, index, fileInfo);
                                quote.variableRegex = /@([\w-]+)/g;
                                quote.propRegex = /\$([\w-]+)/g;
                                result.push(quote);
                            }
                        }
                        parserInput.forget();
                        return new tree.Expression(result, true);
                    }
                    parserInput.restore();
                },
                //
                // An @import atrule
                //
                //     @import "lib";
                //
                // Depending on our environment, importing is done differently:
                // In the browser, it's an XHR request, in Node, it would be a
                // file-system operation. The function used for importing is
                // stored in `import`, which we pass to the Import constructor.
                //
                'import': function () {
                    var path;
                    var features;
                    var index = parserInput.i;
                    var dir = parserInput.$re(/^@import?\s+/);
                    if (dir) {
                        var options = (dir ? this.importOptions() : null) || {};
                        if ((path = this.entities.quoted() || this.entities.url())) {
                            features = this.mediaFeatures();
                            if (!parserInput.$char(';')) {
                                parserInput.i = index;
                                error('missing semi-colon or unrecognised media features on import');
                            }
                            features = features && new (tree.Value)(features);
                            return new (tree.Import)(path, features, options, index, fileInfo);
                        }
                        else {
                            parserInput.i = index;
                            error('malformed import statement');
                        }
                    }
                },
                importOptions: function () {
                    var o;
                    var options = {};
                    var optionName;
                    var value;
                    // list of options, surrounded by parens
                    if (!parserInput.$char('(')) {
                        return null;
                    }
                    do {
                        o = this.importOption();
                        if (o) {
                            optionName = o;
                            value = true;
                            switch (optionName) {
                                case 'css':
                                    optionName = 'less';
                                    value = false;
                                    break;
                                case 'once':
                                    optionName = 'multiple';
                                    value = false;
                                    break;
                            }
                            options[optionName] = value;
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                    } while (o);
                    expectChar(')');
                    return options;
                },
                importOption: function () {
                    var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
                    if (opt) {
                        return opt[1];
                    }
                },
                mediaFeature: function () {
                    var entities = this.entities;
                    var nodes = [];
                    var e;
                    var p;
                    parserInput.save();
                    do {
                        e = entities.keyword() || entities.variable() || entities.mixinLookup();
                        if (e) {
                            nodes.push(e);
                        }
                        else if (parserInput.$char('(')) {
                            p = this.property();
                            e = this.value();
                            if (parserInput.$char(')')) {
                                if (p && e) {
                                    nodes.push(new (tree.Paren)(new (tree.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));
                                }
                                else if (e) {
                                    nodes.push(new (tree.Paren)(e));
                                }
                                else {
                                    error('badly formed media feature definition');
                                }
                            }
                            else {
                                error('Missing closing \')\'', 'Parse');
                            }
                        }
                    } while (e);
                    parserInput.forget();
                    if (nodes.length > 0) {
                        return new (tree.Expression)(nodes);
                    }
                },
                mediaFeatures: function () {
                    var entities = this.entities;
                    var features = [];
                    var e;
                    do {
                        e = this.mediaFeature();
                        if (e) {
                            features.push(e);
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                        else {
                            e = entities.variable() || entities.mixinLookup();
                            if (e) {
                                features.push(e);
                                if (!parserInput.$char(',')) {
                                    break;
                                }
                            }
                        }
                    } while (e);
                    return features.length > 0 ? features : null;
                },
                media: function () {
                    var features;
                    var rules;
                    var media;
                    var debugInfo;
                    var index = parserInput.i;
                    if (context.dumpLineNumbers) {
                        debugInfo = getDebugInfo(index);
                    }
                    parserInput.save();
                    if (parserInput.$str('@media')) {
                        features = this.mediaFeatures();
                        rules = this.block();
                        if (!rules) {
                            error('media definitions require block statements after any features');
                        }
                        parserInput.forget();
                        media = new (tree.Media)(rules, features, index, fileInfo);
                        if (context.dumpLineNumbers) {
                            media.debugInfo = debugInfo;
                        }
                        return media;
                    }
                    parserInput.restore();
                },
                //
                // A @plugin directive, used to import plugins dynamically.
                //
                //     @plugin (args) "lib";
                //
                plugin: function () {
                    var path;
                    var args;
                    var options;
                    var index = parserInput.i;
                    var dir = parserInput.$re(/^@plugin?\s+/);
                    if (dir) {
                        args = this.pluginArgs();
                        if (args) {
                            options = {
                                pluginArgs: args,
                                isPlugin: true
                            };
                        }
                        else {
                            options = { isPlugin: true };
                        }
                        if ((path = this.entities.quoted() || this.entities.url())) {
                            if (!parserInput.$char(';')) {
                                parserInput.i = index;
                                error('missing semi-colon on @plugin');
                            }
                            return new (tree.Import)(path, null, options, index, fileInfo);
                        }
                        else {
                            parserInput.i = index;
                            error('malformed @plugin statement');
                        }
                    }
                },
                pluginArgs: function () {
                    // list of options, surrounded by parens
                    parserInput.save();
                    if (!parserInput.$char('(')) {
                        parserInput.restore();
                        return null;
                    }
                    var args = parserInput.$re(/^\s*([^\);]+)\)\s*/);
                    if (args[1]) {
                        parserInput.forget();
                        return args[1].trim();
                    }
                    else {
                        parserInput.restore();
                        return null;
                    }
                },
                //
                // A CSS AtRule
                //
                //     @charset "utf-8";
                //
                atrule: function () {
                    var index = parserInput.i;
                    var name;
                    var value;
                    var rules;
                    var nonVendorSpecificName;
                    var hasIdentifier;
                    var hasExpression;
                    var hasUnknown;
                    var hasBlock = true;
                    var isRooted = true;
                    if (parserInput.currentChar() !== '@') {
                        return;
                    }
                    value = this['import']() || this.plugin() || this.media();
                    if (value) {
                        return value;
                    }
                    parserInput.save();
                    name = parserInput.$re(/^@[a-z-]+/);
                    if (!name) {
                        return;
                    }
                    nonVendorSpecificName = name;
                    if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {
                        nonVendorSpecificName = "@" + name.slice(name.indexOf('-', 2) + 1);
                    }
                    switch (nonVendorSpecificName) {
                        case '@charset':
                            hasIdentifier = true;
                            hasBlock = false;
                            break;
                        case '@namespace':
                            hasExpression = true;
                            hasBlock = false;
                            break;
                        case '@keyframes':
                        case '@counter-style':
                            hasIdentifier = true;
                            break;
                        case '@document':
                        case '@supports':
                            hasUnknown = true;
                            isRooted = false;
                            break;
                        default:
                            hasUnknown = true;
                            break;
                    }
                    parserInput.commentStore.length = 0;
                    if (hasIdentifier) {
                        value = this.entity();
                        if (!value) {
                            error("expected " + name + " identifier");
                        }
                    }
                    else if (hasExpression) {
                        value = this.expression();
                        if (!value) {
                            error("expected " + name + " expression");
                        }
                    }
                    else if (hasUnknown) {
                        value = this.permissiveValue(/^[{;]/);
                        hasBlock = (parserInput.currentChar() === '{');
                        if (!value) {
                            if (!hasBlock && parserInput.currentChar() !== ';') {
                                error(name + " rule is missing block or ending semi-colon");
                            }
                        }
                        else if (!value.value) {
                            value = null;
                        }
                    }
                    if (hasBlock) {
                        rules = this.blockRuleset();
                    }
                    if (rules || (!hasBlock && value && parserInput.$char(';'))) {
                        parserInput.forget();
                        return new (tree.AtRule)(name, value, rules, index, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);
                    }
                    parserInput.restore('at-rule options not recognised');
                },
                //
                // A Value is a comma-delimited list of Expressions
                //
                //     font-family: Baskerville, Georgia, serif;
                //
                // In a Rule, a Value represents everything after the `:`,
                // and before the `;`.
                //
                value: function () {
                    var e;
                    var expressions = [];
                    var index = parserInput.i;
                    do {
                        e = this.expression();
                        if (e) {
                            expressions.push(e);
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                    } while (e);
                    if (expressions.length > 0) {
                        return new (tree.Value)(expressions, index);
                    }
                },
                important: function () {
                    if (parserInput.currentChar() === '!') {
                        return parserInput.$re(/^! *important/);
                    }
                },
                sub: function () {
                    var a;
                    var e;
                    parserInput.save();
                    if (parserInput.$char('(')) {
                        a = this.addition();
                        if (a && parserInput.$char(')')) {
                            parserInput.forget();
                            e = new (tree.Expression)([a]);
                            e.parens = true;
                            return e;
                        }
                        parserInput.restore('Expected \')\'');
                        return;
                    }
                    parserInput.restore();
                },
                multiplication: function () {
                    var m;
                    var a;
                    var op;
                    var operation;
                    var isSpaced;
                    m = this.operand();
                    if (m) {
                        isSpaced = parserInput.isWhitespace(-1);
                        while (true) {
                            if (parserInput.peek(/^\/[*\/]/)) {
                                break;
                            }
                            parserInput.save();
                            op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');
                            if (!op) {
                                parserInput.forget();
                                break;
                            }
                            a = this.operand();
                            if (!a) {
                                parserInput.restore();
                                break;
                            }
                            parserInput.forget();
                            m.parensInOp = true;
                            a.parensInOp = true;
                            operation = new (tree.Operation)(op, [operation || m, a], isSpaced);
                            isSpaced = parserInput.isWhitespace(-1);
                        }
                        return operation || m;
                    }
                },
                addition: function () {
                    var m;
                    var a;
                    var op;
                    var operation;
                    var isSpaced;
                    m = this.multiplication();
                    if (m) {
                        isSpaced = parserInput.isWhitespace(-1);
                        while (true) {
                            op = parserInput.$re(/^[-+]\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));
                            if (!op) {
                                break;
                            }
                            a = this.multiplication();
                            if (!a) {
                                break;
                            }
                            m.parensInOp = true;
                            a.parensInOp = true;
                            operation = new (tree.Operation)(op, [operation || m, a], isSpaced);
                            isSpaced = parserInput.isWhitespace(-1);
                        }
                        return operation || m;
                    }
                },
                conditions: function () {
                    var a;
                    var b;
                    var index = parserInput.i;
                    var condition;
                    a = this.condition(true);
                    if (a) {
                        while (true) {
                            if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
                                break;
                            }
                            b = this.condition(true);
                            if (!b) {
                                break;
                            }
                            condition = new (tree.Condition)('or', condition || a, b, index);
                        }
                        return condition || a;
                    }
                },
                condition: function (needsParens) {
                    var result;
                    var logical;
                    var next;
                    function or() {
                        return parserInput.$str('or');
                    }
                    result = this.conditionAnd(needsParens);
                    if (!result) {
                        return;
                    }
                    logical = or();
                    if (logical) {
                        next = this.condition(needsParens);
                        if (next) {
                            result = new (tree.Condition)(logical, result, next);
                        }
                        else {
                            return;
                        }
                    }
                    return result;
                },
                conditionAnd: function (needsParens) {
                    var result;
                    var logical;
                    var next;
                    var self = this;
                    function insideCondition() {
                        var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);
                        if (!cond && !needsParens) {
                            return self.atomicCondition(needsParens);
                        }
                        return cond;
                    }
                    function and() {
                        return parserInput.$str('and');
                    }
                    result = insideCondition();
                    if (!result) {
                        return;
                    }
                    logical = and();
                    if (logical) {
                        next = this.conditionAnd(needsParens);
                        if (next) {
                            result = new (tree.Condition)(logical, result, next);
                        }
                        else {
                            return;
                        }
                    }
                    return result;
                },
                negatedCondition: function (needsParens) {
                    if (parserInput.$str('not')) {
                        var result = this.parenthesisCondition(needsParens);
                        if (result) {
                            result.negate = !result.negate;
                        }
                        return result;
                    }
                },
                parenthesisCondition: function (needsParens) {
                    function tryConditionFollowedByParenthesis(me) {
                        var body;
                        parserInput.save();
                        body = me.condition(needsParens);
                        if (!body) {
                            parserInput.restore();
                            return;
                        }
                        if (!parserInput.$char(')')) {
                            parserInput.restore();
                            return;
                        }
                        parserInput.forget();
                        return body;
                    }
                    var body;
                    parserInput.save();
                    if (!parserInput.$str('(')) {
                        parserInput.restore();
                        return;
                    }
                    body = tryConditionFollowedByParenthesis(this);
                    if (body) {
                        parserInput.forget();
                        return body;
                    }
                    body = this.atomicCondition(needsParens);
                    if (!body) {
                        parserInput.restore();
                        return;
                    }
                    if (!parserInput.$char(')')) {
                        parserInput.restore("expected ')' got '" + parserInput.currentChar() + "'");
                        return;
                    }
                    parserInput.forget();
                    return body;
                },
                atomicCondition: function (needsParens) {
                    var entities = this.entities;
                    var index = parserInput.i;
                    var a;
                    var b;
                    var c;
                    var op;
                    function cond() {
                        return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();
                    }
                    cond = cond.bind(this);
                    a = cond();
                    if (a) {
                        if (parserInput.$char('>')) {
                            if (parserInput.$char('=')) {
                                op = '>=';
                            }
                            else {
                                op = '>';
                            }
                        }
                        else if (parserInput.$char('<')) {
                            if (parserInput.$char('=')) {
                                op = '<=';
                            }
                            else {
                                op = '<';
                            }
                        }
                        else if (parserInput.$char('=')) {
                            if (parserInput.$char('>')) {
                                op = '=>';
                            }
                            else if (parserInput.$char('<')) {
                                op = '=<';
                            }
                            else {
                                op = '=';
                            }
                        }
                        if (op) {
                            b = cond();
                            if (b) {
                                c = new (tree.Condition)(op, a, b, index, false);
                            }
                            else {
                                error('expected expression');
                            }
                        }
                        else {
                            c = new (tree.Condition)('=', a, new (tree.Keyword)('true'), index, false);
                        }
                        return c;
                    }
                },
                //
                // An operand is anything that can be part of an operation,
                // such as a Color, or a Variable
                //
                operand: function () {
                    var entities = this.entities;
                    var negate;
                    if (parserInput.peek(/^-[@\$\(]/)) {
                        negate = parserInput.$char('-');
                    }
                    var o = this.sub() || entities.dimension() ||
                        entities.color() || entities.variable() ||
                        entities.property() || entities.call() ||
                        entities.quoted(true) || entities.colorKeyword() ||
                        entities.mixinLookup();
                    if (negate) {
                        o.parensInOp = true;
                        o = new (tree.Negative)(o);
                    }
                    return o;
                },
                //
                // Expressions either represent mathematical operations,
                // or white-space delimited Entities.
                //
                //     1px solid black
                //     @var * 2
                //
                expression: function () {
                    var entities = [];
                    var e;
                    var delim;
                    var index = parserInput.i;
                    do {
                        e = this.comment();
                        if (e) {
                            entities.push(e);
                            continue;
                        }
                        e = this.addition() || this.entity();
                        if (e instanceof tree.Comment) {
                            e = null;
                        }
                        if (e) {
                            entities.push(e);
                            // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
                            if (!parserInput.peek(/^\/[\/*]/)) {
                                delim = parserInput.$char('/');
                                if (delim) {
                                    entities.push(new (tree.Anonymous)(delim, index));
                                }
                            }
                        }
                    } while (e);
                    if (entities.length > 0) {
                        return new (tree.Expression)(entities);
                    }
                },
                property: function () {
                    var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
                    if (name) {
                        return name[1];
                    }
                },
                ruleProperty: function () {
                    var name = [];
                    var index = [];
                    var s;
                    var k;
                    parserInput.save();
                    var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
                    if (simpleProperty) {
                        name = [new (tree.Keyword)(simpleProperty[1])];
                        parserInput.forget();
                        return name;
                    }
                    function match(re) {
                        var i = parserInput.i;
                        var chunk = parserInput.$re(re);
                        if (chunk) {
                            index.push(i);
                            return name.push(chunk[1]);
                        }
                    }
                    match(/^(\*?)/);
                    while (true) {
                        if (!match(/^((?:[\w-]+)|(?:[@\$]\{[\w-]+\}))/)) {
                            break;
                        }
                    }
                    if ((name.length > 1) && match(/^((?:\+_|\+)?)\s*:/)) {
                        parserInput.forget();
                        // at last, we have the complete match now. move forward,
                        // convert name particles to tree objects and return:
                        if (name[0] === '') {
                            name.shift();
                            index.shift();
                        }
                        for (k = 0; k < name.length; k++) {
                            s = name[k];
                            name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?
                                new (tree.Keyword)(s) :
                                (s.charAt(0) === '@' ?
                                    new (tree.Variable)("@" + s.slice(2, -1), index[k], fileInfo) :
                                    new (tree.Property)("$" + s.slice(2, -1), index[k], fileInfo));
                        }
                        return name;
                    }
                    parserInput.restore();
                }
            }
        };
    };
    Parser.serializeVars = function (vars) {
        var s = '';
        for (var name_1 in vars) {
            if (Object.hasOwnProperty.call(vars, name_1)) {
                var value = vars[name_1];
                s += ((name_1[0] === '@') ? '' : '@') + name_1 + ": " + value + ((String(value).slice(-1) === ';') ? '' : ';');
            }
        }
        return s;
    };

    function boolean(condition) {
        return condition ? Keyword.True : Keyword.False;
    }
    /**
     * Functions with evalArgs set to false are sent context
     * as the first argument.
     */
    function If(context, condition, trueValue, falseValue) {
        return condition.eval(context) ? trueValue.eval(context)
            : (falseValue ? falseValue.eval(context) : new Anonymous);
    }
    If.evalArgs = false;
    function isdefined(context, variable) {
        try {
            variable.eval(context);
            return Keyword.True;
        }
        catch (e) {
            return Keyword.False;
        }
    }
    isdefined.evalArgs = false;
    var boolean$1 = { isdefined: isdefined, boolean: boolean, 'if': If };

    var colorFunctions;
    function clamp$1(val) {
        return Math.min(1, Math.max(0, val));
    }
    function hsla(origColor, hsl) {
        var color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);
        if (color) {
            if (origColor.value &&
                /^(rgb|hsl)/.test(origColor.value)) {
                color.value = origColor.value;
            }
            else {
                color.value = 'rgb';
            }
            return color;
        }
    }
    function toHSL(color) {
        if (color.toHSL) {
            return color.toHSL();
        }
        else {
            throw new Error('Argument cannot be evaluated to a color');
        }
    }
    function toHSV(color) {
        if (color.toHSV) {
            return color.toHSV();
        }
        else {
            throw new Error('Argument cannot be evaluated to a color');
        }
    }
    function number(n) {
        if (n instanceof Dimension) {
            return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);
        }
        else if (typeof n === 'number') {
            return n;
        }
        else {
            throw {
                type: 'Argument',
                message: 'color functions take numbers as parameters'
            };
        }
    }
    function scaled(n, size) {
        if (n instanceof Dimension && n.unit.is('%')) {
            return parseFloat(n.value * size / 100);
        }
        else {
            return number(n);
        }
    }
    colorFunctions = {
        rgb: function (r, g, b) {
            var a = 1;
            /**
             * Comma-less syntax
             *   e.g. rgb(0 128 255 / 50%)
             */
            if (r instanceof Expression) {
                var val = r.value;
                r = val[0];
                g = val[1];
                b = val[2];
                /**
                 * @todo - should this be normalized in
                 *   function caller? Or parsed differently?
                 */
                if (b instanceof Operation) {
                    var op = b;
                    b = op.operands[0];
                    a = op.operands[1];
                }
            }
            var color = colorFunctions.rgba(r, g, b, a);
            if (color) {
                color.value = 'rgb';
                return color;
            }
        },
        rgba: function (r, g, b, a) {
            try {
                if (r instanceof Color) {
                    if (g) {
                        a = number(g);
                    }
                    else {
                        a = r.alpha;
                    }
                    return new Color(r.rgb, a, 'rgba');
                }
                var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });
                a = number(a);
                return new Color(rgb, a, 'rgba');
            }
            catch (e) { }
        },
        hsl: function (h, s, l) {
            var a = 1;
            if (h instanceof Expression) {
                var val = h.value;
                h = val[0];
                s = val[1];
                l = val[2];
                if (l instanceof Operation) {
                    var op = l;
                    l = op.operands[0];
                    a = op.operands[1];
                }
            }
            var color = colorFunctions.hsla(h, s, l, a);
            if (color) {
                color.value = 'hsl';
                return color;
            }
        },
        hsla: function (h, s, l, a) {
            try {
                if (h instanceof Color) {
                    if (s) {
                        a = number(s);
                    }
                    else {
                        a = h.alpha;
                    }
                    return new Color(h.rgb, a, 'hsla');
                }
                var m1_1;
                var m2_1;
                function hue(h) {
                    h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
                    if (h * 6 < 1) {
                        return m1_1 + (m2_1 - m1_1) * h * 6;
                    }
                    else if (h * 2 < 1) {
                        return m2_1;
                    }
                    else if (h * 3 < 2) {
                        return m1_1 + (m2_1 - m1_1) * (2 / 3 - h) * 6;
                    }
                    else {
                        return m1_1;
                    }
                }
                h = (number(h) % 360) / 360;
                s = clamp$1(number(s));
                l = clamp$1(number(l));
                a = clamp$1(number(a));
                m2_1 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                m1_1 = l * 2 - m2_1;
                var rgb = [
                    hue(h + 1 / 3) * 255,
                    hue(h) * 255,
                    hue(h - 1 / 3) * 255
                ];
                a = number(a);
                return new Color(rgb, a, 'hsla');
            }
            catch (e) { }
        },
        hsv: function (h, s, v) {
            return colorFunctions.hsva(h, s, v, 1.0);
        },
        hsva: function (h, s, v, a) {
            h = ((number(h) % 360) / 360) * 360;
            s = number(s);
            v = number(v);
            a = number(a);
            var i;
            var f;
            i = Math.floor((h / 60) % 6);
            f = (h / 60) - i;
            var vs = [v,
                v * (1 - s),
                v * (1 - f * s),
                v * (1 - (1 - f) * s)];
            var perm = [[0, 3, 1],
                [2, 0, 1],
                [1, 0, 3],
                [1, 2, 0],
                [3, 1, 0],
                [0, 1, 2]];
            return colorFunctions.rgba(vs[perm[i][0]] * 255, vs[perm[i][1]] * 255, vs[perm[i][2]] * 255, a);
        },
        hue: function (color) {
            return new Dimension(toHSL(color).h);
        },
        saturation: function (color) {
            return new Dimension(toHSL(color).s * 100, '%');
        },
        lightness: function (color) {
            return new Dimension(toHSL(color).l * 100, '%');
        },
        hsvhue: function (color) {
            return new Dimension(toHSV(color).h);
        },
        hsvsaturation: function (color) {
            return new Dimension(toHSV(color).s * 100, '%');
        },
        hsvvalue: function (color) {
            return new Dimension(toHSV(color).v * 100, '%');
        },
        red: function (color) {
            return new Dimension(color.rgb[0]);
        },
        green: function (color) {
            return new Dimension(color.rgb[1]);
        },
        blue: function (color) {
            return new Dimension(color.rgb[2]);
        },
        alpha: function (color) {
            return new Dimension(toHSL(color).a);
        },
        luma: function (color) {
            return new Dimension(color.luma() * color.alpha * 100, '%');
        },
        luminance: function (color) {
            var luminance = (0.2126 * color.rgb[0] / 255) +
                (0.7152 * color.rgb[1] / 255) +
                (0.0722 * color.rgb[2] / 255);
            return new Dimension(luminance * color.alpha * 100, '%');
        },
        saturate: function (color, amount, method) {
            // filter: saturate(3.2);
            // should be kept as is, so check for color
            if (!color.rgb) {
                return null;
            }
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.s += hsl.s * amount.value / 100;
            }
            else {
                hsl.s += amount.value / 100;
            }
            hsl.s = clamp$1(hsl.s);
            return hsla(color, hsl);
        },
        desaturate: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.s -= hsl.s * amount.value / 100;
            }
            else {
                hsl.s -= amount.value / 100;
            }
            hsl.s = clamp$1(hsl.s);
            return hsla(color, hsl);
        },
        lighten: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.l += hsl.l * amount.value / 100;
            }
            else {
                hsl.l += amount.value / 100;
            }
            hsl.l = clamp$1(hsl.l);
            return hsla(color, hsl);
        },
        darken: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.l -= hsl.l * amount.value / 100;
            }
            else {
                hsl.l -= amount.value / 100;
            }
            hsl.l = clamp$1(hsl.l);
            return hsla(color, hsl);
        },
        fadein: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.a += hsl.a * amount.value / 100;
            }
            else {
                hsl.a += amount.value / 100;
            }
            hsl.a = clamp$1(hsl.a);
            return hsla(color, hsl);
        },
        fadeout: function (color, amount, method) {
            var hsl = toHSL(color);
            if (typeof method !== 'undefined' && method.value === 'relative') {
                hsl.a -= hsl.a * amount.value / 100;
            }
            else {
                hsl.a -= amount.value / 100;
            }
            hsl.a = clamp$1(hsl.a);
            return hsla(color, hsl);
        },
        fade: function (color, amount) {
            var hsl = toHSL(color);
            hsl.a = amount.value / 100;
            hsl.a = clamp$1(hsl.a);
            return hsla(color, hsl);
        },
        spin: function (color, amount) {
            var hsl = toHSL(color);
            var hue = (hsl.h + amount.value) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return hsla(color, hsl);
        },
        //
        // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein
        // http://sass-lang.com
        //
        mix: function (color1, color2, weight) {
            if (!weight) {
                weight = new Dimension(50);
            }
            var p = weight.value / 100.0;
            var w = p * 2 - 1;
            var a = toHSL(color1).a - toHSL(color2).a;
            var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
            var w2 = 1 - w1;
            var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
                color1.rgb[1] * w1 + color2.rgb[1] * w2,
                color1.rgb[2] * w1 + color2.rgb[2] * w2];
            var alpha = color1.alpha * p + color2.alpha * (1 - p);
            return new Color(rgb, alpha);
        },
        greyscale: function (color) {
            return colorFunctions.desaturate(color, new Dimension(100));
        },
        contrast: function (color, dark, light, threshold) {
            // filter: contrast(3.2);
            // should be kept as is, so check for color
            if (!color.rgb) {
                return null;
            }
            if (typeof light === 'undefined') {
                light = colorFunctions.rgba(255, 255, 255, 1.0);
            }
            if (typeof dark === 'undefined') {
                dark = colorFunctions.rgba(0, 0, 0, 1.0);
            }
            // Figure out which is actually light and dark:
            if (dark.luma() > light.luma()) {
                var t = light;
                light = dark;
                dark = t;
            }
            if (typeof threshold === 'undefined') {
                threshold = 0.43;
            }
            else {
                threshold = number(threshold);
            }
            if (color.luma() < threshold) {
                return light;
            }
            else {
                return dark;
            }
        },
        // Changes made in 2.7.0 - Reverted in 3.0.0
        // contrast: function (color, color1, color2, threshold) {
        //     // Return which of `color1` and `color2` has the greatest contrast with `color`
        //     // according to the standard WCAG contrast ratio calculation.
        //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        //     // The threshold param is no longer used, in line with SASS.
        //     // filter: contrast(3.2);
        //     // should be kept as is, so check for color
        //     if (!color.rgb) {
        //         return null;
        //     }
        //     if (typeof color1 === 'undefined') {
        //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);
        //     }
        //     if (typeof color2 === 'undefined') {
        //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);
        //     }
        //     var contrast1, contrast2;
        //     var luma = color.luma();
        //     var luma1 = color1.luma();
        //     var luma2 = color2.luma();
        //     // Calculate contrast ratios for each color
        //     if (luma > luma1) {
        //         contrast1 = (luma + 0.05) / (luma1 + 0.05);
        //     } else {
        //         contrast1 = (luma1 + 0.05) / (luma + 0.05);
        //     }
        //     if (luma > luma2) {
        //         contrast2 = (luma + 0.05) / (luma2 + 0.05);
        //     } else {
        //         contrast2 = (luma2 + 0.05) / (luma + 0.05);
        //     }
        //     if (contrast1 > contrast2) {
        //         return color1;
        //     } else {
        //         return color2;
        //     }
        // },
        argb: function (color) {
            return new Anonymous(color.toARGB());
        },
        color: function (c) {
            if ((c instanceof Quoted) &&
                (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {
                var val = c.value.slice(1);
                return new Color(val, undefined, "#" + val);
            }
            if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {
                c.value = undefined;
                return c;
            }
            throw {
                type: 'Argument',
                message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'
            };
        },
        tint: function (color, amount) {
            return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);
        },
        shade: function (color, amount) {
            return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);
        }
    };
    var color = colorFunctions;

    // Color Blending
    // ref: http://www.w3.org/TR/compositing-1
    function colorBlend(mode, color1, color2) {
        var ab = color1.alpha; // result
        var // backdrop
        cb;
        var as = color2.alpha;
        var // source
        cs;
        var ar;
        var cr;
        var r = [];
        ar = as + ab * (1 - as);
        for (var i = 0; i < 3; i++) {
            cb = color1.rgb[i] / 255;
            cs = color2.rgb[i] / 255;
            cr = mode(cb, cs);
            if (ar) {
                cr = (as * cs + ab * (cb -
                    as * (cb + cs - cr))) / ar;
            }
            r[i] = cr * 255;
        }
        return new Color(r, ar);
    }
    var colorBlendModeFunctions = {
        multiply: function (cb, cs) {
            return cb * cs;
        },
        screen: function (cb, cs) {
            return cb + cs - cb * cs;
        },
        overlay: function (cb, cs) {
            cb *= 2;
            return (cb <= 1) ?
                colorBlendModeFunctions.multiply(cb, cs) :
                colorBlendModeFunctions.screen(cb - 1, cs);
        },
        softlight: function (cb, cs) {
            var d = 1;
            var e = cb;
            if (cs > 0.5) {
                e = 1;
                d = (cb > 0.25) ? Math.sqrt(cb)
                    : ((16 * cb - 12) * cb + 4) * cb;
            }
            return cb - (1 - 2 * cs) * e * (d - cb);
        },
        hardlight: function (cb, cs) {
            return colorBlendModeFunctions.overlay(cs, cb);
        },
        difference: function (cb, cs) {
            return Math.abs(cb - cs);
        },
        exclusion: function (cb, cs) {
            return cb + cs - 2 * cb * cs;
        },
        // non-w3c functions:
        average: function (cb, cs) {
            return (cb + cs) / 2;
        },
        negation: function (cb, cs) {
            return 1 - Math.abs(cb + cs - 1);
        }
    };
    for (var f in colorBlendModeFunctions) {
        if (colorBlendModeFunctions.hasOwnProperty(f)) {
            colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);
        }
    }

    var dataUri = (function (environment) {
        var fallback = function (functionThis, node) { return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context); };
        return { 'data-uri': function (mimetypeNode, filePathNode) {
                if (!filePathNode) {
                    filePathNode = mimetypeNode;
                    mimetypeNode = null;
                }
                var mimetype = mimetypeNode && mimetypeNode.value;
                var filePath = filePathNode.value;
                var currentFileInfo = this.currentFileInfo;
                var currentDirectory = currentFileInfo.rewriteUrls ?
                    currentFileInfo.currentDirectory : currentFileInfo.entryPath;
                var fragmentStart = filePath.indexOf('#');
                var fragment = '';
                if (fragmentStart !== -1) {
                    fragment = filePath.slice(fragmentStart);
                    filePath = filePath.slice(0, fragmentStart);
                }
                var context = clone(this.context);
                context.rawBuffer = true;
                var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);
                if (!fileManager) {
                    return fallback(this, filePathNode);
                }
                var useBase64 = false;
                // detect the mimetype if not given
                if (!mimetypeNode) {
                    mimetype = environment.mimeLookup(filePath);
                    if (mimetype === 'image/svg+xml') {
                        useBase64 = false;
                    }
                    else {
                        // use base 64 unless it's an ASCII or UTF-8 format
                        var charset = environment.charsetLookup(mimetype);
                        useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;
                    }
                    if (useBase64) {
                        mimetype += ';base64';
                    }
                }
                else {
                    useBase64 = /;base64$/.test(mimetype);
                }
                var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);
                if (!fileSync.contents) {
                    logger.warn("Skipped data-uri embedding of " + filePath + " because file not found");
                    return fallback(this, filePathNode || mimetypeNode);
                }
                var buf = fileSync.contents;
                if (useBase64 && !environment.encodeBase64) {
                    return fallback(this, filePathNode);
                }
                buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);
                var uri = "data:" + mimetype + "," + buf + fragment;
                return new URL(new Quoted("\"" + uri + "\"", uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
            } };
    });

    var getItemsFromNode = function (node) {
        // handle non-array values as an array of length 1
        // return 'undefined' if index is invalid
        var items = Array.isArray(node.value) ?
            node.value : Array(node);
        return items;
    };
    var list = {
        _SELF: function (n) {
            return n;
        },
        '~': function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i] = arguments[_i];
            }
            if (expr.length === 1) {
                return expr[0];
            }
            return new Value(expr);
        },
        extract: function (values, index) {
            // (1-based index)
            index = index.value - 1;
            return getItemsFromNode(values)[index];
        },
        length: function (values) {
            return new Dimension(getItemsFromNode(values).length);
        },
        /**
         * Creates a Less list of incremental values.
         * Modeled after Lodash's range function, also exists natively in PHP
         *
         * @param {Dimension} [start=1]
         * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output
         * @param {Dimension} [step=1]
         */
        range: function (start, end, step) {
            var from;
            var to;
            var stepValue = 1;
            var list = [];
            if (end) {
                to = end;
                from = start.value;
                if (step) {
                    stepValue = step.value;
                }
            }
            else {
                from = 1;
                to = start;
            }
            for (var i = from; i <= to.value; i += stepValue) {
                list.push(new Dimension(i, to.unit));
            }
            return new Expression(list);
        },
        each: function (list, rs) {
            var _this = this;
            var rules = [];
            var newRules;
            var iterator;
            var tryEval = function (val) {
                if (val instanceof Node) {
                    return val.eval(_this.context);
                }
                return val;
            };
            if (list.value && !(list instanceof Quoted)) {
                if (Array.isArray(list.value)) {
                    iterator = list.value.map(tryEval);
                }
                else {
                    iterator = [tryEval(list.value)];
                }
            }
            else if (list.ruleset) {
                iterator = tryEval(list.ruleset).rules;
            }
            else if (list.rules) {
                iterator = list.rules.map(tryEval);
            }
            else if (Array.isArray(list)) {
                iterator = list.map(tryEval);
            }
            else {
                iterator = [tryEval(list)];
            }
            var valueName = '@value';
            var keyName = '@key';
            var indexName = '@index';
            if (rs.params) {
                valueName = rs.params[0] && rs.params[0].name;
                keyName = rs.params[1] && rs.params[1].name;
                indexName = rs.params[2] && rs.params[2].name;
                rs = rs.rules;
            }
            else {
                rs = rs.ruleset;
            }
            for (var i = 0; i < iterator.length; i++) {
                var key = void 0;
                var value = void 0;
                var item = iterator[i];
                if (item instanceof Declaration) {
                    key = typeof item.name === 'string' ? item.name : item.name[0].value;
                    value = item.value;
                }
                else {
                    key = new Dimension(i + 1);
                    value = item;
                }
                if (item instanceof Comment) {
                    continue;
                }
                newRules = rs.rules.slice(0);
                if (valueName) {
                    newRules.push(new Declaration(valueName, value, false, false, this.index, this.currentFileInfo));
                }
                if (indexName) {
                    newRules.push(new Declaration(indexName, new Dimension(i + 1), false, false, this.index, this.currentFileInfo));
                }
                if (keyName) {
                    newRules.push(new Declaration(keyName, key, false, false, this.index, this.currentFileInfo));
                }
                rules.push(new Ruleset([new (Selector)([new Element("", '&')])], newRules, rs.strictImports, rs.visibilityInfo()));
            }
            return new Ruleset([new (Selector)([new Element("", '&')])], rules, rs.strictImports, rs.visibilityInfo()).eval(this.context);
        }
    };

    var MathHelper = function (fn, unit, n) {
        if (!(n instanceof Dimension)) {
            throw { type: 'Argument', message: 'argument must be a number' };
        }
        if (unit == null) {
            unit = n.unit;
        }
        else {
            n = n.unify();
        }
        return new Dimension(fn(parseFloat(n.value)), unit);
    };

    var mathFunctions = {
        // name,  unit
        ceil: null,
        floor: null,
        sqrt: null,
        abs: null,
        tan: '',
        sin: '',
        cos: '',
        atan: 'rad',
        asin: 'rad',
        acos: 'rad'
    };
    for (var f$1 in mathFunctions) {
        if (mathFunctions.hasOwnProperty(f$1)) {
            mathFunctions[f$1] = MathHelper.bind(null, Math[f$1], mathFunctions[f$1]);
        }
    }
    mathFunctions.round = function (n, f) {
        var fraction = typeof f === 'undefined' ? 0 : f.value;
        return MathHelper(function (num) { return num.toFixed(fraction); }, null, n);
    };

    var minMax = function (isMin, args) {
        args = Array.prototype.slice.call(args);
        switch (args.length) {
            case 0: throw { type: 'Argument', message: 'one or more arguments required' };
        }
        var i; // key is the unit.toString() for unified Dimension values,
        var j;
        var current;
        var currentUnified;
        var referenceUnified;
        var unit;
        var unitStatic;
        var unitClone;
        var // elems only contains original argument values.
        order = [];
        var values = {};
        // value is the index into the order array.
        for (i = 0; i < args.length; i++) {
            current = args[i];
            if (!(current instanceof Dimension)) {
                if (Array.isArray(args[i].value)) {
                    Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
                }
                continue;
            }
            currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();
            unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
            unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;
            unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;
            j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];
            if (j === undefined) {
                if (unitStatic !== undefined && unit !== unitStatic) {
                    throw { type: 'Argument', message: 'incompatible types' };
                }
                values[unit] = order.length;
                order.push(current);
                continue;
            }
            referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();
            if (isMin && currentUnified.value < referenceUnified.value ||
                !isMin && currentUnified.value > referenceUnified.value) {
                order[j] = current;
            }
        }
        if (order.length == 1) {
            return order[0];
        }
        args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');
        return new Anonymous((isMin ? 'min' : 'max') + "(" + args + ")");
    };
    var number$1 = {
        min: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return minMax(true, args);
            }
            catch (e) { }
        },
        max: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                return minMax(false, args);
            }
            catch (e) { }
        },
        convert: function (val, unit) {
            return val.convertTo(unit.value);
        },
        pi: function () {
            return new Dimension(Math.PI);
        },
        mod: function (a, b) {
            return new Dimension(a.value % b.value, a.unit);
        },
        pow: function (x, y) {
            if (typeof x === 'number' && typeof y === 'number') {
                x = new Dimension(x);
                y = new Dimension(y);
            }
            else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {
                throw { type: 'Argument', message: 'arguments must be numbers' };
            }
            return new Dimension(Math.pow(x.value, y.value), x.unit);
        },
        percentage: function (n) {
            var result = MathHelper(function (num) { return num * 100; }, '%', n);
            return result;
        }
    };

    var string = {
        e: function (str) {
            return new Quoted('"', str instanceof JavaScript ? str.evaluated : str.value, true);
        },
        escape: function (str) {
            return new Anonymous(encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')
                .replace(/\(/g, '%28').replace(/\)/g, '%29'));
        },
        replace: function (string, pattern, replacement, flags) {
            var result = string.value;
            replacement = (replacement.type === 'Quoted') ?
                replacement.value : replacement.toCSS();
            result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);
            return new Quoted(string.quote || '', result, string.escaped);
        },
        '%': function (string /* arg, arg, ... */) {
            var args = Array.prototype.slice.call(arguments, 1);
            var result = string.value;
            var _loop_1 = function (i) {
                /* jshint loopfunc:true */
                result = result.replace(/%[sda]/i, function (token) {
                    var value = ((args[i].type === 'Quoted') &&
                        token.match(/s/i)) ? args[i].value : args[i].toCSS();
                    return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
                });
            };
            for (var i = 0; i < args.length; i++) {
                _loop_1(i);
            }
            result = result.replace(/%%/g, '%');
            return new Quoted(string.quote || '', result, string.escaped);
        }
    };

    var svg = (function (environment) {
        return { 'svg-gradient': function (direction) {
                var stops;
                var gradientDirectionSvg;
                var gradientType = 'linear';
                var rectangleDimension = 'x="0" y="0" width="1" height="1"';
                var renderEnv = { compress: false };
                var returner;
                var directionValue = direction.toCSS(renderEnv);
                var i;
                var color;
                var position;
                var positionValue;
                var alpha;
                function throwArgumentDescriptor() {
                    throw { type: 'Argument',
                        message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +
                            ' end_color [end_position] or direction, color list' };
                }
                if (arguments.length == 2) {
                    if (arguments[1].value.length < 2) {
                        throwArgumentDescriptor();
                    }
                    stops = arguments[1].value;
                }
                else if (arguments.length < 3) {
                    throwArgumentDescriptor();
                }
                else {
                    stops = Array.prototype.slice.call(arguments, 1);
                }
                switch (directionValue) {
                    case 'to bottom':
                        gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
                        break;
                    case 'to right':
                        gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
                        break;
                    case 'to bottom right':
                        gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
                        break;
                    case 'to top right':
                        gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
                        break;
                    case 'ellipse':
                    case 'ellipse at center':
                        gradientType = 'radial';
                        gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
                        rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
                        break;
                    default:
                        throw { type: 'Argument', message: 'svg-gradient direction must be \'to bottom\', \'to right\',' +
                                ' \'to bottom right\', \'to top right\' or \'ellipse at center\'' };
                }
                returner = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"><" + gradientType + "Gradient id=\"g\" " + gradientDirectionSvg + ">";
                for (i = 0; i < stops.length; i += 1) {
                    if (stops[i] instanceof Expression) {
                        color = stops[i].value[0];
                        position = stops[i].value[1];
                    }
                    else {
                        color = stops[i];
                        position = undefined;
                    }
                    if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {
                        throwArgumentDescriptor();
                    }
                    positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';
                    alpha = color.alpha;
                    returner += "<stop offset=\"" + positionValue + "\" stop-color=\"" + color.toRGB() + "\"" + (alpha < 1 ? " stop-opacity=\"" + alpha + "\"" : '') + "/>";
                }
                returner += "</" + gradientType + "Gradient><rect " + rectangleDimension + " fill=\"url(#g)\" /></svg>";
                returner = encodeURIComponent(returner);
                returner = "data:image/svg+xml," + returner;
                return new URL(new Quoted("'" + returner + "'", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
            } };
    });

    var isa = function (n, Type) { return (n instanceof Type) ? Keyword.True : Keyword.False; };
    var isunit = function (n, unit) {
        if (unit === undefined) {
            throw { type: 'Argument', message: 'missing the required second argument to isunit.' };
        }
        unit = typeof unit.value === 'string' ? unit.value : unit;
        if (typeof unit !== 'string') {
            throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };
        }
        return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;
    };
    var types = {
        isruleset: function (n) {
            return isa(n, DetachedRuleset);
        },
        iscolor: function (n) {
            return isa(n, Color);
        },
        isnumber: function (n) {
            return isa(n, Dimension);
        },
        isstring: function (n) {
            return isa(n, Quoted);
        },
        iskeyword: function (n) {
            return isa(n, Keyword);
        },
        isurl: function (n) {
            return isa(n, URL);
        },
        ispixel: function (n) {
            return isunit(n, 'px');
        },
        ispercentage: function (n) {
            return isunit(n, '%');
        },
        isem: function (n) {
            return isunit(n, 'em');
        },
        isunit: isunit,
        unit: function (val, unit) {
            if (!(val instanceof Dimension)) {
                throw { type: 'Argument', message: "the first argument to unit must be a number" + (val instanceof Operation ? '. Have you forgotten parenthesis?' : '') };
            }
            if (unit) {
                if (unit instanceof Keyword) {
                    unit = unit.value;
                }
                else {
                    unit = unit.toCSS();
                }
            }
            else {
                unit = '';
            }
            return new Dimension(val.value, unit);
        },
        'get-unit': function (n) {
            return new Anonymous(n.unit);
        }
    };

    var functions = (function (environment) {
        var functions = { functionRegistry: functionRegistry, functionCaller: functionCaller };
        // register functions
        functionRegistry.addMultiple(boolean$1);
        functionRegistry.add('default', defaultFunc.eval.bind(defaultFunc));
        functionRegistry.addMultiple(color);
        functionRegistry.addMultiple(colorBlend);
        functionRegistry.addMultiple(dataUri(environment));
        functionRegistry.addMultiple(list);
        functionRegistry.addMultiple(mathFunctions);
        functionRegistry.addMultiple(number$1);
        functionRegistry.addMultiple(string);
        functionRegistry.addMultiple(svg());
        functionRegistry.addMultiple(types);
        return functions;
    });

    function transformTree (root, options) {
        options = options || {};
        var evaldRoot;
        var variables = options.variables;
        var evalEnv = new contexts.Eval(options);
        //
        // Allows setting variables with a hash, so:
        //
        //   `{ color: new tree.Color('#f01') }` will become:
        //
        //   new tree.Declaration('@color',
        //     new tree.Value([
        //       new tree.Expression([
        //         new tree.Color('#f01')
        //       ])
        //     ])
        //   )
        //
        if (typeof variables === 'object' && !Array.isArray(variables)) {
            variables = Object.keys(variables).map(function (k) {
                var value = variables[k];
                if (!(value instanceof tree.Value)) {
                    if (!(value instanceof tree.Expression)) {
                        value = new tree.Expression([value]);
                    }
                    value = new tree.Value([value]);
                }
                return new tree.Declaration("@" + k, value, false, null, 0);
            });
            evalEnv.frames = [new tree.Ruleset(null, variables)];
        }
        var visitors$1 = [
            new visitors.JoinSelectorVisitor(),
            new visitors.MarkVisibleSelectorsVisitor(true),
            new visitors.ExtendVisitor(),
            new visitors.ToCSSVisitor({ compress: Boolean(options.compress) })
        ];
        var preEvalVisitors = [];
        var v;
        var visitorIterator;
        /**
         * first() / get() allows visitors to be added while visiting
         *
         * @todo Add scoping for visitors just like functions for @plugin; right now they're global
         */
        if (options.pluginManager) {
            visitorIterator = options.pluginManager.visitor();
            for (var i = 0; i < 2; i++) {
                visitorIterator.first();
                while ((v = visitorIterator.get())) {
                    if (v.isPreEvalVisitor) {
                        if (i === 0 || preEvalVisitors.indexOf(v) === -1) {
                            preEvalVisitors.push(v);
                            v.run(root);
                        }
                    }
                    else {
                        if (i === 0 || visitors$1.indexOf(v) === -1) {
                            if (v.isPreVisitor) {
                                visitors$1.unshift(v);
                            }
                            else {
                                visitors$1.push(v);
                            }
                        }
                    }
                }
            }
        }
        evaldRoot = root.eval(evalEnv);
        for (var i = 0; i < visitors$1.length; i++) {
            visitors$1[i].run(evaldRoot);
        }
        // Run any remaining visitors added after eval pass
        if (options.pluginManager) {
            visitorIterator.first();
            while ((v = visitorIterator.get())) {
                if (visitors$1.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {
                    v.run(evaldRoot);
                }
            }
        }
        return evaldRoot;
    }

    /**
     * Plugin Manager
     */
    var PluginManager = /** @class */ (function () {
        function PluginManager(less) {
            this.less = less;
            this.visitors = [];
            this.preProcessors = [];
            this.postProcessors = [];
            this.installedPlugins = [];
            this.fileManagers = [];
            this.iterator = -1;
            this.pluginCache = {};
            this.Loader = new less.PluginLoader(less);
        }
        /**
         * Adds all the plugins in the array
         * @param {Array} plugins
         */
        PluginManager.prototype.addPlugins = function (plugins) {
            if (plugins) {
                for (var i = 0; i < plugins.length; i++) {
                    this.addPlugin(plugins[i]);
                }
            }
        };
        /**
         *
         * @param plugin
         * @param {String} filename
         */
        PluginManager.prototype.addPlugin = function (plugin, filename, functionRegistry) {
            this.installedPlugins.push(plugin);
            if (filename) {
                this.pluginCache[filename] = plugin;
            }
            if (plugin.install) {
                plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);
            }
        };
        /**
         *
         * @param filename
         */
        PluginManager.prototype.get = function (filename) {
            return this.pluginCache[filename];
        };
        /**
         * Adds a visitor. The visitor object has options on itself to determine
         * when it should run.
         * @param visitor
         */
        PluginManager.prototype.addVisitor = function (visitor) {
            this.visitors.push(visitor);
        };
        /**
         * Adds a pre processor object
         * @param {object} preProcessor
         * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import
         */
        PluginManager.prototype.addPreProcessor = function (preProcessor, priority) {
            var indexToInsertAt;
            for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
                if (this.preProcessors[indexToInsertAt].priority >= priority) {
                    break;
                }
            }
            this.preProcessors.splice(indexToInsertAt, 0, { preProcessor: preProcessor, priority: priority });
        };
        /**
         * Adds a post processor object
         * @param {object} postProcessor
         * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression
         */
        PluginManager.prototype.addPostProcessor = function (postProcessor, priority) {
            var indexToInsertAt;
            for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
                if (this.postProcessors[indexToInsertAt].priority >= priority) {
                    break;
                }
            }
            this.postProcessors.splice(indexToInsertAt, 0, { postProcessor: postProcessor, priority: priority });
        };
        /**
         *
         * @param manager
         */
        PluginManager.prototype.addFileManager = function (manager) {
            this.fileManagers.push(manager);
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getPreProcessors = function () {
            var preProcessors = [];
            for (var i = 0; i < this.preProcessors.length; i++) {
                preProcessors.push(this.preProcessors[i].preProcessor);
            }
            return preProcessors;
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getPostProcessors = function () {
            var postProcessors = [];
            for (var i = 0; i < this.postProcessors.length; i++) {
                postProcessors.push(this.postProcessors[i].postProcessor);
            }
            return postProcessors;
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getVisitors = function () {
            return this.visitors;
        };
        PluginManager.prototype.visitor = function () {
            var self = this;
            return {
                first: function () {
                    self.iterator = -1;
                    return self.visitors[self.iterator];
                },
                get: function () {
                    self.iterator += 1;
                    return self.visitors[self.iterator];
                }
            };
        };
        /**
         *
         * @returns {Array}
         * @private
         */
        PluginManager.prototype.getFileManagers = function () {
            return this.fileManagers;
        };
        return PluginManager;
    }());
    var pm;
    var PluginManagerFactory = function (less, newFactory) {
        if (newFactory || !pm) {
            pm = new PluginManager(less);
        }
        return pm;
    };

    function SourceMapOutput (environment) {
        var SourceMapOutput = /** @class */ (function () {
            function SourceMapOutput(options) {
                this._css = [];
                this._rootNode = options.rootNode;
                this._contentsMap = options.contentsMap;
                this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;
                if (options.sourceMapFilename) {
                    this._sourceMapFilename = options.sourceMapFilename.replace(/\\/g, '/');
                }
                this._outputFilename = options.outputFilename;
                this.sourceMapURL = options.sourceMapURL;
                if (options.sourceMapBasepath) {
                    this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\/g, '/');
                }
                if (options.sourceMapRootpath) {
                    this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\/g, '/');
                    if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {
                        this._sourceMapRootpath += '/';
                    }
                }
                else {
                    this._sourceMapRootpath = '';
                }
                this._outputSourceFiles = options.outputSourceFiles;
                this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();
                this._lineNumber = 0;
                this._column = 0;
            }
            SourceMapOutput.prototype.removeBasepath = function (path) {
                if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {
                    path = path.substring(this._sourceMapBasepath.length);
                    if (path.charAt(0) === '\\' || path.charAt(0) === '/') {
                        path = path.substring(1);
                    }
                }
                return path;
            };
            SourceMapOutput.prototype.normalizeFilename = function (filename) {
                filename = filename.replace(/\\/g, '/');
                filename = this.removeBasepath(filename);
                return (this._sourceMapRootpath || '') + filename;
            };
            SourceMapOutput.prototype.add = function (chunk, fileInfo, index, mapLines) {
                // ignore adding empty strings
                if (!chunk) {
                    return;
                }
                var lines, sourceLines, columns, sourceColumns, i;
                if (fileInfo && fileInfo.filename) {
                    var inputSource = this._contentsMap[fileInfo.filename];
                    // remove vars/banner added to the top of the file
                    if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
                        // adjust the index
                        index -= this._contentsIgnoredCharsMap[fileInfo.filename];
                        if (index < 0) {
                            index = 0;
                        }
                        // adjust the source
                        inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
                    }
                    /**
                     * ignore empty content, or failsafe
                     * if contents map is incorrect
                     */
                    if (inputSource === undefined) {
                        this._css.push(chunk);
                        return;
                    }
                    inputSource = inputSource.substring(0, index);
                    sourceLines = inputSource.split('\n');
                    sourceColumns = sourceLines[sourceLines.length - 1];
                }
                lines = chunk.split('\n');
                columns = lines[lines.length - 1];
                if (fileInfo && fileInfo.filename) {
                    if (!mapLines) {
                        this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column },
                            original: { line: sourceLines.length, column: sourceColumns.length },
                            source: this.normalizeFilename(fileInfo.filename) });
                    }
                    else {
                        for (i = 0; i < lines.length; i++) {
                            this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0 },
                                original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0 },
                                source: this.normalizeFilename(fileInfo.filename) });
                        }
                    }
                }
                if (lines.length === 1) {
                    this._column += columns.length;
                }
                else {
                    this._lineNumber += lines.length - 1;
                    this._column = columns.length;
                }
                this._css.push(chunk);
            };
            SourceMapOutput.prototype.isEmpty = function () {
                return this._css.length === 0;
            };
            SourceMapOutput.prototype.toCSS = function (context) {
                this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });
                if (this._outputSourceFiles) {
                    for (var filename in this._contentsMap) {
                        if (this._contentsMap.hasOwnProperty(filename)) {
                            var source = this._contentsMap[filename];
                            if (this._contentsIgnoredCharsMap[filename]) {
                                source = source.slice(this._contentsIgnoredCharsMap[filename]);
                            }
                            this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
                        }
                    }
                }
                this._rootNode.genCSS(context, this);
                if (this._css.length > 0) {
                    var sourceMapURL = void 0;
                    var sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());
                    if (this.sourceMapURL) {
                        sourceMapURL = this.sourceMapURL;
                    }
                    else if (this._sourceMapFilename) {
                        sourceMapURL = this._sourceMapFilename;
                    }
                    this.sourceMapURL = sourceMapURL;
                    this.sourceMap = sourceMapContent;
                }
                return this._css.join('');
            };
            return SourceMapOutput;
        }());
        return SourceMapOutput;
    }

    function SourceMapBuilder (SourceMapOutput, environment) {
        var SourceMapBuilder = /** @class */ (function () {
            function SourceMapBuilder(options) {
                this.options = options;
            }
            SourceMapBuilder.prototype.toCSS = function (rootNode, options, imports) {
                var sourceMapOutput = new SourceMapOutput({
                    contentsIgnoredCharsMap: imports.contentsIgnoredChars,
                    rootNode: rootNode,
                    contentsMap: imports.contents,
                    sourceMapFilename: this.options.sourceMapFilename,
                    sourceMapURL: this.options.sourceMapURL,
                    outputFilename: this.options.sourceMapOutputFilename,
                    sourceMapBasepath: this.options.sourceMapBasepath,
                    sourceMapRootpath: this.options.sourceMapRootpath,
                    outputSourceFiles: this.options.outputSourceFiles,
                    sourceMapGenerator: this.options.sourceMapGenerator,
                    sourceMapFileInline: this.options.sourceMapFileInline,
                    disableSourcemapAnnotation: this.options.disableSourcemapAnnotation
                });
                var css = sourceMapOutput.toCSS(options);
                this.sourceMap = sourceMapOutput.sourceMap;
                this.sourceMapURL = sourceMapOutput.sourceMapURL;
                if (this.options.sourceMapInputFilename) {
                    this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
                }
                if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {
                    this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);
                }
                return css + this.getCSSAppendage();
            };
            SourceMapBuilder.prototype.getCSSAppendage = function () {
                var sourceMapURL = this.sourceMapURL;
                if (this.options.sourceMapFileInline) {
                    if (this.sourceMap === undefined) {
                        return '';
                    }
                    sourceMapURL = "data:application/json;base64," + environment.encodeBase64(this.sourceMap);
                }
                if (this.options.disableSourcemapAnnotation) {
                    return '';
                }
                if (sourceMapURL) {
                    return "/*# sourceMappingURL=" + sourceMapURL + " */";
                }
                return '';
            };
            SourceMapBuilder.prototype.getExternalSourceMap = function () {
                return this.sourceMap;
            };
            SourceMapBuilder.prototype.setExternalSourceMap = function (sourceMap) {
                this.sourceMap = sourceMap;
            };
            SourceMapBuilder.prototype.isInline = function () {
                return this.options.sourceMapFileInline;
            };
            SourceMapBuilder.prototype.getSourceMapURL = function () {
                return this.sourceMapURL;
            };
            SourceMapBuilder.prototype.getOutputFilename = function () {
                return this.options.sourceMapOutputFilename;
            };
            SourceMapBuilder.prototype.getInputFilename = function () {
                return this.sourceMapInputFilename;
            };
            return SourceMapBuilder;
        }());
        return SourceMapBuilder;
    }

    function ParseTree (SourceMapBuilder) {
        var ParseTree = /** @class */ (function () {
            function ParseTree(root, imports) {
                this.root = root;
                this.imports = imports;
            }
            ParseTree.prototype.toCSS = function (options) {
                var evaldRoot;
                var result = {};
                var sourceMapBuilder;
                try {
                    evaldRoot = transformTree(this.root, options);
                }
                catch (e) {
                    throw new LessError(e, this.imports);
                }
                try {
                    var compress = Boolean(options.compress);
                    if (compress) {
                        logger.warn('The compress option has been deprecated. ' +
                            'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');
                    }
                    var toCSSOptions = {
                        compress: compress,
                        dumpLineNumbers: options.dumpLineNumbers,
                        strictUnits: Boolean(options.strictUnits),
                        numPrecision: 8
                    };
                    if (options.sourceMap) {
                        sourceMapBuilder = new SourceMapBuilder(options.sourceMap);
                        result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
                    }
                    else {
                        result.css = evaldRoot.toCSS(toCSSOptions);
                    }
                }
                catch (e) {
                    throw new LessError(e, this.imports);
                }
                if (options.pluginManager) {
                    var postProcessors = options.pluginManager.getPostProcessors();
                    for (var i = 0; i < postProcessors.length; i++) {
                        result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });
                    }
                }
                if (options.sourceMap) {
                    result.map = sourceMapBuilder.getExternalSourceMap();
                }
                result.imports = [];
                for (var file in this.imports.files) {
                    if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {
                        result.imports.push(file);
                    }
                }
                return result;
            };
            return ParseTree;
        }());
        return ParseTree;
    }

    function ImportManager (environment) {
        // FileInfo = {
        //  'rewriteUrls' - option - whether to adjust URL's to be relative
        //  'filename' - full resolved filename of current file
        //  'rootpath' - path to append to normal URLs for this node
        //  'currentDirectory' - path to the current file, absolute
        //  'rootFilename' - filename of the base file
        //  'entryPath' - absolute path to the entry file
        //  'reference' - whether the file should not be output and only output parts that are referenced
        var ImportManager = /** @class */ (function () {
            function ImportManager(less, context, rootFileInfo) {
                this.less = less;
                this.rootFilename = rootFileInfo.filename;
                this.paths = context.paths || []; // Search paths, when importing
                this.contents = {}; // map - filename to contents of all the files
                this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore
                this.mime = context.mime;
                this.error = null;
                this.context = context;
                // Deprecated? Unused outside of here, could be useful.
                this.queue = []; // Files which haven't been imported yet
                this.files = {}; // Holds the imported parse trees.
            }
            /**
             * Add an import to be imported
             * @param path - the raw path
             * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)
             * @param currentFileInfo - the current file info (used for instance to work out relative paths)
             * @param importOptions - import options
             * @param callback - callback for when it is imported
             */
            ImportManager.prototype.push = function (path, tryAppendExtension, currentFileInfo, importOptions, callback) {
                var importManager = this, pluginLoader = this.context.pluginManager.Loader;
                this.queue.push(path);
                var fileParsedFunc = function (e, root, fullPath) {
                    importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue
                    var importedEqualsRoot = fullPath === importManager.rootFilename;
                    if (importOptions.optional && e) {
                        callback(null, { rules: [] }, false, null);
                        logger.info("The file " + fullPath + " was skipped because it was not found and the import was marked optional.");
                    }
                    else {
                        // Inline imports aren't cached here.
                        // If we start to cache them, please make sure they won't conflict with non-inline imports of the
                        // same name as they used to do before this comment and the condition below have been added.
                        if (!importManager.files[fullPath] && !importOptions.inline) {
                            importManager.files[fullPath] = { root: root, options: importOptions };
                        }
                        if (e && !importManager.error) {
                            importManager.error = e;
                        }
                        callback(e, root, importedEqualsRoot, fullPath);
                    }
                };
                var newFileInfo = {
                    rewriteUrls: this.context.rewriteUrls,
                    entryPath: currentFileInfo.entryPath,
                    rootpath: currentFileInfo.rootpath,
                    rootFilename: currentFileInfo.rootFilename
                };
                var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);
                if (!fileManager) {
                    fileParsedFunc({ message: "Could not find a file-manager for " + path });
                    return;
                }
                var loadFileCallback = function (loadedFile) {
                    var plugin;
                    var resolvedFilename = loadedFile.filename;
                    var contents = loadedFile.contents.replace(/^\uFEFF/, '');
                    // Pass on an updated rootpath if path of imported file is relative and file
                    // is in a (sub|sup) directory
                    //
                    // Examples:
                    // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',
                    //   then rootpath should become 'less/module/nav/'
                    // - If path of imported file is '../mixins.less' and rootpath is 'less/',
                    //   then rootpath should become 'less/../'
                    newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
                    if (newFileInfo.rewriteUrls) {
                        newFileInfo.rootpath = fileManager.join((importManager.context.rootpath || ''), fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));
                        if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
                            newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
                        }
                    }
                    newFileInfo.filename = resolvedFilename;
                    var newEnv = new contexts.Parse(importManager.context);
                    newEnv.processImports = false;
                    importManager.contents[resolvedFilename] = contents;
                    if (currentFileInfo.reference || importOptions.reference) {
                        newFileInfo.reference = true;
                    }
                    if (importOptions.isPlugin) {
                        plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);
                        if (plugin instanceof LessError) {
                            fileParsedFunc(plugin, null, resolvedFilename);
                        }
                        else {
                            fileParsedFunc(null, plugin, resolvedFilename);
                        }
                    }
                    else if (importOptions.inline) {
                        fileParsedFunc(null, contents, resolvedFilename);
                    }
                    else {
                        // import (multiple) parse trees apparently get altered and can't be cached.
                        // TODO: investigate why this is
                        if (importManager.files[resolvedFilename]
                            && !importManager.files[resolvedFilename].options.multiple
                            && !importOptions.multiple) {
                            fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);
                        }
                        else {
                            new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {
                                fileParsedFunc(e, root, resolvedFilename);
                            });
                        }
                    }
                };
                var loadedFile;
                var promise;
                var context = clone(this.context);
                if (tryAppendExtension) {
                    context.ext = importOptions.isPlugin ? '.js' : '.less';
                }
                if (importOptions.isPlugin) {
                    context.mime = 'application/javascript';
                    if (context.syncImport) {
                        loadedFile = pluginLoader.loadPluginSync(path, currentFileInfo.currentDirectory, context, environment, fileManager);
                    }
                    else {
                        promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);
                    }
                }
                else {
                    if (context.syncImport) {
                        loadedFile = fileManager.loadFileSync(path, currentFileInfo.currentDirectory, context, environment);
                    }
                    else {
                        promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment, function (err, loadedFile) {
                            if (err) {
                                fileParsedFunc(err);
                            }
                            else {
                                loadFileCallback(loadedFile);
                            }
                        });
                    }
                }
                if (loadedFile) {
                    if (!loadedFile.filename) {
                        fileParsedFunc(loadedFile);
                    }
                    else {
                        loadFileCallback(loadedFile);
                    }
                }
                else if (promise) {
                    promise.then(loadFileCallback, fileParsedFunc);
                }
            };
            return ImportManager;
        }());
        return ImportManager;
    }

    function Parse (environment, ParseTree, ImportManager) {
        var parse = function (input, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = copyOptions(this.options, {});
            }
            else {
                options = copyOptions(this.options, options || {});
            }
            if (!callback) {
                var self_1 = this;
                return new Promise(function (resolve, reject) {
                    parse.call(self_1, input, options, function (err, output) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(output);
                        }
                    });
                });
            }
            else {
                var context_1;
                var rootFileInfo = void 0;
                var pluginManager_1 = new PluginManagerFactory(this, !options.reUsePluginManager);
                options.pluginManager = pluginManager_1;
                context_1 = new contexts.Parse(options);
                if (options.rootFileInfo) {
                    rootFileInfo = options.rootFileInfo;
                }
                else {
                    var filename = options.filename || 'input';
                    var entryPath = filename.replace(/[^\/\\]*$/, '');
                    rootFileInfo = {
                        filename: filename,
                        rewriteUrls: context_1.rewriteUrls,
                        rootpath: context_1.rootpath || '',
                        currentDirectory: entryPath,
                        entryPath: entryPath,
                        rootFilename: filename
                    };
                    // add in a missing trailing slash
                    if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {
                        rootFileInfo.rootpath += '/';
                    }
                }
                var imports_1 = new ImportManager(this, context_1, rootFileInfo);
                this.importManager = imports_1;
                // TODO: allow the plugins to be just a list of paths or names
                // Do an async plugin queue like lessc
                if (options.plugins) {
                    options.plugins.forEach(function (plugin) {
                        var evalResult, contents;
                        if (plugin.fileContent) {
                            contents = plugin.fileContent.replace(/^\uFEFF/, '');
                            evalResult = pluginManager_1.Loader.evalPlugin(contents, context_1, imports_1, plugin.options, plugin.filename);
                            if (evalResult instanceof LessError) {
                                return callback(evalResult);
                            }
                        }
                        else {
                            pluginManager_1.addPlugin(plugin);
                        }
                    });
                }
                new Parser(context_1, imports_1, rootFileInfo)
                    .parse(input, function (e, root) {
                    if (e) {
                        return callback(e);
                    }
                    callback(null, root, imports_1, options);
                }, options);
            }
        };
        return parse;
    }

    function Render (environment, ParseTree, ImportManager) {
        var render = function (input, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = copyOptions(this.options, {});
            }
            else {
                options = copyOptions(this.options, options || {});
            }
            if (!callback) {
                var self_1 = this;
                return new Promise(function (resolve, reject) {
                    render.call(self_1, input, options, function (err, output) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(output);
                        }
                    });
                });
            }
            else {
                this.parse(input, options, function (err, root, imports, options) {
                    if (err) {
                        return callback(err);
                    }
                    var result;
                    try {
                        var parseTree = new ParseTree(root, imports);
                        result = parseTree.toCSS(options);
                    }
                    catch (err) {
                        return callback(err);
                    }
                    callback(null, result);
                });
            }
        };
        return render;
    }

    var version = "4.1.1";

    function parseNodeVersion(version) {
      var match = version.match(/^v(\d{1,2})\.(\d{1,2})\.(\d{1,2})(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$/); // eslint-disable-line max-len
      if (!match) {
        throw new Error('Unable to parse: ' + version);
      }

      var res = {
        major: parseInt(match[1], 10),
        minor: parseInt(match[2], 10),
        patch: parseInt(match[3], 10),
        pre: match[4] || '',
        build: match[5] || '',
      };

      return res;
    }

    var parseNodeVersion_1 = parseNodeVersion;

    function lessRoot (environment, fileManagers) {
        var sourceMapOutput, sourceMapBuilder, parseTree, importManager;
        environment = new Environment(environment, fileManagers);
        sourceMapOutput = SourceMapOutput(environment);
        sourceMapBuilder = SourceMapBuilder(sourceMapOutput, environment);
        parseTree = ParseTree(sourceMapBuilder);
        importManager = ImportManager(environment);
        var render = Render(environment, parseTree);
        var parse = Parse(environment, parseTree, importManager);
        var v = parseNodeVersion_1("v" + version);
        var initial = {
            version: [v.major, v.minor, v.patch],
            data: data,
            tree: tree,
            Environment: Environment,
            AbstractFileManager: AbstractFileManager,
            AbstractPluginLoader: AbstractPluginLoader,
            environment: environment,
            visitors: visitors,
            Parser: Parser,
            functions: functions(environment),
            contexts: contexts,
            SourceMapOutput: sourceMapOutput,
            SourceMapBuilder: sourceMapBuilder,
            ParseTree: parseTree,
            ImportManager: importManager,
            render: render,
            parse: parse,
            LessError: LessError,
            transformTree: transformTree,
            utils: utils,
            PluginManager: PluginManagerFactory,
            logger: logger
        };
        // Create a public API
        var ctor = function (t) {
            return function () {
                var obj = Object.create(t.prototype);
                t.apply(obj, Array.prototype.slice.call(arguments, 0));
                return obj;
            };
        };
        var t;
        var api = Object.create(initial);
        for (var n in initial.tree) {
            /* eslint guard-for-in: 0 */
            t = initial.tree[n];
            if (typeof t === 'function') {
                api[n.toLowerCase()] = ctor(t);
            }
            else {
                api[n] = Object.create(null);
                for (var o in t) {
                    /* eslint guard-for-in: 0 */
                    api[n][o.toLowerCase()] = ctor(t[o]);
                }
            }
        }
        /**
         * Some of the functions assume a `this` context of the API object,
         * which causes it to fail when wrapped for ES6 imports.
         *
         * An assumed `this` should be removed in the future.
         */
        initial.parse = initial.parse.bind(api);
        initial.render = initial.render.bind(api);
        return api;
    }

    /* global window, XMLHttpRequest */
    var options;
    var logger$1;
    var fileCache = {};
    // TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load
    var FileManager = function () { };
    FileManager.prototype = Object.assign(new AbstractFileManager(), {
        alwaysMakePathsAbsolute: function () {
            return true;
        },
        join: function (basePath, laterPath) {
            if (!basePath) {
                return laterPath;
            }
            return this.extractUrlParts(laterPath, basePath).path;
        },
        doXHR: function (url, type, callback, errback) {
            var xhr = new XMLHttpRequest();
            var async = options.isFileProtocol ? options.fileAsync : true;
            if (typeof xhr.overrideMimeType === 'function') {
                xhr.overrideMimeType('text/css');
            }
            logger$1.debug("XHR: Getting '" + url + "'");
            xhr.open('GET', url, async);
            xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
            xhr.send(null);
            function handleResponse(xhr, callback, errback) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    callback(xhr.responseText, xhr.getResponseHeader('Last-Modified'));
                }
                else if (typeof errback === 'function') {
                    errback(xhr.status, url);
                }
            }
            if (options.isFileProtocol && !options.fileAsync) {
                if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
                    callback(xhr.responseText);
                }
                else {
                    errback(xhr.status, url);
                }
            }
            else if (async) {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        handleResponse(xhr, callback, errback);
                    }
                };
            }
            else {
                handleResponse(xhr, callback, errback);
            }
        },
        supports: function () {
            return true;
        },
        clearFileCache: function () {
            fileCache = {};
        },
        loadFile: function (filename, currentDirectory, options, environment) {
            // TODO: Add prefix support like less-node?
            // What about multiple paths?
            if (currentDirectory && !this.isPathAbsolute(filename)) {
                filename = currentDirectory + filename;
            }
            filename = options.ext ? this.tryAppendExtension(filename, options.ext) : filename;
            options = options || {};
            // sheet may be set to the stylesheet for the initial load or a collection of properties including
            // some context variables for imports
            var hrefParts = this.extractUrlParts(filename, window.location.href);
            var href = hrefParts.url;
            var self = this;
            return new Promise(function (resolve, reject) {
                if (options.useFileCache && fileCache[href]) {
                    try {
                        var lessText = fileCache[href];
                        return resolve({ contents: lessText, filename: href, webInfo: { lastModified: new Date() } });
                    }
                    catch (e) {
                        return reject({ filename: href, message: "Error loading file " + href + " error was " + e.message });
                    }
                }
                self.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {
                    // per file cache
                    fileCache[href] = data;
                    // Use remote copy (re-parse)
                    resolve({ contents: data, filename: href, webInfo: { lastModified: lastModified } });
                }, function doXHRError(status, url) {
                    reject({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")", href: href });
                });
            });
        }
    });
    var FM = (function (opts, log) {
        options = opts;
        logger$1 = log;
        return FileManager;
    });

    // TODO: Add tests for browser @plugin
    /**
     * Browser Plugin Loader
     */
    var PluginLoader = function (less) {
        this.less = less;
        // Should we shim this.require for browser? Probably not?
    };
    PluginLoader.prototype = Object.assign(new AbstractPluginLoader(), {
        loadPlugin: function (filename, basePath, context, environment, fileManager) {
            return new Promise(function (fulfill, reject) {
                fileManager.loadFile(filename, basePath, context, environment)
                    .then(fulfill).catch(reject);
            });
        }
    });

    var LogListener = (function (less, options) {
        var logLevel_debug = 4;
        var logLevel_info = 3;
        var logLevel_warn = 2;
        var logLevel_error = 1;
        // The amount of logging in the javascript console.
        // 3 - Debug, information and errors
        // 2 - Information and errors
        // 1 - Errors
        // 0 - None
        // Defaults to 2
        options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ? logLevel_info : logLevel_error);
        if (!options.loggers) {
            options.loggers = [{
                    debug: function (msg) {
                        if (options.logLevel >= logLevel_debug) {
                            console.log(msg);
                        }
                    },
                    info: function (msg) {
                        if (options.logLevel >= logLevel_info) {
                            console.log(msg);
                        }
                    },
                    warn: function (msg) {
                        if (options.logLevel >= logLevel_warn) {
                            console.warn(msg);
                        }
                    },
                    error: function (msg) {
                        if (options.logLevel >= logLevel_error) {
                            console.error(msg);
                        }
                    }
                }];
        }
        for (var i = 0; i < options.loggers.length; i++) {
            less.logger.addListener(options.loggers[i]);
        }
    });

    var ErrorReporting = (function (window, less, options) {
        function errorHTML(e, rootHref) {
            var id = "less-error-message:" + extractId(rootHref || '');
            var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
            var elem = window.document.createElement('div');
            var timer;
            var content;
            var errors = [];
            var filename = e.filename || rootHref;
            var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];
            elem.id = id;
            elem.className = 'less-error-message';
            content = "<h3>" + (e.type || 'Syntax') + "Error: " + (e.message || 'There is an error in your .less file') +
                ("</h3><p>in <a href=\"" + filename + "\">" + filenameNoPath + "</a> ");
            var errorline = function (e, i, classname) {
                if (e.extract[i] !== undefined) {
                    errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                        .replace(/\{class\}/, classname)
                        .replace(/\{content\}/, e.extract[i]));
                }
            };
            if (e.line) {
                errorline(e, 0, '');
                errorline(e, 1, 'line');
                errorline(e, 2, '');
                content += "on line " + e.line + ", column " + (e.column + 1) + ":</p><ul>" + errors.join('') + "</ul>";
            }
            if (e.stack && (e.extract || options.logLevel >= 4)) {
                content += "<br/>Stack Trace</br />" + e.stack.split('\n').slice(1).join('<br/>');
            }
            elem.innerHTML = content;
            // CSS for error messages
            browser.createCSS(window.document, [
                '.less-error-message ul, .less-error-message li {',
                'list-style-type: none;',
                'margin-right: 15px;',
                'padding: 4px 0;',
                'margin: 0;',
                '}',
                '.less-error-message label {',
                'font-size: 12px;',
                'margin-right: 15px;',
                'padding: 4px 0;',
                'color: #cc7777;',
                '}',
                '.less-error-message pre {',
                'color: #dd6666;',
                'padding: 4px 0;',
                'margin: 0;',
                'display: inline-block;',
                '}',
                '.less-error-message pre.line {',
                'color: #ff0000;',
                '}',
                '.less-error-message h3 {',
                'font-size: 20px;',
                'font-weight: bold;',
                'padding: 15px 0 5px 0;',
                'margin: 0;',
                '}',
                '.less-error-message a {',
                'color: #10a',
                '}',
                '.less-error-message .error {',
                'color: red;',
                'font-weight: bold;',
                'padding-bottom: 2px;',
                'border-bottom: 1px dashed red;',
                '}'
            ].join('\n'), { title: 'error-message' });
            elem.style.cssText = [
                'font-family: Arial, sans-serif',
                'border: 1px solid #e00',
                'background-color: #eee',
                'border-radius: 5px',
                '-webkit-border-radius: 5px',
                '-moz-border-radius: 5px',
                'color: #e00',
                'padding: 15px',
                'margin-bottom: 15px'
            ].join(';');
            if (options.env === 'development') {
                timer = setInterval(function () {
                    var document = window.document;
                    var body = document.body;
                    if (body) {
                        if (document.getElementById(id)) {
                            body.replaceChild(elem, document.getElementById(id));
                        }
                        else {
                            body.insertBefore(elem, body.firstChild);
                        }
                        clearInterval(timer);
                    }
                }, 10);
            }
        }
        function removeErrorHTML(path) {
            var node = window.document.getElementById("less-error-message:" + extractId(path));
            if (node) {
                node.parentNode.removeChild(node);
            }
        }
        function removeError(path) {
            if (!options.errorReporting || options.errorReporting === 'html') {
                removeErrorHTML(path);
            }
            else if (options.errorReporting === 'console') ;
            else if (typeof options.errorReporting === 'function') {
                options.errorReporting('remove', path);
            }
        }
        function errorConsole(e, rootHref) {
            var template = '{line} {content}';
            var filename = e.filename || rootHref;
            var errors = [];
            var content = (e.type || 'Syntax') + "Error: " + (e.message || 'There is an error in your .less file') + " in " + filename;
            var errorline = function (e, i, classname) {
                if (e.extract[i] !== undefined) {
                    errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                        .replace(/\{class\}/, classname)
                        .replace(/\{content\}/, e.extract[i]));
                }
            };
            if (e.line) {
                errorline(e, 0, '');
                errorline(e, 1, 'line');
                errorline(e, 2, '');
                content += " on line " + e.line + ", column " + (e.column + 1) + ":\n" + errors.join('\n');
            }
            if (e.stack && (e.extract || options.logLevel >= 4)) {
                content += "\nStack Trace\n" + e.stack;
            }
            less.logger.error(content);
        }
        function error(e, rootHref) {
            if (!options.errorReporting || options.errorReporting === 'html') {
                errorHTML(e, rootHref);
            }
            else if (options.errorReporting === 'console') {
                errorConsole(e, rootHref);
            }
            else if (typeof options.errorReporting === 'function') {
                options.errorReporting('add', e, rootHref);
            }
        }
        return {
            add: error,
            remove: removeError
        };
    });

    // Cache system is a bit outdated and could do with work
    var Cache = (function (window, options, logger) {
        var cache = null;
        if (options.env !== 'development') {
            try {
                cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;
            }
            catch (_) { }
        }
        return {
            setCSS: function (path, lastModified, modifyVars, styles) {
                if (cache) {
                    logger.info("saving " + path + " to cache.");
                    try {
                        cache.setItem(path, styles);
                        cache.setItem(path + ":timestamp", lastModified);
                        if (modifyVars) {
                            cache.setItem(path + ":vars", JSON.stringify(modifyVars));
                        }
                    }
                    catch (e) {
                        // TODO - could do with adding more robust error handling
                        logger.error("failed to save \"" + path + "\" to local storage for caching.");
                    }
                }
            },
            getCSS: function (path, webInfo, modifyVars) {
                var css = cache && cache.getItem(path);
                var timestamp = cache && cache.getItem(path + ":timestamp");
                var vars = cache && cache.getItem(path + ":vars");
                modifyVars = modifyVars || {};
                vars = vars || "{}"; // if not set, treat as the JSON representation of an empty object
                if (timestamp && webInfo.lastModified &&
                    (new Date(webInfo.lastModified).valueOf() ===
                        new Date(timestamp).valueOf()) &&
                    JSON.stringify(modifyVars) === vars) {
                    // Use local copy
                    return css;
                }
            }
        };
    });

    var ImageSize = (function () {
        function imageSize() {
            throw {
                type: 'Runtime',
                message: 'Image size functions are not supported in browser version of less'
            };
        }
        var imageFunctions = {
            'image-size': function (filePathNode) {
                imageSize();
                return -1;
            },
            'image-width': function (filePathNode) {
                imageSize();
                return -1;
            },
            'image-height': function (filePathNode) {
                imageSize();
                return -1;
            }
        };
        functionRegistry.addMultiple(imageFunctions);
    });

    //
    var root = (function (window, options) {
        var document = window.document;
        var less = lessRoot();
        less.options = options;
        var environment = less.environment;
        var FileManager = FM(options, less.logger);
        var fileManager = new FileManager();
        environment.addFileManager(fileManager);
        less.FileManager = FileManager;
        less.PluginLoader = PluginLoader;
        LogListener(less, options);
        var errors = ErrorReporting(window, less, options);
        var cache = less.cache = options.cache || Cache(window, options, less.logger);
        ImageSize(less.environment);
        // Setup user functions - Deprecate?
        if (options.functions) {
            less.functions.functionRegistry.addMultiple(options.functions);
        }
        var typePattern = /^text\/(x-)?less$/;
        function clone(obj) {
            var cloned = {};
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    cloned[prop] = obj[prop];
                }
            }
            return cloned;
        }
        // only really needed for phantom
        function bind(func, thisArg) {
            var curryArgs = Array.prototype.slice.call(arguments, 2);
            return function () {
                var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));
                return func.apply(thisArg, args);
            };
        }
        function loadStyles(modifyVars) {
            var styles = document.getElementsByTagName('style');
            var style;
            for (var i = 0; i < styles.length; i++) {
                style = styles[i];
                if (style.type.match(typePattern)) {
                    var instanceOptions = clone(options);
                    instanceOptions.modifyVars = modifyVars;
                    var lessText = style.innerHTML || '';
                    instanceOptions.filename = document.location.href.replace(/#.*$/, '');
                    /* jshint loopfunc:true */
                    // use closure to store current style
                    less.render(lessText, instanceOptions, bind(function (style, e, result) {
                        if (e) {
                            errors.add(e, 'inline');
                        }
                        else {
                            style.type = 'text/css';
                            if (style.styleSheet) {
                                style.styleSheet.cssText = result.css;
                            }
                            else {
                                style.innerHTML = result.css;
                            }
                        }
                    }, null, style));
                }
            }
        }
        function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {
            var instanceOptions = clone(options);
            addDataAttr(instanceOptions, sheet);
            instanceOptions.mime = sheet.type;
            if (modifyVars) {
                instanceOptions.modifyVars = modifyVars;
            }
            function loadInitialFileCallback(loadedFile) {
                var data = loadedFile.contents;
                var path = loadedFile.filename;
                var webInfo = loadedFile.webInfo;
                var newFileInfo = {
                    currentDirectory: fileManager.getPath(path),
                    filename: path,
                    rootFilename: path,
                    rewriteUrls: instanceOptions.rewriteUrls
                };
                newFileInfo.entryPath = newFileInfo.currentDirectory;
                newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;
                if (webInfo) {
                    webInfo.remaining = remaining;
                    var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);
                    if (!reload && css) {
                        webInfo.local = true;
                        callback(null, css, data, sheet, webInfo, path);
                        return;
                    }
                }
                // TODO add tests around how this behaves when reloading
                errors.remove(path);
                instanceOptions.rootFileInfo = newFileInfo;
                less.render(data, instanceOptions, function (e, result) {
                    if (e) {
                        e.href = path;
                        callback(e);
                    }
                    else {
                        cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);
                        callback(null, result.css, data, sheet, webInfo, path);
                    }
                });
            }
            fileManager.loadFile(sheet.href, null, instanceOptions, environment)
                .then(function (loadedFile) {
                loadInitialFileCallback(loadedFile);
            }).catch(function (err) {
                console.log(err);
                callback(err);
            });
        }
        function loadStyleSheets(callback, reload, modifyVars) {
            for (var i = 0; i < less.sheets.length; i++) {
                loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);
            }
        }
        function initRunningMode() {
            if (less.env === 'development') {
                less.watchTimer = setInterval(function () {
                    if (less.watchMode) {
                        fileManager.clearFileCache();
                        loadStyleSheets(function (e, css, _, sheet, webInfo) {
                            if (e) {
                                errors.add(e, e.href || sheet.href);
                            }
                            else if (css) {
                                browser.createCSS(window.document, css, sheet);
                            }
                        });
                    }
                }, options.poll);
            }
        }
        //
        // Watch mode
        //
        less.watch = function () {
            if (!less.watchMode) {
                less.env = 'development';
                initRunningMode();
            }
            this.watchMode = true;
            return true;
        };
        less.unwatch = function () { clearInterval(less.watchTimer); this.watchMode = false; return false; };
        //
        // Synchronously get all <link> tags with the 'rel' attribute set to
        // "stylesheet/less".
        //
        less.registerStylesheetsImmediately = function () {
            var links = document.getElementsByTagName('link');
            less.sheets = [];
            for (var i = 0; i < links.length; i++) {
                if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&
                    (links[i].type.match(typePattern)))) {
                    less.sheets.push(links[i]);
                }
            }
        };
        //
        // Asynchronously get all <link> tags with the 'rel' attribute set to
        // "stylesheet/less", returning a Promise.
        //
        less.registerStylesheets = function () { return new Promise(function (resolve, reject) {
            less.registerStylesheetsImmediately();
            resolve();
        }); };
        //
        // With this function, it's possible to alter variables and re-render
        // CSS without reloading less-files
        //
        less.modifyVars = function (record) { return less.refresh(true, record, false); };
        less.refresh = function (reload, modifyVars, clearFileCache) {
            if ((reload || clearFileCache) && clearFileCache !== false) {
                fileManager.clearFileCache();
            }
            return new Promise(function (resolve, reject) {
                var startTime;
                var endTime;
                var totalMilliseconds;
                var remainingSheets;
                startTime = endTime = new Date();
                // Set counter for remaining unprocessed sheets
                remainingSheets = less.sheets.length;
                if (remainingSheets === 0) {
                    endTime = new Date();
                    totalMilliseconds = endTime - startTime;
                    less.logger.info('Less has finished and no sheets were loaded.');
                    resolve({
                        startTime: startTime,
                        endTime: endTime,
                        totalMilliseconds: totalMilliseconds,
                        sheets: less.sheets.length
                    });
                }
                else {
                    // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array
                    loadStyleSheets(function (e, css, _, sheet, webInfo) {
                        if (e) {
                            errors.add(e, e.href || sheet.href);
                            reject(e);
                            return;
                        }
                        if (webInfo.local) {
                            less.logger.info("Loading " + sheet.href + " from cache.");
                        }
                        else {
                            less.logger.info("Rendered " + sheet.href + " successfully.");
                        }
                        browser.createCSS(window.document, css, sheet);
                        less.logger.info("CSS for " + sheet.href + " generated in " + (new Date() - endTime) + "ms");
                        // Count completed sheet
                        remainingSheets--;
                        // Check if the last remaining sheet was processed and then call the promise
                        if (remainingSheets === 0) {
                            totalMilliseconds = new Date() - startTime;
                            less.logger.info("Less has finished. CSS generated in " + totalMilliseconds + "ms");
                            resolve({
                                startTime: startTime,
                                endTime: endTime,
                                totalMilliseconds: totalMilliseconds,
                                sheets: less.sheets.length
                            });
                        }
                        endTime = new Date();
                    }, reload, modifyVars);
                }
                loadStyles(modifyVars);
            });
        };
        less.refreshStyles = loadStyles;
        return less;
    });

    /**
     * Kicks off less and compiles any stylesheets
     * used in the browser distributed version of less
     * to kick-start less using the browser api
     */
    var options$1 = defaultOptions();
    if (window.less) {
        for (var key in window.less) {
            if (window.less.hasOwnProperty(key)) {
                options$1[key] = window.less[key];
            }
        }
    }
    addDefaultOptions(window, options$1);
    options$1.plugins = options$1.plugins || [];
    if (window.LESS_PLUGINS) {
        options$1.plugins = options$1.plugins.concat(window.LESS_PLUGINS);
    }
    var less = root(window, options$1);
    window.less = less;
    var css;
    var head;
    var style;
    // Always restore page visibility
    function resolveOrReject(data) {
        if (data.filename) {
            console.warn(data);
        }
        if (!options$1.async) {
            head.removeChild(style);
        }
    }
    if (options$1.onReady) {
        if (/!watch/.test(window.location.hash)) {
            less.watch();
        }
        // Simulate synchronous stylesheet loading by hiding page rendering
        if (!options$1.async) {
            css = 'body { display: none !important }';
            head = document.head || document.getElementsByTagName('head')[0];
            style = document.createElement('style');
            style.type = 'text/css';
            if (style.styleSheet) {
                style.styleSheet.cssText = css;
            }
            else {
                style.appendChild(document.createTextNode(css));
            }
            head.appendChild(style);
        }
        less.registerStylesheetsImmediately();
        less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);
    }

    return less;

})));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!********************************!*\
  !*** ./modules/boilerplate.js ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ boilerplate)
/* harmony export */ });
/* harmony import */ var _fontfaceobserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fontfaceobserver.js */ "./modules/fontfaceobserver.js");
/* harmony import */ var _pageSetup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pageSetup.js */ "./modules/pageSetup.js");
/* harmony import */ var _replace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./replace.js */ "./modules/replace.js");
/* harmony import */ var _placeholder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./placeholder.js */ "./modules/placeholder.js");
/* harmony import */ var _textFit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./textFit.js */ "./modules/textFit.js");
/* harmony import */ var _mto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mto.js */ "./modules/mto.js");
/* harmony import */ var _limiters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./limiters */ "./modules/limiters.js");








const highestZ = () => {
  return Array.from(document.querySelectorAll('body *')).map(a => parseFloat(window.getComputedStyle(a).zIndex)).filter(a => !isNaN(a)).sort().pop() + 1;
}; // display a message to block rendering for major issues


const blockRender = v => {
  document.querySelector("body").innerHTML = `<style>html { position: absolute; background: #111820; color: white; font-family: sans-serif; font-size: 0.5rem; z-index: ${highestZ()}; height: 100%; width: 100%;}  body { margin: 1rem; width: 80%!important; } p { font-size: 0.4rem; } </style>
  <h2>â ï¸ Legacy render detected</h2>
  <h4>â Please enable <code>{ allowLegacyRendering: true }</code>
   in the boilerplate or update this template to version 1.1 or 2.1</h4>
   <p>This template is using renderer ${v}</p>
   <p>Please contact support if you see this message.</p>`;
  document.dispatchEvent(new Event('printready'));
}; // wait for the dom to laod or continue if it has already loaded


const domReady = new Promise((resolve, reject) => {
  if (document.readyState === "complete" || document.readyState === "loaded" || document.readyState === "interactive") {
    resolve();
  } else {
    window.addEventListener("DOMContentLoaded", resolve);
    window.addEventListener("error", reject);
  }
}); // wait for the window to laod or continue if it has already loaded

const winLoad = new Promise((resolve, reject) => {
  if (document.readyState === "complete") {
    resolve();
  } else {
    window.addEventListener("load", resolve);
    window.addEventListener("error", reject);
  }
});

const loadLESS = (variables = {}) => {
  return new Promise(async (resolve, reject) => {
    try {
      // let styleCode = document.createElement('link');
      // styleCode.setAttribute('type', 'text/css');
      // styleCode.setAttribute('rel', 'stylesheet');
      // styleCode.setAttribute('href', 'https://cdn.jsdelivr.net/gh/OutfitDelivery/boilerplate@v3.0/css/main.min.css');
      // document.head.insertAdjacentElement('afterbegin', styleCode);
      if (document.querySelector('[type="text/less"]') !== null) {
        window.less = {
          globalVars: variables
        };

        __webpack_require__(/*! less */ "./node_modules/less/dist/less.js"); // require('prefixfree');


        document.querySelectorAll('style[media=""][data-href$=".less"]:not([href])').forEach(e => e.remove());
      }

      resolve();
    } catch (e) {
      reject(e);
    }
  });
};

class boilerplate {
  constructor({
    fonts = [],
    ensureImagesLoad = true,
    ensureNoOverflows = false,
    allowLegacyRendering = false,
    exportReduceFont = 0,
    firefoxReduceFont = 0,
    waitForImages = false,
    trimMarks = false,
    allowNoMetaData = false,
    variables = {}
  } = {}) {
    this.fonts = fonts || '';
    this.ensureNoOverflows = ensureNoOverflows;
    this.waitForImages = waitForImages;
    this.ensureImagesLoad = ensureImagesLoad;
    this.allowLegacyRendering = allowLegacyRendering;
    this.exportReduceFont = exportReduceFont;
    this.firefoxReduceFont = firefoxReduceFont;
    this.trimMarks = trimMarks;
    this.allowNoMetaData = allowNoMetaData;
    this.variables = variables;

    if (!this.keepConsole) {
      console.clear();
    }

    if (JSON.stringify(variables) !== '{}') {
      console.table(variables);
    }
  }

  start() {
    return new Promise((resolve, reject) => {
      // all these checks need to be done before the tempalte code can be run 
      let checkList = [domReady, loadLESS(this.variables), this.setOutfitState(), this.fontsLoaded(), this.setBrowserType(), this.setSize(), this.addCrop()];

      if (this.waitForImages) {
        checkList.push((0,_pageSetup_js__WEBPACK_IMPORTED_MODULE_1__.ensureAllImagesLoaded)());
      }

      Promise.all(checkList).then(() => {
        if (typeof window.onTextChange === "function") {
          window.onTextChange();
        }

        window.addEventListener("resize", async e => {
          await this.setSize();

          if (state !== "preview" && typeof onTextChange === "function") {
            window.onTextChange('resize');
          }
        });

        if (state === 'document') {// OutfitIframeShared.eventEmitter.addListener(
          //   'token-value:change', (e) => {
          //   if (state !== "preview" && typeof window.onTextChange === "function") {
          //     if (e.currentTarget.parentNode) {
          //       window.onTextChange(e.currentTarget.parentNode);
          //     } else {
          //       window.onTextChange();
          //     }
          //   }
          // });
        }

        if (state === "document") {
          (0,_pageSetup_js__WEBPACK_IMPORTED_MODULE_1__.imageCompression)(); // set timeout is used here to push this to the end of the heap which means it will load after everything else 

          setTimeout(() => {
            if (!this.allowNoMetaData) {
              this.defaultsRemoved();
            }
          }, 0);
        }

        console.log("Content checks ran ð");
        resolve();
      }).catch(reject);
    });
  } // ensure that all fonts are loaded check


  fontsLoaded() {
    return new Promise((resolve, reject) => {
      let fontsListed = this.fonts;

      if (!Array.isArray(fontsListed)) {
        fontsListed = [fontsListed];
      }

      if (!fontsListed || fontsListed && fontsListed.length < 1 || fontsListed[0] === "PUT_ALL_FONT_NAMES_HERE") {
        reject("No fonts were put in the boilerplate config. For example { fonts: ['IBM Plex Sans'] }");
      } else {
        Promise.all(fontsListed.map(font => {
          return new _fontfaceobserver_js__WEBPACK_IMPORTED_MODULE_0__.default(font).load();
        })).then(el => {
          // TODO detect fonts loaded that are not in the array list 
          // let { fonts } = document;
          // const it = fonts.entries();
          // let arr = [];
          // let done = false;
          // while (!done) {
          //   const font = it.next();
          //   if (!font.done) {
          //     arr.push(font.value[0].family);
          //   } else {
          //     done = font.done;
          //   }
          // }
          // let loadedFonts = [...new Set(arr)]
          // console.log(loadedFonts)
          resolve(el);
        }).catch(reject);
      }
    });
  }

  setBrowserType() {
    return new Promise(resolve => {
      let browser = {
        // Opera 8.0+
        isOpera: !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0,
        // Firefox 1.0+
        isFirefox: typeof InstallTrigger !== 'undefined',
        // Safari 3.0+ "[object HTMLElementConstructor]" 
        isSafari: /constructor/i.test(window.HTMLElement) || function (p) {
          return p.toString() === "[object SafariRemoteNotification]";
        }(!window['safari'] || typeof safari !== 'undefined' && window['safari'].pushNotification),
        // Internet Explorer 6-11
        isIE:
        /*@cc_on!@*/
         false || !!document.documentMode,
        // Chrome 1 - 79
        isChrome: !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime),
        // mac detection
        isMac: window.navigator.appVersion.includes("Mac")
      }; //  Edge 20+

      browser['isEdge'] = !browser.isIE && !!window.StyleMedia; // Edge (based on chromium) detection

      browser['isEdgeChromium'] = browser.isChrome && navigator.userAgent.indexOf("Edg") != -1; // Blink engine detection

      browser['isBlink'] = (browser.isChrome || browser.isOpera) && !!window.CSS;
      document.body.classList += ' ' + Object.keys(browser).filter(key => {
        return browser[key];
      }).join(' ');
      this.browser = browser;
      resolve(browser);
    });
  }

  setOutfitState() {
    return new Promise(resolve => {
      var mode = window.location.href.indexOf("exports") > -1 ? "export" : false;
      mode = !mode && window.location.href.indexOf("templates") > -1 ? "template" : mode;
      mode = !mode && window.location.href.indexOf("projects") > -1 ? "document" : mode;
      mode = !mode && window.location.href.indexOf("preview") > -1 ? "preview" : mode;
      mode = !mode && window.location.href.indexOf("localhost") > -1 ? "local" : mode;

      if (!mode) {
        mode = "error";
      }

      document.body.setAttribute("document-state", mode);
      document.body.setAttribute("data-trim", this.trimMarks);
      window.state = mode;
      this.state = mode;
      resolve(mode);
    });
  }

  setSize() {
    return new Promise(resolve => {
      const vw = (this.trimMarks ? window.innerWidth : window.innerWidth + 57.62) / 100;
      const vh = (this.trimMarks ? window.innerHeight : window.innerHeight + 57.62) / 100;
      const vmin = Math.min(vw, vh);
      const vmax = Math.max(vw, vh); // Saving the preliminary font size calculation

      const preliminaryCalc = vmin * 2 + vmax * 1.4 + vh * 2; // Checking if the document is currently in export mode

      const isExportMode = window.state === "exports"; // Checking if the active browser is Firefox

      const isFirefox = navigator.userAgent.includes("Firefox");
      const exportModeFontSize = preliminaryCalc - this.exportReduceFont / 100 * preliminaryCalc;
      const firefoxFontSize = preliminaryCalc - this.firefoxReduceFont / 100 * preliminaryCalc; // Reducing the preliminaryCalc value by reduceVal in export mode and in Firefox preview mode

      const finalCalc = isExportMode ? exportModeFontSize : isFirefox ? firefoxFontSize : preliminaryCalc;
      document.documentElement.style.fontSize = `${finalCalc}px`;
      resolve();
    });
  }

  pageHeightSetup() {
    let agent = navigator.userAgent;

    if (agent.includes('OPTION 2.1')) {
      console.info("Renderer 2.1 Set");

      if (!this.trimMarks) {
        return "calc(100vh - 1px)";
      }

      return "100vh";
    } else if (agent.includes('OPTION 1.1')) {
      console.info("Renderer 1.1 Set");
      return "100vh";
    } else if (agent.includes('OPTION 1.0')) {
      if (!this.allowLegacyRendering) {
        blockRender('1.0');
      }

      return "100vh";
    } else if (agent.includes('OPTION 2.0')) {
      if (!this.allowLegacyRendering) {
        blockRender('2.0');
      }

      if (!this.trimMarks) {
        return "calc(100vh - 1px)";
      }

      return "100vh";
    } else {
      // console.error("Renderer Not Set");
      return "100vh";
    }
  } // Fix for the resizable background images - fullscreen and digital vairaitons only


  addCrop() {
    return new Promise(resolve => {
      // crop and bleed
      var cropSVG = '<svg class="crop-mark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21.6 21.6" xmlns:v="https://vecta.io/nano"><path d="M21 15V0m-6 21H0" fill="none" stroke="#000" stroke-width="0.25" stroke-miterlimit="10.0131"/></svg>';
      let pageHeight = this.pageHeightSetup();
      document.querySelectorAll(".page").forEach(page => {
        page.style.height = pageHeight;

        if (this.trimMarks) {
          page.insertAdjacentHTML("afterbegin", `<div class="crop-marks">
            <div class="crop-mark top-left">${cropSVG}</div>
            <div class="crop-mark top-right">${cropSVG}</div>
            <div class="crop-mark bottom-left">${cropSVG}</div>
            <div class="crop-mark bottom-right">${cropSVG}</div>
          </div>`);
        }
      });
      Array.prototype.slice.call(document.querySelectorAll(".bleed")).forEach(bleed => {
        bleed.style.cssText = this.trimMarks ? "position: absolute; top: 4.41mm; right: 4.41mm; bottom: 4.41mm; left: 4.41mm;" : "position: absolute; top: -3mm; right: -3mm; bottom: -3mm; left: -3mm";
      });
      document.querySelectorAll("[data-trim='false'] .outfit-resizable-background").forEach(el => {
        el.parentNode.style.left = "0";
        el.parentNode.style.right = "0";
        el.parentNode.style.top = "0";
        el.parentNode.style.bottom = "0";
        el.parentNode.style.width = "100%";
        el.parentNode.style.height = "100%";
      });
      resolve();
    });
  }

  ensureNoOverflows() {
    return new Promise((resolve, reject) => {
      let overflows = document.querySelectorAll('.overflow, [overflow]');

      if (overflows) {
        reject(overflows);
      }

      resolve();
    });
  } // send a event to stop a render 


  completeRender() {
    let checkList = [winLoad];

    if (this.ensureImagesLoad) {
      checkList.push(_pageSetup_js__WEBPACK_IMPORTED_MODULE_1__.ensureAllImagesLoaded);
    }

    if (this.ensureNoOverflows) {
      checkList.push(ensureNoOverflows);
    }

    Promise.all(checkList).then(values => {
      let loadTime = Date.now() - window.performance.timing.navigationStart;
      console.info(`Document has finished rendering in ${loadTime}ms`);
      document.dispatchEvent(new Event('printready'));
    }).catch(err => {
      console.error(err);
      throw 'â ï¸ Render failed for logged reason â¤´ï¸';
    });
  }

  defaultsRemoved() {
    // ensure that the user has changed important tempalte metadata
    return new Promise((resolve, reject) => {
      let title = document.title;

      if (title === '' || title === 'PUT_TEMPLATE_NAME_HERE') {
        reject('Please put the name of the template in the title of the document');
      }

      let builtBy = document.querySelector('meta[name="template-built-by"]').getAttribute('content');

      if (builtBy === '' || builtBy === 'PUT_YOUR_NAME_HERE') {
        reject('Please add your name in the document meta tags');
      }

      let scopeCard = document.querySelector('meta[name="scope"]').getAttribute('content');

      if (scopeCard === '' || scopeCard === 'DTB-PUT_JIRA_NUMBER_HERE') {
        reject('Please add the scope card ID in the document meta tags');
      }

      let builtCard = document.querySelector('meta[name="build"]').getAttribute('content');

      if (builtCard === '' || builtCard === 'DTB-PUT_JIRA_NUMBER_HERE') {
        reject('Please add the build card ID in the document meta tags');
      }

      if ([...document.head.childNodes].some(node => {
        if (node && node.data && node.nodeType === 8) {
          return node.data.includes('Template Admin Build Instructions');
        }
      })) {
        reject('Please remove the "Template Admin Build Instructions" comment from the top of the document');
      }

      resolve();
    });
  }

  hotReloadOnChange() {
    if (this.state === 'document' && typeof BroadcastChannel === 'function') {
      let bc = new BroadcastChannel('fs-sync');

      bc.onmessage = ev => {
        if (!window.top.reloading) {
          window.top.reloading = true;
          window.top.location.reload();
        }
      };
    }
  }

  dynamicReplace() {
    return _replace_js__WEBPACK_IMPORTED_MODULE_2__.dynamicReplace.apply(this, arguments);
  }

  textFit() {
    return _textFit_js__WEBPACK_IMPORTED_MODULE_4__.default.apply(this, arguments);
  }

  setupPlaceholder() {
    return _placeholder_js__WEBPACK_IMPORTED_MODULE_3__.default.apply(this, arguments);
  }

  maxLineCheck() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.maxLineCheck.apply(this, arguments);
  }

  maxHeightCheck() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.maxHeightCheck.apply(this, arguments);
  }

  charLimit() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.charLimit.apply(this, arguments);
  }

  dynamicAssign() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.dynamicAssign.apply(this, arguments);
  }

  highestZindex() {
    return highestZ();
  }

  ensureAllImagesLoaded() {
    return _pageSetup_js__WEBPACK_IMPORTED_MODULE_1__.ensureAllImagesLoaded.apply(this, arguments);
  }

  setupMTO() {
    return _mto_js__WEBPACK_IMPORTED_MODULE_5__.setupMTO.apply(this, arguments);
  }

  getWidth() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.getWidth.apply(this, arguments);
  }

  getHeight() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.getHeight.apply(this, arguments);
  }

  countLines() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.countLines.apply(this, arguments);
  }

  calculateTextMetrics() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.calculateTextMetrics.apply(this, arguments);
  }

  lineClamp() {
    return _limiters__WEBPACK_IMPORTED_MODULE_6__.lineClamp.apply(this, arguments);
  }

}
})();

__webpack_exports__ = __webpack_exports__.default;
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL2ZvbnRmYWNlb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL2xpbWl0ZXJzLmpzIiwid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbW9kdWxlcy9saW5lQ2xhbXAuanMiLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9tb2R1bGVzL210by5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvcGFnZVNldHVwLmpzIiwid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbW9kdWxlcy9wbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvcmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL21vZHVsZXMvdGV4dEZpdC5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9sZXNzL2Rpc3QvbGVzcy5qcyIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbW9kdWxlcy9ib2lsZXJwbGF0ZS5qcyJdLCJuYW1lcyI6WyJmIiwiZyIsImwiLCJhIiwicHVzaCIsImxlbmd0aCIsIm0iLCJzaGlmdCIsInNldFRpbWVvdXQiLCJuIiwicCIsImIiLCJxIiwiciIsImMiLCJ0IiwidSIsIlR5cGVFcnJvciIsImQiLCJ0aGVuIiwiY2FsbCIsImUiLCJ2IiwiaCIsInByb3RvdHlwZSIsInciLCJrIiwieCIsIndpbmRvdyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmFjZSIsImFsbCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiYm9keSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkeVN0YXRlIiwiZGV0YWNoRXZlbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsInN0eWxlIiwiY3NzVGV4dCIsInoiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwic2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwiQSIsInBhcmVudE5vZGUiLCJCIiwiZmFtaWx5Iiwid2VpZ2h0Iiwic3RyZXRjaCIsImxvYWQiLCJIIiwiRGF0ZSIsImdldFRpbWUiLCJKIiwiRyIsIk0iLCJFcnJvciIsImZvbnRzIiwiTCIsIk4iLCJjbGVhclRpbWVvdXQiLCJDIiwiZXhlYyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInBhcnNlSW50IiwieSIsInJlbW92ZUNoaWxkIiwiSSIsImhpZGRlbiIsImRpciIsIkQiLCJFIiwiRiIsInRlc3QiLCJ2ZW5kb3IiLCJLIiwiZm9udCIsImpvaW4iLCJpbmxpbmVCbG9jayIsImVsIiwiaW5jbHVkZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZGlzcGxheSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwidGV4dE5vZGVzVW5kZXIiLCJ3YWxrIiwiY3JlYXRlVHJlZVdhbGtlciIsIk5vZGVGaWx0ZXIiLCJTSE9XX1RFWFQiLCJuZXh0Tm9kZSIsInRleHRDb250ZW50IiwidHJpbSIsInBhcmVudEVsZW1lbnQiLCJmaW5kVGV4dE5vZGUiLCJ0YXJnZXQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInRhZ05hbWUiLCJzaW1wbGVSb3VuZGluZyIsIm51bSIsIk1hdGgiLCJyb3VuZCIsImNvdW50TGluZXMiLCJlbGVtZW50cyIsImVsVHlwZSIsIk9iamVjdCIsInRvU3RyaW5nIiwicmVzdWx0IiwibWFwIiwibXVpbHRDb3VudCIsInRleHROb2RlcyIsImNvbnNvbGUiLCJsb2ciLCJmb3JFYWNoIiwibWV0cmljcyIsImNhbGN1bGF0ZVRleHRNZXRyaWNzIiwibGluZSIsImxpbmVDb3VudCIsImRhdGFzZXQiLCJyYXdMaW5lc0NvdW50IiwibGluZUNvdW50Um91bmRlZCIsImNhbGN1bGF0ZWRMaW5lc0NvdW50IiwiY2xhbXBEZWZhdWx0cyIsIm1heExpbmVzIiwibWluRm9udFNpemUiLCJ1c2VTb2Z0Q2xhbXAiLCJlbGxpcHNpcyIsImxpbmVDbGFtcCIsImNvbmZpZyIsImVsZW1lbnQiLCJjbGFtcCIsIkxpbmVDbGFtcCIsImFwcGx5Iiwid2F0Y2giLCJnZXRIZWlnaHQiLCJoZWlnaHQiLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsImJveF9zaXppbmciLCJwYWRkaW5nX3RvcCIsInBhZGRpbmdfYm90dG9tIiwiYm9yZGVyX3RvcCIsImJvcmRlcl9ib3R0b20iLCJjYWxjdWxhdGVkSGVpZ2h0IiwiZ2V0V2lkdGgiLCJwYWRkaW5nX2xlZnQiLCJwYWRkaW5nX3JpZ2h0IiwiYm9yZGVyX2xlZnQiLCJib3JkZXJfcmlnaHQiLCJjYWxjdWxhdGVkV2lkdGgiLCJtYXhMaW5lQ2hlY2siLCJpc0V4cG9ydE1vZGUiLCJsb2NhdGlvbiIsImhyZWYiLCJpbmRleE9mIiwiaXNMb2NhbERldiIsInByZXZlbnRFeHBvcnRPdmVyZmxvdyIsImlzUHJvamVjdEtpdCIsInVuZGVmaW5lZCIsInBhcmVudCIsInF1ZXJ5U2VsZWN0b3IiLCJibG9ja3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYmxvY2siLCJtYXhMaW5lIiwibWF4TGluZUFsdCIsImFkZCIsInJlbW92ZSIsIm1heEhlaWdodENoZWNrIiwibWF4SGVpZ2h0IiwibWF4SGVpZ2h0RHluYW1pYyIsImR5bmFtaWNBc3NpZ24iLCJibG9ja0hlaWdodCIsImNvbXB1dGVkQmxvY2tTdHlsZSIsImNzc01heEhlaWdodCIsImVycm9yIiwibWF4SGVpZ2h0VW5pdCIsImZvbnRTaXplIiwiY29udGFpbmVyIiwib3ZlcmZsb3ciLCJjb250YWluZXJIZWlnaHQiLCJzdWJ0cmFoZW5kcyIsInN1YnRyYWhlbmRzSGVpZ2h0IiwicmVkdWNlIiwidG90YWxIZWlnaHQiLCJzdWJ0cmFoZW5kIiwic3VidHJhaGVuZE1hcmdpbnMiLCJ0b3AiLCJtYXJnaW5Ub3AiLCJib3R0b20iLCJtYXJnaW5Cb3R0b20iLCJvZmZzZXRIZWlnaHQiLCJkeW5hbWljSGVpZ2h0IiwiY2hhckxpbWl0IiwibGltaXQiLCJ0b2tlblZhbHVlIiwiaXRlbSIsImNvZGUiLCJpbm5lclRleHQiLCJjb25zdHJ1Y3RvciIsImhhcmRDbGFtcEFzRmFsbGJhY2siLCJtYXhGb250U2l6ZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJ2YWx1ZSIsIm1hdGNoIiwiTXV0YXRpb25PYnNlcnZlciIsInVwZGF0ZUhhbmRsZXIiLCJjbG9uZSIsImNsb25lTm9kZSIsInJlcGxhY2VXaXRoIiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxIZWlnaHRXaXRob3V0VGV4dCIsInRleHRIZWlnaHQiLCJuYXR1cmFsSGVpZ2h0V2l0aE9uZUxpbmUiLCJmaXJzdExpbmVIZWlnaHQiLCJhZGRpdGlvbmFsTGluZUhlaWdodCIsIl93YXRjaGluZyIsIm9ic2VydmVyIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiY2hpbGRMaXN0IiwiYXR0cmlidXRlcyIsInVud2F0Y2giLCJkaXNjb25uZWN0IiwicHJldmlvdXNseVdhdGNoaW5nIiwib3JpZ2luYWxXb3JkcyIsInNvZnRDbGFtcCIsImhhcmRDbGFtcCIsInNraXBDaGVjayIsInNob3VsZENsYW1wIiwiY3VycmVudFRleHQiLCJmaW5kQm91bmRhcnkiLCJ2YWwiLCJzbGljZSIsIm1pbiIsIm1heCIsImVtaXQiLCJzdGFydFNpemUiLCJkb25lIiwiY2hhbmdlZCIsImN1cnNvciIsImZsb29yIiwiaW5zdGFuY2UiLCJ0eXBlIiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZ2V0U2lkZWJhciIsInNpZGViYXIiLCJwb3AiLCJoaWRlSW5wdXQiLCJpbnB1dFZhbHVlIiwiaW5wdXQiLCJzZXR1cE1UTyIsInRlYW1NZXRhZGF0YSIsInRlYW1zQWxsb3dlZCIsImlucHV0TmFtZSIsInN0YXRlIiwibXRvTm90U3VwcG9ydGVkIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsImlubmVySFRNTCIsInNldEludGVydmFsIiwidG9Mb3dlckNhc2UiLCJzcGxpdCIsImZpbHRlciIsImhpZGVUZWFtc1RoYXRBcmVOb3RBbGxvd2VkIiwiaW5wdXRPcHRpb24iLCJzcGFuIiwic3Vic3RyaW5nIiwiaGFuZGxlTVRPRGF0YSIsImltYWdlQ29tcHJlc3Npb24iLCJpbWFnZUNvbXByZXNzRWwiLCJlZGl0b3JTdHJpbmciLCJjaGVja1VSTCIsInVybCIsImltZ1NyYyIsImdldEF0dHJpYnV0ZSIsImltZ0VsIiwiaW1nVVJMIiwiYmtnSW1nRWwiLCJia2dVcmwiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJyZXBsYWNlIiwiZW5zdXJlQWxsSW1hZ2VzTG9hZGVkIiwiZG9jIiwidGltZW91dCIsImxvYWRBbGxJbWFnZXMiLCJBcnJheSIsImZyb20iLCJzZWFyY2hET00iLCJzcmNDaGVja2VyIiwiY29sbGVjdGlvbiIsIm5vZGUiLCJwcm9wIiwic3JjIiwiY29udGVudERvY3VtZW50IiwiY29udGVudFdpbmRvdyIsImltZyIsIlNldCIsImxvYWRJbWFnZSIsImltZ1Byb21pc2UiLCJJbWFnZSIsIm9ubG9hZCIsIm5hdHVyYWxXaWR0aCIsIm9uZXJyb3IiLCJ0aW1lciIsImltZ0xpc3QiLCJjYXRjaCIsInJlc3VsdHMiLCJzZXR1cFBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJWaXNpYmlsaXR5IiwicGxhY2Vob2xkZXJJbWFnZXMiLCJwYWdlcyIsInBhZ2UiLCJpbmRleCIsInBsYWNlaG9sZGVySW1hZ2UiLCJwbGFjZWhvbGRlclN0cnVjdHVyZSIsImluc2VydEFkamFjZW50SFRNTCIsIlN0cmluZyIsInJlcGxhY2VBbGwiLCJzdHIiLCJuZXdTdHIiLCJkeW5hbWljUmVwbGFjZSIsInNlbGVjdG9yIiwiZGF0YSIsImR5bmFtaWNSZXBsYWNlTXVsdGkiLCJkeW5hbWljUmVwbGFjZVNpbmdsZSIsInRhcmdldHMiLCJsb29rdXAiLCJsb29rdXBTcGFuIiwidGVtcCIsInRleHQiLCJodG1sIiwicmVwbGFjZUZyb20iLCJyZXBsYWNlVG8iLCJzZWFyY2giLCJkZWZhdWx0U2V0dGluZ3MiLCJhbGlnblZlcnQiLCJhbGlnbkhvcml6IiwibXVsdGlMaW5lIiwic3RvcE92ZXJmbG93IiwiZm9udFVuaXQiLCJmb250Q2hhbmdlU2l6ZSIsInJlUHJvY2VzcyIsIndpZHRoT25seSIsImFsaWduVmVydFdpdGhGbGV4Ym94IiwidGV4dEZpdCIsImVscyIsIm9wdGlvbnMiLCJzZXR0aW5ncyIsImtleSIsImhhc093blByb3BlcnR5IiwidG9BcnJheSIsImkiLCJwcm9jZXNzSXRlbSIsImlzRWxlbWVudCIsImlubmVyU3BhbiIsIm9yaWdpbmFsSGVpZ2h0Iiwib3JpZ2luYWxIVE1MIiwib3JpZ2luYWxXaWR0aCIsImxvdyIsIm1pZCIsImhpZ2giLCJvdXRlckhUTUwiLCJ0ZXh0Rml0dGVkU3BhbiIsImNsYXNzTmFtZSIsInN0YXJ0aW5nU2l6ZSIsInNpemUiLCJ0b0ZpeGVkIiwic2Nyb2xsSGVpZ2h0IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiY3VzdG9tT3ZlcmZsb3dNZXNzYWdlIiwibyIsIkhUTUxFbGVtZW50Iiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImhpZ2hlc3RaIiwiekluZGV4IiwiaXNOYU4iLCJzb3J0IiwiYmxvY2tSZW5kZXIiLCJFdmVudCIsImRvbVJlYWR5Iiwid2luTG9hZCIsImxvYWRMRVNTIiwidmFyaWFibGVzIiwibGVzcyIsImdsb2JhbFZhcnMiLCJyZXF1aXJlIiwiYm9pbGVycGxhdGUiLCJlbnN1cmVJbWFnZXNMb2FkIiwiZW5zdXJlTm9PdmVyZmxvd3MiLCJhbGxvd0xlZ2FjeVJlbmRlcmluZyIsImV4cG9ydFJlZHVjZUZvbnQiLCJmaXJlZm94UmVkdWNlRm9udCIsIndhaXRGb3JJbWFnZXMiLCJ0cmltTWFya3MiLCJhbGxvd05vTWV0YURhdGEiLCJrZWVwQ29uc29sZSIsImNsZWFyIiwiSlNPTiIsInN0cmluZ2lmeSIsInRhYmxlIiwic3RhcnQiLCJjaGVja0xpc3QiLCJzZXRPdXRmaXRTdGF0ZSIsImZvbnRzTG9hZGVkIiwic2V0QnJvd3NlclR5cGUiLCJzZXRTaXplIiwiYWRkQ3JvcCIsIm9uVGV4dENoYW5nZSIsImRlZmF1bHRzUmVtb3ZlZCIsImZvbnRzTGlzdGVkIiwiaXNBcnJheSIsIkZvbnRGYWNlT2JzZXJ2ZXIiLCJicm93c2VyIiwiaXNPcGVyYSIsIm9wciIsImFkZG9ucyIsIm9wZXJhIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsInNhZmFyaSIsInB1c2hOb3RpZmljYXRpb24iLCJpc0lFIiwiZG9jdW1lbnRNb2RlIiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJ3ZWJzdG9yZSIsInJ1bnRpbWUiLCJpc01hYyIsImFwcFZlcnNpb24iLCJTdHlsZU1lZGlhIiwiQ1NTIiwia2V5cyIsIm1vZGUiLCJ2dyIsImlubmVyV2lkdGgiLCJ2aCIsImlubmVySGVpZ2h0Iiwidm1pbiIsInZtYXgiLCJwcmVsaW1pbmFyeUNhbGMiLCJleHBvcnRNb2RlRm9udFNpemUiLCJmaXJlZm94Rm9udFNpemUiLCJmaW5hbENhbGMiLCJkb2N1bWVudEVsZW1lbnQiLCJwYWdlSGVpZ2h0U2V0dXAiLCJhZ2VudCIsImluZm8iLCJjcm9wU1ZHIiwicGFnZUhlaWdodCIsImJsZWVkIiwibGVmdCIsInJpZ2h0Iiwib3ZlcmZsb3dzIiwiY29tcGxldGVSZW5kZXIiLCJ2YWx1ZXMiLCJsb2FkVGltZSIsIm5vdyIsInBlcmZvcm1hbmNlIiwidGltaW5nIiwibmF2aWdhdGlvblN0YXJ0IiwiZXJyIiwidGl0bGUiLCJidWlsdEJ5Iiwic2NvcGVDYXJkIiwiYnVpbHRDYXJkIiwiaGVhZCIsImNoaWxkTm9kZXMiLCJzb21lIiwiaG90UmVsb2FkT25DaGFuZ2UiLCJCcm9hZGNhc3RDaGFubmVsIiwiYmMiLCJvbm1lc3NhZ2UiLCJldiIsInJlbG9hZGluZyIsInJlbG9hZCIsImFyZ3VtZW50cyIsImhpZ2hlc3RaaW5kZXgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQXNFLENBQUMsWUFBWTtBQUNqRjs7QUFDQSxNQUFJQSxDQUFKO0FBQUEsTUFDRUMsQ0FBQyxHQUFHLEVBRE47O0FBRUEsV0FBU0MsQ0FBVCxDQUFXQyxDQUFYLEVBQWM7QUFDWkYsS0FBQyxDQUFDRyxJQUFGLENBQU9ELENBQVA7QUFDQSxTQUFLRixDQUFDLENBQUNJLE1BQVAsSUFBaUJMLENBQUMsRUFBbEI7QUFDRDs7QUFDRCxXQUFTTSxDQUFULEdBQWE7QUFDWCxXQUFPTCxDQUFDLENBQUNJLE1BQVQsR0FBbUJKLENBQUMsQ0FBQyxDQUFELENBQUQsSUFBUUEsQ0FBQyxDQUFDTSxLQUFGLEVBQVI7QUFDcEI7O0FBQ0RQLEdBQUMsR0FBRyxZQUFZO0FBQ2RRLGNBQVUsQ0FBQ0YsQ0FBRCxDQUFWO0FBQ0QsR0FGRDs7QUFHQSxXQUFTRyxDQUFULENBQVdOLENBQVgsRUFBYztBQUNaLFNBQUtBLENBQUwsR0FBU08sQ0FBVDtBQUNBLFNBQUtDLENBQUwsR0FBUyxLQUFLLENBQWQ7QUFDQSxTQUFLWCxDQUFMLEdBQVMsRUFBVDtBQUNBLFFBQUlXLENBQUMsR0FBRyxJQUFSOztBQUNBLFFBQUk7QUFDRlIsT0FBQyxDQUNDLFVBQVVBLENBQVYsRUFBYTtBQUNYUyxTQUFDLENBQUNELENBQUQsRUFBSVIsQ0FBSixDQUFEO0FBQ0QsT0FIRixFQUlDLFVBQVVBLENBQVYsRUFBYTtBQUNYVSxTQUFDLENBQUNG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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsYUFBYTtBQUNiO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1DQUFtQyw0Q0FBNEM7QUFDL0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0RBQStEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0NBQWdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsK0JBQStCLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQixFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFr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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJDQUEyQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNENBQTRDO0FBQzNGLCtDQUErQyxvQ0FBb0M7QUFDbkYsNENBQTRDLHdDQUF3QztBQUNwRiw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHVEQUF1RCxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0QsNkRBQTZELHlEQUF5RDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxJQUFJO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsVUFBVTtBQUN6RztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUVBQWlFLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLFVBQVU7QUFDMUc7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxFQUFFLGFBQWEsRUFBRSxhQUFhLElBQUk7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsSUFBSTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhLGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdEQUF3RDtBQUNwRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxvRUFBb0U7QUFDcEU7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILFlBQVk7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUJBQXVCLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsSUFBSSxPQUFPLElBQUksT0FBTyxJQUFJLGtEQUFrRDtBQUNuSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFHO0FBQ1YsV0FBT0Esc0RBQUEsQ0FBZ0IsSUFBaEIsRUFBc0I0VixTQUF0QixDQUFQO0FBQ0Q7O0FBQ0Q1WCxZQUFVLEdBQUc7QUFDWCxXQUFPQSx1REFBQSxDQUFpQixJQUFqQixFQUF1QjRYLFNBQXZCLENBQVA7QUFDRDs7QUFDRC9XLHNCQUFvQixHQUFHO0FBQ3JCLFdBQU9BLGlFQUFBLENBQTJCLElBQTNCLEVBQWlDK1csU0FBakMsQ0FBUDtBQUNEOztBQUNEblcsV0FBUyxHQUFHO0FBQ1YsV0FBT0Esc0RBQUEsQ0FBZ0IsSUFBaEIsRUFBc0JtVyxTQUF0QixDQUFQO0FBQ0Q7O0FBelo4QixDIiwiZmlsZSI6ImJvaWxlcnBsYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYm9pbGVycGxhdGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiYm9pbGVycGxhdGVcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIvKiBGb250IEZhY2UgT2JzZXJ2ZXIgdjIuMS4wIC0gwqkgQnJhbSBTdGVpbi4gTGljZW5zZTogQlNELTMtQ2xhdXNlICovIChmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgZixcbiAgICBnID0gW107XG4gIGZ1bmN0aW9uIGwoYSkge1xuICAgIGcucHVzaChhKTtcbiAgICAxID09IGcubGVuZ3RoICYmIGYoKTtcbiAgfVxuICBmdW5jdGlvbiBtKCkge1xuICAgIGZvciAoOyBnLmxlbmd0aDsgKSBnWzBdKCksIGcuc2hpZnQoKTtcbiAgfVxuICBmID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQobSk7XG4gIH07XG4gIGZ1bmN0aW9uIG4oYSkge1xuICAgIHRoaXMuYSA9IHA7XG4gICAgdGhpcy5iID0gdm9pZCAwO1xuICAgIHRoaXMuZiA9IFtdO1xuICAgIHZhciBiID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgYShcbiAgICAgICAgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBxKGIsIGEpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHIoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgcihiLCBjKTtcbiAgICB9XG4gIH1cbiAgdmFyIHAgPSAyO1xuICBmdW5jdGlvbiB0KGEpIHtcbiAgICByZXR1cm4gbmV3IG4oZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgIGMoYSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdShhKSB7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChiKSB7XG4gICAgICBiKGEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHEoYSwgYikge1xuICAgIGlmIChhLmEgPT0gcCkge1xuICAgICAgaWYgKGIgPT0gYSkgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgdmFyIGMgPSAhMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBkID0gYiAmJiBiLnRoZW47XG4gICAgICAgIGlmIChudWxsICE9IGIgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgYiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGQpIHtcbiAgICAgICAgICBkLmNhbGwoXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgYyB8fCBxKGEsIGIpO1xuICAgICAgICAgICAgICBjID0gITA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgYyB8fCByKGEsIGIpO1xuICAgICAgICAgICAgICBjID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYyB8fCByKGEsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhLmEgPSAwO1xuICAgICAgYS5iID0gYjtcbiAgICAgIHYoYSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHIoYSwgYikge1xuICAgIGlmIChhLmEgPT0gcCkge1xuICAgICAgaWYgKGIgPT0gYSkgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgYS5hID0gMTtcbiAgICAgIGEuYiA9IGI7XG4gICAgICB2KGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB2KGEpIHtcbiAgICBsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhLmEgIT0gcClcbiAgICAgICAgZm9yICg7IGEuZi5sZW5ndGg7ICkge1xuICAgICAgICAgIHZhciBiID0gYS5mLnNoaWZ0KCksXG4gICAgICAgICAgICBjID0gYlswXSxcbiAgICAgICAgICAgIGQgPSBiWzFdLFxuICAgICAgICAgICAgZSA9IGJbMl0sXG4gICAgICAgICAgICBiID0gYlszXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgMCA9PSBhLmFcbiAgICAgICAgICAgICAgPyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGNcbiAgICAgICAgICAgICAgICA/IGUoYy5jYWxsKHZvaWQgMCwgYS5iKSlcbiAgICAgICAgICAgICAgICA6IGUoYS5iKVxuICAgICAgICAgICAgICA6IDEgPT0gYS5hICYmXG4gICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZCA/IGUoZC5jYWxsKHZvaWQgMCwgYS5iKSkgOiBiKGEuYikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgIGIoaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbi5wcm90b3R5cGUuZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuYyh2b2lkIDAsIGEpO1xuICB9O1xuICBuLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChkLCBlKSB7XG4gICAgICBjLmYucHVzaChbYSwgYiwgZCwgZV0pO1xuICAgICAgdihjKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gdyhhKSB7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICBmdW5jdGlvbiBkKGMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaFtjXSA9IGQ7XG4gICAgICAgICAgZSArPSAxO1xuICAgICAgICAgIGUgPT0gYS5sZW5ndGggJiYgYihoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBlID0gMCxcbiAgICAgICAgaCA9IFtdO1xuICAgICAgMCA9PSBhLmxlbmd0aCAmJiBiKGgpO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhLmxlbmd0aDsgayArPSAxKSB1KGFba10pLmMoZChrKSwgYyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24geChhKSB7XG4gICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGEubGVuZ3RoOyBkICs9IDEpIHUoYVtkXSkuYyhiLCBjKTtcbiAgICB9KTtcbiAgfVxuICB3aW5kb3cuUHJvbWlzZSB8fFxuICAgICgod2luZG93LlByb21pc2UgPSBuKSxcbiAgICAod2luZG93LlByb21pc2UucmVzb2x2ZSA9IHUpLFxuICAgICh3aW5kb3cuUHJvbWlzZS5yZWplY3QgPSB0KSxcbiAgICAod2luZG93LlByb21pc2UucmFjZSA9IHgpLFxuICAgICh3aW5kb3cuUHJvbWlzZS5hbGwgPSB3KSxcbiAgICAod2luZG93LlByb21pc2UucHJvdG90eXBlLnRoZW4gPSBuLnByb3RvdHlwZS5jKSxcbiAgICAod2luZG93LlByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBuLnByb3RvdHlwZS5nKSk7XG59KSgpO1xuXG4gIGZ1bmN0aW9uIGwoYSwgYikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAgICAgID8gYS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGIsICExKVxuICAgICAgOiBhLmF0dGFjaEV2ZW50KFwic2Nyb2xsXCIsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIG0oYSkge1xuICAgIGRvY3VtZW50LmJvZHlcbiAgICAgID8gYSgpXG4gICAgICA6IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAgICAgID8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjKTtcbiAgICAgICAgICBhKCk7XG4gICAgICAgIH0pXG4gICAgICA6IGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uIGsoKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgXCJpbnRlcmFjdGl2ZVwiID09IGRvY3VtZW50LnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY29tcGxldGVcIiA9PSBkb2N1bWVudC5yZWFkeVN0YXRlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgayksIGEoKTtcbiAgICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdChhKSB7XG4gICAgdGhpcy5hID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmEuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIHRoaXMuYS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7XG4gICAgdGhpcy5iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5oID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5mID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGhpcy5nID0gLTE7XG4gICAgdGhpcy5iLnN0eWxlLmNzc1RleHQgPVxuICAgICAgXCJtYXgtd2lkdGg6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO292ZXJmbG93OnNjcm9sbDtmb250LXNpemU6MTZweDtcIjtcbiAgICB0aGlzLmMuc3R5bGUuY3NzVGV4dCA9XG4gICAgICBcIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO1xuICAgIHRoaXMuZi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgIFwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7XG4gICAgdGhpcy5oLnN0eWxlLmNzc1RleHQgPVxuICAgICAgXCJkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoyMDAlO2hlaWdodDoyMDAlO2ZvbnQtc2l6ZToxNnB4O21heC13aWR0aDpub25lO1wiO1xuICAgIHRoaXMuYi5hcHBlbmRDaGlsZCh0aGlzLmgpO1xuICAgIHRoaXMuYy5hcHBlbmRDaGlsZCh0aGlzLmYpO1xuICAgIHRoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmIpO1xuICAgIHRoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmMpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYSwgYikge1xuICAgIGEuYS5zdHlsZS5jc3NUZXh0ID1cbiAgICAgIFwibWF4LXdpZHRoOm5vbmU7bWluLXdpZHRoOjIwcHg7bWluLWhlaWdodDoyMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDphdXRvO21hcmdpbjowO3BhZGRpbmc6MDt0b3A6LTk5OXB4O3doaXRlLXNwYWNlOm5vd3JhcDtmb250LXN5bnRoZXNpczpub25lO2ZvbnQ6XCIgK1xuICAgICAgYiArXG4gICAgICBcIjtcIjtcbiAgfVxuICBmdW5jdGlvbiB6KGEpIHtcbiAgICB2YXIgYiA9IGEuYS5vZmZzZXRXaWR0aCxcbiAgICAgIGMgPSBiICsgMTAwO1xuICAgIGEuZi5zdHlsZS53aWR0aCA9IGMgKyBcInB4XCI7XG4gICAgYS5jLnNjcm9sbExlZnQgPSBjO1xuICAgIGEuYi5zY3JvbGxMZWZ0ID0gYS5iLnNjcm9sbFdpZHRoICsgMTAwO1xuICAgIHJldHVybiBhLmcgIT09IGIgPyAoKGEuZyA9IGIpLCAhMCkgOiAhMTtcbiAgfVxuICBmdW5jdGlvbiBBKGEsIGIpIHtcbiAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgdmFyIGEgPSBrO1xuICAgICAgeihhKSAmJiBhLmEucGFyZW50Tm9kZSAmJiBiKGEuZyk7XG4gICAgfVxuICAgIHZhciBrID0gYTtcbiAgICBsKGEuYiwgYyk7XG4gICAgbChhLmMsIGMpO1xuICAgIHooYSk7XG4gIH1cbiAgZnVuY3Rpb24gQihhLCBiKSB7XG4gICAgdmFyIGMgPSBiIHx8IHt9O1xuICAgIHRoaXMuZmFtaWx5ID0gYTtcbiAgICB0aGlzLnN0eWxlID0gYy5zdHlsZSB8fCBcIm5vcm1hbFwiO1xuICAgIHRoaXMud2VpZ2h0ID0gYy53ZWlnaHQgfHwgXCJub3JtYWxcIjtcbiAgICB0aGlzLnN0cmV0Y2ggPSBjLnN0cmV0Y2ggfHwgXCJub3JtYWxcIjtcbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgayA9IGEgfHwgXCJCRVNic3d5XCIsXG4gICAgICAgICAgciA9IDAsXG4gICAgICAgICAgbiA9IGIgfHwgM2UzLFxuICAgICAgICAgIEggPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKEooKSAmJiAhRygpKSB7XG4gICAgICAgICAgICB2YXIgTSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gSCA+PSBuXG4gICAgICAgICAgICAgICAgICAgID8gYihFcnJvcihcIlwiICsgbiArIFwibXMgdGltZW91dCBleGNlZWRlZCBsb2FkaW5nIGZvbnRzXCIpKVxuICAgICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmZvbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAubG9hZChMKGMsICdcIicgKyBjLmZhbWlseSArICdcIicpLCBrKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMSA8PSBjLmxlbmd0aCA/IGEoKSA6IHNldFRpbWVvdXQoZSwgMjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUoKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIE4gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgICAgIHIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGMoRXJyb3IoXCJcIiArIG4gKyBcIm1zIHRpbWVvdXQgZXhjZWVkZWQgbG9hZGluZyBmb250c1wiKSk7XG4gICAgICAgICAgICAgICAgfSwgbik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgUHJvbWlzZS5yYWNlKFtOLCBNXSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChyKTtcbiAgICAgICAgICAgICAgYShjKTtcbiAgICAgICAgICAgIH0sIGIpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgbShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGI7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGIgPVxuICAgICAgICAgICAgICAgICAgICAoLTEgIT0gZiAmJiAtMSAhPSBnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoLTEgIT0gZiAmJiAtMSAhPSBoKSB8fFxuICAgICAgICAgICAgICAgICAgICAoLTEgIT0gZyAmJiAtMSAhPSBoKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAoYiA9IGYgIT0gZyAmJiBmICE9IGggJiYgZyAhPSBoKSB8fFxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gQyAmJlxuICAgICAgICAgICAgICAgICAgICAgICgoYiA9IC9BcHBsZVdlYktpdFxcLyhbMC05XSspKD86XFwuKFswLTldKykpLy5leGVjKFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAoQyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhIWIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICg1MzYgPiBwYXJzZUludChiWzFdLCAxMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDUzNiA9PT0gcGFyc2VJbnQoYlsxXSwgMTApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTEgPj0gcGFyc2VJbnQoYlsyXSwgMTApKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgKGIgPVxuICAgICAgICAgICAgICAgICAgICAgIEMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKGYgPT0gdyAmJiBnID09IHcgJiYgaCA9PSB3KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGYgPT0geCAmJiBnID09IHggJiYgaCA9PSB4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGYgPT0geSAmJiBnID09IHkgJiYgaCA9PSB5KSkpKSxcbiAgICAgICAgICAgICAgICAgICAgKGIgPSAhYik7XG4gICAgICAgICAgICAgICAgYiAmJlxuICAgICAgICAgICAgICAgICAgKGQucGFyZW50Tm9kZSAmJiBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksXG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQociksXG4gICAgICAgICAgICAgICAgICBhKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBJKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIEggPj0gbilcbiAgICAgICAgICAgICAgICAgIGQucGFyZW50Tm9kZSAmJiBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksXG4gICAgICAgICAgICAgICAgICAgIGIoRXJyb3IoXCJcIiArIG4gKyBcIm1zIHRpbWVvdXQgZXhjZWVkZWQgbG9hZGluZyBmb250c1wiKSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgICAgICAgIGlmICghMCA9PT0gYSB8fCB2b2lkIDAgPT09IGEpXG4gICAgICAgICAgICAgICAgICAgIChmID0gZS5hLm9mZnNldFdpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAoZyA9IHAuYS5vZmZzZXRXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgKGggPSBxLmEub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgICAgIHIgPSBzZXRUaW1lb3V0KEksIDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgdChrKSxcbiAgICAgICAgICAgICAgICBwID0gbmV3IHQoayksXG4gICAgICAgICAgICAgICAgcSA9IG5ldyB0KGspLFxuICAgICAgICAgICAgICAgIGYgPSAtMSxcbiAgICAgICAgICAgICAgICBnID0gLTEsXG4gICAgICAgICAgICAgICAgaCA9IC0xLFxuICAgICAgICAgICAgICAgIHcgPSAtMSxcbiAgICAgICAgICAgICAgICB4ID0gLTEsXG4gICAgICAgICAgICAgICAgeSA9IC0xLFxuICAgICAgICAgICAgICAgIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICBkLmRpciA9IFwibHRyXCI7XG4gICAgICAgICAgICAgIHUoZSwgTChjLCBcInNhbnMtc2VyaWZcIikpO1xuICAgICAgICAgICAgICB1KHAsIEwoYywgXCJzZXJpZlwiKSk7XG4gICAgICAgICAgICAgIHUocSwgTChjLCBcIm1vbm9zcGFjZVwiKSk7XG4gICAgICAgICAgICAgIGQuYXBwZW5kQ2hpbGQoZS5hKTtcbiAgICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChwLmEpO1xuICAgICAgICAgICAgICBkLmFwcGVuZENoaWxkKHEuYSk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZCk7XG4gICAgICAgICAgICAgIHcgPSBlLmEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIHggPSBwLmEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIHkgPSBxLmEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIEkoKTtcbiAgICAgICAgICAgICAgQShlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGYgPSBhO1xuICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHUoZSwgTChjLCAnXCInICsgYy5mYW1pbHkgKyAnXCIsc2Fucy1zZXJpZicpKTtcbiAgICAgICAgICAgICAgQShwLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGcgPSBhO1xuICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHUocCwgTChjLCAnXCInICsgYy5mYW1pbHkgKyAnXCIsc2VyaWYnKSk7XG4gICAgICAgICAgICAgIEEocSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBoID0gYTtcbiAgICAgICAgICAgICAgICB2KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB1KHEsIEwoYywgJ1wiJyArIGMuZmFtaWx5ICsgJ1wiLG1vbm9zcGFjZScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gIH1cbiAgdmFyIEMgPSBudWxsLFxuICAgIEQgPSBudWxsLFxuICAgIEUgPSBudWxsLFxuICAgIEYgPSBudWxsO1xuICBmdW5jdGlvbiBHKCkge1xuICAgIGlmIChudWxsID09PSBEKVxuICAgICAgaWYgKEooKSAmJiAvQXBwbGUvLnRlc3Qod2luZG93Lm5hdmlnYXRvci52ZW5kb3IpKSB7XG4gICAgICAgIHZhciBhID0gL0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkoPzpcXC4oWzAtOV0rKSkvLmV4ZWMoXG4gICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgKTtcbiAgICAgICAgRCA9ICEhYSAmJiA2MDMgPiBwYXJzZUludChhWzFdLCAxMCk7XG4gICAgICB9IGVsc2UgRCA9ICExO1xuICAgIHJldHVybiBEO1xuICB9XG4gIGZ1bmN0aW9uIEooKSB7XG4gICAgbnVsbCA9PT0gRiAmJiAoRiA9ICEhZG9jdW1lbnQuZm9udHMpO1xuICAgIHJldHVybiBGO1xuICB9XG4gIGZ1bmN0aW9uIEsoKSB7XG4gICAgaWYgKG51bGwgPT09IEUpIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGEuc3R5bGUuZm9udCA9IFwiY29uZGVuc2VkIDEwMHB4IHNhbnMtc2VyaWZcIjtcbiAgICAgIH0gY2F0Y2ggKGIpIHt9XG4gICAgICBFID0gXCJcIiAhPT0gYS5zdHlsZS5mb250O1xuICAgIH1cbiAgICByZXR1cm4gRTtcbiAgfVxuICBmdW5jdGlvbiBMKGEsIGIpIHtcbiAgICByZXR1cm4gW2Euc3R5bGUsIGEud2VpZ2h0LCBLKCkgPyBhLnN0cmV0Y2ggOiBcIlwiLCBcIjEwMHB4XCIsIGJdLmpvaW4oXCIgXCIpO1xuICB9XG4gXG5leHBvcnQgZGVmYXVsdCBCO1xuIiwiaW1wb3J0IExpbmVDbGFtcCBmcm9tIFwiLi9saW5lQ2xhbXAuanNcIlxyXG5cclxuZnVuY3Rpb24gaW5saW5lQmxvY2soZWwpIHtcclxuICBpZiAoIVsnaW5saW5lJywnaW5saW5lLWJsb2NrJ10uaW5jbHVkZXMod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXkpIHx8IGVsLmNsYXNzTGlzdC5jb250YWlucygndGV4dEZpdHRlZCcpKSB7XHJcbiAgICByZXR1cm4gZWxcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuLy8gZmluZCBhbGwgdGV4dCBub2RlcyB1bmRlciBhIGdpdmVuIGVsZW1lbnRcclxuZnVuY3Rpb24gdGV4dE5vZGVzVW5kZXIoZWwpe1xyXG4gIHZhciBuLCBhPVtdLCB3YWxrPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWwsTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCxmYWxzZSk7XHJcbiAgd2hpbGUobiA9IHdhbGsubmV4dE5vZGUoKSkge1xyXG4gICAgaWYgKG4udGV4dENvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgIGlmIChpbmxpbmVCbG9jayhuLnBhcmVudEVsZW1lbnQpICYmICFhLmluY2x1ZGVzKG4ucGFyZW50RWxlbWVudCkpIHtcclxuICAgICAgICBhLnB1c2gobi5wYXJlbnRFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYTtcclxufVxyXG5cclxuLy8gc29tZSBlbGVtbmV0cyBkb24ndCBoYXZlIGhlaWdodCB2YWx1ZXMgc2V0IGNvcnJlY3RseSBzbyB3ZSBuZWVkIHRvIGRyaWxsIGRvd24gXHJcbmZ1bmN0aW9uIGZpbmRUZXh0Tm9kZSh0YXJnZXQpIHtcclxuICAvLyBpZiAoY2hpbGQgJiYgWydTUEFOJywnVE9LRU4tVkFMVUUnLCdTVFJPTkcnLCdQJywnRU0nLCcnXS5pbmNsdWRlcyhjaGlsZC50YWdOYW1lKSkge1xyXG4gIGlmICh0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQgJiYgIVsnQlInXS5pbmNsdWRlcyh0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQudGFnTmFtZSkpIHtcclxuICAgIHRhcmdldCA9IGZpbmRUZXh0Tm9kZSh0YXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpO1xyXG4gIH1cclxuICByZXR1cm4gdGFyZ2V0XHJcbn1cclxuLy8gbm90IHNvIHNpbXBsZSByb3VuZGluZyBmb3IgbGluZSBjb3VudGluZyBwdXJwb3Nlc1xyXG5mdW5jdGlvbiBzaW1wbGVSb3VuZGluZyhudW0pIHtcclxuICBpZiAobnVtID4gMTApIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSk7XHJcbiAgICAvLyByZXR1cm4gbnVtLnRvRml4ZWQoMCkucmVwbGFjZSgvKFxcLjArfDArKSQvLCAnJyk7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSkvLy5yZXBsYWNlKC8oXFwuMCt8MCspJC8sICcnKTtcclxufVxyXG4vLyBjb3VudCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluc2lkZSBvZiB0aGUgY3VycmVudCBkaXJlY3QgZWxlbWVudFxyXG5mdW5jdGlvbiBjb3VudExpbmVzKGVsZW1lbnRzKSB7XHJcbiAgdmFyIGVsVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50cyk7XHJcbiAgaWYgKFxyXG4gICAgZWxUeXBlICE9PSBcIltvYmplY3QgQXJyYXldXCIgJiZcclxuICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiICYmXHJcbiAgICBlbFR5cGUgIT09IFwiW29iamVjdCBIVE1MQ29sbGVjdGlvbl1cIlxyXG4gICkge1xyXG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG4gIH1cclxuICBsZXQgcmVzdWx0ID0gWy4uLmVsZW1lbnRzXS5tYXAodGFyZ2V0ID0+IHtcclxuICAgIC8vIGlmICgxID09IDIpIHtcclxuICAgIC8vICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2NvdW50aW5nTGluZXMnKTtcclxuICAgIC8vICAgbGV0IHRlc3RCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgLy8gICBsZXQgY291bnRlclRhcmdldCA9IGZpbmRUZXh0Tm9kZSh0YXJnZXQpXHJcbiAgICAvLyAgIGNvbnNvbGUubG9nKGNvdW50ZXJUYXJnZXQpXHJcbiAgICAvLyAgIC8vIGxldCB0YXJnZXRGaXggPSB0YXJnZXQuZmlyc3RDaGlsZCA/IHRhcmdldC5maXJzdENoaWxkLmNsYXNzTGlzdCA9PT0gXCJ0ZXh0Rml0dGVkXCIgPyB0YXJnZXQuZmlyc3RDaGlsZCA6IHRhcmdldCA6IHRhcmdldDsgXHJcbiAgICAvLyAgIHRlc3RCb3guY2xhc3NMaXN0ID0gXCJsaW5lQ291bnRlclwiO1xyXG4gICAgLy8gICAvLyB0ZXN0Qm94LnN0eWxlLmZvbnRGYW1pbHkgPSBcIi13ZWJraXQtcGljdG9ncmFwaFwiO1xyXG4gICAgLy8gICAvLyB0ZXN0Qm94LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAvLyAgIC8vIHRlc3RCb3guc3R5bGUuZm9udFNpemUgPSB0YXJnZXRGaXguc3R5bGUuZm9udFNpemU7XHJcbiAgICAvLyAgIHRlc3RCb3guaW5uZXJUZXh0ID0gXCLigItcIjtcclxuICAgIC8vICAgY291bnRlclRhcmdldC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyYmVnaW4nLCB0ZXN0Qm94KSBcclxuICAgIC8vICAgbGV0IG9uZUxpbmVIZWlnaHQgPSBnZXRIZWlnaHQodGVzdEJveCk7XHJcbiAgICAvLyAgIHRlc3RCb3gucmVtb3ZlKCk7XHJcbiAgICAvLyAgIGxldCBsaW5lQ291bnQgPSBnZXRIZWlnaHQodGFyZ2V0KSAvIG9uZUxpbmVIZWlnaHQ7XHJcbiAgICAvLyAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdjb3VudGluZ0xpbmVzJylcclxuICAgIC8vICAgbGV0IGxpbmVDb3VudFJvdW5kZWQgPSBzaW1wbGVSb3VuZGluZyhsaW5lQ291bnQpXHJcbiAgICAvLyAgIHRhcmdldC5kYXRhc2V0LmNhbGN1bGF0ZWRMaW5lc0NvdW50ID0gbGluZUNvdW50Um91bmRlZDsgLy8gYWRkcyBwcm9wZXJ0eSBmb3IgQ1NTIHRhcmdldGluZ1xyXG4gICAgLy8gICB0YXJnZXQuZGF0YXNldC5yYXdMaW5lc0NvdW50ID0gbGluZUNvdW50OyAvLyBhZGRzIHByb3BlcnR5IGZvciBDU1MgdGFyZ2V0aW5nXHJcbiAgICAvLyAgIHJldHVybiBsaW5lQ291bnRSb3VuZGVkO1xyXG4gICAgLy8gfSBlbHNlIHtcclxuICAgICAgbGV0IG11aWx0Q291bnQgPSAwO1xyXG4gICAgICBsZXQgdGV4dE5vZGVzID0gdGV4dE5vZGVzVW5kZXIodGFyZ2V0KTtcclxuXHJcbiAgICAgIC8vIGxldCB0ZXN0ID0gdGV4dE5vZGVzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgLy8gICBjb25zb2xlLmxvZyhzKVxyXG4gICAgICAvLyB9KVxyXG4gICAgICBjb25zb2xlLmxvZyh0ZXh0Tm9kZXMsJ3RleHROb2RlcycpXHJcblxyXG4gICAgICB0ZXh0Tm9kZXMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgLy8gbGV0IGlubGluZUVsZW1lbnQgPSBcclxuICAgICAgICAvLyBpZiAoZWwubm9kZU5hbWUgPT0pXHJcbiAgICAgICAgLy8gbGV0IGRpc3BsYXlUeXBlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXk7XHJcbiAgICAgICAgLy8gaWYgKGRpc3BsYXlUeXBlID09IFwiaW5saW5lXCIgfHwgZGlzcGxheVR5cGUgPT0gXCJpbmxpbmUtYmxvY2tcIikge1xyXG4gICAgICAgIC8vICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGlmIChpbmxpbmVCbG9jayhlbCkpIHtcclxuICAgICAgICAgIGxldCBtZXRyaWNzID0gY2FsY3VsYXRlVGV4dE1ldHJpY3MoZWwpO1xyXG4gICAgICAgICAgbGV0IGxpbmUgPSBzaW1wbGVSb3VuZGluZyhtZXRyaWNzLmxpbmVDb3VudClcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGVsLCBsaW5lKVxyXG4gICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgZWwuZGF0YXNldC5yYXdMaW5lc0NvdW50ID0gbGluZTtcclxuICAgICAgICAgICAgbXVpbHRDb3VudCArPSBsaW5lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgIH0pXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRhcmdldC5pbm5lclRleHQuc3Vic3RyaW5nKDAsIDEwKSwgbXVpbHRDb3VudClcclxuICAgICAgbGV0IGxpbmVDb3VudFJvdW5kZWQgPSBzaW1wbGVSb3VuZGluZyhtdWlsdENvdW50KVxyXG4gICAgICB0YXJnZXQuZGF0YXNldC5jYWxjdWxhdGVkTGluZXNDb3VudCA9IGxpbmVDb3VudFJvdW5kZWQgLy8gYWRkcyBwcm9wZXJ0eSBmb3IgQ1NTIHRhcmdldGluZ1xyXG4gICAgICByZXR1cm4gbGluZUNvdW50Um91bmRlZFxyXG4gICAgICAvLyBsZXQgbWV0cmljcyA9IGNhbGN1bGF0ZVRleHRNZXRyaWNzKHRhcmdldCk7XHJcbiAgICAgIC8vIGlmIChtZXRyaWNzLmxpbmVDb3VudCkge1xyXG4gICAgICAvLyAgIGxldCBsaW5lQ291bnRSb3VuZGVkID0gc2ltcGxlUm91bmRpbmcobWV0cmljcy5saW5lQ291bnQpXHJcbiAgICAgIC8vICAgdGFyZ2V0LmRhdGFzZXQuY2FsY3VsYXRlZExpbmVzQ291bnQgPSBsaW5lQ291bnRSb3VuZGVkIC8vIGFkZHMgcHJvcGVydHkgZm9yIENTUyB0YXJnZXRpbmdcclxuICAgICAgLy8gICB0YXJnZXQuZGF0YXNldC5yYXdMaW5lc0NvdW50ID0gbWV0cmljcy5saW5lQ291bnQ7IC8vIGFkZHMgcHJvcGVydHkgZm9yIENTUyB0YXJnZXRpbmdcclxuICAgICAgLy8gICByZXR1cm4gbGluZUNvdW50Um91bmRlZFxyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIHJldHVybiBudWxsXHJcbiAgICAvLyB9XHJcbiAgfSk7XHJcbiAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMSkge1xyXG4gICAgcmV0dXJuIHJlc3VsdFswXTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubGV0IGNsYW1wRGVmYXVsdHMgPSB7IG1heExpbmVzOiAxLCBtaW5Gb250U2l6ZTogMTgsIHVzZVNvZnRDbGFtcDogdHJ1ZSwgZWxsaXBzaXM6ICcuLi4nIH1cclxuZnVuY3Rpb24gbGluZUNsYW1wKGVsZW1lbnRzLCBjb25maWcpICB7XHJcbiAgY29uZmlnID0geyAuLi5jbGFtcERlZmF1bHRzLCAuLi5jb25maWcgfVxyXG4gIHZhciBlbFR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpO1xyXG4gIGlmIChcclxuICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICYmXHJcbiAgICBlbFR5cGUgIT09IFwiW29iamVjdCBOb2RlTGlzdF1cIiAmJlxyXG4gICAgZWxUeXBlICE9PSBcIltvYmplY3QgSFRNTENvbGxlY3Rpb25dXCJcclxuICApIHtcclxuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuICB9XHJcbiAgcmV0dXJuIFsuLi5lbGVtZW50c10ubWFwKGVsZW1lbnQgPT4ge1xyXG4gICAgY29uc3QgY2xhbXAgPSBuZXcgTGluZUNsYW1wKGVsZW1lbnQsIGNvbmZpZylcclxuICAgIGNsYW1wLmFwcGx5KClcclxuICAgIGNsYW1wLndhdGNoKClcclxuICAgXHJcbiAgICByZXR1cm4gY2xhbXA7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbGluZUNvdW50IGFuZCBsaW5lIGhpZWdodCBpbmZvIGZyb20gdGhpcyBsaWJhcmF5IGh0dHBzOi8vZ2l0aHViLmNvbS90dmFuYy9saW5lY2xhbXBcclxuZnVuY3Rpb24gY2FsY3VsYXRlVGV4dE1ldHJpY3MoZWxlbWVudHMsIGNvbmZpZykge1xyXG4gIHZhciBlbFR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpO1xyXG4gIGlmIChcclxuICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICYmXHJcbiAgICBlbFR5cGUgIT09IFwiW29iamVjdCBOb2RlTGlzdF1cIiAmJlxyXG4gICAgZWxUeXBlICE9PSBcIltvYmplY3QgSFRNTENvbGxlY3Rpb25dXCJcclxuICApIHtcclxuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuICB9XHJcbiAgbGV0IHJlc3VsdCA9IFsuLi5lbGVtZW50c10ubWFwKGVsZW1lbnQgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBMaW5lQ2xhbXAoZWxlbWVudCwgY29uZmlnKS5jYWxjdWxhdGVUZXh0TWV0cmljcygpO1xyXG4gIH0pO1xyXG4gIGlmIChyZXN1bHQubGVuZ3RoID09IDEpIHtcclxuICAgIHJldHVybiByZXN1bHRbMF07XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSBoZWlnaHQgd2l0aG91dCBwYWRkaW5nLlxyXG5mdW5jdGlvbiBnZXRIZWlnaHQoZWwpIHtcclxuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcbiAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKSk7XHJcbiAgdmFyIGJveF9zaXppbmcgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTtcclxuICBpZiAoYm94X3NpemluZyA9PT0gXCJib3JkZXItYm94XCIpIHtcclxuICAgIHZhciBwYWRkaW5nX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctdG9wXCIpKTtcclxuICAgIHZhciBwYWRkaW5nX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctYm90dG9tXCIpKTtcclxuICAgIHZhciBib3JkZXJfdG9wID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXRvcC13aWR0aFwiKSk7XHJcbiAgICB2YXIgYm9yZGVyX2JvdHRvbSA9IHBhcnNlRmxvYXQoXHJcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItYm90dG9tLXdpZHRoXCIpXHJcbiAgICApO1xyXG4gICAgaGVpZ2h0ID0gaGVpZ2h0IC0gcGFkZGluZ190b3AgLSBwYWRkaW5nX2JvdHRvbSAtIGJvcmRlcl90b3AgLSBib3JkZXJfYm90dG9tO1xyXG4gIH1cclxuICBlbC5kYXRhc2V0LmNhbGN1bGF0ZWRIZWlnaHQgPSBoZWlnaHQ7IC8vIGFkZHMgcHJvcGVydHkgZm9yIGRlYnVnaW5nXHJcbiAgcmV0dXJuIGhlaWdodDtcclxufVxyXG5cclxuLy8gQ2FsY3VsYXRlIHdpZHRoIHdpdGhvdXQgcGFkZGluZy5cclxuZnVuY3Rpb24gZ2V0V2lkdGgoZWwpIHtcclxuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcbiAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIikpO1xyXG4gIHZhciBib3hfc2l6aW5nID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImJveC1zaXppbmdcIik7XHJcbiAgaWYgKGJveF9zaXppbmcgPT09IFwiYm9yZGVyLWJveFwiKSB7XHJcbiAgICB2YXIgcGFkZGluZ19sZWZ0ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1sZWZ0XCIpKTtcclxuICAgIHZhciBwYWRkaW5nX3JpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1yaWdodFwiKSk7XHJcbiAgICB2YXIgYm9yZGVyX2xlZnQgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItbGVmdC13aWR0aFwiKSk7XHJcbiAgICB2YXIgYm9yZGVyX3JpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIpKTtcclxuICAgIHdpZHRoID0gd2lkdGggLSBwYWRkaW5nX2xlZnQgLSBwYWRkaW5nX3JpZ2h0IC0gYm9yZGVyX2xlZnQgLSBib3JkZXJfcmlnaHQ7XHJcbiAgfVxyXG4gIGVsLmRhdGFzZXQuY2FsY3VsYXRlZFdpZHRoID0gd2lkdGg7IC8vIGFkZHMgcHJvcGVydHkgZm9yIGRlYnVnaW5nXHJcbiAgcmV0dXJuIHdpZHRoO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXhMaW5lQ2hlY2soZWxlbWVudCA9IG51bGwpIHtcclxuICBjb25zdCBpc0V4cG9ydE1vZGUgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZXhwb3J0c1wiKSA+IC0xO1xyXG4gIGNvbnN0IGlzTG9jYWxEZXYgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwibG9jYWxob3N0XCIpID4gLTE7XHJcbiAgY29uc3QgcHJldmVudEV4cG9ydE92ZXJmbG93ID1cclxuICAgIGRvY3VtZW50LmJvZHkuZGF0YXNldC5wcmV2ZW50RXhwb3J0T3ZlcmZsb3cgPT09IFwidHJ1ZVwiO1xyXG4gIGNvbnN0IGlzUHJvamVjdEtpdCA9IGlzTG9jYWxEZXZcclxuICAgID8gdW5kZWZpbmVkXHJcbiAgICA6IHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5wcmV2aWV3LWZyYW1lXCIpO1xyXG5cclxuICBpZiAoKGlzRXhwb3J0TW9kZSAmJiBwcmV2ZW50RXhwb3J0T3ZlcmZsb3cpIHx8IGlzUHJvamVjdEtpdCkgcmV0dXJuO1xyXG5cclxuICBjb25zdCBibG9ja3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtbWF4LWxpbmVdXCIpO1xyXG4gIGJsb2Nrcy5mb3JFYWNoKChibG9jaykgPT4ge1xyXG4gICAgY29uc3QgbGluZUNvdW50ID0gY291bnRMaW5lcyhibG9jayk7XHJcbiAgICAvLyBHZXR0aW5nIHRoZSBkYXRhLW1heC1saW5lIGF0dHJpYnV0ZSB2YWx1ZSAobWF4IG51bWJlciBvZiBsaW5lcyBhbGxvd2VkKSBcclxuICAgIGNvbnN0IG1heExpbmUgPSBibG9jay5kYXRhc2V0Lm1heExpbmVBbHQgfHwgYmxvY2suZGF0YXNldC5tYXhMaW5lO1xyXG5cclxuICAgIGxpbmVDb3VudCA+IG1heExpbmVcclxuICAgICAgPyBibG9jay5jbGFzc0xpc3QuYWRkKFwib3ZlcmZsb3dcIilcclxuICAgICAgOiBibG9jay5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4qRGV0YWlsZWQgaW5zdHJ1Y3Rpb24gY2FuIGJlIGZvdW5kIGhlcmU6XHJcbiBodHRwczovL2dpdGh1Yi5jb20vYWxla3MtZnJvbnRlbmQvbWF4LWhlaWdodC1jaGVja1xyXG4qL1xyXG5mdW5jdGlvbiBtYXhIZWlnaHRDaGVjayhlbGVtZW50ID0gbnVsbCkge1xyXG4gIGNvbnN0IGlzRXhwb3J0TW9kZSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJleHBvcnRzXCIpID4gLTE7XHJcbiAgY29uc3QgaXNMb2NhbERldiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJsb2NhbGhvc3RcIikgPiAtMTtcclxuICBjb25zdCBwcmV2ZW50RXhwb3J0T3ZlcmZsb3cgPVxyXG4gICAgZG9jdW1lbnQuYm9keS5kYXRhc2V0LnByZXZlbnRFeHBvcnRPdmVyZmxvdyA9PT0gXCJ0cnVlXCI7XHJcbiAgY29uc3QgaXNQcm9qZWN0S2l0ID0gaXNMb2NhbERldlxyXG4gICAgPyB1bmRlZmluZWRcclxuICAgIDogd2luZG93LnBhcmVudC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnByZXZpZXctZnJhbWVcIik7XHJcblxyXG4gIGlmICgoaXNFeHBvcnRNb2RlICYmIHByZXZlbnRFeHBvcnRPdmVyZmxvdykgfHwgaXNQcm9qZWN0S2l0KSByZXR1cm47XHJcblxyXG4gIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1tYXgtaGVpZ2h0XVwiKTtcclxuICBibG9ja3MuZm9yRWFjaCgoYmxvY2spID0+IHtcclxuICAgIGlmIChibG9jay5kYXRhc2V0Lm1heEhlaWdodCA9PT0gXCJkeW5hbWljXCIgfHwgYmxvY2suZGF0YXNldC5tYXhIZWlnaHREeW5hbWljID09PSBcInRydWVcIikge1xyXG4gICAgICBkeW5hbWljQXNzaWduKGJsb2NrKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gZ2V0SGVpZ2h0KGJsb2NrKTtcclxuICAgIGNvbnN0IG1heEhlaWdodCA9IGJsb2NrLmRhdGFzZXQubWF4SGVpZ2h0O1xyXG5cclxuICAgIC8vIFRPRE8gaW1wcm92ZSB0aGlzIFxyXG4gICAgaWYgKGJsb2NrLmRhdGFzZXQubWF4SGVpZ2h0ID09PSBcImNzc1wiKSB7XHJcbiAgICAgIGNvbnN0IGNvbXB1dGVkQmxvY2tTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJsb2NrKTtcclxuICAgICAgY29uc3QgY3NzTWF4SGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZEJsb2NrU3R5bGUubWF4SGVpZ2h0KTtcclxuICAgICAgaWYgKCFjc3NNYXhIZWlnaHQpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGVyZSBuZWVkcyB0byBiZSBhIG1heCBoZWlnaHQgc2V0IG9uIHRoZSBlbGVtZW50IGlmIHlvdSB3YW50IHRvIHVzZSBkYXRhLW1heC1oZWlnaHQ9XCJjc3NcIicpXHJcbiAgICAgIH1cclxuICAgICAgbWF4SGVpZ2h0ID0gY3NzTWF4SGVpZ2h0XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTZXR0aW5nIHRoZSBlbGVtZW50J3MgbWF4LWhlaWdodFxyXG4gICAgICBibG9jay5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBibG9jay5kYXRhc2V0Lm1heEhlaWdodFVuaXQgfHwgXCJweFwiO1xyXG5cclxuICAgICAgLy8gUmVjYWxjdWxhdGluZyBtYXhIZWlnaHQgaW4gY2FzZSAncmVtJyBpcyBzZXQgYXMgYSB1bml0XHJcbiAgICAgIGlmIChibG9jay5kYXRhc2V0Lm1heEhlaWdodFVuaXQgPT09IFwicmVtXCIpIHtcclxuICAgICAgICBtYXhIZWlnaHQgPSBtYXhIZWlnaHQgKiBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmZvbnRTaXplKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZGluZyBhbiAnb3ZlcmZsb3cnIGNsYXNzIHRvIGFuIGVsZW1lbnQgaWYgaXQncyBvZmZzZXQgaGVpZ2h0IGV4Y2VlZGVzIHRoZSBtYXgtbGluZS1oZWlnaHRcclxuICAgIGJsb2NrSGVpZ2h0ID4gbWF4SGVpZ2h0XHJcbiAgICAgID8gYmxvY2suY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpXHJcbiAgICAgIDogYmxvY2suY2xhc3NMaXN0LnJlbW92ZShcIm92ZXJmbG93XCIpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljQXNzaWduKGVsZW1lbnQgPSBudWxsKSB7XHJcbiAgY29uc3QgY29udGFpbmVyID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgLy8gY29uc3QgY29udGFpbmVyQ29tcHV0ZWQgPSB7XHJcbiAgLy8gICBoZWlnaHQ6IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5oZWlnaHQpLFxyXG4gIC8vICAgdG9wOiBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikucGFkZGluZ1RvcCksXHJcbiAgLy8gICBib3R0b206IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wYWRkaW5nQm90dG9tKSxcclxuICAvLyB9O1xyXG4gIC8vIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IE1hdGguZmxvb3IoXHJcbiAgLy8gICBjb250YWluZXJDb21wdXRlZC5oZWlnaHQgLSBjb250YWluZXJDb21wdXRlZC50b3AgLSBjb250YWluZXJDb21wdXRlZC5ib3R0b21cclxuICAvLyApO1xyXG4gIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IGdldEhlaWdodChjb250YWluZXIpXHJcbiAgLy8gVE9ETyB3b3JrIG91dCB3aGF0IHN1YnRyYWhlbmQgaXMgXHJcbiAgY29uc3Qgc3VidHJhaGVuZHMgPSBbLi4uY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuanMtc3VidHJhaGVuZFwiKV07XHJcblxyXG4gIGNvbnN0IHN1YnRyYWhlbmRzSGVpZ2h0ID0gc3VidHJhaGVuZHMucmVkdWNlKCh0b3RhbEhlaWdodCwgc3VidHJhaGVuZCkgPT4ge1xyXG4gICAgY29uc3Qgc3VidHJhaGVuZE1hcmdpbnMgPSB7XHJcbiAgICAgIHRvcDogcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdWJ0cmFoZW5kKS5tYXJnaW5Ub3ApLFxyXG4gICAgICBib3R0b206IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoc3VidHJhaGVuZCkubWFyZ2luQm90dG9tKSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0b3RhbEhlaWdodCArXHJcbiAgICAgIHN1YnRyYWhlbmQub2Zmc2V0SGVpZ2h0ICtcclxuICAgICAgc3VidHJhaGVuZE1hcmdpbnMudG9wICtcclxuICAgICAgc3VidHJhaGVuZE1hcmdpbnMuYm90dG9tXHJcbiAgICApO1xyXG4gIH0sIDApO1xyXG5cclxuICBjb25zdCBkeW5hbWljSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gc3VidHJhaGVuZHNIZWlnaHQ7XHJcblxyXG4gIGVsZW1lbnQuZGF0YXNldC5tYXhIZWlnaHREeW5hbWljID0gXCJ0cnVlXCI7XHJcbiAgZWxlbWVudC5kYXRhc2V0Lm1heEhlaWdodCA9IGR5bmFtaWNIZWlnaHQ7XHJcbiAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XHJcbn1cclxuXHJcbi8vIEFkZGluZyBsaW1pdCBmb3IgdGhlIHdvcmQgbGVuZ3RoXHJcbmZ1bmN0aW9uIGNoYXJMaW1pdChlbGVtZW50ID0gbnVsbCkge1xyXG4gIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jaGFyLWxpbWl0XVwiKTtcclxuICBibG9ja3MuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgY29uc3QgbGltaXQgPSBlbGVtZW50LmRhdGFzZXQuY2hhckxpbWl0O1xyXG5cclxuICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB0b2tlblZhbHVlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRva2VuLXZhbHVlXCIpO1xyXG5cclxuICAgIGlmICh0b2tlblZhbHVlLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgIGVsZW1lbnQgPSB0b2tlblZhbHVlLml0ZW0oMCk7XHJcbiAgICB9XHJcbiAgICB2YXIgY29kZSA9IGVsZW1lbnQuaW5uZXJUZXh0O1xyXG4gICAgaWYgKGNvZGUubGVuZ3RoID4gbGltaXQpIHtcclxuICAgICAgLy8gQ2hlY2sgVG9rZW4gQWdhaW5cclxuICAgICAgaWYgKHRva2VuVmFsdWUubGVuZ3RoICE9IDApIHtcclxuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBDaGVjayBUb2tlbiBBZ2FpblxyXG4gICAgICBpZiAodG9rZW5WYWx1ZS5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IHsgY2hhckxpbWl0LCBkeW5hbWljQXNzaWduLCBtYXhIZWlnaHRDaGVjaywgbWF4TGluZUNoZWNrLCBnZXRXaWR0aCwgZ2V0SGVpZ2h0LCBjb3VudExpbmVzLCBjYWxjdWxhdGVUZXh0TWV0cmljcywgbGluZUNsYW1wIH0iLCJpbXBvcnQgeyBnZXRIZWlnaHQgfSBmcm9tICcuL2xpbWl0ZXJzLmpzJ1xuXG4vKipcbiAqIFJlZHVjZXMgZm9udCBzaXplIG9yIHRyaW1zIHRleHQgdG8gbWFrZSBpdCBmaXQgd2l0aGluIHNwZWNpZmllZCBib3VuZHMuXG4gKlxuICogU3VwcG9ydHMgY2xhbXBpbmcgYnkgbnVtYmVyIG9mIGxpbmVzIG9yIHRleHQgaGVpZ2h0LlxuICpcbiAqIEtub3duIGxpbWl0YXRpb25zOlxuICogMS4gQ2hhcmFjdGVycyB0aGF0IGRpc3RvcnQgbGluZSBoZWlnaHRzIChlbW9qaXMsIHphbGdvKSBtYXkgY2F1c2VcbiAqIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqIDIuIENhbGxpbmcge0BzZWUgaGFyZENsYW1wKCl9IHdpcGVzIGNoaWxkIGVsZW1lbnRzLiBGdXR1cmUgdXBkYXRlcyBtYXkgYWxsb3dcbiAqIGlubGluZSBjaGlsZCBlbGVtZW50cyB0byBiZSBwcmVzZXJ2ZWQuXG4gKlxuICogQHRvZG8gU3BsaXQgdGV4dCBtZXRyaWNzIGludG8gb3duIGxpYnJhcnlcbiAqIEB0b2RvIFRlc3Qgbm9uLUxUUiB0ZXh0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDbGFtcCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIFRoZSBlbGVtZW50IHRvIGNsYW1wLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIE9wdGlvbnMgdG8gZ292ZXJuIGNsYW1waW5nIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4TGluZXNdXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBsaW5lcyB0byBhbGxvdy4gRGVmYXVsdHMgdG8gMS5cbiAgICogVG8gc2V0IGEgbWF4aW11bSBoZWlnaHQgaW5zdGVhZCwgdXNlIHtAc2VlIG9wdGlvbnMubWF4SGVpZ2h0fVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4SGVpZ2h0XVxuICAgKiBUaGUgbWF4aW11bSBoZWlnaHQgKGluIHBpeGVscykgb2YgdGV4dCBpbiBhbiBlbGVtZW50LlxuICAgKiBUaGlzIG9wdGlvbiBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC4gT25jZSBzZXQsIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlclxuICAgKiB7QHNlZSBvcHRpb25zLm1heExpbmVzfS4gTm90ZSB0aGF0IHRoaXMgYXBwbGllcyB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LCBub3RcbiAgICogdGhlIGVsZW1lbnQgaXRzZWxmLiBSZXN0cmljdGluZyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGNhbiBiZSBhY2hpZXZlZFxuICAgKiB3aXRoIENTUyA8Y29kZT5tYXgtaGVpZ2h0PC9jb2RlPi5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VTb2Z0Q2xhbXBdXG4gICAqIElmIHRydWUsIHJlZHVjZSBmb250IHNpemUgKHNvZnQgY2xhbXApIHRvIGF0IGxlYXN0IHtAc2VlIG9wdGlvbnMubWluRm9udFNpemV9XG4gICAqIGJlZm9yZSByZXNvcnRpbmcgdG8gdHJpbW1pbmcgdGV4dC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFyZENsYW1wQXNGYWxsYmFja11cbiAgICogSWYgdHJ1ZSwgcmVzb3J0IHRvIGhhcmQgY2xhbXBpbmcgaWYgc29mdCBjbGFtcGluZyByZWFjaGVzIHRoZSBtaW5pbXVtIGZvbnQgc2l6ZVxuICAgKiBhbmQgc3RpbGwgZG9lc24ndCBmaXQgd2l0aGluIHRoZSBtYXggaGVpZ2h0IG9yIG51bWJlciBvZiBsaW5lcy5cbiAgICogRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVsbGlwc2lzXVxuICAgKiBUaGUgY2hhcmFjdGVyIHdpdGggd2hpY2ggdG8gcmVwcmVzZW50IGNsaXBwZWQgdHJhaWxpbmcgdGV4dC5cbiAgICogVGhpcyBvcHRpb24gdGFrZXMgZWZmZWN0IHdoZW4gXCJoYXJkXCIgY2xhbXBpbmcgaXMgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pbkZvbnRTaXplXVxuICAgKiBUaGUgbG93ZXN0IGZvbnQgc2l6ZSwgaW4gcGl4ZWxzLCB0byB0cnkgYmVmb3JlIHJlc29ydGluZyB0byByZW1vdmluZ1xuICAgKiB0cmFpbGluZyB0ZXh0IChoYXJkIGNsYW1waW5nKS4gRGVmYXVsdHMgdG8gMS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvbnRTaXplXVxuICAgKiBUaGUgbWF4aW11bSBmb250IHNpemUgaW4gcGl4ZWxzLiBXZSdsbCBzdGFydCB3aXRoIHRoaXMgZm9udCBzaXplIHRoZW5cbiAgICogcmVkdWNlIHVudGlsIHRleHQgZml0cyBjb25zdHJhaW50cywgb3IgZm9udCBzaXplIGlzIGVxdWFsIHRvXG4gICAqIHtAc2VlIG9wdGlvbnMubWluRm9udFNpemV9LiBEZWZhdWx0cyB0byB0aGUgZWxlbWVudCdzIGluaXRpYWwgY29tcHV0ZWQgZm9udCBzaXplLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZWxlbWVudCxcbiAgICB7XG4gICAgICBtYXhMaW5lcyA9IHVuZGVmaW5lZCxcbiAgICAgIG1heEhlaWdodCA9IHVuZGVmaW5lZCxcbiAgICAgIHVzZVNvZnRDbGFtcCA9IGZhbHNlLFxuICAgICAgaGFyZENsYW1wQXNGYWxsYmFjayA9IHRydWUsXG4gICAgICBtaW5Gb250U2l6ZSA9IDEsXG4gICAgICBtYXhGb250U2l6ZSA9IHVuZGVmaW5lZCxcbiAgICAgIGVsbGlwc2lzID0gXCLigKZcIixcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3JpZ2luYWxXb3Jkc1wiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogZWxlbWVudC50ZXh0Q29udGVudC5tYXRjaCgvXFxTK1xccyovZykgfHwgW10sXG4gICAgfSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVwZGF0ZUhhbmRsZXJcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICgpID0+IHRoaXMuYXBwbHkoKSxcbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMudXBkYXRlSGFuZGxlciksXG4gICAgfSlcblxuICAgIGlmICh1bmRlZmluZWQgPT09IG1heEZvbnRTaXplKSB7XG4gICAgICBtYXhGb250U2l6ZSA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmZvbnRTaXplLCAxMClcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5tYXhMaW5lcyA9IG1heExpbmVzXG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHRcbiAgICB0aGlzLnVzZVNvZnRDbGFtcCA9IHVzZVNvZnRDbGFtcFxuICAgIHRoaXMuaGFyZENsYW1wQXNGYWxsYmFjayA9IGhhcmRDbGFtcEFzRmFsbGJhY2tcbiAgICB0aGlzLm1pbkZvbnRTaXplID0gbWluRm9udFNpemVcbiAgICB0aGlzLm1heEZvbnRTaXplID0gbWF4Rm9udFNpemVcbiAgICB0aGlzLmVsbGlwc2lzID0gZWxsaXBzaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHYXRoZXIgbWV0cmljcyBhYm91dCB0aGUgbGF5b3V0IG9mIHRoZSBlbGVtZW50J3MgdGV4dC5cbiAgICogVGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gLSBjYWxsIHdpdGggY2FyZS5cbiAgICpcbiAgICogQHJldHVybnMge1RleHRNZXRyaWNzfVxuICAgKiBMYXlvdXQgbWV0cmljcyBmb3IgdGhlIGNsYW1wZWQgZWxlbWVudCdzIHRleHQuXG4gICAqL1xuICBjYWxjdWxhdGVUZXh0TWV0cmljcygpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50XG4gICAgY29uc3QgY2xvbmUgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKVxuICAgIGNvbnN0IHN0eWxlID0gY2xvbmUuc3R5bGVcblxuICAgIC8vIEFwcGVuZCwgZG9uJ3QgcmVwbGFjZVxuICAgIHN0eWxlLmNzc1RleHQgKz0gXCI7bWluLWhlaWdodDowIWltcG9ydGFudDttYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50XCJcbiAgICBlbGVtZW50LnJlcGxhY2VXaXRoKGNsb25lKVxuXG4gICAgY29uc3QgbmF0dXJhbEhlaWdodCA9IGNsb25lLm9mZnNldEhlaWdodFxuXG4gICAgLy8gQ2xlYXIgdG8gbWVhc3VyZSBlbXB0eSBoZWlnaHQuIHRleHRDb250ZW50IGZhc3RlciB0aGFuIGlubmVySFRNTFxuICAgIGNsb25lLnRleHRDb250ZW50ID0gXCJcIlxuXG4gICAgY29uc3QgbmF0dXJhbEhlaWdodFdpdGhvdXRUZXh0ID0gZ2V0SGVpZ2h0KGNsb25lKSAvLyBjbG9uZS5vZmZzZXRIZWlnaHRcbiAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gbmF0dXJhbEhlaWdodCAtIG5hdHVyYWxIZWlnaHRXaXRob3V0VGV4dFxuXG4gICAgLy8gRmlsbCBlbGVtZW50IHdpdGggc2luZ2xlIG5vbi1icmVha2luZyBzcGFjZSB0byBmaW5kIGhlaWdodCBvZiBvbmUgbGluZVxuICAgIGNsb25lLnRleHRDb250ZW50ID0gXCJcXHhhMFwiXG5cbiAgICAvLyBHZXQgaGVpZ2h0IG9mIGVsZW1lbnQgd2l0aCBvbmx5IG9uZSBsaW5lIG9mIHRleHRcbiAgICBjb25zdCBuYXR1cmFsSGVpZ2h0V2l0aE9uZUxpbmUgPSBnZXRIZWlnaHQoY2xvbmUpIC8vIGNsb25lLm9mZnNldEhlaWdodFxuICAgIGNvbnN0IGZpcnN0TGluZUhlaWdodCA9IG5hdHVyYWxIZWlnaHRXaXRoT25lTGluZSAtIG5hdHVyYWxIZWlnaHRXaXRob3V0VGV4dFxuXG4gICAgLy8gQWRkIGxpbmUgKDxicj4gKyBuYnNwKS4gYXBwZW5kQ2hpbGQoKSBmYXN0ZXIgdGhhbiBpbm5lckhUTUxcbiAgICBjbG9uZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpXG4gICAgY2xvbmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXHhhMFwiKSlcblxuICAgIGNvbnN0IGFkZGl0aW9uYWxMaW5lSGVpZ2h0ID0gZ2V0SGVpZ2h0KGNsb25lKSAtIG5hdHVyYWxIZWlnaHRXaXRoT25lTGluZSAvLyBjbG9uZS5vZmZzZXRIZWlnaHQgLSBuYXR1cmFsSGVpZ2h0V2l0aE9uZUxpbmVcbiAgICBjb25zdCBsaW5lQ291bnQgPVxuICAgICAgMSArIChuYXR1cmFsSGVpZ2h0IC0gbmF0dXJhbEhlaWdodFdpdGhPbmVMaW5lKSAvIGFkZGl0aW9uYWxMaW5lSGVpZ2h0XG5cbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbnRlbnRcbiAgICBjbG9uZS5yZXBsYWNlV2l0aChlbGVtZW50KVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gVGV4dE1ldHJpY3NcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7dGV4dEhlaWdodH1cbiAgICAgKiBUaGUgdmVydGljYWwgc3BhY2UgcmVxdWlyZWQgdG8gZGlzcGxheSB0aGUgZWxlbWVudCdzIGN1cnJlbnQgdGV4dC5cbiAgICAgKiBUaGlzIGlzIDxlbT5ub3Q8L2VtPiBuZWNlc3NhcmlseSB0aGUgc2FtZSBhcyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIFRoaXMgbnVtYmVyIG1heSBldmVuIGJlIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCdzIGhlaWdodCBpbiBjYXNlc1xuICAgICAqIHdoZXJlIHRoZSB0ZXh0IG92ZXJmbG93cyB0aGUgZWxlbWVudCdzIGJsb2NrIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge25hdHVyYWxIZWlnaHRXaXRoT25lTGluZX1cbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IHdpdGggb25seSBvbmUgbGluZSBvZiB0ZXh0IGFuZCB3aXRob3V0XG4gICAgICogbWluaW11bSBvciBtYXhpbXVtIGhlaWdodHMuIFRoaXMgaW5mb3JtYXRpb24gbWF5IGJlIGhlbHBmdWwgd2hlblxuICAgICAqIGRlYWxpbmcgd2l0aCBpbmxpbmUgZWxlbWVudHMgKGFuZCBwb3RlbnRpYWxseSBvdGhlciBzY2VuYXJpb3MpLCB3aGVyZVxuICAgICAqIHRoZSBmaXJzdCBsaW5lIG9mIHRleHQgZG9lcyBub3QgaW5jcmVhc2UgdGhlIGVsZW1lbnQncyBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2ZpcnN0TGluZUhlaWdodH1cbiAgICAgKiBUaGUgaGVpZ2h0IHRoYXQgdGhlIGZpcnN0IGxpbmUgb2YgdGV4dCBhZGRzIHRvIHRoZSBlbGVtZW50LCBpLmUuLCB0aGVcbiAgICAgKiBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCB3aGlsZSBlbXB0eSBhbmQgdGhlIGhlaWdodFxuICAgICAqIG9mIHRoZSBlbGVtZW50IHdoaWxlIGl0IGNvbnRhaW5zIG9uZSBsaW5lIG9mIHRleHQuIFRoaXMgbnVtYmVyIG1heSBiZVxuICAgICAqIHplcm8gZm9yIGlubGluZSBlbGVtZW50cyBiZWNhdXNlIHRoZSBmaXJzdCBsaW5lIG9mIHRleHQgZG9lcyBub3RcbiAgICAgKiBpbmNyZWFzZSB0aGUgaGVpZ2h0IG9mIGlubGluZSBlbGVtZW50cy5cblxuICAgICAqIEBwcm9wZXJ0eSB7YWRkaXRpb25hbExpbmVIZWlnaHR9XG4gICAgICogVGhlIGhlaWdodCB0aGF0IGVhY2ggbGluZSBvZiB0ZXh0IGFmdGVyIHRoZSBmaXJzdCBhZGRzIHRvIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtsaW5lQ291bnR9XG4gICAgICogVGhlIG51bWJlciBvZiBsaW5lcyBvZiB0ZXh0IHRoZSBlbGVtZW50IGNvbnRhaW5zLlxuICAgICAqL1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0SGVpZ2h0LFxuICAgICAgbmF0dXJhbEhlaWdodFdpdGhPbmVMaW5lLFxuICAgICAgZmlyc3RMaW5lSGVpZ2h0LFxuICAgICAgYWRkaXRpb25hbExpbmVIZWlnaHQsXG4gICAgICBsaW5lQ291bnQsXG4gICAgICBuYXR1cmFsSGVpZ2h0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhdGNoIGZvciBjaGFuZ2VzIHRoYXQgbWF5IGFmZmVjdCBsYXlvdXQuIFJlc3BvbmQgYnkgcmVjbGFtcGluZyBpZlxuICAgKiBuZWNlc3NhcnkuXG4gICAqL1xuICB3YXRjaCgpIHtcbiAgICBpZiAoIXRoaXMuX3dhdGNoaW5nKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnVwZGF0ZUhhbmRsZXIpXG5cbiAgICAgIC8vIE1pbmltdW0gcmVxdWlyZWQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGV4dCBub2RlcyxcbiAgICAgIC8vIGFuZCB3aG9sZXNhbGUgcmVwbGFjZW1lbnQgdmlhIGlubmVySFRNTFxuICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwge1xuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLl93YXRjaGluZyA9IHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agd2F0Y2hpbmcgZm9yIGxheW91dCBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TGluZUNsYW1wfVxuICAgKi9cbiAgdW53YXRjaCgpIHtcbiAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMudXBkYXRlSGFuZGxlcilcblxuICAgIHRoaXMuX3dhdGNoaW5nID0gZmFsc2VcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ29uZHVjdCBlaXRoZXIgc29mdCBjbGFtcGluZyBvciBoYXJkIGNsYW1waW5nLCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIG9mXG4gICAqIHByb3BlcnR5IHtAc2VlIExpbmVDbGFtcC51c2VTb2Z0Q2xhbXB9LlxuICAgKi9cbiAgYXBwbHkoKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzbHlXYXRjaGluZyA9IHRoaXMuX3dhdGNoaW5nXG5cbiAgICAgIC8vIElnbm9yZSBpbnRlcm5hbGx5IHN0YXJ0ZWQgbXV0YXRpb25zLCBsZXN0IHdlIHJlY3Vyc2UgaW50byBvYmxpdmlvblxuICAgICAgdGhpcy51bndhdGNoKClcblxuICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5vcmlnaW5hbFdvcmRzLmpvaW4oXCJcIilcblxuICAgICAgaWYgKHRoaXMudXNlU29mdENsYW1wKSB7XG4gICAgICAgIHRoaXMuc29mdENsYW1wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFyZENsYW1wKClcbiAgICAgIH1cblxuICAgICAgLy8gUmVzdW1lIG9ic2VydmF0aW9uIGlmIHByZXZpb3VzbHkgd2F0Y2hpbmdcbiAgICAgIGlmIChwcmV2aW91c2x5V2F0Y2hpbmcpIHtcbiAgICAgICAgdGhpcy53YXRjaChmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaW1zIHRleHQgdW50aWwgaXQgZml0cyB3aXRoaW4gY29uc3RyYWludHNcbiAgICogKG1heGltdW0gaGVpZ2h0IG9yIG51bWJlciBvZiBsaW5lcykuXG4gICAqXG4gICAqIEBzZWUge0xpbmVDbGFtcC5tYXhMaW5lc31cbiAgICogQHNlZSB7TGluZUNsYW1wLm1heEhlaWdodH1cbiAgICovXG4gIGhhcmRDbGFtcChza2lwQ2hlY2sgPSB0cnVlKSB7XG4gICAgaWYgKHNraXBDaGVjayB8fCB0aGlzLnNob3VsZENsYW1wKCkpIHtcbiAgICAgIGxldCBjdXJyZW50VGV4dFxuXG4gICAgICBmaW5kQm91bmRhcnkoXG4gICAgICAgIDEsXG4gICAgICAgIHRoaXMub3JpZ2luYWxXb3Jkcy5sZW5ndGgsXG4gICAgICAgICh2YWwpID0+IHtcbiAgICAgICAgICBjdXJyZW50VGV4dCA9IHRoaXMub3JpZ2luYWxXb3Jkcy5zbGljZSgwLCB2YWwpLmpvaW4oXCIgXCIpXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gY3VycmVudFRleHRcblxuICAgICAgICAgIHJldHVybiB0aGlzLnNob3VsZENsYW1wKClcbiAgICAgICAgfSxcbiAgICAgICAgKHZhbCwgbWluLCBtYXgpID0+IHtcbiAgICAgICAgICAvLyBBZGQgb25lIG1vcmUgd29yZCBpZiBub3Qgb24gbWF4XG4gICAgICAgICAgaWYgKHZhbCA+IG1pbikge1xuICAgICAgICAgICAgY3VycmVudFRleHQgPSB0aGlzLm9yaWdpbmFsV29yZHMuc2xpY2UoMCwgbWF4KS5qb2luKFwiIFwiKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZW4gdHJpbSBsZXR0ZXJzIHVudGlsIGl0IGZpdHNcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IGN1cnJlbnRUZXh0LnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gY3VycmVudFRleHQgKyB0aGlzLmVsbGlwc2lzXG4gICAgICAgICAgfSB3aGlsZSAodGhpcy5zaG91bGRDbGFtcCgpKVxuXG4gICAgICAgICAgLy8gQnJvYWRjYXN0IG1vcmUgc3BlY2lmaWMgaGFyZENsYW1wIGV2ZW50IGZpcnN0XG4gICAgICAgICAgZW1pdCh0aGlzLCBcImxpbmVjbGFtcC5oYXJkY2xhbXBcIilcbiAgICAgICAgICBlbWl0KHRoaXMsIFwibGluZWNsYW1wLmNsYW1wXCIpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZXMgZm9udCBzaXplIHVudGlsIHRleHQgZml0cyB3aXRoaW4gdGhlIHNwZWNpZmllZCBoZWlnaHQgb3IgbnVtYmVyIG9mXG4gICAqIGxpbmVzLiBSZXNvcnRzIHRvIHVzaW5nIHtAc2VlIGhhcmRDbGFtcCgpfSBpZiB0ZXh0IHN0aWxsIGV4Y2VlZHMgY2xhbXBcbiAgICogcGFyYW1ldGVycy5cbiAgICovXG4gIHNvZnRDbGFtcCgpIHtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZVxuICAgIGNvbnN0IHN0YXJ0U2l6ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCkuZm9udFNpemVcbiAgICBzdHlsZS5mb250U2l6ZSA9IFwiXCJcblxuICAgIGxldCBkb25lID0gZmFsc2VcbiAgICBsZXQgc2hvdWxkQ2xhbXBcblxuICAgIGZpbmRCb3VuZGFyeShcbiAgICAgIHRoaXMubWluRm9udFNpemUsXG4gICAgICB0aGlzLm1heEZvbnRTaXplLFxuICAgICAgKHZhbCkgPT4ge1xuICAgICAgICBzdHlsZS5mb250U2l6ZSA9IHZhbCArIFwicHhcIlxuICAgICAgICBzaG91bGRDbGFtcCA9IHRoaXMuc2hvdWxkQ2xhbXAoKVxuICAgICAgICByZXR1cm4gc2hvdWxkQ2xhbXBcbiAgICAgIH0sXG4gICAgICAodmFsLCBtaW4pID0+IHtcbiAgICAgICAgaWYgKHZhbCA+IG1pbikge1xuICAgICAgICAgIHN0eWxlLmZvbnRTaXplID0gbWluICsgXCJweFwiXG4gICAgICAgICAgc2hvdWxkQ2xhbXAgPSB0aGlzLnNob3VsZENsYW1wKClcbiAgICAgICAgfVxuICAgICAgICBkb25lID0gIXNob3VsZENsYW1wXG4gICAgICB9XG4gICAgKVxuXG4gICAgY29uc3QgY2hhbmdlZCA9IHN0eWxlLmZvbnRTaXplICE9PSBzdGFydFNpemVcblxuICAgIC8vIEVtaXQgc3BlY2lmaWMgc29mdENsYW1wIGV2ZW50IGZpcnN0XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIGVtaXQodGhpcywgXCJsaW5lY2xhbXAuc29mdGNsYW1wXCIpXG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgZW1pdCBgbGluZWNsYW1wLmNsYW1wYCBldmVudCB0d2ljZS5cbiAgICBpZiAoIWRvbmUgJiYgdGhpcy5oYXJkQ2xhbXBBc0ZhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhcmRDbGFtcChmYWxzZSlcbiAgICB9IGVsc2UgaWYgKGNoYW5nZWQpIHtcbiAgICAgIC8vIGhhcmRDbGFtcCBlbWl0cyBgbGluZWNsYW1wLmNsYW1wYCB0b28uIE9ubHkgZW1pdCBmcm9tIGhlcmUgaWYgd2UncmVcbiAgICAgIC8vIG5vdCBhbHNvIGhhcmQgY2xhbXBpbmcuXG4gICAgICBlbWl0KHRoaXMsIFwibGluZWNsYW1wLmNsYW1wXCIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogV2hldGhlciBoZWlnaHQgb2YgdGV4dCBvciBudW1iZXIgb2YgbGluZXMgZXhjZWVkIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAc2VlIExpbmVDbGFtcC5tYXhIZWlnaHRcbiAgICogQHNlZSBMaW5lQ2xhbXAubWF4TGluZXNcbiAgICovXG4gIHNob3VsZENsYW1wKCkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50LCB0ZXh0SGVpZ2h0IH0gPSB0aGlzLmNhbGN1bGF0ZVRleHRNZXRyaWNzKClcblxuICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMubWF4SGVpZ2h0ICYmIHVuZGVmaW5lZCAhPT0gdGhpcy5tYXhMaW5lcykge1xuICAgICAgcmV0dXJuIHRleHRIZWlnaHQgPiB0aGlzLm1heEhlaWdodCB8fCBsaW5lQ291bnQgPiB0aGlzLm1heExpbmVzXG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gdGhpcy5tYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybiB0ZXh0SGVpZ2h0ID4gdGhpcy5tYXhIZWlnaHRcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB0aGlzLm1heExpbmVzKSB7XG4gICAgICByZXR1cm4gbGluZUNvdW50ID4gdGhpcy5tYXhMaW5lc1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwibWF4TGluZXMgb3IgbWF4SGVpZ2h0IG11c3QgYmUgc2V0IGJlZm9yZSBjYWxsaW5nIHNob3VsZENsYW1wKCkuXCJcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBwb2ludCBpbiBhIGNvbnRpZ291cyByYW5nZSB3aGVyZSBhIGdpdmVuXG4gKiB0ZXN0IGNhbGxiYWNrIHdpbGwgZ28gZnJvbSByZXR1cm5pbmcgdHJ1ZSB0byByZXR1cm5pbmcgZmFsc2UuXG4gKlxuICogU2luY2UgdGhpcyB1c2VzIGEgYmluYXJ5LXNlYXJjaCBhbGdvcml0aG0gdGhpcyBpcyBhbiBPKGxvZyBuKSBmdW5jdGlvbixcbiAqIHdoZXJlIG4gPSBtYXggLSBtaW4uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICogVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gKiBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB0ZXN0XG4gKiBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgdmFsdWUgaW4gdGhlIHJhbmdlIGFuZCByZXR1cm5zIGEgdHJ1dGh5IG9yIGZhbHN5IHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb25lXG4gKiBBIGZ1bmN0aW9uIHRvIHBlcmZvcm0gd2hlbiBjb21wbGV0ZS4gUmVjZWl2ZXMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzXG4gKiAtIGN1cnNvclxuICogLSBtYXhQYXNzaW5nVmFsdWVcbiAqIC0gbWluRmFpbGluZ1ZhbHVlXG4gKi9cbmZ1bmN0aW9uIGZpbmRCb3VuZGFyeShtaW4sIG1heCwgdGVzdCwgZG9uZSkge1xuICAvLyBzdGFydCBoYWxmd2F5IHRocm91Z2ggdGhlIHJhbmdlXG4gIGxldCBjdXJzb3IgPSAobWluICsgbWF4KSAvIDJcblxuICB3aGlsZSAobWF4ID4gbWluKSB7XG4gICAgaWYgKHRlc3QoY3Vyc29yKSkge1xuICAgICAgbWF4ID0gY3Vyc29yXG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbiA9IGN1cnNvclxuICAgIH1cblxuICAgIGlmIChtYXggLSBtaW4gPT09IDEpIHtcbiAgICAgIGRvbmUoY3Vyc29yLCBtaW4sIG1heClcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY3Vyc29yID0gTWF0aC5mbG9vcigobWluICsgbWF4KSAvIDIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgdHlwZSkge1xuICBpbnN0YW5jZS5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KHR5cGUpKVxufVxuIiwiICAvLyBnZXQgc2lkZWJhciBlbGVtZW50IG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgY29uc3QgZ2V0U2lkZWJhciA9ICgpID0+IHtcbiAgICBsZXQgc2lkZWJhciA9IHdpbmRvdy50b3AuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5zaWRlYmFyIC5jdXJyZW50LWxpc3RcIik7XG4gICAgaWYgKHNpZGViYXIubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIFsuLi5zaWRlYmFyXS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGlkZUlucHV0ID0gKGlucHV0VmFsdWUpID0+IHtcbiAgICBnZXRTaWRlYmFyKCkucXVlcnlTZWxlY3RvckFsbChcIi5zaWRlYmFyLWl0ZW1zXCIpXG4gICAgLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQucXVlcnlTZWxlY3RvcihcIi5maWVsZC12YXJpYWJsZS10YWdcIikuaW5uZXJUZXh0ID09PSBpbnB1dFZhbHVlKSB7XG4gICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHNldHVwTVRPID0gKHRlYW1NZXRhZGF0YSwgdGVhbXNBbGxvd2VkID0gJycsIGlucHV0TmFtZSA9ICdUZWFtIG1ldGFkYXRhJykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjb25zdCBzaWRlYmFyID0gZ2V0U2lkZWJhcigpO1xuICAgICAgICAvLyBzdGF0ZSBpc24ndCBnbG9iYWwgaW4gdjIgc28gdGhpcyBsaW5lIGlzIG5lZWRlZCBmb3IgdGhhdCB2ZXJzaW9uIGJ1dCBzaG91bGRuJ3QgYmUgaW5jbHVkZWQgaW4gdjNcbiAgICAgICAgLy8gY29uc3Qgc3RhdGUgPSBkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZShcImRvY3VtZW50LXN0YXRlXCIpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgcmVqZWN0KCdwbGVhc2Ugc2V0IHRoZSBzdGF0ZSBhdHRyaWJ1dGUnKVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGFyZSBvbiBhbnkgb3RoZXIgcGFnZSB0aGVuIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgdG8gdGhlIHNpZGViYXIgYW5kIHdlIGNhbiBza2lwIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKHN0YXRlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgICAgICBsZXQgbXRvTm90U3VwcG9ydGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGdldFNpZGViYXIoKS5maXJzdENoaWxkLmZpcnN0Q2hpbGQubGFzdENoaWxkLmlubmVyVGV4dCA9PSBpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgICAgICBnZXRTaWRlYmFyKCkucXVlcnlTZWxlY3RvcignLmNob2ljZS12YXJpYWJsZScpLmlubmVySFRNTCA9IGA8cD4ke2lucHV0TmFtZX0gZnVuY3Rpb25hbGl0eSBpcyBub3QgYXZhaWxhYmxlIG9uIGEgdGVtcGxhdGUgbGV2ZWwuPC9wPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldEludGVydmFsKCgpID0+IG10b05vdFN1cHBvcnRlZCgpLCA1MDApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgLy8gdHVybiB0ZWFtc0FsbG93ZWQgZnJvbSBzdHJpbmcgaW50byBhcnJheVxuICAgICAgICAgIHRlYW1zQWxsb3dlZCA9IHRlYW1zQWxsb3dlZC50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiX1wiKS5qb2luKFwiIFwiKS5zcGxpdCgnLCcpLmZpbHRlcihuID0+IG4pXG4gICAgICAgICAgICBsZXQgaGlkZVRlYW1zVGhhdEFyZU5vdEFsbG93ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0ZWFtc0FsbG93ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBvbmx5IGFsbG93aW5nIHRoZSB1c2VyIHRvIHNlbGVjdCBzb21lIG9mIHRoZSB0ZWFtcyB0aGVuIHdlIHNob3VsZCByZW1vdmUgdGhlIG9uZXMgdGhhdCB0aGUgdXNlciBoYXNuJ3QgZ290IGFjY2VzcyB0by4gXG4gICAgICAgICAgICAgICAgaWYgKGdldFNpZGViYXIoKS5maXJzdENoaWxkLmZpcnN0Q2hpbGQubGFzdENoaWxkLmlubmVyVGV4dCA9PSBpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGdldFNpZGViYXIoKS5xdWVyeVNlbGVjdG9yQWxsKCcuc2VhcmNoLWJhci13cmFwcGVyJykuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSlcbiAgICAgICAgICAgICAgICAgIGdldFNpZGViYXIoKS5xdWVyeVNlbGVjdG9yQWxsKCcuYWN0aW9uLWJ1dHRvbnMnKS5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKVxuICAgICAgICAgICAgICAgICAgZ2V0U2lkZWJhcigpLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaG9pY2UtdmFyaWFibGUgLm11bHRpY2hvaWNlLWVkaXQtcm93JykuZm9yRWFjaCgoaW5wdXRPcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZWFtc0FsbG93ZWQuaW5jbHVkZXMoaW5wdXRPcHRpb24ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0T3B0aW9uLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFuID0gaW5wdXRPcHRpb24ucXVlcnlTZWxlY3RvcihcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIDQgZGlnaXQgbnVtYmVyIGZyb20gc3RhcnQgb2YgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Bhbi5pbm5lclRleHQubWF0Y2goL15bMC05XXs0fS9nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5pbm5lclRleHQgPSBzcGFuLmlubmVyVGV4dC5zdWJzdHJpbmcoNyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBhcmUgbm90IG9uIHRoZSBNVE8gc2lkZWJhciBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0U2lkZWJhcigpLnF1ZXJ5U2VsZWN0b3IoJy5jaG9pY2UtdmFyaWFibGUnKS5pbm5lckhUTUwgPSBgPHA+JHtpbnB1dE5hbWV9IGlzIG5vdCBhdmFpbGFibGUgZm9yIHlvdXIgdGVhbS4gUGxlYXNlIGNsaWNrIGJhY2sgdG8gY29udGludWUgZWRpdGluZyB5b3VyIGRvY3VtZW50LjwvcD5gO1xuICAgICAgICAgICAgICAgIGhpZGVJbnB1dChpbnB1dE5hbWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEludGVydmFsKCgpID0+IGhpZGVUZWFtc1RoYXRBcmVOb3RBbGxvd2VkKCksIDUwMClcbiAgICAgICAgICAgIGhpZGVUZWFtc1RoYXRBcmVOb3RBbGxvd2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgICAgICBnZXRTaWRlYmFyKCkucXVlcnlTZWxlY3RvckFsbCgnLmNob2ljZS12YXJpYWJsZScpLmlubmVySFRNTCA9IGA8cD4ke2lucHV0TmFtZX0gaXMgb25seSBhdmFpbGFibGUgb24gdGhlIGVkaXQgcGFnZS48L3A+YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFsnZG9jdW1lbnQnLCAnZXhwb3J0JywgJ3ByZXZpZXcnXS5pbmNsdWRlcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmhhbmRsZU1UT0RhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgd2luZG93LmhhbmRsZU1UT0RhdGEodGVhbU1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUodGVhbU1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQW4gTVRPIGVycm9yIGhhcyBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4gSWYgdGhlIGlzc3VlIHN0aWxsIHBlcnNpc3RzIHBsZWFzZSBjb250YWN0IE91dGZpdCBTdXBwb3J0XCIpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuXG5leHBvcnQgeyBzZXR1cE1UTywgZ2V0U2lkZWJhciB9O1xuIiwiY29uc3QgaW1hZ2VDb21wcmVzc2lvbiA9ICgpID0+IHtcbiAgdmFyIGltYWdlQ29tcHJlc3NFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jdXN0b20tY29tcHJlc3Npb25dXCIpO1xuICB2YXIgZWRpdG9yU3RyaW5nID0gXCI/cXVhbD1lZGl0b3JcIjtcblxuICBmdW5jdGlvbiBjaGVja1VSTChlZGl0b3JTdHJpbmcsIHVybCkge1xuICAgIGlmICh1cmwuaW5jbHVkZXMoZWRpdG9yU3RyaW5nKSB8fCB1cmwuaW5jbHVkZXMoXCIuc3ZnXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbWFnZUNvbXByZXNzRWwuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAvL05vbiBSZXBvIEltYWdlcyB3aXRoIGRhdGEtY3VzdG9tLWNvbXByZXNzaW9uIG9uIGltZyBlbGVtZW50IGl0c2VsZlxuICAgIHZhciBpbWdTcmMgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgY29uc29sZS5sb2coaW1nU3JjKTtcbiAgICBpZiAoaW1nU3JjKSB7XG4gICAgICAvL3NyYyBhdHRyaWJ1dGUgZXhpc3RzIGFzc3VtZSB0aGF0IHRoaXMgaXMgYW4gPGltZz4gZWxlbWVudFxuICAgICAgaWYgKCFjaGVja1VSTChlZGl0b3JTdHJpbmcsIGltZ1NyYykpIHJldHVybjtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInNyY1wiLCBpbWdTcmMgKyBlZGl0b3JTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW1nRWwgPSBlbC5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpO1xuICAgICAgaWYgKCFpbWdFbCkgcmV0dXJuO1xuICAgICAgdmFyIGltZ1VSTCA9IGltZ0VsLmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgIGlmICghY2hlY2tVUkwoZWRpdG9yU3RyaW5nLCBpbWdVUkwpKSByZXR1cm47XG4gICAgICBpbWdFbC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgaW1nVVJMICsgZWRpdG9yU3RyaW5nKTtcblxuICAgICAgdmFyIGJrZ0ltZ0VsID0gZWwucXVlcnlTZWxlY3RvcihcIi5vdXRmaXQtcmVzaXphYmxlLWJhY2tncm91bmRcIik7XG4gICAgICBpZiAoIWJrZ0ltZ0VsKSByZXR1cm47XG4gICAgICB2YXIgYmtnVXJsID0gYmtnSW1nRWwuc3R5bGUuYmFja2dyb3VuZEltYWdlXG4gICAgICAgIC5zbGljZSg0LCAtMSlcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICAgICAgaWYgKCFjaGVja1VSTChlZGl0b3JTdHJpbmcsIGJrZ1VybCkpIHJldHVybjtcbiAgICAgIGJrZ0ltZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke2JrZ1VybH0ke2VkaXRvclN0cmluZ31cIilgO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGh0dHBzOi8vYmxvZy5jcmlteC5jb20vMjAxNy8wMy8wOS9nZXQtYWxsLWltYWdlcy1pbi1kb20taW5jbHVkaW5nLWJhY2tncm91bmQtZW4vXG4vLyB0aW1lIG91dCBpcyBzZXQgdG8gNjAgc2Vjb25kcyBhcyB0aGF0IGlzIGFzIGxvbmcgYXMgdGhlIHBsYXRmb3JtIHRpbWVvdXRcbmNvbnN0IGVuc3VyZUFsbEltYWdlc0xvYWRlZCA9IChkb2MgPSBkb2N1bWVudCwgdGltZW91dCA9IDZlNCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxvYWRBbGxJbWFnZXMoQXJyYXkuZnJvbShzZWFyY2hET00oZG9jKSksIHRpbWVvdXQpXG4gICAgICAudGhlbihyZXNvbHZlLCByZWplY3QpXG4gIH0pXG59XG5cbmNvbnN0IHNlYXJjaERPTSA9IChkb2MpID0+IHtcbiAgY29uc3Qgc3JjQ2hlY2tlciA9IC91cmxcXChcXHMqP1snXCJdP1xccyo/KFxcUys/KVxccyo/W1wiJ10/XFxzKj9cXCkvaVxuICByZXR1cm4gQXJyYXkuZnJvbShkb2MucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuICAgIC5yZWR1Y2UoKGNvbGxlY3Rpb24sIG5vZGUpID0+IHtcbiAgICAgIC8vIGJnIHNyY1xuICAgICAgbGV0IHByb3AgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKVxuICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1pbWFnZScpXG4gICAgICAvLyBtYXRjaCBgdXJsKC4uLilgXG4gICAgICBsZXQgbWF0Y2ggPSBzcmNDaGVja2VyLmV4ZWMocHJvcClcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb2xsZWN0aW9uLmFkZChtYXRjaFsxXSlcbiAgICAgIH1cbiAgICAgIGlmICgvXmltZyQvaS50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICAgICAgLy8gc3JjIGZyb20gaW1nIHRhZ1xuICAgICAgICBjb2xsZWN0aW9uLmFkZChub2RlLnNyYylcbiAgICAgIH0gZWxzZSBpZiAoL15mcmFtZSQvaS50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICAgICAgLy8gaWZyYW1lXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VhcmNoRE9NKG5vZGUuY29udGVudERvY3VtZW50IHx8IG5vZGUuY29udGVudFdpbmRvdy5kb2N1bWVudClcbiAgICAgICAgICAgIC5mb3JFYWNoKGltZyA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbWcpIHsgY29sbGVjdGlvbi5hZGQoaW1nKSB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgICB9LCBuZXcgU2V0KCkpXG59XG5cbmNvbnN0IGxvYWRJbWFnZSA9IChzcmMsIHRpbWVvdXQgPSA1MDAwKSA9PiB7XG4gIHZhciBpbWdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBpbWcgPSBuZXcgSW1hZ2UoKVxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHdpZHRoOiBpbWcubmF0dXJhbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltZy5uYXR1cmFsSGVpZ2h0XG4gICAgICB9KVxuICAgIH1cbiAgICBpbWcub25lcnJvciA9IHJlamVjdFxuICAgIGltZy5zcmMgPSBzcmNcbiAgfSlcbiAgdmFyIHRpbWVyID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQocmVqZWN0LCB0aW1lb3V0KVxuICB9KVxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtpbWdQcm9taXNlLCB0aW1lcl0pXG59XG5cbmNvbnN0IGxvYWRBbGxJbWFnZXMgPSAoaW1nTGlzdCwgdGltZW91dCA9IDUwMDApID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBQcm9taXNlLmFsbChcbiAgICAgIGltZ0xpc3RcbiAgICAgICAgLm1hcChzcmMgPT4gbG9hZEltYWdlKHNyYywgdGltZW91dCkpXG4gICAgICAgIC5tYXAocCA9PiBwLmNhdGNoKGUgPT4gZmFsc2UpKVxuICAgICkudGhlbihyZXN1bHRzID0+IHJlc29sdmUocmVzdWx0cy5maWx0ZXIociA9PiByKSkpXG4gIH0pXG59XG5cbmV4cG9ydCB7IGltYWdlQ29tcHJlc3Npb24sIGVuc3VyZUFsbEltYWdlc0xvYWRlZCB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBQbGFjZWhvbGRlcihwbGFjZWhvbGRlclZpc2liaWxpdHksIHBsYWNlaG9sZGVySW1hZ2VzKSB7XG4gICAgLy8gSWYgYXJyYXkgbGVuZ3RoIDwgMSBvciB0aGUgZmlyc3QgaXRlbSBpcyBcIlwiIG9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgaWYgKFxuICAgICAgcGxhY2Vob2xkZXJJbWFnZXMubGVuZ3RoIDwgMSB8fFxuICAgICAgcGxhY2Vob2xkZXJJbWFnZXNbMF0gPT0gXCJcIiB8fFxuICAgICAgcGxhY2Vob2xkZXJJbWFnZXNbMF0gPT0gbnVsbCB8fFxuICAgICAgcGxhY2Vob2xkZXJJbWFnZXNbMF0gPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwbGFjZWhvbGRlclZpc2liaWxpdHkgPT0gXCJoaWRlXCJcbiAgICApXG4gICAgICByZXR1cm47XG4gIFxuICAgIHZhciBwYWdlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucGFnZSAuY29udGFpbmVyXCIpO1xuICAgIHBhZ2VzLmZvckVhY2goKHBhZ2UsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgcGxhY2Vob2xkZXJJbWFnZSA9IHBsYWNlaG9sZGVySW1hZ2VzW2luZGV4XTtcbiAgICAgIGlmIChcbiAgICAgICAgcGxhY2Vob2xkZXJJbWFnZSA9PSBcIlwiIHx8XG4gICAgICAgIHBsYWNlaG9sZGVySW1hZ2UgPT0gbnVsbCB8fFxuICAgICAgICBwbGFjZWhvbGRlckltYWdlID09IHVuZGVmaW5lZFxuICAgICAgKVxuICAgICAgICBwbGFjZWhvbGRlckltYWdlID0gcGxhY2Vob2xkZXJJbWFnZXNbMF07XG4gIFxuICAgICAgbGV0IHBsYWNlaG9sZGVyU3RydWN0dXJlID0gYDxkaXYgY2xhc3M9XCJwbGFjZWhvbGRlckltYWdlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJyR7cGxhY2Vob2xkZXJJbWFnZX0nKVwiPjwvZGl2PmA7XG4gICAgICBwYWdlLmluc2VydEFkamFjZW50SFRNTChcImFmdGVyYmVnaW5cIiwgcGxhY2Vob2xkZXJTdHJ1Y3R1cmUpO1xuICAgIH0pO1xuICB9IiwiLy8gcmVuZGVyIGhhcyBhbiBpc3N1ZSB3aXRoIHJlcGxhY2VBbGwgY2F1c2luZyBlcnJvcnMgdG8gYmUgdGhyb3duIHdoaWNoIHN0b3BzIHRoZSByZW5kZXIuIFRoaXMgaXMgYSBwb2xseWZpbCBmb3IgYWxsIHJlbmRlcnNcclxuU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHN0ciwgbmV3U3RyKSB7XHJcbiAgLy8gSWYgYSByZWdleCBwYXR0ZXJuXHJcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCByZWdleHBdXCIpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcGxhY2Uoc3RyLCBuZXdTdHIpO1xyXG4gIH1cclxuICAvLyBJZiBhIHN0cmluZ1xyXG4gIHJldHVybiB0aGlzLnNwbGl0KHN0cikuam9pbihuZXdTdHIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZHluYW1pY1JlcGxhY2Uoc2VsZWN0b3IgPSBudWxsLCBkYXRhID0gbnVsbCkge1xyXG4gIGlmIChzZWxlY3RvciAhPSBudWxsICYmIGRhdGEgIT0gbnVsbCkgXHJcbiAgeyBcclxuICAgIGR5bmFtaWNSZXBsYWNlTXVsdGkoc2VsZWN0b3IsIGRhdGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkeW5hbWljUmVwbGFjZVNpbmdsZSgpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHluYW1pY1JlcGxhY2VNdWx0aSh0YXJnZXQsIGRhdGEpIHtcclxuICBjb25zdCB0YXJnZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpO1xyXG4gIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBpdGVtWzBdO1xyXG4gICAgICBjb25zdCBsb29rdXAgPSBpdGVtWzFdO1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRhcmdldC5pbm5lclRleHQuaW5jbHVkZXMobG9va3VwKSAhPSAtMSAmJlxyXG4gICAgICAgIChpbnB1dFZhbHVlICE9IFwiXCIgfHwgaW5wdXRWYWx1ZS5sZW5ndGggIT0gMClcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGFyZ2V0LmlubmVySFRNTCA9IHRhcmdldC5pbm5lckhUTUwucmVwbGFjZUFsbChsb29rdXAsIGlucHV0VmFsdWUpOyAvL0lmIGZvdW5kIHJlcGxhY2VcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgbG9va3VwU3BhbiA9IGA8c3BhbiBjbGFzcz0nbG9va3VwLXZhbHVlJz4ke2xvb2t1cH08L3NwYW4+YDtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0YXJnZXQuaW5uZXJIVE1MKTtcclxuICAgICAgICBsZXQgdGVtcCA9IHRhcmdldC5pbm5lckhUTUwuc3BsaXQobG9va3VwU3Bhbik7XHJcbiAgICAgICAgdGVtcCA9IHRlbXAubWFwKCh4KSA9PiB4LnJlcGxhY2VBbGwobG9va3VwLCBsb29rdXBTcGFuKSk7XHJcbiAgICAgICAgdGFyZ2V0LmlubmVySFRNTCA9IHRlbXAuam9pbihsb29rdXBTcGFuKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNSZXBsYWNlU2luZ2xlKCkge1xyXG4gIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXJlcGxhY2UtZnJvbV1cIik7XHJcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgY29uc3QgdGV4dCA9IGVsLmlubmVyVGV4dDtcclxuICAgIGNvbnN0IGh0bWwgPSBlbC5pbm5lckhUTUw7XHJcbiAgICBjb25zdCBsb29rdXAgPSBlbC5kYXRhc2V0LnJlcGxhY2VGcm9tO1xyXG4gICAgY29uc3QgcmVwbGFjZSA9IGVsLmRhdGFzZXQucmVwbGFjZVRvO1xyXG5cclxuICAgIGlmICh0ZXh0LnNlYXJjaChsb29rdXApICE9IC0xICYmIChyZXBsYWNlICE9IFwiXCIgfHwgcmVwbGFjZS5sZW5ndGggIT0gMCkpIHtcclxuICAgICAgZWwuaW5uZXJIVE1MID0gaHRtbC5yZXBsYWNlQWxsKGxvb2t1cCwgcmVwbGFjZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGR5bmFtaWNSZXBsYWNlLCBkeW5hbWljUmVwbGFjZVNpbmdsZSwgZHluYW1pY1JlcGxhY2VNdWx0aSB9IiwiaW1wb3J0IHsgZ2V0V2lkdGgsIGdldEhlaWdodCwgY291bnRMaW5lcyB9IGZyb20gJy4vbGltaXRlcnMuanMnXG4vKipcbiAqIHRleHRGaXQgdjMuMS4wXG4gKiBQcmV2aW91c2x5IGtub3duIGFzIGpRdWVyeS50ZXh0Rml0XG4gKiAxMS8yMDE0IGJ5IFNUUk1MIChzdHJtbC5naXRodWIuY29tKVxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBUbyB1c2U6IHRleHRGaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RhcmdldC1kaXYnKSwgb3B0aW9ucyk7XG4gKlxuICogV2lsbCBtYWtlIHRoZSAqdGV4dCogY29udGVudCBpbnNpZGUgYSBjb250YWluZXIgc2NhbGUgdG8gZml0IHRoZSBjb250YWluZXJcbiAqIFRoZSBjb250YWluZXIgaXMgcmVxdWlyZWQgdG8gaGF2ZSBhIHNldCB3aWR0aCBhbmQgaGVpZ2h0XG4gKiBVc2VzIGJpbmFyeSBzZWFyY2ggdG8gZml0IHRleHQgd2l0aCBtaW5pbWFsIGxheW91dCBjYWxscy5cbiAqIFZlcnNpb24gMi4wIGRvZXMgbm90IHVzZSBqUXVlcnkuXG4gKi9cbi8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSwgZG9jdW1lbnQ6dHJ1ZSwgd2luZG93OnRydWUsIEhUTUxFbGVtZW50OnRydWUqL1xuXG4vLyAoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbi8vICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAgLy8gVU1EIHNoaW1cbi8vICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4vLyAgICAgLy8gQU1EXG4vLyAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbi8vICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuLy8gICAgIC8vIE5vZGUvQ29tbW9uSlNcbi8vICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICAvLyBCcm93c2VyXG4vLyAgICAgcm9vdC50ZXh0Rml0ID0gZmFjdG9yeSgpO1xuLy8gICB9XG4vLyB9KSh0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdGhpcywgZnVuY3Rpb24gKCkge1xuLy8gICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIGFsaWduVmVydDogZmFsc2UsIC8vIGlmIHRydWUsIHRleHRGaXQgd2lsbCBhbGlnbiB2ZXJ0aWNhbGx5IHVzaW5nIGNzcyB0YWJsZXNcbiAgICBhbGlnbkhvcml6OiBmYWxzZSwgLy8gaWYgdHJ1ZSwgdGV4dEZpdCB3aWxsIHNldCB0ZXh0LWFsaWduOiBjZW50ZXJcbiAgICBtdWx0aUxpbmU6IGZhbHNlLCAvLyBpZiB0cnVlLCB0ZXh0Rml0IHdpbGwgbm90IHNldCB3aGl0ZS1zcGFjZTogbm8td3JhcFxuICAgIHN0b3BPdmVyZmxvdzogZmFsc2UsIC8vIGlmIHRydWUsIGEgZXJyb3Igd2UgYmUgdGhyb3duIGlmIHRoZSBjb250ZW50IGlzIG92ZXJmbG93aW5nXG4gICAgZm9udFVuaXQ6IFwicmVtXCIsIC8vIHdoYXQgdW5pdCBzaG91bGQgdGhlIGZpbmFsIGZvbnQgYmUuIHVzaW5nIHJlbXMgb3IgbW0gaXMgc29tZXRpbWVzIHVzZWZ1bFxuICAgIGZvbnRDaGFuZ2VTaXplOiAwLjEsIC8vIGhvdyBtdWNoIHNob3VsZCB0aGUgZm9udCBzaXplIGJ5IGFqdXN0ZWQgYnkgZWFjaCB0aW1lLiAwLjEgYW5kIDAuMDEgaXMgdXNlZnVsIGZvciB3aGVuIHVzaW5nIGEgcmVtIGZvbnQgdW5pdFxuICAgIG1pbkZvbnRTaXplOiAwLjMsXG4gICAgbWF4Rm9udFNpemU6IDEsXG4gICAgbWF4TGluZTogZmFsc2UsXG4gICAgcmVQcm9jZXNzOiB0cnVlLCAvLyBpZiB0cnVlLCB0ZXh0Rml0IHdpbGwgcmUtcHJvY2VzcyBhbHJlYWR5LWZpdCBub2Rlcy4gU2V0IHRvICdmYWxzZScgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgIHdpZHRoT25seTogZmFsc2UsIC8vIGlmIHRydWUsIHRleHRGaXQgd2lsbCBmaXQgdGV4dCB0byBlbGVtZW50IHdpZHRoLCByZWdhcmRsZXNzIG9mIHRleHQgaGVpZ2h0XG4gICAgYWxpZ25WZXJ0V2l0aEZsZXhib3g6IGZhbHNlLCAvLyBpZiB0cnVlLCB0ZXh0Rml0IHdpbGwgdXNlIGZsZXhib3ggZm9yIHZlcnRpY2FsIGFsaWdubWVudFxuICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsIC8vIGluIGNhc2UgeW91IG5lZWQgdG8gY2hhbmdlIHRoaXNcbiAgfTtcblxuICBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0ZXh0Rml0KGVscywgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gICAgLy8gRXh0ZW5kIG9wdGlvbnMuXG4gICAgdmFyIHNldHRpbmdzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRTZXR0aW5ncykge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzZXR0aW5nc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGluZ3Nba2V5XSA9IGRlZmF1bHRTZXR0aW5nc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgalF1ZXJ5IG9iamVjdHMgaW50byBhcnJheXNcbiAgICBpZiAodHlwZW9mIGVscy50b0FycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVscyA9IGVscy50b0FycmF5KCk7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBwYXNzaW5nIGEgc2luZ2xlIGVsXG4gICAgdmFyIGVsVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbHMpO1xuICAgIGlmIChcbiAgICAgIGVsVHlwZSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICYmXG4gICAgICBlbFR5cGUgIT09IFwiW29iamVjdCBOb2RlTGlzdF1cIiAmJlxuICAgICAgZWxUeXBlICE9PSBcIltvYmplY3QgSFRNTENvbGxlY3Rpb25dXCJcbiAgICApIHtcbiAgICAgIGVscyA9IFtlbHNdO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgZWFjaCBlbCB3ZSd2ZSBwYXNzZWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb2Nlc3NJdGVtKGVsc1tpXSwgc2V0dGluZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhlIG1lYXQuIEdpdmVuIGFuIGVsLCBtYWtlIHRoZSB0ZXh0IGluc2lkZSBpdCBmaXQgaXRzIHBhcmVudC5cbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWwgICAgICAgQ2hpbGQgZWwuXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgICAgIE9wdGlvbnMgZm9yIGZpdC5cbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NJdGVtKGVsLCBzZXR0aW5ncykge1xuICAgIGlmICghaXNFbGVtZW50KGVsKSB8fCAoIXNldHRpbmdzLnJlUHJvY2VzcyAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJ0ZXh0Rml0dGVkXCIpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNldCB0ZXh0Rml0dGVkIGF0dHJpYnV0ZSBzbyB3ZSBrbm93IHRoaXMgd2FzIHByb2Nlc3NlZC5cbiAgICBpZiAoIXNldHRpbmdzLnJlUHJvY2Vzcykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwidGV4dEZpdHRlZFwiLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgaW5uZXJTcGFuLCBvcmlnaW5hbEhlaWdodCwgb3JpZ2luYWxIVE1MLCBvcmlnaW5hbFdpZHRoO1xuICAgIHZhciBsb3csIG1pZCwgaGlnaDtcblxuICAgIC8vIEdldCBlbGVtZW50IGRhdGEuXG4gICAgb3JpZ2luYWxIVE1MID0gZWwuaW5uZXJIVE1MO1xuICAgIG9yaWdpbmFsV2lkdGggPSBnZXRXaWR0aChlbCk7XG4gICAgb3JpZ2luYWxIZWlnaHQgPSBnZXRIZWlnaHQoZWwpO1xuXG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBpZiB3ZSBjYW4ndCBmaW5kIGJveCBkaW1lbnNpb25zXG4gICAgaWYgKCFvcmlnaW5hbFdpZHRoIHx8ICghc2V0dGluZ3Mud2lkdGhPbmx5ICYmICFvcmlnaW5hbEhlaWdodCkpIHtcbiAgICAgIGlmICghc2V0dGluZ3Mud2lkdGhPbmx5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJTZXQgYSBoZWlnaHQgYW5kIHdpZHRoIG9uIHRoZSB0YXJnZXQgZWxlbWVudCBcIiArXG4gICAgICAgICAgICBlbC5vdXRlckhUTUwgK1xuICAgICAgICAgICAgXCIgYmVmb3JlIHVzaW5nIHRleHRGaXQhXCJcbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiU2V0IGEgd2lkdGggb24gdGhlIHRhcmdldCBlbGVtZW50IFwiICtcbiAgICAgICAgICAgIGVsLm91dGVySFRNTCArXG4gICAgICAgICAgICBcIiBiZWZvcmUgdXNpbmcgdGV4dEZpdCFcIlxuICAgICAgICApO1xuICAgIH1cbiAgICBsZXQgdGV4dEZpdHRlZFNwYW4gPSBlbC5xdWVyeVNlbGVjdG9yKFwic3Bhbi50ZXh0Rml0dGVkXCIpXG4gICAgLy8gQWRkIHRleHRGaXR0ZWQgc3BhbiBpbnNpZGUgdGhpcyBjb250YWluZXIuXG4gICAgaWYgKCF0ZXh0Rml0dGVkU3Bhbikge1xuICAgICAgaW5uZXJTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBpbm5lclNwYW4uY2xhc3NOYW1lID0gXCJ0ZXh0Rml0dGVkXCI7XG4gICAgICAvLyBJbmxpbmUgYmxvY2sgZW5zdXJlIGl0IHRha2VzIG9uIHRoZSBzaXplIG9mIGl0cyBjb250ZW50cywgZXZlbiBpZiB0aGV5IGFyZSBlbmNsb3NlZFxuICAgICAgLy8gaW4gb3RoZXIgdGFncyBsaWtlIDxwPlxuICAgICAgaW5uZXJTcGFuLnN0eWxlW1wiZGlzcGxheVwiXSA9IHNldHRpbmdzLmRpc3BsYXk7XG4gICAgICBpbm5lclNwYW4uaW5uZXJIVE1MID0gb3JpZ2luYWxIVE1MO1xuICAgICAgZWwuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGlubmVyU3Bhbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcHJvY2Vzc2luZy5cbiAgICAgIGlubmVyU3BhbiA9IHRleHRGaXR0ZWRTcGFuO1xuICAgICAgLy8gUmVtb3ZlIHZlcnRpY2FsIGFsaWduIGlmIHdlJ3JlIHJlcHJvY2Vzc2luZy5cbiAgICAgIGlmIChpbm5lclNwYW4uY2xhc3NMaXN0LmNvbnRhaW5zKFwidGV4dEZpdEFsaWduVmVydFwiKSkge1xuICAgICAgICBpbm5lclNwYW4uY2xhc3NOYW1lID0gaW5uZXJTcGFuLmNsYXNzTmFtZS5yZXBsYWNlKFxuICAgICAgICAgIFwidGV4dEZpdEFsaWduVmVydFwiLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKTtcbiAgICAgICAgaW5uZXJTcGFuLnN0eWxlW1wiaGVpZ2h0XCJdID0gXCJcIjtcbiAgICAgICAgZWwuY2xhc3NOYW1lLnJlcGxhY2UoXCJ0ZXh0Rml0QWxpZ25WZXJ0RmxleFwiLCBcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlICYgc2V0IGFsaWdubWVudFxuICAgIGlmIChzZXR0aW5ncy5hbGlnbkhvcml6KSB7XG4gICAgICBlbC5zdHlsZVtcInRleHQtYWxpZ25cIl0gPSBcImNlbnRlclwiO1xuICAgICAgaW5uZXJTcGFuLnN0eWxlW1widGV4dC1hbGlnblwiXSA9IFwiY2VudGVyXCI7XG4gICAgfVxuXG4gICAgdmFyIG1heExpbmUgPSBwYXJzZUludChlbC5kYXRhc2V0Lm1heExpbmUgfHwgc2V0dGluZ3MubWF4TGluZSk7XG4gICAgY29uc29sZS5sb2cobWF4TGluZSwgJ21heGxpbmUnKVxuICAgIHZhciBzdGFydGluZ1NpemUgPSBpbm5lclNwYW4uc3R5bGUuZm9udFNpemU7XG5cbiAgICBsb3cgPSBzZXR0aW5ncy5taW5Gb250U2l6ZTtcbiAgICBoaWdoID0gc2V0dGluZ3MubWF4Rm9udFNpemU7XG4gICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgaGlnaGVzdCBiZXN0IGZpdFxuICAgIHZhciBzaXplID0gbG93O1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgbWlkID0gcGFyc2VGbG9hdCgoKGhpZ2ggKyBsb3cpIC8gMikudG9GaXhlZCgyKSk7XG4gICAgICBpbm5lclNwYW4uc3R5bGUuZm9udFNpemUgPSBtaWQgKyBzZXR0aW5ncy5mb250VW5pdDtcblxuICAgICAgdmFyIHNjcm9sbFdpZHRoID0gZ2V0V2lkdGgoaW5uZXJTcGFuKSA8PSBvcmlnaW5hbFdpZHRoO1xuICAgICAgdmFyIHNjcm9sbEhlaWdodCA9XG4gICAgICAgIHNldHRpbmdzLndpZHRoT25seSB8fCBnZXRIZWlnaHQoaW5uZXJTcGFuKSA8PSBvcmlnaW5hbEhlaWdodDtcblxuICAgICAgLy8gY2hlY2sgaWYgdG9vIG1hbnkgbGluZXMgYW5kIGlmIGl0IGlzIHRoZW4gd2UgbmVlZCB0byBhZGp1c3QgdGhlIGZvbnQgc2l6ZSBhY2NvcmRpbmdseVxuICAgICAgdmFyIG1heExpbmVzID0gZmFsc2U7XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihtYXhMaW5lKSkge1xuICAgICAgICB2YXIgbGluZUNvdW50ID0gY291bnRMaW5lcyhpbm5lclNwYW4pO1xuICAgICAgICBtYXhMaW5lcyA9IGxpbmVDb3VudCA+IG1heExpbmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxXaWR0aCAmJiBzY3JvbGxIZWlnaHQgJiYgIW1heExpbmVzKSB7XG4gICAgICAgIHNpemUgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIHNldHRpbmdzLmZvbnRDaGFuZ2VTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIHNldHRpbmdzLmZvbnRDaGFuZ2VTaXplO1xuICAgICAgfVxuICAgICAgLy8gYXdhaXQgaW5qZWN0aW9uIHBvaW50XG4gICAgfVxuICAgIGlmIChzdGFydGluZ1NpemUgIT09IHNpemUgKyBzZXR0aW5ncy5mb250VW5pdCkge1xuICAgICAgY29uc29sZS5sb2coXCJ0ZXh0Rml0IGZvbnQgY2hhbmdlZCB0bzpcIiwgc2l6ZSArIHNldHRpbmdzLmZvbnRVbml0KTtcbiAgICB9XG4gICAgLy8gdXBkYXRpbmcgZm9udCBpZiBkaWZmZXJzOlxuICAgIGlmIChpbm5lclNwYW4uc3R5bGUuZm9udFNpemUgIT0gc2l6ZSArIHNldHRpbmdzLmZvbnRVbml0KVxuICAgICAgaW5uZXJTcGFuLnN0eWxlLmZvbnRTaXplID0gc2l6ZSArIHNldHRpbmdzLmZvbnRVbml0O1xuXG4gICAgLy8gYWRkIHRoZSByZXF1aXJlZCBDU1MgaW4gb3JkZXIgdG8gc3RvcCBvdmVyZmxvd3NcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihtYXhMaW5lKSB8fCBzZXR0aW5ncy5zdG9wT3ZlcmZsb3cpIHtcbiAgICAgIC8vIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdmVyZmxvd1N0eWxlU2hlZXRcIikpIHtcbiAgICAgIC8vICAgdmFyIHN0eWxlID0gW1wiLm92ZXJmbG93ID4gc3BhbiB7XCIsIFwib3ZlcmZsb3c6IGhpZGRlbjtcIiwgXCJ9XCJdLmpvaW4oXCJcIik7XG4gICAgICAvLyAgIHZhciBjc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAvLyAgIGNzcy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgLy8gICBjc3MuaWQgPSBcIm92ZXJmbG93U3R5bGVTaGVldFwiO1xuICAgICAgLy8gICBjc3MuaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICAvLyAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY3NzKTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gZGV0ZWN0IGlmIGRhdGEgbWF4IGxpbmVzIGhhcyBiZWVuIGV4Y2VlZGVkXG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihtYXhMaW5lKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwib3ZlcmZsb3dcIik7XG4gICAgICAgIGRlbGV0ZSBlbC5kYXRhc2V0LmN1c3RvbU92ZXJmbG93TWVzc2FnZTtcbiAgICAgICAgdmFyIGxpbmVDb3VudCA9IGNvdW50TGluZXMoaW5uZXJTcGFuKTtcbiAgICAgICAgZWwuZGF0YXNldC5saW5lQ291bnQgPSBsaW5lQ291bnQ7XG4gICAgICAgIGlmIChsaW5lQ291bnQgPiBtYXhMaW5lKSB7XG4gICAgICAgICAgLy8gZWwuZGF0YXNldC5jdXN0b21PdmVyZmxvd01lc3NhZ2UgPSBcIlRvbyBtdWNoIGNvbnRlbnQgaGFzIGJlZW4gYWRkZWQgZm9yIHRoZSBhbGxvd2VkIHNwYWNlXCI7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBkZXRlY3QgaWYgdGhlIGNvbnRlbnQgaXMgbGFyZ2VyIHRoYW4gaXQncyBwYXJlbnRcbiAgICAgIGlmIChzZXR0aW5ncy5zdG9wT3ZlcmZsb3cpIHtcbiAgICAgICAgdmFyIG92ZXJmbG93ID0gZ2V0SGVpZ2h0KGVsKSA8IGdldEhlaWdodChpbm5lclNwYW4pO1xuICAgICAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKFwib3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT3VyIGhlaWdodCBpcyBmaW5hbGl6ZWQuIElmIHdlIGFyZSBhbGlnbmluZyB2ZXJ0aWNhbGx5LCBzZXQgdGhhdCB1cC5cbiAgICBpZiAoc2V0dGluZ3MuYWxpZ25WZXJ0KSB7XG4gICAgICAvLyBhZGRTdHlsZVNoZWV0KCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGlubmVyU3Bhbik7XG4gICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW1wicG9zaXRpb25cIl0gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgZWwuc3R5bGVbXCJwb3NpdGlvblwiXSA9IFwicmVsYXRpdmVcIjtcbiAgICAgIH1cbiAgICAgIGlmICghaW5uZXJTcGFuLmNsYXNzTGlzdC5jb250YWlucyhcInRleHRGaXRBbGlnblZlcnRcIikpIHtcbiAgICAgICAgaW5uZXJTcGFuLmNsYXNzTmFtZSA9IGlubmVyU3Bhbi5jbGFzc05hbWUgKyBcIiB0ZXh0Rml0QWxpZ25WZXJ0XCI7XG4gICAgICB9XG4gICAgICBpbm5lclNwYW4uc3R5bGVbXCJoZWlnaHRcIl0gPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICBpZiAoXG4gICAgICAgIHNldHRpbmdzLmFsaWduVmVydFdpdGhGbGV4Ym94ICYmXG4gICAgICAgICFlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0ZXh0Rml0QWxpZ25WZXJ0RmxleFwiKVxuICAgICAgKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZSArIFwiIHRleHRGaXRBbGlnblZlcnRGbGV4XCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcbiAgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiXG4gICAgICA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAvL0RPTTJcbiAgICAgIDogbyAmJlxuICAgICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgbyAhPT0gbnVsbCAmJlxuICAgICAgICAgIG8ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIjtcbiAgfSIsIi8qKlxuICogTGVzcyAtIExlYW5lciBDU1MgdjQuMS4xXG4gKiBodHRwOi8vbGVzc2Nzcy5vcmdcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMjEsIEFsZXhpcyBTZWxsaWVyIDxzZWxmQGNsb3VkaGVhZC5uZXQ+XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBMaWNlbnNlLlxuICpcbiAqIEBsaWNlbnNlIEFwYWNoZS0yLjBcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5sZXNzID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gRXhwb3J0IGEgbmV3IGRlZmF1bHQgZWFjaCB0aW1lXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0T3B0aW9ucyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLyogSW5saW5lIEphdmFzY3JpcHQgLSBAcGx1Z2luIHN0aWxsIGFsbG93ZWQgKi9cclxuICAgICAgICAgICAgamF2YXNjcmlwdEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiBPdXRwdXRzIGEgbWFrZWZpbGUgaW1wb3J0IGRlcGVuZGVuY3kgbGlzdCB0byBzdGRvdXQuICovXHJcbiAgICAgICAgICAgIGRlcGVuZHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiAoREVQUkVDQVRFRCkgQ29tcHJlc3MgdXNpbmcgbGVzcyBidWlsdC1pbiBjb21wcmVzc2lvbi5cclxuICAgICAgICAgICAgICogVGhpcyBkb2VzIGFuIG9rYXkgam9iIGJ1dCBkb2VzIG5vdCB1dGlsaXNlIGFsbCB0aGUgdHJpY2tzIG9mXHJcbiAgICAgICAgICAgICAqIGRlZGljYXRlZCBjc3MgY29tcHJlc3Npb24uICovXHJcbiAgICAgICAgICAgIGNvbXByZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgLyogUnVucyB0aGUgbGVzcyBwYXJzZXIgYW5kIGp1c3QgcmVwb3J0cyBlcnJvcnMgd2l0aG91dCBhbnkgb3V0cHV0LiAqL1xyXG4gICAgICAgICAgICBsaW50OiBmYWxzZSxcclxuICAgICAgICAgICAgLyogU2V0cyBhdmFpbGFibGUgaW5jbHVkZSBwYXRocy5cclxuICAgICAgICAgICAgICogSWYgdGhlIGZpbGUgaW4gYW4gQGltcG9ydCBydWxlIGRvZXMgbm90IGV4aXN0IGF0IHRoYXQgZXhhY3QgbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAqIGxlc3Mgd2lsbCBsb29rIGZvciBpdCBhdCB0aGUgbG9jYXRpb24ocykgcGFzc2VkIHRvIHRoaXMgb3B0aW9uLlxyXG4gICAgICAgICAgICAgKiBZb3UgbWlnaHQgdXNlIHRoaXMgZm9yIGluc3RhbmNlIHRvIHNwZWNpZnkgYSBwYXRoIHRvIGEgbGlicmFyeSB3aGljaFxyXG4gICAgICAgICAgICAgKiB5b3Ugd2FudCB0byBiZSByZWZlcmVuY2VkIHNpbXBseSBhbmQgcmVsYXRpdmVseSBpbiB0aGUgbGVzcyBmaWxlcy4gKi9cclxuICAgICAgICAgICAgcGF0aHM6IFtdLFxyXG4gICAgICAgICAgICAvKiBjb2xvciBvdXRwdXQgaW4gdGhlIHRlcm1pbmFsICovXHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICAvKiBUaGUgc3RyaWN0SW1wb3J0cyBjb250cm9scyB3aGV0aGVyIHRoZSBjb21waWxlciB3aWxsIGFsbG93IGFuIEBpbXBvcnQgaW5zaWRlIG9mIGVpdGhlclxyXG4gICAgICAgICAgICAgKiBAbWVkaWEgYmxvY2tzIG9yIChhIGxhdGVyIGFkZGl0aW9uKSBvdGhlciBzZWxlY3RvciBibG9ja3MuXHJcbiAgICAgICAgICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2xlc3MvbGVzcy5qcy9pc3N1ZXMvNjU2ICovXHJcbiAgICAgICAgICAgIHN0cmljdEltcG9ydHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiBBbGxvdyBJbXBvcnRzIGZyb20gSW5zZWN1cmUgSFRUUFMgSG9zdHMgKi9cclxuICAgICAgICAgICAgaW5zZWN1cmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiBBbGxvd3MgeW91IHRvIGFkZCBhIHBhdGggdG8gZXZlcnkgZ2VuZXJhdGVkIGltcG9ydCBhbmQgdXJsIGluIHlvdXIgY3NzLlxyXG4gICAgICAgICAgICAgKiBUaGlzIGRvZXMgbm90IGFmZmVjdCBsZXNzIGltcG9ydCBzdGF0ZW1lbnRzIHRoYXQgYXJlIHByb2Nlc3NlZCwganVzdCBvbmVzXHJcbiAgICAgICAgICAgICAqIHRoYXQgYXJlIGxlZnQgaW4gdGhlIG91dHB1dCBjc3MuICovXHJcbiAgICAgICAgICAgIHJvb3RwYXRoOiAnJyxcclxuICAgICAgICAgICAgLyogQnkgZGVmYXVsdCBVUkxzIGFyZSBrZXB0IGFzLWlzLCBzbyBpZiB5b3UgaW1wb3J0IGEgZmlsZSBpbiBhIHN1Yi1kaXJlY3RvcnlcclxuICAgICAgICAgICAgICogdGhhdCByZWZlcmVuY2VzIGFuIGltYWdlLCBleGFjdGx5IHRoZSBzYW1lIFVSTCB3aWxsIGJlIG91dHB1dCBpbiB0aGUgY3NzLlxyXG4gICAgICAgICAgICAgKiBUaGlzIG9wdGlvbiBhbGxvd3MgeW91IHRvIHJlLXdyaXRlIFVSTCdzIGluIGltcG9ydGVkIGZpbGVzIHNvIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAqIFVSTCBpcyBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgaW1wb3J0ZWQgZmlsZSAqL1xyXG4gICAgICAgICAgICByZXdyaXRlVXJsczogZmFsc2UsXHJcbiAgICAgICAgICAgIC8qIEhvdyB0byBwcm9jZXNzIG1hdGhcclxuICAgICAgICAgICAgICogICAwIGFsd2F5cyAgICAgICAgICAgLSBlYWdlcmx5IHRyeSB0byBzb2x2ZSBhbGwgb3BlcmF0aW9uc1xyXG4gICAgICAgICAgICAgKiAgIDEgcGFyZW5zLWRpdmlzaW9uICAtIHJlcXVpcmUgcGFyZW5zIGZvciBkaXZpc2lvbiBcIi9cIlxyXG4gICAgICAgICAgICAgKiAgIDIgcGFyZW5zIHwgc3RyaWN0ICAtIHJlcXVpcmUgcGFyZW5zIGZvciBhbGwgb3BlcmF0aW9uc1xyXG4gICAgICAgICAgICAgKiAgIDMgc3RyaWN0LWxlZ2FjeSAgICAtIGxlZ2FjeSBzdHJpY3QgYmVoYXZpb3IgKHN1cGVyLXN0cmljdClcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG1hdGg6IDEsXHJcbiAgICAgICAgICAgIC8qIFdpdGhvdXQgdGhpcyBvcHRpb24sIGxlc3MgYXR0ZW1wdHMgdG8gZ3Vlc3MgYXQgdGhlIG91dHB1dCB1bml0IHdoZW4gaXQgZG9lcyBtYXRocy4gKi9cclxuICAgICAgICAgICAgc3RyaWN0VW5pdHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKiBFZmZlY3RpdmVseSB0aGUgZGVjbGFyYXRpb24gaXMgcHV0IGF0IHRoZSB0b3Agb2YgeW91ciBiYXNlIExlc3MgZmlsZSxcclxuICAgICAgICAgICAgICogbWVhbmluZyBpdCBjYW4gYmUgdXNlZCBidXQgaXQgYWxzbyBjYW4gYmUgb3ZlcnJpZGRlbiBpZiB0aGlzIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAqIGlzIGRlZmluZWQgaW4gdGhlIGZpbGUuICovXHJcbiAgICAgICAgICAgIGdsb2JhbFZhcnM6IG51bGwsXHJcbiAgICAgICAgICAgIC8qIEFzIG9wcG9zZWQgdG8gdGhlIGdsb2JhbCB2YXJpYWJsZSBvcHRpb24sIHRoaXMgcHV0cyB0aGUgZGVjbGFyYXRpb24gYXQgdGhlXHJcbiAgICAgICAgICAgICAqIGVuZCBvZiB5b3VyIGJhc2UgZmlsZSwgbWVhbmluZyBpdCB3aWxsIG92ZXJyaWRlIGFueXRoaW5nIGRlZmluZWQgaW4geW91ciBMZXNzIGZpbGUuICovXHJcbiAgICAgICAgICAgIG1vZGlmeVZhcnM6IG51bGwsXHJcbiAgICAgICAgICAgIC8qIFRoaXMgb3B0aW9uIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBhIGFyZ3VtZW50IHRvIGdvIG9uIHRvIGV2ZXJ5IFVSTC4gICovXHJcbiAgICAgICAgICAgIHVybEFyZ3M6ICcnXHJcbiAgICAgICAgfTtcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RJZChocmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIGhyZWYucmVwbGFjZSgvXlthLXotXSs6XFwvKz9bXlxcL10rLywgJycpIC8vIFJlbW92ZSBwcm90b2NvbCAmIGRvbWFpblxyXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcP1xcJl1saXZlcmVsb2FkPVxcdysvLCAnJykgLy8gUmVtb3ZlIExpdmVSZWxvYWQgY2FjaGVidXN0ZXJcclxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXC8vLCAnJykgLy8gUmVtb3ZlIHJvb3QgL1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuW2EtekEtWl0rJC8sICcnKSAvLyBSZW1vdmUgc2ltcGxlIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAucmVwbGFjZSgvW15cXC5cXHctXSsvZywgJy0nKSAvLyBSZXBsYWNlIGlsbGVnYWwgY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csICc6Jyk7IC8vIFJlcGxhY2UgZG90cyB3aXRoIGNvbG9ucyhmb3IgdmFsaWQgaWQpXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGREYXRhQXR0cihvcHRpb25zLCB0YWcpIHtcclxuICAgICAgICBmb3IgKHZhciBvcHQgaW4gdGFnLmRhdGFzZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRhZy5kYXRhc2V0Lmhhc093blByb3BlcnR5KG9wdCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHQgPT09ICdlbnYnIHx8IG9wdCA9PT0gJ2R1bXBMaW5lTnVtYmVycycgfHwgb3B0ID09PSAncm9vdHBhdGgnIHx8IG9wdCA9PT0gJ2Vycm9yUmVwb3J0aW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IHRhZy5kYXRhc2V0W29wdF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29wdF0gPSBKU09OLnBhcnNlKHRhZy5kYXRhc2V0W29wdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XG5cbiAgICB2YXIgYnJvd3NlciA9IHtcclxuICAgICAgICBjcmVhdGVDU1M6IGZ1bmN0aW9uIChkb2N1bWVudCwgc3R5bGVzLCBzaGVldCkge1xyXG4gICAgICAgICAgICAvLyBTdHJpcCB0aGUgcXVlcnktc3RyaW5nXHJcbiAgICAgICAgICAgIHZhciBocmVmID0gc2hlZXQuaHJlZiB8fCAnJztcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdGl0bGUgc2V0LCB1c2UgdGhlIGZpbGVuYW1lLCBtaW51cyB0aGUgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgIHZhciBpZCA9IFwibGVzczpcIiArIChzaGVldC50aXRsZSB8fCBleHRyYWN0SWQoaHJlZikpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGhhcyBhbHJlYWR5IGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLCB3ZSBtYXkgbmVlZCB0byByZXBsYWNlIGl0XHJcbiAgICAgICAgICAgIHZhciBvbGRTdHlsZU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgICAgICAgIHZhciBrZWVwT2xkU3R5bGVOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdHlsZXNoZWV0IG5vZGUgZm9yIGluc2VydGlvbiBvciAoaWYgbmVjZXNzYXJ5KSByZXBsYWNlbWVudFxyXG4gICAgICAgICAgICB2YXIgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xyXG4gICAgICAgICAgICBpZiAoc2hlZXQubWVkaWEpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgc2hlZXQubWVkaWEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlTm9kZS5pZCA9IGlkO1xyXG4gICAgICAgICAgICBpZiAoIXN0eWxlTm9kZS5zdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZU5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVzKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudHMgbWF0Y2ggY29udGVudHMgb2Ygb2xkU3R5bGVOb2RlLCBkb24ndCByZXBsYWNlIG9sZFN0eWxlTm9kZVxyXG4gICAgICAgICAgICAgICAga2VlcE9sZFN0eWxlTm9kZSA9IChvbGRTdHlsZU5vZGUgIT09IG51bGwgJiYgb2xkU3R5bGVOb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJiBzdHlsZU5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkU3R5bGVOb2RlLmZpcnN0Q2hpbGQubm9kZVZhbHVlID09PSBzdHlsZU5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb2xkU3R5bGVOb2RlLCBqdXN0IGFwcGVuZDsgb3RoZXJ3aXNlLCBvbmx5IGFwcGVuZCBpZiB3ZSBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIHJlcGxhY2Ugb2xkU3R5bGVOb2RlIHdpdGggYW4gdXBkYXRlZCBzdHlsZXNoZWV0XHJcbiAgICAgICAgICAgIGlmIChvbGRTdHlsZU5vZGUgPT09IG51bGwgfHwga2VlcE9sZFN0eWxlTm9kZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0RWwgPSBzaGVldCAmJiBzaGVldC5uZXh0U2libGluZyB8fCBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZU5vZGUsIG5leHRFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFN0eWxlTm9kZSAmJiBrZWVwT2xkU3R5bGVOb2RlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgb2xkU3R5bGVOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2xkU3R5bGVOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGb3IgSUUuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuICphZnRlciogdGhlIHN0eWxlIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSwgb3RoZXJ3aXNlIElFIDcgYW5kIDggbWF5IGNyYXNoLlxyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cDovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTLzdlMDgxYjY1LTg3OGEtNGMyMi04ZTY4LWMxMGQzOWMyZWQzMi9pbnRlcm5ldC1leHBsb3Jlci1jcmFzaGVzLWFwcGVuZGluZy1zdHlsZS1lbGVtZW50LXRvLWhlYWRcclxuICAgICAgICAgICAgaWYgKHN0eWxlTm9kZS5zdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlTm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCByZWFzc2lnbiBzdHlsZVNoZWV0LmNzc1RleHQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGN1cnJlbnRTY3JpcHQ6IGZ1bmN0aW9uICh3aW5kb3cpIHtcclxuICAgICAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdCB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgYWRkRGVmYXVsdE9wdGlvbnMgPSAoZnVuY3Rpb24gKHdpbmRvdywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHVzZSBvcHRpb25zIGZyb20gdGhlIGN1cnJlbnQgc2NyaXB0IHRhZyBkYXRhIGF0dHJpYnVlc1xyXG4gICAgICAgIGFkZERhdGFBdHRyKG9wdGlvbnMsIGJyb3dzZXIuY3VycmVudFNjcmlwdCh3aW5kb3cpKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgPSAvXihmaWxlfChjaHJvbWV8c2FmYXJpKSgtZXh0ZW5zaW9uKT98cmVzb3VyY2V8cXJjfGFwcCk6Ly50ZXN0KHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExvYWQgc3R5bGVzIGFzeW5jaHJvbm91c2x5IChkZWZhdWx0OiBmYWxzZSlcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoaXMgaXMgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdCwgc28gdGhhdCB0aGUgYm9keVxyXG4gICAgICAgIC8vIGRvZXNuJ3Qgc3RhcnQgbG9hZGluZyBiZWZvcmUgdGhlIHN0eWxlc2hlZXRzIGFyZSBwYXJzZWQuXHJcbiAgICAgICAgLy8gU2V0dGluZyB0aGlzIHRvIGB0cnVlYCBjYW4gcmVzdWx0IGluIGZsaWNrZXJpbmcuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBvcHRpb25zLmFzeW5jID0gb3B0aW9ucy5hc3luYyB8fCBmYWxzZTtcclxuICAgICAgICBvcHRpb25zLmZpbGVBc3luYyA9IG9wdGlvbnMuZmlsZUFzeW5jIHx8IGZhbHNlO1xyXG4gICAgICAgIC8vIEludGVydmFsIGJldHdlZW4gd2F0Y2ggcG9sbHNcclxuICAgICAgICBvcHRpb25zLnBvbGwgPSBvcHRpb25zLnBvbGwgfHwgKG9wdGlvbnMuaXNGaWxlUHJvdG9jb2wgPyAxMDAwIDogMTUwMCk7XHJcbiAgICAgICAgb3B0aW9ucy5lbnYgPSBvcHRpb25zLmVudiB8fCAod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09ICcxMjcuMC4wLjEnIHx8XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PSAnMC4wLjAuMCcgfHxcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09ICdsb2NhbGhvc3QnIHx8XHJcbiAgICAgICAgICAgICh3aW5kb3cubG9jYXRpb24ucG9ydCAmJlxyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnBvcnQubGVuZ3RoID4gMCkgfHxcclxuICAgICAgICAgICAgb3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA/ICdkZXZlbG9wbWVudCdcclxuICAgICAgICAgICAgOiAncHJvZHVjdGlvbicpO1xyXG4gICAgICAgIHZhciBkdW1wTGluZU51bWJlcnMgPSAvIWR1bXBMaW5lTnVtYmVyczooY29tbWVudHN8bWVkaWFxdWVyeXxhbGwpLy5leGVjKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtcclxuICAgICAgICBpZiAoZHVtcExpbmVOdW1iZXJzKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZHVtcExpbmVOdW1iZXJzID0gZHVtcExpbmVOdW1iZXJzWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy51c2VGaWxlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnVzZUZpbGVDYWNoZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm9uUmVhZHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLm9uUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZVVybHMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yZXdyaXRlVXJscyA9ICdhbGwnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIGxvZ2dlciA9IHtcclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2Vycm9yJywgbXNnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCd3YXJuJywgbXNnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluZm86IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdpbmZvJywgbXNnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlYnVnOiBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZGVidWcnLCBtc2cpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgbXNnKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9nRnVuY3Rpb24gPSB0aGlzLl9saXN0ZW5lcnNbaV1bdHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihtc2cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbGlzdGVuZXJzOiBbXVxyXG4gICAgfTtcblxuICAgIC8qKlxyXG4gICAgICogQHRvZG8gRG9jdW1lbnQgd2h5IHRoaXMgYWJzdHJhY3Rpb24gZXhpc3RzLCBhbmQgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuXHJcbiAgICAgKiAgICAgICBlbnZpcm9ubWVudCwgZmlsZSBtYW5hZ2VycywgYW5kIHBsdWdpbiBtYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHZhciBFbnZpcm9ubWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBFbnZpcm9ubWVudChleHRlcm5hbEVudmlyb25tZW50LCBmaWxlTWFuYWdlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlTWFuYWdlcnMgPSBmaWxlTWFuYWdlcnMgfHwgW107XHJcbiAgICAgICAgICAgIGV4dGVybmFsRW52aXJvbm1lbnQgPSBleHRlcm5hbEVudmlyb25tZW50IHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxGdW5jdGlvbnMgPSBbJ2VuY29kZUJhc2U2NCcsICdtaW1lTG9va3VwJywgJ2NoYXJzZXRMb29rdXAnLCAnZ2V0U291cmNlTWFwR2VuZXJhdG9yJ107XHJcbiAgICAgICAgICAgIHZhciByZXF1aXJlZEZ1bmN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25zID0gcmVxdWlyZWRGdW5jdGlvbnMuY29uY2F0KG9wdGlvbmFsRnVuY3Rpb25zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IGZ1bmN0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbnZpcm9ubWVudEZ1bmMgPSBleHRlcm5hbEVudmlyb25tZW50W3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChlbnZpcm9ubWVudEZ1bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IGVudmlyb25tZW50RnVuYy5iaW5kKGV4dGVybmFsRW52aXJvbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IHJlcXVpcmVkRnVuY3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FybihcIm1pc3NpbmcgcmVxdWlyZWQgZnVuY3Rpb24gaW4gZW52aXJvbm1lbnQgLSBcIiArIHByb3BOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0RmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGN1cnJlbnREaXJlY3RvcnksIG9wdGlvbnMsIGVudmlyb25tZW50LCBpc1N5bmMpIHtcclxuICAgICAgICAgICAgaWYgKCFmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2dldEZpbGVNYW5hZ2VyIGNhbGxlZCB3aXRoIG5vIGZpbGVuYW1lLi4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlLiBjb250aW51aW5nLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGlyZWN0b3J5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdnZXRGaWxlTWFuYWdlciBjYWxsZWQgd2l0aCBudWxsIGRpcmVjdG9yeS4uIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZS4gY29udGludWluZy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmlsZU1hbmFnZXJzID0gdGhpcy5maWxlTWFuYWdlcnM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VycyA9IFtdLmNvbmNhdChmaWxlTWFuYWdlcnMpLmNvbmNhdChvcHRpb25zLnBsdWdpbk1hbmFnZXIuZ2V0RmlsZU1hbmFnZXJzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmaWxlTWFuYWdlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlTWFuYWdlciA9IGZpbGVNYW5hZ2Vyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxlTWFuYWdlcltpc1N5bmMgPyAnc3VwcG9ydHNTeW5jJyA6ICdzdXBwb3J0cyddKGZpbGVuYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBvcHRpb25zLCBlbnZpcm9ubWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZU1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuYWRkRmlsZU1hbmFnZXIgPSBmdW5jdGlvbiAoZmlsZU1hbmFnZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlTWFuYWdlcnMucHVzaChmaWxlTWFuYWdlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuY2xlYXJGaWxlTWFuYWdlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZU1hbmFnZXJzID0gW107XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRW52aXJvbm1lbnQ7XHJcbiAgICB9KCkpO1xuXG4gICAgdmFyIGNvbG9ycyA9IHtcclxuICAgICAgICAnYWxpY2VibHVlJzogJyNmMGY4ZmYnLFxyXG4gICAgICAgICdhbnRpcXVld2hpdGUnOiAnI2ZhZWJkNycsXHJcbiAgICAgICAgJ2FxdWEnOiAnIzAwZmZmZicsXHJcbiAgICAgICAgJ2FxdWFtYXJpbmUnOiAnIzdmZmZkNCcsXHJcbiAgICAgICAgJ2F6dXJlJzogJyNmMGZmZmYnLFxyXG4gICAgICAgICdiZWlnZSc6ICcjZjVmNWRjJyxcclxuICAgICAgICAnYmlzcXVlJzogJyNmZmU0YzQnLFxyXG4gICAgICAgICdibGFjayc6ICcjMDAwMDAwJyxcclxuICAgICAgICAnYmxhbmNoZWRhbG1vbmQnOiAnI2ZmZWJjZCcsXHJcbiAgICAgICAgJ2JsdWUnOiAnIzAwMDBmZicsXHJcbiAgICAgICAgJ2JsdWV2aW9sZXQnOiAnIzhhMmJlMicsXHJcbiAgICAgICAgJ2Jyb3duJzogJyNhNTJhMmEnLFxyXG4gICAgICAgICdidXJseXdvb2QnOiAnI2RlYjg4NycsXHJcbiAgICAgICAgJ2NhZGV0Ymx1ZSc6ICcjNWY5ZWEwJyxcclxuICAgICAgICAnY2hhcnRyZXVzZSc6ICcjN2ZmZjAwJyxcclxuICAgICAgICAnY2hvY29sYXRlJzogJyNkMjY5MWUnLFxyXG4gICAgICAgICdjb3JhbCc6ICcjZmY3ZjUwJyxcclxuICAgICAgICAnY29ybmZsb3dlcmJsdWUnOiAnIzY0OTVlZCcsXHJcbiAgICAgICAgJ2Nvcm5zaWxrJzogJyNmZmY4ZGMnLFxyXG4gICAgICAgICdjcmltc29uJzogJyNkYzE0M2MnLFxyXG4gICAgICAgICdjeWFuJzogJyMwMGZmZmYnLFxyXG4gICAgICAgICdkYXJrYmx1ZSc6ICcjMDAwMDhiJyxcclxuICAgICAgICAnZGFya2N5YW4nOiAnIzAwOGI4YicsXHJcbiAgICAgICAgJ2Rhcmtnb2xkZW5yb2QnOiAnI2I4ODYwYicsXHJcbiAgICAgICAgJ2RhcmtncmF5JzogJyNhOWE5YTknLFxyXG4gICAgICAgICdkYXJrZ3JleSc6ICcjYTlhOWE5JyxcclxuICAgICAgICAnZGFya2dyZWVuJzogJyMwMDY0MDAnLFxyXG4gICAgICAgICdkYXJra2hha2knOiAnI2JkYjc2YicsXHJcbiAgICAgICAgJ2RhcmttYWdlbnRhJzogJyM4YjAwOGInLFxyXG4gICAgICAgICdkYXJrb2xpdmVncmVlbic6ICcjNTU2YjJmJyxcclxuICAgICAgICAnZGFya29yYW5nZSc6ICcjZmY4YzAwJyxcclxuICAgICAgICAnZGFya29yY2hpZCc6ICcjOTkzMmNjJyxcclxuICAgICAgICAnZGFya3JlZCc6ICcjOGIwMDAwJyxcclxuICAgICAgICAnZGFya3NhbG1vbic6ICcjZTk5NjdhJyxcclxuICAgICAgICAnZGFya3NlYWdyZWVuJzogJyM4ZmJjOGYnLFxyXG4gICAgICAgICdkYXJrc2xhdGVibHVlJzogJyM0ODNkOGInLFxyXG4gICAgICAgICdkYXJrc2xhdGVncmF5JzogJyMyZjRmNGYnLFxyXG4gICAgICAgICdkYXJrc2xhdGVncmV5JzogJyMyZjRmNGYnLFxyXG4gICAgICAgICdkYXJrdHVycXVvaXNlJzogJyMwMGNlZDEnLFxyXG4gICAgICAgICdkYXJrdmlvbGV0JzogJyM5NDAwZDMnLFxyXG4gICAgICAgICdkZWVwcGluayc6ICcjZmYxNDkzJyxcclxuICAgICAgICAnZGVlcHNreWJsdWUnOiAnIzAwYmZmZicsXHJcbiAgICAgICAgJ2RpbWdyYXknOiAnIzY5Njk2OScsXHJcbiAgICAgICAgJ2RpbWdyZXknOiAnIzY5Njk2OScsXHJcbiAgICAgICAgJ2RvZGdlcmJsdWUnOiAnIzFlOTBmZicsXHJcbiAgICAgICAgJ2ZpcmVicmljayc6ICcjYjIyMjIyJyxcclxuICAgICAgICAnZmxvcmFsd2hpdGUnOiAnI2ZmZmFmMCcsXHJcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJzogJyMyMjhiMjInLFxyXG4gICAgICAgICdmdWNoc2lhJzogJyNmZjAwZmYnLFxyXG4gICAgICAgICdnYWluc2Jvcm8nOiAnI2RjZGNkYycsXHJcbiAgICAgICAgJ2dob3N0d2hpdGUnOiAnI2Y4ZjhmZicsXHJcbiAgICAgICAgJ2dvbGQnOiAnI2ZmZDcwMCcsXHJcbiAgICAgICAgJ2dvbGRlbnJvZCc6ICcjZGFhNTIwJyxcclxuICAgICAgICAnZ3JheSc6ICcjODA4MDgwJyxcclxuICAgICAgICAnZ3JleSc6ICcjODA4MDgwJyxcclxuICAgICAgICAnZ3JlZW4nOiAnIzAwODAwMCcsXHJcbiAgICAgICAgJ2dyZWVueWVsbG93JzogJyNhZGZmMmYnLFxyXG4gICAgICAgICdob25leWRldyc6ICcjZjBmZmYwJyxcclxuICAgICAgICAnaG90cGluayc6ICcjZmY2OWI0JyxcclxuICAgICAgICAnaW5kaWFucmVkJzogJyNjZDVjNWMnLFxyXG4gICAgICAgICdpbmRpZ28nOiAnIzRiMDA4MicsXHJcbiAgICAgICAgJ2l2b3J5JzogJyNmZmZmZjAnLFxyXG4gICAgICAgICdraGFraSc6ICcjZjBlNjhjJyxcclxuICAgICAgICAnbGF2ZW5kZXInOiAnI2U2ZTZmYScsXHJcbiAgICAgICAgJ2xhdmVuZGVyYmx1c2gnOiAnI2ZmZjBmNScsXHJcbiAgICAgICAgJ2xhd25ncmVlbic6ICcjN2NmYzAwJyxcclxuICAgICAgICAnbGVtb25jaGlmZm9uJzogJyNmZmZhY2QnLFxyXG4gICAgICAgICdsaWdodGJsdWUnOiAnI2FkZDhlNicsXHJcbiAgICAgICAgJ2xpZ2h0Y29yYWwnOiAnI2YwODA4MCcsXHJcbiAgICAgICAgJ2xpZ2h0Y3lhbic6ICcjZTBmZmZmJyxcclxuICAgICAgICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAnI2ZhZmFkMicsXHJcbiAgICAgICAgJ2xpZ2h0Z3JheSc6ICcjZDNkM2QzJyxcclxuICAgICAgICAnbGlnaHRncmV5JzogJyNkM2QzZDMnLFxyXG4gICAgICAgICdsaWdodGdyZWVuJzogJyM5MGVlOTAnLFxyXG4gICAgICAgICdsaWdodHBpbmsnOiAnI2ZmYjZjMScsXHJcbiAgICAgICAgJ2xpZ2h0c2FsbW9uJzogJyNmZmEwN2EnLFxyXG4gICAgICAgICdsaWdodHNlYWdyZWVuJzogJyMyMGIyYWEnLFxyXG4gICAgICAgICdsaWdodHNreWJsdWUnOiAnIzg3Y2VmYScsXHJcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmF5JzogJyM3Nzg4OTknLFxyXG4gICAgICAgICdsaWdodHNsYXRlZ3JleSc6ICcjNzc4ODk5JyxcclxuICAgICAgICAnbGlnaHRzdGVlbGJsdWUnOiAnI2IwYzRkZScsXHJcbiAgICAgICAgJ2xpZ2h0eWVsbG93JzogJyNmZmZmZTAnLFxyXG4gICAgICAgICdsaW1lJzogJyMwMGZmMDAnLFxyXG4gICAgICAgICdsaW1lZ3JlZW4nOiAnIzMyY2QzMicsXHJcbiAgICAgICAgJ2xpbmVuJzogJyNmYWYwZTYnLFxyXG4gICAgICAgICdtYWdlbnRhJzogJyNmZjAwZmYnLFxyXG4gICAgICAgICdtYXJvb24nOiAnIzgwMDAwMCcsXHJcbiAgICAgICAgJ21lZGl1bWFxdWFtYXJpbmUnOiAnIzY2Y2RhYScsXHJcbiAgICAgICAgJ21lZGl1bWJsdWUnOiAnIzAwMDBjZCcsXHJcbiAgICAgICAgJ21lZGl1bW9yY2hpZCc6ICcjYmE1NWQzJyxcclxuICAgICAgICAnbWVkaXVtcHVycGxlJzogJyM5MzcwZDgnLFxyXG4gICAgICAgICdtZWRpdW1zZWFncmVlbic6ICcjM2NiMzcxJyxcclxuICAgICAgICAnbWVkaXVtc2xhdGVibHVlJzogJyM3YjY4ZWUnLFxyXG4gICAgICAgICdtZWRpdW1zcHJpbmdncmVlbic6ICcjMDBmYTlhJyxcclxuICAgICAgICAnbWVkaXVtdHVycXVvaXNlJzogJyM0OGQxY2MnLFxyXG4gICAgICAgICdtZWRpdW12aW9sZXRyZWQnOiAnI2M3MTU4NScsXHJcbiAgICAgICAgJ21pZG5pZ2h0Ymx1ZSc6ICcjMTkxOTcwJyxcclxuICAgICAgICAnbWludGNyZWFtJzogJyNmNWZmZmEnLFxyXG4gICAgICAgICdtaXN0eXJvc2UnOiAnI2ZmZTRlMScsXHJcbiAgICAgICAgJ21vY2Nhc2luJzogJyNmZmU0YjUnLFxyXG4gICAgICAgICduYXZham93aGl0ZSc6ICcjZmZkZWFkJyxcclxuICAgICAgICAnbmF2eSc6ICcjMDAwMDgwJyxcclxuICAgICAgICAnb2xkbGFjZSc6ICcjZmRmNWU2JyxcclxuICAgICAgICAnb2xpdmUnOiAnIzgwODAwMCcsXHJcbiAgICAgICAgJ29saXZlZHJhYic6ICcjNmI4ZTIzJyxcclxuICAgICAgICAnb3JhbmdlJzogJyNmZmE1MDAnLFxyXG4gICAgICAgICdvcmFuZ2VyZWQnOiAnI2ZmNDUwMCcsXHJcbiAgICAgICAgJ29yY2hpZCc6ICcjZGE3MGQ2JyxcclxuICAgICAgICAncGFsZWdvbGRlbnJvZCc6ICcjZWVlOGFhJyxcclxuICAgICAgICAncGFsZWdyZWVuJzogJyM5OGZiOTgnLFxyXG4gICAgICAgICdwYWxldHVycXVvaXNlJzogJyNhZmVlZWUnLFxyXG4gICAgICAgICdwYWxldmlvbGV0cmVkJzogJyNkODcwOTMnLFxyXG4gICAgICAgICdwYXBheWF3aGlwJzogJyNmZmVmZDUnLFxyXG4gICAgICAgICdwZWFjaHB1ZmYnOiAnI2ZmZGFiOScsXHJcbiAgICAgICAgJ3BlcnUnOiAnI2NkODUzZicsXHJcbiAgICAgICAgJ3BpbmsnOiAnI2ZmYzBjYicsXHJcbiAgICAgICAgJ3BsdW0nOiAnI2RkYTBkZCcsXHJcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOiAnI2IwZTBlNicsXHJcbiAgICAgICAgJ3B1cnBsZSc6ICcjODAwMDgwJyxcclxuICAgICAgICAncmViZWNjYXB1cnBsZSc6ICcjNjYzMzk5JyxcclxuICAgICAgICAncmVkJzogJyNmZjAwMDAnLFxyXG4gICAgICAgICdyb3N5YnJvd24nOiAnI2JjOGY4ZicsXHJcbiAgICAgICAgJ3JveWFsYmx1ZSc6ICcjNDE2OWUxJyxcclxuICAgICAgICAnc2FkZGxlYnJvd24nOiAnIzhiNDUxMycsXHJcbiAgICAgICAgJ3NhbG1vbic6ICcjZmE4MDcyJyxcclxuICAgICAgICAnc2FuZHlicm93bic6ICcjZjRhNDYwJyxcclxuICAgICAgICAnc2VhZ3JlZW4nOiAnIzJlOGI1NycsXHJcbiAgICAgICAgJ3NlYXNoZWxsJzogJyNmZmY1ZWUnLFxyXG4gICAgICAgICdzaWVubmEnOiAnI2EwNTIyZCcsXHJcbiAgICAgICAgJ3NpbHZlcic6ICcjYzBjMGMwJyxcclxuICAgICAgICAnc2t5Ymx1ZSc6ICcjODdjZWViJyxcclxuICAgICAgICAnc2xhdGVibHVlJzogJyM2YTVhY2QnLFxyXG4gICAgICAgICdzbGF0ZWdyYXknOiAnIzcwODA5MCcsXHJcbiAgICAgICAgJ3NsYXRlZ3JleSc6ICcjNzA4MDkwJyxcclxuICAgICAgICAnc25vdyc6ICcjZmZmYWZhJyxcclxuICAgICAgICAnc3ByaW5nZ3JlZW4nOiAnIzAwZmY3ZicsXHJcbiAgICAgICAgJ3N0ZWVsYmx1ZSc6ICcjNDY4MmI0JyxcclxuICAgICAgICAndGFuJzogJyNkMmI0OGMnLFxyXG4gICAgICAgICd0ZWFsJzogJyMwMDgwODAnLFxyXG4gICAgICAgICd0aGlzdGxlJzogJyNkOGJmZDgnLFxyXG4gICAgICAgICd0b21hdG8nOiAnI2ZmNjM0NycsXHJcbiAgICAgICAgJ3R1cnF1b2lzZSc6ICcjNDBlMGQwJyxcclxuICAgICAgICAndmlvbGV0JzogJyNlZTgyZWUnLFxyXG4gICAgICAgICd3aGVhdCc6ICcjZjVkZWIzJyxcclxuICAgICAgICAnd2hpdGUnOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgJ3doaXRlc21va2UnOiAnI2Y1ZjVmNScsXHJcbiAgICAgICAgJ3llbGxvdyc6ICcjZmZmZjAwJyxcclxuICAgICAgICAneWVsbG93Z3JlZW4nOiAnIzlhY2QzMidcclxuICAgIH07XG5cbiAgICB2YXIgdW5pdENvbnZlcnNpb25zID0ge1xyXG4gICAgICAgIGxlbmd0aDoge1xyXG4gICAgICAgICAgICAnbSc6IDEsXHJcbiAgICAgICAgICAgICdjbSc6IDAuMDEsXHJcbiAgICAgICAgICAgICdtbSc6IDAuMDAxLFxyXG4gICAgICAgICAgICAnaW4nOiAwLjAyNTQsXHJcbiAgICAgICAgICAgICdweCc6IDAuMDI1NCAvIDk2LFxyXG4gICAgICAgICAgICAncHQnOiAwLjAyNTQgLyA3MixcclxuICAgICAgICAgICAgJ3BjJzogMC4wMjU0IC8gNzIgKiAxMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHVyYXRpb246IHtcclxuICAgICAgICAgICAgJ3MnOiAxLFxyXG4gICAgICAgICAgICAnbXMnOiAwLjAwMVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5nbGU6IHtcclxuICAgICAgICAgICAgJ3JhZCc6IDEgLyAoMiAqIE1hdGguUEkpLFxyXG4gICAgICAgICAgICAnZGVnJzogMSAvIDM2MCxcclxuICAgICAgICAgICAgJ2dyYWQnOiAxIC8gNDAwLFxyXG4gICAgICAgICAgICAndHVybic6IDFcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIGRhdGEgPSB7IGNvbG9yczogY29sb3JzLCB1bml0Q29udmVyc2lvbnM6IHVuaXRDb252ZXJzaW9ucyB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVhc29uIHdoeSBOb2RlIGlzIGEgY2xhc3MgYW5kIG90aGVyIG5vZGVzIHNpbXBseSBkbyBub3QgZXh0ZW5kXHJcbiAgICAgKiBmcm9tIE5vZGUgKHNpbmNlIHdlJ3JlIHRyYW5zcGlsaW5nKSBpcyBkdWUgdG8gdGhpcyBpc3N1ZTpcclxuICAgICAqXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGVzcy9sZXNzLmpzL2lzc3Vlcy8zNDM0XHJcbiAgICAgKi9cclxuICAgIHZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE5vZGUoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVWaXNpYmxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZWQgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY3VycmVudEZpbGVJbmZvJywge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmZpbGVJbmZvKCk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaW5kZXgnLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuZ2V0SW5kZXgoKTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKG5vZGVzLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0KG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKHNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXQobm9kZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4IHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5nZXRJbmRleCgpKSB8fCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuZmlsZUluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWxlSW5mbyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuZmlsZUluZm8oKSkgfHwge307XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5pc1J1bGVzZXRMaWtlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc3RycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmdlbkNTUyhjb250ZXh0LCB7XHJcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChjaHVuaywgZmlsZUluZm8sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Rycy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cnMubGVuZ3RoID09PSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cnMuam9pbignJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5nZW5DU1MgPSBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLl9vcGVyYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wLCBhLCBiKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJysnOiByZXR1cm4gYSArIGI7XHJcbiAgICAgICAgICAgICAgICBjYXNlICctJzogcmV0dXJuIGEgLSBiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnKic6IHJldHVybiBhICogYjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOiByZXR1cm4gYSAvIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmZyb3VuZCA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gY29udGV4dCAmJiBjb250ZXh0Lm51bVByZWNpc2lvbjtcclxuICAgICAgICAgICAgLy8gYWRkIFwiZXBzaWxvblwiIHRvIGVuc3VyZSBudW1iZXJzIGxpa2UgMS4wMDAwMDAwMDUgKHJlcHJlc2VudGVkIGFzIDEuMDAwMDAwMDA0OTk5Li4uKSBhcmUgcHJvcGVybHkgcm91bmRlZDpcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVjaXNpb24pID8gTnVtYmVyKCh2YWx1ZSArIDJlLTE2KS50b0ZpeGVkKHByZWNpc2lvbikpIDogdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAvKiByZXR1cm5zOlxyXG4gICAgICAgICAgICAgLTE6IGEgPCBiXHJcbiAgICAgICAgICAgICAwOiBhID0gYlxyXG4gICAgICAgICAgICAgMTogYSA+IGJcclxuICAgICAgICAgICAgIGFuZCAqYW55KiBvdGhlciB2YWx1ZSBmb3IgYSAhPSBiIChlLmcuIHVuZGVmaW5lZCwgTmFOLCAtMiBldGMuKSAqL1xyXG4gICAgICAgICAgICBpZiAoKGEuY29tcGFyZSkgJiZcclxuICAgICAgICAgICAgICAgIC8vIGZvciBcInN5bW1ldHJpYyByZXN1bHRzXCIgZm9yY2UgdG9DU1MtYmFzZWQgY29tcGFyaXNvblxyXG4gICAgICAgICAgICAgICAgLy8gb2YgUXVvdGVkIG9yIEFub255bW91cyBpZiBlaXRoZXIgdmFsdWUgaXMgb25lIG9mIHRob3NlXHJcbiAgICAgICAgICAgICAgICAhKGIudHlwZSA9PT0gJ1F1b3RlZCcgfHwgYi50eXBlID09PSAnQW5vbnltb3VzJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbXBhcmUoYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYi5jb21wYXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLWIuY29tcGFyZShhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhLnR5cGUgIT09IGIudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhID0gYS52YWx1ZTtcclxuICAgICAgICAgICAgYiA9IGIudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTm9kZS5jb21wYXJlKGFbaV0sIGJbaV0pICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUubnVtZXJpY0NvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMVxyXG4gICAgICAgICAgICAgICAgOiBhID09PSBiID8gMFxyXG4gICAgICAgICAgICAgICAgICAgIDogYSA+IGIgPyAxIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSByZXByZXNlbnRzIHJvb3Qgb2YgYXN0IGltcG9ydGVkIGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmJsb2Nrc1Zpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2liaWxpdHlCbG9ja3MgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpYmlsaXR5QmxvY2tzICE9PSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuYWRkVmlzaWJpbGl0eUJsb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52aXNpYmlsaXR5QmxvY2tzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5QmxvY2tzID0gdGhpcy52aXNpYmlsaXR5QmxvY2tzICsgMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZVZpc2liaWxpdHlCbG9jayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUJsb2NrcyA9IHRoaXMudmlzaWJpbGl0eUJsb2NrcyAtIDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUdXJucyBvbiBub2RlIHZpc2liaWxpdHkgLSBpZiBjYWxsZWQgbm9kZSB3aWxsIGJlIHNob3duIGluIG91dHB1dCByZWdhcmRsZXNzXHJcbiAgICAgICAgLy8gb2Ygd2hldGhlciBpdCBjb21lcyBmcm9tIGltcG9ydCBieSByZWZlcmVuY2Ugb3Igbm90XHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuZW5zdXJlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUdXJucyBvZmYgbm9kZSB2aXNpYmlsaXR5IC0gaWYgY2FsbGVkIG5vZGUgd2lsbCBOT1QgYmUgc2hvd24gaW4gb3V0cHV0IHJlZ2FyZGxlc3NcclxuICAgICAgICAvLyBvZiB3aGV0aGVyIGl0IGNvbWVzIGZyb20gaW1wb3J0IGJ5IHJlZmVyZW5jZSBvciBub3RcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5lbnN1cmVJbnZpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZVZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZXM6XHJcbiAgICAgICAgLy8gZmFsc2UgLSB0aGUgbm9kZSBtdXN0IG5vdCBiZSB2aXNpYmxlXHJcbiAgICAgICAgLy8gdHJ1ZSAtIHRoZSBub2RlIG11c3QgYmUgdmlzaWJsZVxyXG4gICAgICAgIC8vIHVuZGVmaW5lZCBvciBudWxsIC0gdGhlIG5vZGUgaGFzIHRoZSBzYW1lIHZpc2liaWxpdHkgYXMgaXRzIHBhcmVudFxyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVZpc2libGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS52aXNpYmlsaXR5SW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlCbG9ja3M6IHRoaXMudmlzaWJpbGl0eUJsb2NrcyxcclxuICAgICAgICAgICAgICAgIG5vZGVWaXNpYmxlOiB0aGlzLm5vZGVWaXNpYmxlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5jb3B5VmlzaWJpbGl0eUluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlCbG9ja3MgPSBpbmZvLnZpc2liaWxpdHlCbG9ja3M7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZVZpc2libGUgPSBpbmZvLm5vZGVWaXNpYmxlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE5vZGU7XHJcbiAgICB9KCkpO1xuXG4gICAgLy9cclxuICAgIC8vIFJHQiBDb2xvcnMgLSAjZmYwMDE0LCAjZWVlXHJcbiAgICAvL1xyXG4gICAgdmFyIENvbG9yID0gZnVuY3Rpb24gKHJnYiwgYSwgb3JpZ2luYWxGb3JtKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIGVuZCBnb2FsIGhlcmUsIGlzIHRvIHBhcnNlIHRoZSBhcmd1bWVudHNcclxuICAgICAgICAvLyBpbnRvIGFuIGludGVnZXIgdHJpcGxldCwgc3VjaCBhcyBgMTI4LCAyNTUsIDBgXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGlzIGZhY2lsaXRhdGVzIG9wZXJhdGlvbnMgYW5kIGNvbnZlcnNpb25zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmdiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJnYiA9IHJnYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmdiLmxlbmd0aCA+PSA2KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmdiID0gW107XHJcbiAgICAgICAgICAgIHJnYi5tYXRjaCgvLnsyfS9nKS5tYXAoZnVuY3Rpb24gKGMsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmdiLnB1c2gocGFyc2VJbnQoYywgMTYpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWxwaGEgPSAocGFyc2VJbnQoYywgMTYpKSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJnYiA9IFtdO1xyXG4gICAgICAgICAgICByZ2Iuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoYywgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZ2IucHVzaChwYXJzZUludChjICsgYywgMTYpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWxwaGEgPSAocGFyc2VJbnQoYyArIGMsIDE2KSkgLyAyNTU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFscGhhID0gdGhpcy5hbHBoYSB8fCAodHlwZW9mIGEgPT09ICdudW1iZXInID8gYSA6IDEpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGb3JtICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gb3JpZ2luYWxGb3JtO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb2xvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQ29sb3InLFxyXG4gICAgICAgIGx1bWE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSwgZyA9IHRoaXMucmdiWzFdIC8gMjU1LCBiID0gdGhpcy5yZ2JbMl0gLyAyNTU7XHJcbiAgICAgICAgICAgIHIgPSAociA8PSAwLjAzOTI4KSA/IHIgLyAxMi45MiA6IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcclxuICAgICAgICAgICAgZyA9IChnIDw9IDAuMDM5MjgpID8gZyAvIDEyLjkyIDogTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xyXG4gICAgICAgICAgICBiID0gKGIgPD0gMC4wMzkyOCkgPyBiIC8gMTIuOTIgOiBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnRvQ1NTKGNvbnRleHQpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgZG9Ob3RDb21wcmVzcykge1xyXG4gICAgICAgICAgICB2YXIgY29tcHJlc3MgPSBjb250ZXh0ICYmIGNvbnRleHQuY29tcHJlc3MgJiYgIWRvTm90Q29tcHJlc3M7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcjtcclxuICAgICAgICAgICAgdmFyIGFscGhhO1xyXG4gICAgICAgICAgICB2YXIgY29sb3JGdW5jdGlvbjtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgLy8gYHZhbHVlYCBpcyBzZXQgaWYgdGhpcyBjb2xvciB3YXMgb3JpZ2luYWxseVxyXG4gICAgICAgICAgICAvLyBjb252ZXJ0ZWQgZnJvbSBhIG5hbWVkIGNvbG9yIHN0cmluZyBzbyB3ZSBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIHJlc3BlY3QgdGhpcyBhbmQgdHJ5IHRvIG91dHB1dCBuYW1lZCBjb2xvciB0b28uXHJcbiAgICAgICAgICAgIGFscGhhID0gdGhpcy5mcm91bmQoY29udGV4dCwgdGhpcy5hbHBoYSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5pbmRleE9mKCdyZ2InKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JGdW5jdGlvbiA9ICdyZ2JhJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlLmluZGV4T2YoJ2hzbCcpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckZ1bmN0aW9uID0gJ2hzbGEnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JGdW5jdGlvbiA9ICdoc2wnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yRnVuY3Rpb24gPSAncmdiYSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChjb2xvckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2JhJzpcclxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5yZ2IubWFwKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFtcChNYXRoLnJvdW5kKGMpLCAyNTUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNvbmNhdChjbGFtcChhbHBoYSwgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsYSc6XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNsYW1wKGFscGhhLCAxKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy50b0hTTCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvdW5kKGNvbnRleHQsIGNvbG9yLmgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb3VuZChjb250ZXh0LCBjb2xvci5zICogMTAwKSArIFwiJVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb3VuZChjb250ZXh0LCBjb2xvci5sICogMTAwKSArIFwiJVwiXHJcbiAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQoYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbG9yRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgY2FwcGVkIGJldHdlZW4gYDBgIGFuZCBgMjU1YCwgcm91bmRlZCBhbmQgemVyby1wYWRkZWQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JGdW5jdGlvbiArIFwiKFwiICsgYXJncy5qb2luKFwiLFwiICsgKGNvbXByZXNzID8gJycgOiAnICcpKSArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy50b1JHQigpO1xyXG4gICAgICAgICAgICBpZiAoY29tcHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzcGxpdGNvbG9yID0gY29sb3Iuc3BsaXQoJycpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBjb2xvciB0byBzaG9ydCBmb3JtYXRcclxuICAgICAgICAgICAgICAgIGlmIChzcGxpdGNvbG9yWzFdID09PSBzcGxpdGNvbG9yWzJdICYmIHNwbGl0Y29sb3JbM10gPT09IHNwbGl0Y29sb3JbNF0gJiYgc3BsaXRjb2xvcls1XSA9PT0gc3BsaXRjb2xvcls2XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjXCIgKyBzcGxpdGNvbG9yWzFdICsgc3BsaXRjb2xvclszXSArIHNwbGl0Y29sb3JbNV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBPcGVyYXRpb25zIGhhdmUgdG8gYmUgZG9uZSBwZXItY2hhbm5lbCwgaWYgbm90LFxyXG4gICAgICAgIC8vIGNoYW5uZWxzIHdpbGwgc3BpbGwgb250byBlYWNoIG90aGVyLiBPbmNlIHdlIGhhdmVcclxuICAgICAgICAvLyBvdXIgcmVzdWx0LCBpbiB0aGUgZm9ybSBvZiBhbiBpbnRlZ2VyIHRyaXBsZXQsXHJcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgbmV3IENvbG9yIG5vZGUgdG8gaG9sZCB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgb3BlcmF0ZTogZnVuY3Rpb24gKGNvbnRleHQsIG9wLCBvdGhlcikge1xyXG4gICAgICAgICAgICB2YXIgcmdiID0gbmV3IEFycmF5KDMpO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLmFscGhhICogKDEgLSBvdGhlci5hbHBoYSkgKyBvdGhlci5hbHBoYTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAzOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIHJnYltjXSA9IHRoaXMuX29wZXJhdGUoY29udGV4dCwgb3AsIHRoaXMucmdiW2NdLCBvdGhlci5yZ2JbY10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmdiLCBhbHBoYSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1JHQjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9IZXgodGhpcy5yZ2IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9IU0w6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnJnYlswXSAvIDI1NSwgZyA9IHRoaXMucmdiWzFdIC8gMjU1LCBiID0gdGhpcy5yZ2JbMl0gLyAyNTUsIGEgPSB0aGlzLmFscGhhO1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgICAgICB2YXIgaDtcclxuICAgICAgICAgICAgdmFyIHM7XHJcbiAgICAgICAgICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gcyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoIC89IDY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgaDogaCAqIDM2MCwgczogcywgbDogbCwgYTogYSB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcclxuICAgICAgICB0b0hTVjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgciA9IHRoaXMucmdiWzBdIC8gMjU1LCBnID0gdGhpcy5yZ2JbMV0gLyAyNTUsIGIgPSB0aGlzLnJnYlsyXSAvIDI1NSwgYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICAgICAgICAgIHZhciBoO1xyXG4gICAgICAgICAgICB2YXIgcztcclxuICAgICAgICAgICAgdmFyIHYgPSBtYXg7XHJcbiAgICAgICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHMgPSBkIC8gbWF4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xyXG4gICAgICAgICAgICAgICAgaCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoIC89IDY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgaDogaCAqIDM2MCwgczogcywgdjogdiwgYTogYSB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9BUkdCOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b0hleChbdGhpcy5hbHBoYSAqIDI1NV0uY29uY2F0KHRoaXMucmdiKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wYXJlOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHgucmdiICYmXHJcbiAgICAgICAgICAgICAgICB4LnJnYlswXSA9PT0gdGhpcy5yZ2JbMF0gJiZcclxuICAgICAgICAgICAgICAgIHgucmdiWzFdID09PSB0aGlzLnJnYlsxXSAmJlxyXG4gICAgICAgICAgICAgICAgeC5yZ2JbMl0gPT09IHRoaXMucmdiWzJdICYmXHJcbiAgICAgICAgICAgICAgICB4LmFscGhhID09PSB0aGlzLmFscGhhKSA/IDAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBDb2xvci5mcm9tS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXdvcmQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoY29sb3JzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgYyA9IG5ldyBDb2xvcihjb2xvcnNba2V5XS5zbGljZSgxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3RyYW5zcGFyZW50Jykge1xyXG4gICAgICAgICAgICBjID0gbmV3IENvbG9yKFswLCAwLCAwXSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgICAgIGMudmFsdWUgPSBrZXl3b3JkO1xyXG4gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gY2xhbXAodiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHYsIDApLCBtYXgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdG9IZXgodikge1xyXG4gICAgICAgIHJldHVybiBcIiNcIiArIHYubWFwKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGMgPSBjbGFtcChNYXRoLnJvdW5kKGMpLCAyNTUpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGMgPCAxNiA/ICcwJyA6ICcnKSArIGMudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIH0pLmpvaW4oJycpO1xyXG4gICAgfVxuXG4gICAgdmFyIFBhcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gbm9kZTtcclxuICAgIH07XHJcbiAgICBQYXJlbi5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnUGFyZW4nLFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKCcoJyk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoJyknKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyZW4odGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBfbm9TcGFjZUNvbWJpbmF0b3JzID0ge1xyXG4gICAgICAgICcnOiB0cnVlLFxyXG4gICAgICAgICcgJzogdHJ1ZSxcclxuICAgICAgICAnfCc6IHRydWVcclxuICAgIH07XHJcbiAgICB2YXIgQ29tYmluYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnICc7XHJcbiAgICAgICAgICAgIHRoaXMuZW1wdHlPcldoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlID8gdmFsdWUudHJpbSgpIDogJyc7XHJcbiAgICAgICAgICAgIHRoaXMuZW1wdHlPcldoaXRlc3BhY2UgPSB0aGlzLnZhbHVlID09PSAnJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29tYmluYXRvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQ29tYmluYXRvcicsXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBzcGFjZU9yRW1wdHkgPSAoY29udGV4dC5jb21wcmVzcyB8fCBfbm9TcGFjZUNvbWJpbmF0b3JzW3RoaXMudmFsdWVdKSA/ICcnIDogJyAnO1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHNwYWNlT3JFbXB0eSArIHRoaXMudmFsdWUgKyBzcGFjZU9yRW1wdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAoY29tYmluYXRvciwgdmFsdWUsIGlzVmFyaWFibGUsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5jb21iaW5hdG9yID0gY29tYmluYXRvciBpbnN0YW5jZW9mIENvbWJpbmF0b3IgP1xyXG4gICAgICAgICAgICBjb21iaW5hdG9yIDogbmV3IENvbWJpbmF0b3IoY29tYmluYXRvcik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzVmFyaWFibGUgPSBpc1ZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuY29tYmluYXRvciwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnRWxlbWVudCcsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbWJpbmF0b3IgPSB2aXNpdG9yLnZpc2l0KHRoaXMuY29tYmluYXRvcik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzLmNvbWJpbmF0b3IsIHRoaXMudmFsdWUuZXZhbCA/IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSA6IHRoaXMudmFsdWUsIHRoaXMuaXNWYXJpYWJsZSwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQodGhpcy5jb21iaW5hdG9yLCB0aGlzLnZhbHVlLCB0aGlzLmlzVmFyaWFibGUsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9DU1M6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RTZWxlY3RvciA9IGNvbnRleHQuZmlyc3RTZWxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUGFyZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGluIHBhcmVucyBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IG91dGVyIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAvLyBmbGFncyAoYnJlYWtzIG9ubHkgaW50ZXJwb2xhdGVkIHNlbGVjdG9ycyAtIHNlZSAjMTk3MylcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0NTUyA/IHZhbHVlLnRvQ1NTKGNvbnRleHQpIDogdmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IGZpcnN0U2VsZWN0b3I7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgJiYgdGhpcy5jb21iaW5hdG9yLnZhbHVlLmNoYXJBdCgwKSA9PT0gJyYnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5hdG9yLnRvQ1NTKGNvbnRleHQpICsgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBNYXRoJDEgPSB7XHJcbiAgICAgICAgQUxXQVlTOiAwLFxyXG4gICAgICAgIFBBUkVOU19ESVZJU0lPTjogMSxcclxuICAgICAgICBQQVJFTlM6IDJcclxuICAgICAgICAvLyByZW1vdmVkIC0gU1RSSUNUX0xFR0FDWTogM1xyXG4gICAgfTtcclxuICAgIHZhciBSZXdyaXRlVXJscyA9IHtcclxuICAgICAgICBPRkY6IDAsXHJcbiAgICAgICAgTE9DQUw6IDEsXHJcbiAgICAgICAgQUxMOiAyXHJcbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgdHlwZSBvZiB0aGUgZ2l2ZW4gcGF5bG9hZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0VHlwZShwYXlsb2FkKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXlsb2FkKS5zbGljZSg4LCAtMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IChleGNsdWRpbmcgc3BlY2lhbCBjbGFzc2VzIG9yIG9iamVjdHMgd2l0aCBvdGhlciBwcm90b3R5cGVzKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxyXG4gICAgICogQHJldHVybnMge3BheWxvYWQgaXMgUmVjb3JkPHN0cmluZywgYW55Pn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChwYXlsb2FkKSB7XHJcbiAgICAgICAgaWYgKGdldFR5cGUocGF5bG9hZCkgIT09ICdPYmplY3QnKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCkgPT09IE9iamVjdC5wcm90b3R5cGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YW55fSBwYXlsb2FkXHJcbiAgICAgKiBAcmV0dXJucyB7cGF5bG9hZCBpcyBhbnlbXX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNBcnJheShwYXlsb2FkKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFR5cGUocGF5bG9hZCkgPT09ICdBcnJheSc7XHJcbiAgICB9XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcbiAgICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzaWduUHJvcChjYXJyeSwga2V5LCBuZXdWYWwsIG9yaWdpbmFsT2JqZWN0LCBpbmNsdWRlTm9uZW51bWVyYWJsZSkge1xyXG4gICAgICAgIHZhciBwcm9wVHlwZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob3JpZ2luYWxPYmplY3QsIGtleSlcclxuICAgICAgICAgICAgPyAnZW51bWVyYWJsZSdcclxuICAgICAgICAgICAgOiAnbm9uZW51bWVyYWJsZSc7XHJcbiAgICAgICAgaWYgKHByb3BUeXBlID09PSAnZW51bWVyYWJsZScpXHJcbiAgICAgICAgICAgIGNhcnJ5W2tleV0gPSBuZXdWYWw7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVOb25lbnVtZXJhYmxlICYmIHByb3BUeXBlID09PSAnbm9uZW51bWVyYWJsZScpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhcnJ5LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWwsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvcHkgKGNsb25lKSBhbiBvYmplY3QgYW5kIGFsbCBpdHMgcHJvcHMgcmVjdXJzaXZlbHkgdG8gZ2V0IHJpZCBvZiBhbnkgcHJvcCByZWZlcmVuY2VkIG9mIHRoZSBvcmlnaW5hbCBvYmplY3QuIEFycmF5cyBhcmUgYWxzbyBjbG9uZWQsIGhvd2V2ZXIgb2JqZWN0cyBpbnNpZGUgYXJyYXlzIGFyZSBzdGlsbCBsaW5rZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV4cG9ydFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7VH0gdGFyZ2V0IFRhcmdldCBjYW4gYmUgYW55dGhpbmdcclxuICAgICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnM9e31dIE9wdGlvbnMgY2FuIGJlIGBwcm9wc2Agb3IgYG5vbmVudW1lcmFibGVgXHJcbiAgICAgKiBAcmV0dXJucyB7VH0gdGhlIHRhcmdldCB3aXRoIHJlcGxhY2VkIHZhbHVlc1xyXG4gICAgICogQGV4cG9ydFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3B5KHRhcmdldCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGNvcHkoaSwgb3B0aW9ucyk7IH0pO1xyXG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XHJcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKHByb3BzLCBzeW1ib2xzKS5yZWR1Y2UoZnVuY3Rpb24gKGNhcnJ5LCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkob3B0aW9ucy5wcm9wcykgJiYgIW9wdGlvbnMucHJvcHMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcnJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IGNvcHkodmFsLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgYXNzaWduUHJvcChjYXJyeSwga2V5LCBuZXdWYWwsIHRhcmdldCwgb3B0aW9ucy5ub25lbnVtZXJhYmxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcnJ5O1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cblxuICAgIC8qIGpzaGludCBwcm90bzogdHJ1ZSAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TG9jYXRpb24oaW5kZXgsIGlucHV0U3RyZWFtKSB7XHJcbiAgICAgICAgdmFyIG4gPSBpbmRleCArIDE7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBudWxsO1xyXG4gICAgICAgIHZhciBjb2x1bW4gPSAtMTtcclxuICAgICAgICB3aGlsZSAoLS1uID49IDAgJiYgaW5wdXRTdHJlYW0uY2hhckF0KG4pICE9PSAnXFxuJykge1xyXG4gICAgICAgICAgICBjb2x1bW4rKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgbGluZSA9IChpbnB1dFN0cmVhbS5zbGljZSgwLCBpbmRleCkubWF0Y2goL1xcbi9nKSB8fCAnJykubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxyXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29weVtpXSA9IGFycltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbG9uZShvYmopIHtcclxuICAgICAgICB2YXIgY2xvbmVkID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgY2xvbmVkW3Byb3BdID0gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhvYmoxLCBvYmoyKSB7XHJcbiAgICAgICAgdmFyIG5ld09iaiA9IG9iajIgfHwge307XHJcbiAgICAgICAgaWYgKCFvYmoyLl9kZWZhdWx0cykge1xyXG4gICAgICAgICAgICBuZXdPYmogPSB7fTtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRzXzEgPSBjb3B5KG9iajEpO1xyXG4gICAgICAgICAgICBuZXdPYmouX2RlZmF1bHRzID0gZGVmYXVsdHNfMTtcclxuICAgICAgICAgICAgdmFyIGNsb25lZCA9IG9iajIgPyBjb3B5KG9iajIpIDoge307XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3T2JqLCBkZWZhdWx0c18xLCBjbG9uZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29weU9wdGlvbnMob2JqMSwgb2JqMikge1xyXG4gICAgICAgIGlmIChvYmoyICYmIG9iajIuX2RlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0cyA9IGRlZmF1bHRzKG9iajEsIG9iajIpO1xyXG4gICAgICAgIGlmIChvcHRzLnN0cmljdE1hdGgpIHtcclxuICAgICAgICAgICAgb3B0cy5tYXRoID0gTWF0aCQxLlBBUkVOUztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQmFjayBjb21wYXQgd2l0aCBjaGFuZ2VkIHJlbGF0aXZlVXJscyBvcHRpb25cclxuICAgICAgICBpZiAob3B0cy5yZWxhdGl2ZVVybHMpIHtcclxuICAgICAgICAgICAgb3B0cy5yZXdyaXRlVXJscyA9IFJld3JpdGVVcmxzLkFMTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3B0cy5tYXRoLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5tYXRoID0gTWF0aCQxLkFMV0FZUztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmVucy1kaXZpc2lvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5tYXRoID0gTWF0aCQxLlBBUkVOU19ESVZJU0lPTjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmljdCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwYXJlbnMnOlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMubWF0aCA9IE1hdGgkMS5QQVJFTlM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMubWF0aCA9IE1hdGgkMS5QQVJFTlM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnJld3JpdGVVcmxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdHMucmV3cml0ZVVybHMudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnb2ZmJzpcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLnJld3JpdGVVcmxzID0gUmV3cml0ZVVybHMuT0ZGO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbG9jYWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMucmV3cml0ZVVybHMgPSBSZXdyaXRlVXJscy5MT0NBTDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2FsbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5yZXdyaXRlVXJscyA9IFJld3JpdGVVcmxzLkFMTDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKG9iajEsIG9iajIpIHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iajIpIHtcclxuICAgICAgICAgICAgaWYgKG9iajIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIG9iajFbcHJvcF0gPSBvYmoyW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmoxO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IFtdOyB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gYXJyLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyW2ldO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheSh2YWx1ZSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XG5cbiAgICB2YXIgdXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgZ2V0TG9jYXRpb246IGdldExvY2F0aW9uLFxuICAgICAgICBjb3B5QXJyYXk6IGNvcHlBcnJheSxcbiAgICAgICAgY2xvbmU6IGNsb25lLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgIGNvcHlPcHRpb25zOiBjb3B5T3B0aW9ucyxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICBmbGF0dGVuQXJyYXk6IGZsYXR0ZW5BcnJheVxuICAgIH0pO1xuXG4gICAgdmFyIGFub255bW91c0Z1bmMgPSAvKDxhbm9ueW1vdXM+fEZ1bmN0aW9uKTooXFxkKyk6KFxcZCspLztcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhIGNlbnRyYWxpemVkIGNsYXNzIG9mIGFueSBlcnJvciB0aGF0IGNvdWxkIGJlIHRocm93biBpbnRlcm5hbGx5IChtb3N0bHkgYnkgdGhlIHBhcnNlcikuXHJcbiAgICAgKiBCZXNpZGVzIHN0YW5kYXJkIC5tZXNzYWdlIGl0IGtlZXBzIHNvbWUgYWRkaXRpb25hbCBkYXRhIGxpa2UgYSBwYXRoIHRvIHRoZSBmaWxlIHdoZXJlIHRoZSBlcnJvclxyXG4gICAgICogb2NjdXJyZWQgYWxvbmcgd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqIEBleHRlbmRzIEVycm9yXHJcbiAgICAgKiBAdHlwZSB7bW9kdWxlLkxlc3NFcnJvcn1cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBmaWxlbmFtZVxyXG4gICAgICogQHByb3Age251bWJlcn0gaW5kZXhcclxuICAgICAqIEBwcm9wIHtudW1iZXJ9IGxpbmVcclxuICAgICAqIEBwcm9wIHtudW1iZXJ9IGNvbHVtblxyXG4gICAgICogQHByb3Age251bWJlcn0gY2FsbExpbmVcclxuICAgICAqIEBwcm9wIHtudW1iZXJ9IGNhbGxFeHRyYWN0XHJcbiAgICAgKiBAcHJvcCB7c3RyaW5nW119IGV4dHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAgICAgICAgICAgICAgLSBBbiBlcnJvciBvYmplY3QgdG8gd3JhcCBhcm91bmQgb3IganVzdCBhIGRlc2NyaXB0aXZlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVDb250ZW50TWFwIC0gQW4gb2JqZWN0IHdpdGggZmlsZSBjb250ZW50cyBpbiAnY29udGVudHMnIHByb3BlcnR5IChsaWtlIGltcG9ydE1hbmFnZXIpIEB0b2RvIC0gbW92ZSB0byBmaWxlTWFuYWdlcj9cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3VycmVudEZpbGVuYW1lXVxyXG4gICAgICovXHJcbiAgICB2YXIgTGVzc0Vycm9yID0gZnVuY3Rpb24gKGUsIGZpbGVDb250ZW50TWFwLCBjdXJyZW50RmlsZW5hbWUpIHtcclxuICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGUuZmlsZW5hbWUgfHwgY3VycmVudEZpbGVuYW1lO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcclxuICAgICAgICBpZiAoZmlsZUNvbnRlbnRNYXAgJiYgZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZUNvbnRlbnRNYXAuY29udGVudHNbZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgbG9jID0gZ2V0TG9jYXRpb24oZS5pbmRleCwgaW5wdXQpO1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxvYy5saW5lO1xyXG4gICAgICAgICAgICB2YXIgY29sID0gbG9jLmNvbHVtbjtcclxuICAgICAgICAgICAgdmFyIGNhbGxMaW5lID0gZS5jYWxsICYmIGdldExvY2F0aW9uKGUuY2FsbCwgaW5wdXQpLmxpbmU7XHJcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGlucHV0ID8gaW5wdXQuc3BsaXQoJ1xcbicpIDogJyc7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGUudHlwZSB8fCAnU3ludGF4JztcclxuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gZS5pbmRleDtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdHlwZW9mIGxpbmUgPT09ICdudW1iZXInID8gbGluZSArIDEgOiBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxpbmUgJiYgdGhpcy5zdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5zdGFjay5tYXRjaChhbm9ueW1vdXNGdW5jKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvdyB0aGlzIGVudmlyb25tZW50IHN0cmluZ2lmaWVzIGFub255bW91cyBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAqIHNvIHdlIGNhbiBjb3JyZWN0bHkgbWFwIHBsdWdpbiBlcnJvcnMuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSwgaW4gTm9kZSA4LCB0aGUgb3V0cHV0IG9mIGFub255bW91cyBmdW5jcyB2YXJpZWQgYmFzZWQgb24gcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICAgICAgICogYmVpbmcgcHJlc2VudCBvciBub3QsIHNvIHdlIGluamVjdCBkdW1teSBwYXJhbXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uKCdhJywgJ3Rocm93IG5ldyBFcnJvcigpJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZUFkanVzdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZS5zdGFjay5tYXRjaChhbm9ueW1vdXNGdW5jKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHBhcnNlSW50KG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lQWRqdXN0ID0gMSAtIGxpbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRbMl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lID0gcGFyc2VJbnQoZm91bmRbMl0pICsgbGluZUFkanVzdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kWzNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gcGFyc2VJbnQoZm91bmRbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhbGxMaW5lID0gY2FsbExpbmUgKyAxO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxFeHRyYWN0ID0gbGluZXNbY2FsbExpbmVdO1xyXG4gICAgICAgICAgICB0aGlzLmV4dHJhY3QgPSBbXHJcbiAgICAgICAgICAgICAgICBsaW5lc1t0aGlzLmxpbmUgLSAyXSxcclxuICAgICAgICAgICAgICAgIGxpbmVzW3RoaXMubGluZSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgbGluZXNbdGhpcy5saW5lXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgRi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XHJcbiAgICAgICAgTGVzc0Vycm9yLnByb3RvdHlwZSA9IG5ldyBGKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBMZXNzRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgfVxyXG4gICAgTGVzc0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlc3NFcnJvcjtcclxuICAgIC8qKlxyXG4gICAgICogQW4gb3ZlcnJpZGRlbiB2ZXJzaW9uIG9mIHRoZSBkZWZhdWx0IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcclxuICAgICAqIHdoaWNoIHVzZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBjcmVhdGUgYSBoZWxwZnVsIG1lc3NhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIExlc3NFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gJyc7XHJcbiAgICAgICAgdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3QgfHwgW107XHJcbiAgICAgICAgdmFyIGVycm9yID0gW107XHJcbiAgICAgICAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHI7IH07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGl6ZSkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvcHRpb25zLnN0eWxpemU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm9wdGlvbnMuc3R5bGl6ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiwgZ290IGEgXCIgKyB0eXBlICsgXCIhXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxpemUgPSBvcHRpb25zLnN0eWxpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxpbmUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYWN0WzBdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IucHVzaChzdHlsaXplKHRoaXMubGluZSAtIDEgKyBcIiBcIiArIGV4dHJhY3RbMF0sICdncmV5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmFjdFsxXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvclR4dCA9IHRoaXMubGluZSArIFwiIFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhY3RbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclR4dCArPSBleHRyYWN0WzFdLnNsaWNlKDAsIHRoaXMuY29sdW1uKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxpemUoc3R5bGl6ZShzdHlsaXplKGV4dHJhY3RbMV0uc3Vic3RyKHRoaXMuY29sdW1uLCAxKSwgJ2JvbGQnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0WzFdLnNsaWNlKHRoaXMuY29sdW1uICsgMSksICdyZWQnKSwgJ2ludmVyc2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVycm9yLnB1c2goZXJyb3JUeHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmFjdFsyXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yLnB1c2goc3R5bGl6ZSh0aGlzLmxpbmUgKyAxICsgXCIgXCIgKyBleHRyYWN0WzJdLCAnZ3JleScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcnJvciA9IGVycm9yLmpvaW4oJ1xcbicpICsgc3R5bGl6ZSgnJywgJ3Jlc2V0JykgKyBcIlxcblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXNzYWdlICs9IHN0eWxpemUodGhpcy50eXBlICsgXCJFcnJvcjogXCIgKyB0aGlzLm1lc3NhZ2UsICdyZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5maWxlbmFtZSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IHN0eWxpemUoJyBpbiAnLCAncmVkJykgKyB0aGlzLmZpbGVuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5saW5lKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gc3R5bGl6ZShcIiBvbiBsaW5lIFwiICsgdGhpcy5saW5lICsgXCIsIGNvbHVtbiBcIiArICh0aGlzLmNvbHVtbiArIDEpICsgXCI6XCIsICdncmV5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc3NhZ2UgKz0gXCJcXG5cIiArIGVycm9yO1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGxMaW5lKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gc3R5bGl6ZSgnZnJvbSAnLCAncmVkJykgKyAodGhpcy5maWxlbmFtZSB8fCAnJykgKyBcIi9uXCI7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gc3R5bGl6ZSh0aGlzLmNhbGxMaW5lLCAnZ3JleScpICsgXCIgXCIgKyB0aGlzLmNhbGxFeHRyYWN0ICsgXCIvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH07XG5cbiAgICB2YXIgU2VsZWN0b3IgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGV4dGVuZExpc3QsIGNvbmRpdGlvbiwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLmV4dGVuZExpc3QgPSBleHRlbmRMaXN0O1xyXG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMuZXZhbGRDb25kaXRpb24gPSAhY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHRoaXMuZ2V0RWxlbWVudHMoZWxlbWVudHMpO1xyXG4gICAgICAgIHRoaXMubWl4aW5FbGVtZW50c18gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuZWxlbWVudHMsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIFNlbGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdTZWxlY3RvcicsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbmRMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZExpc3QgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5leHRlbmRMaXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gdmlzaXRvci52aXNpdCh0aGlzLmNvbmRpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZURlcml2ZWQ6IGZ1bmN0aW9uIChlbGVtZW50cywgZXh0ZW5kTGlzdCwgZXZhbGRDb25kaXRpb24pIHtcclxuICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLmdldEVsZW1lbnRzKGVsZW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yID0gbmV3IFNlbGVjdG9yKGVsZW1lbnRzLCBleHRlbmRMaXN0IHx8IHRoaXMuZXh0ZW5kTGlzdCwgbnVsbCwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yLmV2YWxkQ29uZGl0aW9uID0gKGV2YWxkQ29uZGl0aW9uICE9IG51bGwpID8gZXZhbGRDb25kaXRpb24gOiB0aGlzLmV2YWxkQ29uZGl0aW9uO1xyXG4gICAgICAgICAgICBuZXdTZWxlY3Rvci5tZWRpYUVtcHR5ID0gdGhpcy5tZWRpYUVtcHR5O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2VsZWN0b3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRFbGVtZW50czogZnVuY3Rpb24gKGVscykge1xyXG4gICAgICAgICAgICBpZiAoIWVscykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgRWxlbWVudCgnJywgJyYnLCBmYWxzZSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbHMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnBhcnNlTm9kZShlbHMsIFsnc2VsZWN0b3InXSwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVyci5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMucGFyc2UuaW1wb3J0cywgdGhpcy5fZmlsZUluZm8uZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHMgPSByZXN1bHRbMF0uZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZWxzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlRW1wdHlTZWxlY3RvcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gbmV3IEVsZW1lbnQoJycsICcmJywgZmFsc2UsIHRoaXMuX2luZGV4LCB0aGlzLl9maWxlSW5mbyksIHNlbHMgPSBbbmV3IFNlbGVjdG9yKFtlbF0sIG51bGwsIG51bGwsIHRoaXMuX2luZGV4LCB0aGlzLl9maWxlSW5mbyldO1xyXG4gICAgICAgICAgICBzZWxzWzBdLm1lZGlhRW1wdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VscztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIG9sZW47XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBvdGhlciA9IG90aGVyLm1peGluRWxlbWVudHMoKTtcclxuICAgICAgICAgICAgb2xlbiA9IG90aGVyLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKG9sZW4gPT09IDAgfHwgbGVuIDwgb2xlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLnZhbHVlICE9PSBvdGhlcltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9sZW47IC8vIHJldHVybiBudW1iZXIgb2YgbWF0Y2hlZCBlbGVtZW50c1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWl4aW5FbGVtZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5taXhpbkVsZW1lbnRzXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWl4aW5FbGVtZW50c187XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2LmNvbWJpbmF0b3IudmFsdWUgKyAodi52YWx1ZS52YWx1ZSB8fCB2LnZhbHVlKTtcclxuICAgICAgICAgICAgfSkuam9pbignJykubWF0Y2goL1ssJiNcXCpcXC5cXHctXShbXFx3LV18KFxcXFwuKSkqL2cpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXSA9PT0gJyYnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1peGluRWxlbWVudHNfID0gZWxlbWVudHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNKdXN0UGFyZW50U2VsZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm1lZGlhRW1wdHkgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzBdLnZhbHVlID09PSAnJicgJiZcclxuICAgICAgICAgICAgICAgICh0aGlzLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcgJyB8fCB0aGlzLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBldmFsZENvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uICYmIHRoaXMuY29uZGl0aW9uLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRMaXN0ID0gdGhpcy5leHRlbmRMaXN0O1xyXG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzICYmIGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5ldmFsKGNvbnRleHQpOyB9KTtcclxuICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3QgJiYgZXh0ZW5kTGlzdC5tYXAoZnVuY3Rpb24gKGV4dGVuZCkgeyByZXR1cm4gZXh0ZW5kLmV2YWwoY29udGV4dCk7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXJpdmVkKGVsZW1lbnRzLCBleHRlbmRMaXN0LCBldmFsZENvbmRpdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIGksIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICgoIWNvbnRleHQgfHwgIWNvbnRleHQuZmlyc3RTZWxlY3RvcikgJiYgdGhpcy5lbGVtZW50c1swXS5jb21iaW5hdG9yLnZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcsIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5nZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRJc091dHB1dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsZENvbmRpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXF1aXJlcyBhbiBhcnJheSBhcmd1bWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbdmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWYWx1ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnVmFsdWUnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF0uZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUodGhpcy52YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgdGhpcy52YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKChjb250ZXh0ICYmIGNvbnRleHQuY29tcHJlc3MpID8gJywnIDogJywgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBLZXl3b3JkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIEtleXdvcmQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0tleXdvcmQnLFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJyUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdTeW50YXgnLCBtZXNzYWdlOiAnSW52YWxpZCAlIHdpdGhvdXQgbnVtYmVyJyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBLZXl3b3JkLlRydWUgPSBuZXcgS2V5d29yZCgndHJ1ZScpO1xyXG4gICAgS2V5d29yZC5GYWxzZSA9IG5ldyBLZXl3b3JkKCdmYWxzZScpO1xuXG4gICAgdmFyIEFub255bW91cyA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgbWFwTGluZXMsIHJ1bGVzZXRMaWtlLCB2aXNpYmlsaXR5SW5mbykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMubWFwTGluZXMgPSBtYXBMaW5lcztcclxuICAgICAgICB0aGlzLnJ1bGVzZXRMaWtlID0gKHR5cGVvZiBydWxlc2V0TGlrZSA9PT0gJ3VuZGVmaW5lZCcpID8gZmFsc2UgOiBydWxlc2V0TGlrZTtcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgfTtcclxuICAgIEFub255bW91cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQW5vbnltb3VzJyxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzKHRoaXMudmFsdWUsIHRoaXMuX2luZGV4LCB0aGlzLl9maWxlSW5mbywgdGhpcy5tYXBMaW5lcywgdGhpcy5ydWxlc2V0TGlrZSwgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIudG9DU1MgJiYgdGhpcy50b0NTUygpID09PSBvdGhlci50b0NTUygpID8gMCA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUnVsZXNldExpa2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVsZXNldExpa2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlVmlzaWJsZSA9IEJvb2xlYW4odGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUsIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLl9pbmRleCwgdGhpcy5tYXBMaW5lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBNQVRIID0gTWF0aCQxO1xyXG4gICAgZnVuY3Rpb24gZXZhbE5hbWUoY29udGV4dCwgbmFtZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBuID0gbmFtZS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHsgYWRkOiBmdW5jdGlvbiAocykgeyB2YWx1ZSArPSBzOyB9IH07XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBuYW1lW2ldLmV2YWwoY29udGV4dCkuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHZhciBEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgaW1wb3J0YW50LCBtZXJnZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgaW5saW5lLCB2YXJpYWJsZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpID8gdmFsdWUgOiBuZXcgVmFsdWUoW3ZhbHVlID8gbmV3IEFub255bW91cyh2YWx1ZSkgOiBudWxsXSk7XHJcbiAgICAgICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQgPyBcIiBcIiArIGltcG9ydGFudC50cmltKCkgOiAnJztcclxuICAgICAgICB0aGlzLm1lcmdlID0gbWVyZ2U7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmlubGluZSA9IGlubGluZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLnZhcmlhYmxlID0gKHZhcmlhYmxlICE9PSB1bmRlZmluZWQpID8gdmFyaWFibGVcclxuICAgICAgICAgICAgOiAobmFtZS5jaGFyQXQgJiYgKG5hbWUuY2hhckF0KDApID09PSAnQCcpKTtcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy52YWx1ZSwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRGVjbGFyYXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0RlY2xhcmF0aW9uJyxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLm5hbWUgKyAoY29udGV4dC5jb21wcmVzcyA/ICc6JyA6ICc6ICcpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLmluZGV4ID0gdGhpcy5faW5kZXg7XHJcbiAgICAgICAgICAgICAgICBlLmZpbGVuYW1lID0gdGhpcy5fZmlsZUluZm8uZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy5pbXBvcnRhbnQgKyAoKHRoaXMuaW5saW5lIHx8IChjb250ZXh0Lmxhc3RSdWxlICYmIGNvbnRleHQuY29tcHJlc3MpKSA/ICcnIDogJzsnKSwgdGhpcy5fZmlsZUluZm8sIHRoaXMuX2luZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRoQnlwYXNzID0gZmFsc2UsIHByZXZNYXRoLCBuYW1lID0gdGhpcy5uYW1lLCBldmFsZFZhbHVlLCB2YXJpYWJsZSA9IHRoaXMudmFyaWFibGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIC8vIGV4cGFuZCAncHJpbWl0aXZlJyBuYW1lIGRpcmVjdGx5IHRvIGdldFxyXG4gICAgICAgICAgICAgICAgLy8gdGhpbmdzIGZhc3RlciAofjEwJSBmb3IgYmVuY2htYXJrLmxlc3MpOlxyXG4gICAgICAgICAgICAgICAgbmFtZSA9IChuYW1lLmxlbmd0aCA9PT0gMSkgJiYgKG5hbWVbMF0gaW5zdGFuY2VvZiBLZXl3b3JkKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVswXS52YWx1ZSA6IGV2YWxOYW1lKGNvbnRleHQsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSBmYWxzZTsgLy8gbmV2ZXIgdHJlYXQgZXhwYW5kZWQgaW50ZXJwb2xhdGlvbiBhcyBuZXcgdmFyaWFibGUgbmFtZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEB0b2RvIHJlbW92ZSB3aGVuIHBhcmVucy1kaXZpc2lvbiBpcyBkZWZhdWx0XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnZm9udCcgJiYgY29udGV4dC5tYXRoID09PSBNQVRILkFMV0FZUykge1xyXG4gICAgICAgICAgICAgICAgbWF0aEJ5cGFzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcmV2TWF0aCA9IGNvbnRleHQubWF0aDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubWF0aCA9IE1BVEguUEFSRU5TX0RJVklTSU9OO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmltcG9ydGFudFNjb3BlLnB1c2goe30pO1xyXG4gICAgICAgICAgICAgICAgZXZhbGRWYWx1ZSA9IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy52YXJpYWJsZSAmJiBldmFsZFZhbHVlLnR5cGUgPT09ICdEZXRhY2hlZFJ1bGVzZXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnUnVsZXNldHMgY2Fubm90IGJlIGV2YWx1YXRlZCBvbiBhIHByb3BlcnR5LicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRhbnQgPSB0aGlzLmltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRhbnRSZXN1bHQgPSBjb250ZXh0LmltcG9ydGFudFNjb3BlLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRhbnQgJiYgaW1wb3J0YW50UmVzdWx0LmltcG9ydGFudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCA9IGltcG9ydGFudFJlc3VsdC5pbXBvcnRhbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKG5hbWUsIGV2YWxkVmFsdWUsIGltcG9ydGFudCwgdGhpcy5tZXJnZSwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuaW5saW5lLCB2YXJpYWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5pbmRleCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLmluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuZmlsZW5hbWUgPSB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGhCeXBhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1hdGggPSBwcmV2TWF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFrZUltcG9ydGFudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKHRoaXMubmFtZSwgdGhpcy52YWx1ZSwgJyFpbXBvcnRhbnQnLCB0aGlzLm1lcmdlLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5pbmxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIGRlYnVnSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBkZWJ1Z0luZm8oY29udGV4dCwgY3R4LCBsaW5lU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzICYmICFjb250ZXh0LmNvbXByZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudHMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWJ1Z0luZm8uYXNDb21tZW50KGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lZGlhcXVlcnknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWJ1Z0luZm8uYXNNZWRpYVF1ZXJ5KGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FsbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlYnVnSW5mby5hc0NvbW1lbnQoY3R4KSArIChsaW5lU2VwYXJhdG9yIHx8ICcnKSArIGRlYnVnSW5mby5hc01lZGlhUXVlcnkoY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWdJbmZvLmFzQ29tbWVudCA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiLyogbGluZSBcIiArIGN0eC5kZWJ1Z0luZm8ubGluZU51bWJlciArIFwiLCBcIiArIGN0eC5kZWJ1Z0luZm8uZmlsZU5hbWUgKyBcIiAqL1xcblwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVidWdJbmZvLmFzTWVkaWFRdWVyeSA9IGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgdmFyIGZpbGVuYW1lV2l0aFByb3RvY29sID0gY3R4LmRlYnVnSW5mby5maWxlTmFtZTtcclxuICAgICAgICAgICAgaWYgKCEvXlthLXpdKzpcXC9cXC8vaS50ZXN0KGZpbGVuYW1lV2l0aFByb3RvY29sKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWVXaXRoUHJvdG9jb2wgPSBcImZpbGU6Ly9cIiArIGZpbGVuYW1lV2l0aFByb3RvY29sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSAtc2Fzcy1kZWJ1Zy1pbmZve2ZpbGVuYW1le2ZvbnQtZmFtaWx5OlwiICsgZmlsZW5hbWVXaXRoUHJvdG9jb2wucmVwbGFjZSgvKFsuOlxcL1xcXFxdKS9nLCBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9ICdcXC8nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgYTtcclxuICAgICAgICAgICAgfSkgKyBcIn1saW5le2ZvbnQtZmFtaWx5OlxcXFwwMDAwM1wiICsgY3R4LmRlYnVnSW5mby5saW5lTnVtYmVyICsgXCJ9fVxcblwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGRlYnVnSW5mbztcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgQ29tbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNMaW5lQ29tbWVudCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmlzTGluZUNvbW1lbnQgPSBpc0xpbmVDb21tZW50O1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIENvbW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0NvbW1lbnQnLFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z0luZm8pIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoZGVidWdJbmZvKGNvbnRleHQsIHRoaXMpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzU2lsZW50OiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgaXNDb21wcmVzc2VkID0gY29udGV4dC5jb21wcmVzcyAmJiB0aGlzLnZhbHVlWzJdICE9PSAnISc7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzTGluZUNvbW1lbnQgfHwgaXNDb21wcmVzc2VkO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIGNvbnRleHRzID0ge307XHJcbiAgICB2YXIgY29weUZyb21PcmlnaW5hbCA9IGZ1bmN0aW9uIGNvcHlGcm9tT3JpZ2luYWwob3JpZ2luYWwsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzVG9Db3B5KSB7XHJcbiAgICAgICAgaWYgKCFvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllc1RvQ29weS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWwuaGFzT3duUHJvcGVydHkocHJvcGVydGllc1RvQ29weVtpXSkpIHtcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNUb0NvcHlbaV1dID0gb3JpZ2luYWxbcHJvcGVydGllc1RvQ29weVtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICBwYXJzZSBpcyB1c2VkIHdoaWxzdCBwYXJzaW5nXHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJzZUNvcHlQcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgIC8vIG9wdGlvbnNcclxuICAgICAgICAncGF0aHMnLFxyXG4gICAgICAgICdyZXdyaXRlVXJscycsXHJcbiAgICAgICAgJ3Jvb3RwYXRoJyxcclxuICAgICAgICAnc3RyaWN0SW1wb3J0cycsXHJcbiAgICAgICAgJ2luc2VjdXJlJyxcclxuICAgICAgICAnZHVtcExpbmVOdW1iZXJzJyxcclxuICAgICAgICAnY29tcHJlc3MnLFxyXG4gICAgICAgICdzeW5jSW1wb3J0JyxcclxuICAgICAgICAnY2h1bmtJbnB1dCcsXHJcbiAgICAgICAgJ21pbWUnLFxyXG4gICAgICAgICd1c2VGaWxlQ2FjaGUnLFxyXG4gICAgICAgIC8vIGNvbnRleHRcclxuICAgICAgICAncHJvY2Vzc0ltcG9ydHMnLFxyXG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGltcG9ydCBtYW5hZ2VyIHRvIHN0b3AgbXVsdGlwbGUgaW1wb3J0IHZpc2l0b3JzIGJlaW5nIGNyZWF0ZWQuXHJcbiAgICAgICAgJ3BsdWdpbk1hbmFnZXInIC8vIFVzZWQgYXMgdGhlIHBsdWdpbiBtYW5hZ2VyIGZvciB0aGUgc2Vzc2lvblxyXG4gICAgXTtcclxuICAgIGNvbnRleHRzLlBhcnNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBjb3B5RnJvbU9yaWdpbmFsKG9wdGlvbnMsIHRoaXMsIHBhcnNlQ29weVByb3BlcnRpZXMpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXRocyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXRocyA9IFt0aGlzLnBhdGhzXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGV2YWxDb3B5UHJvcGVydGllcyA9IFtcclxuICAgICAgICAncGF0aHMnLFxyXG4gICAgICAgICdjb21wcmVzcycsXHJcbiAgICAgICAgJ21hdGgnLFxyXG4gICAgICAgICdzdHJpY3RVbml0cycsXHJcbiAgICAgICAgJ3NvdXJjZU1hcCcsXHJcbiAgICAgICAgJ2ltcG9ydE11bHRpcGxlJyxcclxuICAgICAgICAndXJsQXJncycsXHJcbiAgICAgICAgJ2phdmFzY3JpcHRFbmFibGVkJyxcclxuICAgICAgICAncGx1Z2luTWFuYWdlcicsXHJcbiAgICAgICAgJ2ltcG9ydGFudFNjb3BlJyxcclxuICAgICAgICAncmV3cml0ZVVybHMnIC8vIG9wdGlvbiAtIHdoZXRoZXIgdG8gYWRqdXN0IFVSTCdzIHRvIGJlIHJlbGF0aXZlXHJcbiAgICBdO1xyXG4gICAgY29udGV4dHMuRXZhbCA9IGZ1bmN0aW9uIChvcHRpb25zLCBmcmFtZXMpIHtcclxuICAgICAgICBjb3B5RnJvbU9yaWdpbmFsKG9wdGlvbnMsIHRoaXMsIGV2YWxDb3B5UHJvcGVydGllcyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhdGhzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhzID0gW3RoaXMucGF0aHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcyB8fCBbXTtcclxuICAgICAgICB0aGlzLmltcG9ydGFudFNjb3BlID0gdGhpcy5pbXBvcnRhbnRTY29wZSB8fCBbXTtcclxuICAgIH07XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5lbnRlckNhbGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbGNTdGFjaykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGNTdGFjayA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGNTdGFjay5wdXNoKHRydWUpO1xyXG4gICAgICAgIHRoaXMuaW5DYWxjID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5leGl0Q2FsYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGNTdGFjay5wb3AoKTtcclxuICAgICAgICBpZiAoIXRoaXMuY2FsY1N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmluQ2FsYyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5pblBhcmVudGhlc2lzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnNTdGFjaykge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVuc1N0YWNrID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFyZW5zU3RhY2sucHVzaCh0cnVlKTtcclxuICAgIH07XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5vdXRPZlBhcmVudGhlc2lzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyZW5zU3RhY2sucG9wKCk7XHJcbiAgICB9O1xyXG4gICAgY29udGV4dHMuRXZhbC5wcm90b3R5cGUuaW5DYWxjID0gZmFsc2U7XHJcbiAgICBjb250ZXh0cy5FdmFsLnByb3RvdHlwZS5tYXRoT24gPSB0cnVlO1xyXG4gICAgY29udGV4dHMuRXZhbC5wcm90b3R5cGUuaXNNYXRoT24gPSBmdW5jdGlvbiAob3ApIHtcclxuICAgICAgICBpZiAoIXRoaXMubWF0aE9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wID09PSAnLycgJiYgdGhpcy5tYXRoICE9PSBNYXRoJDEuQUxXQVlTICYmICghdGhpcy5wYXJlbnNTdGFjayB8fCAhdGhpcy5wYXJlbnNTdGFjay5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF0aCA+IE1hdGgkMS5QQVJFTlNfRElWSVNJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW5zU3RhY2sgJiYgdGhpcy5wYXJlbnNTdGFjay5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLnBhdGhSZXF1aXJlc1Jld3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIHZhciBpc1JlbGF0aXZlID0gdGhpcy5yZXdyaXRlVXJscyA9PT0gUmV3cml0ZVVybHMuTE9DQUwgPyBpc1BhdGhMb2NhbFJlbGF0aXZlIDogaXNQYXRoUmVsYXRpdmU7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVsYXRpdmUocGF0aCk7XHJcbiAgICB9O1xyXG4gICAgY29udGV4dHMuRXZhbC5wcm90b3R5cGUucmV3cml0ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcm9vdHBhdGgpIHtcclxuICAgICAgICB2YXIgbmV3UGF0aDtcclxuICAgICAgICByb290cGF0aCA9IHJvb3RwYXRoIHx8ICcnO1xyXG4gICAgICAgIG5ld1BhdGggPSB0aGlzLm5vcm1hbGl6ZVBhdGgocm9vdHBhdGggKyBwYXRoKTtcclxuICAgICAgICAvLyBJZiBhIHBhdGggd2FzIGV4cGxpY2l0IHJlbGF0aXZlIGFuZCB0aGUgcm9vdHBhdGggd2FzIG5vdCBhbiBhYnNvbHV0ZSBwYXRoXHJcbiAgICAgICAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgbmV3IHBhdGggaXMgYWxzbyBleHBsaWNpdCByZWxhdGl2ZS5cclxuICAgICAgICBpZiAoaXNQYXRoTG9jYWxSZWxhdGl2ZShwYXRoKSAmJlxyXG4gICAgICAgICAgICBpc1BhdGhSZWxhdGl2ZShyb290cGF0aCkgJiZcclxuICAgICAgICAgICAgaXNQYXRoTG9jYWxSZWxhdGl2ZShuZXdQYXRoKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgbmV3UGF0aCA9IFwiLi9cIiArIG5ld1BhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQYXRoO1xyXG4gICAgfTtcclxuICAgIGNvbnRleHRzLkV2YWwucHJvdG90eXBlLm5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgdmFyIHNlZ21lbnQ7XHJcbiAgICAgICAgcGF0aCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChzZWdtZW50cy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnLi4nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocGF0aC5sZW5ndGggPT09IDApIHx8IChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcuLicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChzZWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbignLycpO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGlzUGF0aFJlbGF0aXZlKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gIS9eKD86W2Etei1dKzp8XFwvfCMpL2kudGVzdChwYXRoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzUGF0aExvY2FsUmVsYXRpdmUocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy4nO1xyXG4gICAgfVxyXG4gICAgLy8gdG9kbyAtIGRvIHRoZSBzYW1lIGZvciB0aGUgdG9DU1MgP1xuXG4gICAgZnVuY3Rpb24gbWFrZVJlZ2lzdHJ5KGJhc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBfZGF0YToge30sXHJcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZWNhdXRpb25hcnkgY2FzZSBjb252ZXJzaW9uLCBhcyBsYXRlciBxdWVyeWluZyBvZlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZ2lzdHJ5IGJ5IGZ1bmN0aW9uLWNhbGxlciB1c2VzIGxvd2VyIGNhc2UgYXMgd2VsbC5cclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YVtuYW1lXSA9IGZ1bmM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFkZE11bHRpcGxlOiBmdW5jdGlvbiAoZnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkKG5hbWUsIGZ1bmN0aW9uc1tuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV0gfHwgKGJhc2UgJiYgYmFzZS5nZXQobmFtZSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRMb2NhbEZ1bmN0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUmVnaXN0cnkodGhpcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGJhc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUmVnaXN0cnkoYmFzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGZ1bmN0aW9uUmVnaXN0cnkgPSBtYWtlUmVnaXN0cnkobnVsbCk7XG5cbiAgICB2YXIgZGVmYXVsdEZ1bmMgPSB7XHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWVfO1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXJyb3JfO1xyXG4gICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdiA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlXyA9IHY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcl8gPSBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLmVycm9yXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcblxuICAgIHZhciBSdWxlc2V0ID0gZnVuY3Rpb24gKHNlbGVjdG9ycywgcnVsZXMsIHN0cmljdEltcG9ydHMsIHZpc2liaWxpdHlJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XHJcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG4gICAgICAgIHRoaXMuX2xvb2t1cHMgPSB7fTtcclxuICAgICAgICB0aGlzLl92YXJpYWJsZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RyaWN0SW1wb3J0cyA9IHN0cmljdEltcG9ydHM7XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLnNlbGVjdG9ycywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5ydWxlcywgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgUnVsZXNldC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnUnVsZXNldCcsXHJcbiAgICAgICAgaXNSdWxlc2V0OiB0cnVlLFxyXG4gICAgICAgIGlzUnVsZXNldExpa2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRocykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRocyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLnBhdGhzLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5zZWxlY3RvcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzICYmIHRoaXMucnVsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzID0gdmlzaXRvci52aXNpdEFycmF5KHRoaXMucnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzO1xyXG4gICAgICAgICAgICB2YXIgc2VsQ250O1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgaGFzVmFyaWFibGU7XHJcbiAgICAgICAgICAgIHZhciBoYXNPbmVQYXNzaW5nU2VsZWN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JzICYmIChzZWxDbnQgPSB0aGlzLnNlbGVjdG9ycy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBuZXcgQXJyYXkoc2VsQ250KTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRGdW5jLmVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU3ludGF4JyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaXQgaXMgY3VycmVudGx5IG9ubHkgYWxsb3dlZCBpbiBwYXJhbWV0cmljIG1peGluIGd1YXJkcywnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcnNbaV0uZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5lbGVtZW50c1tqXS5pc1ZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNWYXJpYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNbaV0gPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuZXZhbGRDb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT25lUGFzc2luZ1NlbGVjdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9QYXJzZVNlbGVjdG9ycyA9IG5ldyBBcnJheShzZWxDbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9QYXJzZVNlbGVjdG9yc1tpXSA9IHNlbGVjdG9yLnRvQ1NTKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnBhcnNlTm9kZSh0b1BhcnNlU2VsZWN0b3JzLmpvaW4oJywnKSwgW1wic2VsZWN0b3JzXCJdLCBzZWxlY3RvcnNbMF0uZ2V0SW5kZXgoKSwgc2VsZWN0b3JzWzBdLmZpbGVJbmZvKCksIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBmbGF0dGVuQXJyYXkocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdEZ1bmMucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc09uZVBhc3NpbmdTZWxlY3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcyA/IGNvcHlBcnJheSh0aGlzLnJ1bGVzKSA6IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBydWxlc2V0ID0gbmV3IFJ1bGVzZXQoc2VsZWN0b3JzLCBydWxlcywgdGhpcy5zdHJpY3RJbXBvcnRzLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgICAgICB2YXIgcnVsZTtcclxuICAgICAgICAgICAgdmFyIHN1YlJ1bGU7XHJcbiAgICAgICAgICAgIHJ1bGVzZXQub3JpZ2luYWxSdWxlc2V0ID0gdGhpcztcclxuICAgICAgICAgICAgcnVsZXNldC5yb290ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICBydWxlc2V0LmZpcnN0Um9vdCA9IHRoaXMuZmlyc3RSb290O1xyXG4gICAgICAgICAgICBydWxlc2V0LmFsbG93SW1wb3J0cyA9IHRoaXMuYWxsb3dJbXBvcnRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z0luZm8pIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXQuZGVidWdJbmZvID0gdGhpcy5kZWJ1Z0luZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFoYXNPbmVQYXNzaW5nU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW5oZXJpdCBhIGZ1bmN0aW9uIHJlZ2lzdHJ5IGZyb20gdGhlIGZyYW1lcyBzdGFjayB3aGVuIHBvc3NpYmxlO1xyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZnJvbSB0aGUgZ2xvYmFsIHJlZ2lzdHJ5XHJcbiAgICAgICAgICAgIHJ1bGVzZXQuZnVuY3Rpb25SZWdpc3RyeSA9IChmdW5jdGlvbiAoZnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSAhPT0gbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmcmFtZXNbaV0uZnVuY3Rpb25SZWdpc3RyeTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvblJlZ2lzdHJ5O1xyXG4gICAgICAgICAgICB9KGNvbnRleHQuZnJhbWVzKSkuaW5oZXJpdCgpO1xyXG4gICAgICAgICAgICAvLyBwdXNoIHRoZSBjdXJyZW50IHJ1bGVzZXQgdG8gdGhlIGZyYW1lcyBzdGFja1xyXG4gICAgICAgICAgICB2YXIgY3R4RnJhbWVzID0gY29udGV4dC5mcmFtZXM7XHJcbiAgICAgICAgICAgIGN0eEZyYW1lcy51bnNoaWZ0KHJ1bGVzZXQpO1xyXG4gICAgICAgICAgICAvLyBjdXJycmVudCBzZWxlY3RvcnNcclxuICAgICAgICAgICAgdmFyIGN0eFNlbGVjdG9ycyA9IGNvbnRleHQuc2VsZWN0b3JzO1xyXG4gICAgICAgICAgICBpZiAoIWN0eFNlbGVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zZWxlY3RvcnMgPSBjdHhTZWxlY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHhTZWxlY3RvcnMudW5zaGlmdCh0aGlzLnNlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIGltcG9ydHNcclxuICAgICAgICAgICAgaWYgKHJ1bGVzZXQucm9vdCB8fCBydWxlc2V0LmFsbG93SW1wb3J0cyB8fCAhcnVsZXNldC5zdHJpY3RJbXBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBydWxlc2V0LmV2YWxJbXBvcnRzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBmcmFtZXMgYXJvdW5kIG1peGluIGRlZmluaXRpb25zLFxyXG4gICAgICAgICAgICAvLyBzbyB0aGV5IGNhbiBiZSBldmFsdWF0ZWQgbGlrZSBjbG9zdXJlcyB3aGVuIHRoZSB0aW1lIGNvbWVzLlxyXG4gICAgICAgICAgICB2YXIgcnNSdWxlcyA9IHJ1bGVzZXQucnVsZXM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChydWxlID0gcnNSdWxlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZXZhbEZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnNSdWxlc1tpXSA9IHJ1bGUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWVkaWFCbG9ja0NvdW50ID0gKGNvbnRleHQubWVkaWFCbG9ja3MgJiYgY29udGV4dC5tZWRpYUJsb2Nrcy5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIG1peGluIGNhbGxzLlxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHJzUnVsZXNbaV0pOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlLnR5cGUgPT09ICdNaXhpbkNhbGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGUuZXZhbChjb250ZXh0KS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pICYmIHIudmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwb2xsdXRlIHRoZSBzY29wZSBpZiB0aGUgdmFyaWFibGUgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgdGhlcmUuIGNvbnNpZGVyIHJldHVybmluZyBmYWxzZSBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgbmVlZCBhIHdheSB0byBcInJldHVyblwiIHZhcmlhYmxlIGZyb20gbWl4aW5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShydWxlc2V0LnZhcmlhYmxlKHIubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzUnVsZXMuc3BsaWNlLmFwcGx5KHJzUnVsZXMsIFtpLCAxXS5jb25jYXQocnVsZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpICs9IHJ1bGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldC5yZXNldENhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnR5cGUgPT09ICdWYXJpYWJsZUNhbGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGUuZXZhbChjb250ZXh0KS5ydWxlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pICYmIHIudmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwb2xsdXRlIHRoZSBzY29wZSBhdCBhbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByc1J1bGVzLnNwbGljZS5hcHBseShyc1J1bGVzLCBbaSwgMV0uY29uY2F0KHJ1bGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSBydWxlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzZXQucmVzZXRDYWNoZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIGV2ZXJ5dGhpbmcgZWxzZVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHJzUnVsZXNbaV0pOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghcnVsZS5ldmFsRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByc1J1bGVzW2ldID0gcnVsZSA9IHJ1bGUuZXZhbCA/IHJ1bGUuZXZhbChjb250ZXh0KSA6IHJ1bGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChydWxlID0gcnNSdWxlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHJ1bGVzZXRzLCBjaGVjayBpZiBpdCBpcyBhIGNzcyBndWFyZCBhbmQgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgUnVsZXNldCAmJiBydWxlLnNlbGVjdG9ycyAmJiBydWxlLnNlbGVjdG9ycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCBjYW4gYmUgZm9sZGVkIGluIChlLmcuICYgd2hlcmUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JzWzBdICYmIHJ1bGUuc2VsZWN0b3JzWzBdLmlzSnVzdFBhcmVudFNlbGVjdG9yKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnNSdWxlcy5zcGxpY2UoaS0tLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChzdWJSdWxlID0gcnVsZS5ydWxlc1tqXSk7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlJ1bGUgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUnVsZS5jb3B5VmlzaWJpbGl0eUluZm8ocnVsZS52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJSdWxlIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pIHx8ICFzdWJSdWxlLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzUnVsZXMuc3BsaWNlKCsraSwgMCwgc3ViUnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBvcCB0aGUgc3RhY2tcclxuICAgICAgICAgICAgY3R4RnJhbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGN0eFNlbGVjdG9ycy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZWRpYUJsb2Nrcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbWVkaWFCbG9ja0NvdW50OyBpIDwgY29udGV4dC5tZWRpYUJsb2Nrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3NbaV0uYnViYmxlU2VsZWN0b3JzKHNlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsSW1wb3J0czogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcztcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBpbXBvcnRSdWxlcztcclxuICAgICAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzW2ldLnR5cGUgPT09ICdJbXBvcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0UnVsZXMgPSBydWxlc1tpXS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRSdWxlcyAmJiAoaW1wb3J0UnVsZXMubGVuZ3RoIHx8IGltcG9ydFJ1bGVzLmxlbmd0aCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlLmFwcGx5KHJ1bGVzLCBbaSwgMV0uY29uY2F0KGltcG9ydFJ1bGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gaW1wb3J0UnVsZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShpLCAxLCBpbXBvcnRSdWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYWtlSW1wb3J0YW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUnVsZXNldCh0aGlzLnNlbGVjdG9ycywgdGhpcy5ydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyLm1ha2VJbXBvcnRhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gci5tYWtlSW1wb3J0YW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksIHRoaXMuc3RyaWN0SW1wb3J0cywgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hdGNoQXJnczogZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gbGV0cyB5b3UgY2FsbCBhIGNzcyBzZWxlY3RvciB3aXRoIGEgZ3VhcmRcclxuICAgICAgICBtYXRjaENvbmRpdGlvbjogZnVuY3Rpb24gKGFyZ3MsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RTZWxlY3RvciA9IHRoaXMuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAoIWxhc3RTZWxlY3Rvci5ldmFsZENvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VsZWN0b3IuY29uZGl0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAhbGFzdFNlbGVjdG9yLmNvbmRpdGlvbi5ldmFsKG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIGNvbnRleHQuZnJhbWVzKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0Q2FjaGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcnVsZXNldHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fbG9va3VwcyA9IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFyaWFibGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YXJpYWJsZXMgPSAhdGhpcy5ydWxlcyA/IHt9IDogdGhpcy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2gsIHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIERlY2xhcmF0aW9uICYmIHIudmFyaWFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFtyLm5hbWVdID0gcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBldmFsdWF0aW5nIHZhcmlhYmxlcyBpbiBhbiBpbXBvcnQgc3RhdGVtZW50LCBpbXBvcnRzIGhhdmUgbm90IGJlZW4gZXZhbCdkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnbyBpbnNpZGUgaW1wb3J0IHN0YXRlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCByb290IGJlaW5nIGEgc3RyaW5nIChpbiB0aGUgY2FzZSBvZiBpbmxpbmVkIGxlc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIudHlwZSA9PT0gJ0ltcG9ydCcgJiYgci5yb290ICYmIHIucm9vdC52YXJpYWJsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMgPSByLnJvb3QudmFyaWFibGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFycy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFtuYW1lXzFdID0gci5yb290LnZhcmlhYmxlKG5hbWVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BlcnRpZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gIXRoaXMucnVsZXMgPyB7fSA6IHRoaXMucnVsZXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoLCByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBEZWNsYXJhdGlvbiAmJiByLnZhcmlhYmxlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSAoci5uYW1lLmxlbmd0aCA9PT0gMSkgJiYgKHIubmFtZVswXSBpbnN0YW5jZW9mIEtleXdvcmQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubmFtZVswXS52YWx1ZSA6IHIubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBkb24ndCBvdmVyd3JpdGUgYXMgdGhleSBjYW4gbWVyZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNoW1wiJFwiICsgbmFtZV8yXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFtcIiRcIiArIG5hbWVfMl0gPSBbcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoW1wiJFwiICsgbmFtZV8yXS5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFyaWFibGU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNsID0gdGhpcy52YXJpYWJsZXMoKVtuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGRlY2wpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWUoZGVjbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgZGVjbCA9IHRoaXMucHJvcGVydGllcygpW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZGVjbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZShkZWNsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnJ1bGVzLmxlbmd0aDsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY2wgPSB0aGlzLnJ1bGVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWNsIGluc3RhbmNlb2YgRGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlKGRlY2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiAodG9QYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybURlY2xhcmF0aW9uKGRlY2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWNsLnZhbHVlIGluc3RhbmNlb2YgQW5vbnltb3VzICYmICFkZWNsLnBhcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVjbC52YWx1ZS52YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5wYXJzZU5vZGUoZGVjbC52YWx1ZS52YWx1ZSwgWyd2YWx1ZScsICdpbXBvcnRhbnQnXSwgZGVjbC52YWx1ZS5nZXRJbmRleCgpLCBkZWNsLmZpbGVJbmZvKCksIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wucGFyc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsLnZhbHVlID0gcmVzdWx0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wuaW1wb3J0YW50ID0gcmVzdWx0WzFdIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2wucGFyc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsLnBhcnNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRvUGFyc2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtRGVjbGFyYXRpb24uY2FsbChzZWxmLCB0b1BhcnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2Rlc18xID0gW107XHJcbiAgICAgICAgICAgICAgICB0b1BhcnNlLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBub2Rlc18xLnB1c2godHJhbnNmb3JtRGVjbGFyYXRpb24uY2FsbChzZWxmLCBuKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2Rlc18xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBydWxlc2V0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmlsdFJ1bGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXM7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgcnVsZTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgKHJ1bGUgPSBydWxlc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaXNSdWxlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdFJ1bGVzLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRSdWxlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZXBlbmRSdWxlOiBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzO1xyXG4gICAgICAgICAgICBpZiAocnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzLnVuc2hpZnQocnVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzID0gW3J1bGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KHJ1bGUsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yLCBzZWxmLCBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgc2VsZiA9IHNlbGYgfHwgdGhpcztcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgdmFyIGZvdW5kTWl4aW5zO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gc2VsZWN0b3IudG9DU1MoKTtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9sb29rdXBzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9va3Vwc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucnVsZXNldHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZSAhPT0gc2VsZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcnVsZS5zZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChydWxlLnNlbGVjdG9yc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmVsZW1lbnRzLmxlbmd0aCA+IG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWl4aW5zID0gcnVsZS5maW5kKG5ldyBTZWxlY3RvcihzZWxlY3Rvci5lbGVtZW50cy5zbGljZShtYXRjaCkpLCBzZWxmLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvdW5kTWl4aW5zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1peGluc1tpXS5wYXRoLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocnVsZXMsIGZvdW5kTWl4aW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHsgcnVsZTogcnVsZSwgcGF0aDogW10gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvb2t1cHNba2V5XSA9IHJ1bGVzO1xyXG4gICAgICAgICAgICByZXR1cm4gcnVsZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICB2YXIgY2hhcnNldFJ1bGVOb2RlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcnVsZU5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciAvLyBMaW5lIG51bWJlciBkZWJ1Z2dpbmdcclxuICAgICAgICAgICAgZGVidWdJbmZvJDE7XHJcbiAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICB2YXIgcGF0aDtcclxuICAgICAgICAgICAgY29udGV4dC50YWJMZXZlbCA9IChjb250ZXh0LnRhYkxldmVsIHx8IDApO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC50YWJMZXZlbCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0YWJSdWxlU3RyID0gY29udGV4dC5jb21wcmVzcyA/ICcnIDogQXJyYXkoY29udGV4dC50YWJMZXZlbCArIDEpLmpvaW4oJyAgJyk7XHJcbiAgICAgICAgICAgIHZhciB0YWJTZXRTdHIgPSBjb250ZXh0LmNvbXByZXNzID8gJycgOiBBcnJheShjb250ZXh0LnRhYkxldmVsKS5qb2luKCcgICcpO1xyXG4gICAgICAgICAgICB2YXIgc2VwO1xyXG4gICAgICAgICAgICB2YXIgY2hhcnNldE5vZGVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBpbXBvcnROb2RlSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyAocnVsZSA9IHRoaXMucnVsZXNbaV0pOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnROb2RlSW5kZXggPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOb2Rlcy5wdXNoKHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5pc0NoYXJzZXQgJiYgcnVsZS5pc0NoYXJzZXQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOb2Rlcy5zcGxpY2UoY2hhcnNldE5vZGVJbmRleCwgMCwgcnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldE5vZGVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydE5vZGVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZS50eXBlID09PSAnSW1wb3J0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOb2Rlcy5zcGxpY2UoaW1wb3J0Tm9kZUluZGV4LCAwLCBydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOb2Rlcy5wdXNoKHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJ1bGVOb2RlcyA9IGNoYXJzZXRSdWxlTm9kZXMuY29uY2F0KHJ1bGVOb2Rlcyk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIHJvb3Qgbm9kZSwgd2UgZG9uJ3QgcmVuZGVyXHJcbiAgICAgICAgICAgIC8vIGEgc2VsZWN0b3IsIG9yIHt9LlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvJDEgPSBkZWJ1Z0luZm8oY29udGV4dCwgdGhpcywgdGFiU2V0U3RyKTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Z0luZm8kMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoZGVidWdJbmZvJDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGFiU2V0U3RyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwYXRocyA9IHRoaXMucGF0aHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aENudCA9IHBhdGhzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoU3ViQ250ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgc2VwID0gY29udGV4dC5jb21wcmVzcyA/ICcsJyA6IChcIixcXG5cIiArIHRhYlNldFN0cik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdGhTdWJDbnQgPSBwYXRoLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHNlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyc3RTZWxlY3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aFswXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcnN0U2VsZWN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgcGF0aFN1YkNudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbal0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgoY29udGV4dC5jb21wcmVzcyA/ICd7JyA6ICcge1xcbicpICsgdGFiUnVsZVN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29tcGlsZSBydWxlcyBhbmQgcnVsZXNldHNcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgKHJ1bGUgPSBydWxlTm9kZXNbaV0pOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gcnVsZU5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGFzdFJ1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMYXN0UnVsZSA9IGNvbnRleHQubGFzdFJ1bGU7XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pc1J1bGVzZXRMaWtlKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZ2VuQ1NTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHJ1bGUudmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmxhc3RSdWxlID0gY3VycmVudExhc3RSdWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0Lmxhc3RSdWxlICYmIHJ1bGUuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKGNvbnRleHQuY29tcHJlc3MgPyAnJyA6IChcIlxcblwiICsgdGFiUnVsZVN0cikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sYXN0UnVsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKChjb250ZXh0LmNvbXByZXNzID8gJ30nIDogXCJcXG5cIiArIHRhYlNldFN0ciArIFwifVwiKSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRhYkxldmVsLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvdXRwdXQuaXNFbXB0eSgpICYmICFjb250ZXh0LmNvbXByZXNzICYmIHRoaXMuZmlyc3RSb290KSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCdcXG4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgam9pblNlbGVjdG9yczogZnVuY3Rpb24gKHBhdGhzLCBjb250ZXh0LCBzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWxlY3RvcnMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuam9pblNlbGVjdG9yKHBhdGhzLCBjb250ZXh0LCBzZWxlY3RvcnNbc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBqb2luU2VsZWN0b3I6IGZ1bmN0aW9uIChwYXRocywgY29udGV4dCwgc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUGFyZW50aGVzaXMoZWxlbWVudHNUb1Bhaywgb3JpZ2luYWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRQYXJlbiwgajtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1RvUGFrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50UGFyZW4gPSBuZXcgUGFyZW4oZWxlbWVudHNUb1Bha1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zaWRlUGFyZW50ID0gbmV3IEFycmF5KGVsZW1lbnRzVG9QYWsubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZWxlbWVudHNUb1Bhay5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVQYXJlbnRbal0gPSBuZXcgRWxlbWVudChudWxsLCBlbGVtZW50c1RvUGFrW2pdLCBvcmlnaW5hbEVsZW1lbnQuaXNWYXJpYWJsZSwgb3JpZ2luYWxFbGVtZW50Ll9pbmRleCwgb3JpZ2luYWxFbGVtZW50Ll9maWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50UGFyZW4gPSBuZXcgUGFyZW4obmV3IFNlbGVjdG9yKGluc2lkZVBhcmVudCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50UGFyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoY29udGFpbmVkRWxlbWVudCwgb3JpZ2luYWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCwgc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQobnVsbCwgY29udGFpbmVkRWxlbWVudCwgb3JpZ2luYWxFbGVtZW50LmlzVmFyaWFibGUsIG9yaWdpbmFsRWxlbWVudC5faW5kZXgsIG9yaWdpbmFsRWxlbWVudC5fZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoW2VsZW1lbnRdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBqb2lucyBzZWxlY3RvciBwYXRoIGZyb20gYGJlZ2lubmluZ1BhdGhgIHdpdGggc2VsZWN0b3IgcGF0aCBpbiBgYWRkUGF0aGBcclxuICAgICAgICAgICAgLy8gYHJlcGxhY2VkRWxlbWVudGAgY29udGFpbnMgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHJlcGxhY2VkIGJ5IGBhZGRQYXRoYFxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIGNvbmNhdGVuYXRlZCBwYXRoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJlcGxhY2VtZW50SW50b1BhdGgoYmVnaW5uaW5nUGF0aCwgYWRkUGF0aCwgcmVwbGFjZWRFbGVtZW50LCBvcmlnaW5hbFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VsZWN0b3JQYXRoLCBsYXN0U2VsZWN0b3IsIG5ld0pvaW5lZFNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgLy8gb3VyIG5ldyBzZWxlY3RvciBwYXRoXHJcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvclBhdGggPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgam9pbmVkIHNlbGVjdG9yIC0gaWYgJiBpcyB0aGUgZmlyc3QgdGhpbmcgdGhpcyB3aWxsIGJlIGVtcHR5LFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IG5ld0pvaW5lZFNlbGVjdG9yIHdpbGwgYmUgdGhlIGxhc3Qgc2V0IG9mIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgaWYgKGJlZ2lubmluZ1BhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yUGF0aCA9IGNvcHlBcnJheShiZWdpbm5pbmdQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0b3IgPSBuZXdTZWxlY3RvclBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Sm9pbmVkU2VsZWN0b3IgPSBvcmlnaW5hbFNlbGVjdG9yLmNyZWF0ZURlcml2ZWQoY29weUFycmF5KGxhc3RTZWxlY3Rvci5lbGVtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Sm9pbmVkU2VsZWN0b3IgPSBvcmlnaW5hbFNlbGVjdG9yLmNyZWF0ZURlcml2ZWQoW10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFkZFBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC9kZWVwLyBpcyBhIENTUzQgc2VsZWN0b3IgLSAocmVtb3ZlZCwgc28gc2hvdWxkIGRlcHJlY2F0ZSlcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGlzIHZhbGlkIHdpdGhvdXQgYW55dGhpbmcgaW4gZnJvbnQgb2YgaXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBpZiB0aGUgJiBkb2VzIG5vdCBoYXZlIGEgY29tYmluYXRvciB0aGF0IGlzIFwiXCIgb3IgXCIgXCIgdGhlblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVyZSBpcyBhIGNvbWJpbmF0b3Igb24gdGhlIHBhcmVudCwgdGhlbiBncmFiIHRoYXQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGFsbG93cyArIGEgeyAmIC5iIHsgLmEgJiB7IC4uLiB0aG91Z2ggbm90IHN1cmUgd2h5IHlvdSB3b3VsZCB3YW50IHRvIGRvIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tYmluYXRvciA9IHJlcGxhY2VkRWxlbWVudC5jb21iaW5hdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IGFkZFBhdGhbMF0uZWxlbWVudHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0b3IuZW1wdHlPcldoaXRlc3BhY2UgJiYgIXBhcmVudEVsLmNvbWJpbmF0b3IuZW1wdHlPcldoaXRlc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluYXRvciA9IHBhcmVudEVsLmNvbWJpbmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGpvaW4gdGhlIGVsZW1lbnRzIHNvIGZhciB3aXRoIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICBuZXdKb2luZWRTZWxlY3Rvci5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KGNvbWJpbmF0b3IsIHBhcmVudEVsLnZhbHVlLCByZXBsYWNlZEVsZW1lbnQuaXNWYXJpYWJsZSwgcmVwbGFjZWRFbGVtZW50Ll9pbmRleCwgcmVwbGFjZWRFbGVtZW50Ll9maWxlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0pvaW5lZFNlbGVjdG9yLmVsZW1lbnRzID0gbmV3Sm9pbmVkU2VsZWN0b3IuZWxlbWVudHMuY29uY2F0KGFkZFBhdGhbMF0uZWxlbWVudHMuc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbm93IGFkZCB0aGUgam9pbmVkIHNlbGVjdG9yIC0gYnV0IG9ubHkgaWYgaXQgaXMgbm90IGVtcHR5XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3Sm9pbmVkU2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JQYXRoLnB1c2gobmV3Sm9pbmVkU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHV0IHRvZ2V0aGVyIHRoZSBwYXJlbnQgc2VsZWN0b3JzIGFmdGVyIHRoZSBqb2luIChlLmcuIHRoZSByZXN0IG9mIHRoZSBwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICBpZiAoYWRkUGF0aC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RPZlBhdGggPSBhZGRQYXRoLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3RPZlBhdGggPSByZXN0T2ZQYXRoLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNyZWF0ZURlcml2ZWQoc2VsZWN0b3IuZWxlbWVudHMsIFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvclBhdGggPSBuZXdTZWxlY3RvclBhdGguY29uY2F0KHJlc3RPZlBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NlbGVjdG9yUGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBqb2lucyBzZWxlY3RvciBwYXRoIGZyb20gYGJlZ2lubmluZ1BhdGhgIHdpdGggZXZlcnkgc2VsZWN0b3IgcGF0aCBpbiBgYWRkUGF0aHNgIGFycmF5XHJcbiAgICAgICAgICAgIC8vIGByZXBsYWNlZEVsZW1lbnRgIGNvbnRhaW5zIGVsZW1lbnQgdGhhdCBpcyBiZWluZyByZXBsYWNlZCBieSBgYWRkUGF0aGBcclxuICAgICAgICAgICAgLy8gcmV0dXJucyBhcnJheSB3aXRoIGFsbCBjb25jYXRlbmF0ZWQgcGF0aHNcclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkQWxsUmVwbGFjZW1lbnRzSW50b1BhdGgoYmVnaW5uaW5nUGF0aCwgYWRkUGF0aHMsIHJlcGxhY2VkRWxlbWVudCwgb3JpZ2luYWxTZWxlY3RvciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBiZWdpbm5pbmdQYXRoLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yUGF0aCA9IGFkZFJlcGxhY2VtZW50SW50b1BhdGgoYmVnaW5uaW5nUGF0aFtqXSwgYWRkUGF0aHMsIHJlcGxhY2VkRWxlbWVudCwgb3JpZ2luYWxTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3U2VsZWN0b3JQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gbWVyZ2VFbGVtZW50c09uVG9TZWxlY3RvcnMoZWxlbWVudHMsIHNlbGVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksIHNlbDtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKFtuZXcgU2VsZWN0b3IoZWxlbWVudHMpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgKHNlbCA9IHNlbGVjdG9yc1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyB0aGluZyBpbiBzZWwgaXMgYSBwYXJlbnQgdGhpcyBuZWVkcyB0byBqb2luIG9uIHRvIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbFtzZWwubGVuZ3RoIC0gMV0gPSBzZWxbc2VsLmxlbmd0aCAtIDFdLmNyZWF0ZURlcml2ZWQoc2VsW3NlbC5sZW5ndGggLSAxXS5lbGVtZW50cy5jb25jYXQoZWxlbWVudHMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5wdXNoKG5ldyBTZWxlY3RvcihlbGVtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXBsYWNlIGFsbCBwYXJlbnQgc2VsZWN0b3JzIGluc2lkZSBgaW5TZWxlY3RvcmAgYnkgY29udGVudCBvZiBgY29udGV4dGAgYXJyYXlcclxuICAgICAgICAgICAgLy8gcmVzdWx0aW5nIHNlbGVjdG9ycyBhcmUgcmV0dXJuZWQgaW5zaWRlIGBwYXRoc2AgYXJyYXlcclxuICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGBpblNlbGVjdG9yYCBjb250YWluZWQgYXQgbGVhc3Qgb25lIHBhcmVudCBzZWxlY3RvclxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZXBsYWNlUGFyZW50U2VsZWN0b3IocGF0aHMsIGNvbnRleHQsIGluU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBwYXRocyBhcmUgW1tTZWxlY3Rvcl1dXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlyc3QgbGlzdCBpcyBhIGxpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIGxpc3QgaXMgYSBsaXN0IG9mIGluaGVyaXRhbmNlIHNlcGFyYXRlZCBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgIC8vIGUuZy5cclxuICAgICAgICAgICAgICAgIC8vIC5hLCAuYiB7XHJcbiAgICAgICAgICAgICAgICAvLyAgIC5jIHtcclxuICAgICAgICAgICAgICAgIC8vICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gPT0gW1suYV0gWy5jXV0gW1suYl0gWy5jXV1cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgaiwgaywgY3VycmVudEVsZW1lbnRzLCBuZXdTZWxlY3RvcnMsIHNlbGVjdG9yc011bHRpcGxpZWQsIHNlbCwgZWwsIGhhZFBhcmVudFNlbGVjdG9yID0gZmFsc2UsIGxlbmd0aCwgbGFzdFNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZE5lc3RlZFNlbGVjdG9yKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVTZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShlbGVtZW50LnZhbHVlIGluc3RhbmNlb2YgUGFyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYXliZVNlbGVjdG9yID0gZWxlbWVudC52YWx1ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXliZVNlbGVjdG9yIGluc3RhbmNlb2YgU2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVTZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdG9yIHNvIGZhclxyXG4gICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBsaXN0IG9mIG5ldyBzZWxlY3RvcnMgdG8gYWRkIHRvIHRoZSBwYXRoLlxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBidWlsZCBpdCB1cC4gV2UgaW5pdGlhdGUgaXQgd2l0aCBvbmUgZW1wdHkgc2VsZWN0b3IgYXMgd2UgXCJtdWx0aXBseVwiIHRoZSBuZXcgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgcGFyZW50c1xyXG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFtdXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgKGVsID0gaW5TZWxlY3Rvci5lbGVtZW50c1tpXSk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbiBwYXJlbnQgcmVmZXJlbmNlIGVsZW1lbnRzIGp1c3QgZ2V0IGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnZhbHVlICE9PSAnJicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gZmluZE5lc3RlZFNlbGVjdG9yKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZFNlbGVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBjdXJyZW50IGxpc3Qgb2Ygbm9uIHBhcmVudCBzZWxlY3RvciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhjdXJyZW50RWxlbWVudHMsIG5ld1NlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUGF0aHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlZE5ld1NlbGVjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWQgPSByZXBsYWNlUGFyZW50U2VsZWN0b3IobmVzdGVkUGF0aHMsIGNvbnRleHQsIG5lc3RlZFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhZFBhcmVudFNlbGVjdG9yID0gaGFkUGFyZW50U2VsZWN0b3IgfHwgcmVwbGFjZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmVzdGVkUGF0aHMgYXJyYXkgc2hvdWxkIGhhdmUgb25seSBvbmUgbWVtYmVyIC0gcmVwbGFjZVBhcmVudFNlbGVjdG9yIGRvZXMgbm90IG11bHRpcGx5IHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5lc3RlZFBhdGhzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50U2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihjcmVhdGVQYXJlbnRoZXNpcyhuZXN0ZWRQYXRoc1trXSwgZWwpLCBlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQWxsUmVwbGFjZW1lbnRzSW50b1BhdGgobmV3U2VsZWN0b3JzLCBbcmVwbGFjZW1lbnRTZWxlY3Rvcl0sIGVsLCBpblNlbGVjdG9yLCByZXBsYWNlZE5ld1NlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvcnMgPSByZXBsYWNlZE5ld1NlbGVjdG9ycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnRzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYWRQYXJlbnRTZWxlY3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXcgbGlzdCBvZiBzZWxlY3RvcnMgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yc011bHRpcGxpZWQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGN1cnJlbnQgbGlzdCBvZiBub24gcGFyZW50IHNlbGVjdG9yIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHRvIHRoZSBjdXJyZW50IGxpc3Qgb2Ygc2VsZWN0b3JzIHRvIGFkZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhjdXJyZW50RWxlbWVudHMsIG5ld1NlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBvdXIgY3VycmVudCBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5ld1NlbGVjdG9ycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gbmV3U2VsZWN0b3JzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGFyZW50IHBhdGhzLCB0aGUgJiBtaWdodCBiZSBpbiBhIG1peGluIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgYXJlIHBhcmVudHMgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY29tYmluYXRvciB1c2VkIG9uIGVsIHNob3VsZCBub3cgYmUgYXBwbGllZCB0byB0aGUgbmV4dCBlbGVtZW50IGluc3RlYWQgc28gdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIG5vdCBsb3N0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbFswXS5lbGVtZW50cy5wdXNoKG5ldyBFbGVtZW50KGVsLmNvbWJpbmF0b3IsICcnLCBlbC5pc1ZhcmlhYmxlLCBlbC5faW5kZXgsIGVsLl9maWxlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNNdWx0aXBsaWVkLnB1c2goc2VsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgcGFyZW50IHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb250ZXh0Lmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcHV0IHRoZSBjdXJyZW50IHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGpvaW4gdGhlIGxhc3Qgc2VsZWN0b3IncyBlbGVtZW50cyBvbiB0byB0aGUgcGFyZW50cyBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yUGF0aCA9IGFkZFJlcGxhY2VtZW50SW50b1BhdGgoc2VsLCBjb250ZXh0W2tdLCBlbCwgaW5TZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGF0IHRvIG91ciBuZXcgc2V0IG9mIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnNNdWx0aXBsaWVkLnB1c2gobmV3U2VsZWN0b3JQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3VyIG5ldyBzZWxlY3RvcnMgaGFzIGJlZW4gbXVsdGlwbGllZCwgc28gcmVzZXQgdGhlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9ycyA9IHNlbGVjdG9yc011bHRpcGxpZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IGVsZW1lbnRzIGxlZnQgb3ZlciAoZS5nLiAuYSYgLmIgPT0gLmIpXHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlbSBvbiB0byBhbGwgdGhlIGN1cnJlbnQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICBtZXJnZUVsZW1lbnRzT25Ub1NlbGVjdG9ycyhjdXJyZW50RWxlbWVudHMsIG5ld1NlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbmV3U2VsZWN0b3JzW2ldLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKG5ld1NlbGVjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RvciA9IG5ld1NlbGVjdG9yc1tpXVtsZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3JzW2ldW2xlbmd0aCAtIDFdID0gbGFzdFNlbGVjdG9yLmNyZWF0ZURlcml2ZWQobGFzdFNlbGVjdG9yLmVsZW1lbnRzLCBpblNlbGVjdG9yLmV4dGVuZExpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBoYWRQYXJlbnRTZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBkZXJpdmVTZWxlY3Rvcih2aXNpYmlsaXR5SW5mbywgZGVyaXZlRnJvbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yID0gZGVyaXZlRnJvbS5jcmVhdGVEZXJpdmVkKGRlcml2ZUZyb20uZWxlbWVudHMsIGRlcml2ZUZyb20uZXh0ZW5kTGlzdCwgZGVyaXZlRnJvbS5ldmFsZENvbmRpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3Rvci5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGpvaW5TZWxlY3RvciBjb2RlIGZvbGxvd3NcclxuICAgICAgICAgICAgdmFyIGksIG5ld1BhdGhzLCBoYWRQYXJlbnRTZWxlY3RvcjtcclxuICAgICAgICAgICAgbmV3UGF0aHMgPSBbXTtcclxuICAgICAgICAgICAgaGFkUGFyZW50U2VsZWN0b3IgPSByZXBsYWNlUGFyZW50U2VsZWN0b3IobmV3UGF0aHMsIGNvbnRleHQsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCFoYWRQYXJlbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhdGhzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmNhdGVuYXRlZCA9IGNvbnRleHRbaV0ubWFwKGRlcml2ZVNlbGVjdG9yLmJpbmQodGhpcywgc2VsZWN0b3IudmlzaWJpbGl0eUluZm8oKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWQucHVzaChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhdGhzLnB1c2goY29uY2F0ZW5hdGVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQYXRocyA9IFtbc2VsZWN0b3JdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3UGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3UGF0aHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgQXRSdWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBydWxlcywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgZGVidWdJbmZvLCBpc1Jvb3RlZCwgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSAodmFsdWUgaW5zdGFuY2VvZiBOb2RlKSA/IHZhbHVlIDogKHZhbHVlID8gbmV3IEFub255bW91cyh2YWx1ZSkgOiB2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHJ1bGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydWxlcyA9IFtydWxlc107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzWzBdLnNlbGVjdG9ycyA9IChuZXcgU2VsZWN0b3IoW10sIG51bGwsIG51bGwsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pKS5jcmVhdGVFbXB0eVNlbGVjdG9ycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzW2ldLmFsbG93SW1wb3J0cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5ydWxlcywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XHJcbiAgICAgICAgdGhpcy5pc1Jvb3RlZCA9IGlzUm9vdGVkIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29weVZpc2liaWxpdHlJbmZvKHZpc2liaWxpdHlJbmZvKTtcclxuICAgICAgICB0aGlzLmFsbG93Um9vdCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQXRSdWxlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdBdFJ1bGUnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xyXG4gICAgICAgICAgICBpZiAocnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkocnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1J1bGVzZXRMaWtlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVzIHx8ICF0aGlzLmlzQ2hhcnNldCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNDaGFyc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnQGNoYXJzZXQnID09PSB0aGlzLm5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMubmFtZSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJyAnKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChydWxlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRSdWxlc2V0KGNvbnRleHQsIG91dHB1dCwgcnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnOycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgbWVkaWFQYXRoQmFja3VwLCBtZWRpYUJsb2Nrc0JhY2t1cCwgdmFsdWUgPSB0aGlzLnZhbHVlLCBydWxlcyA9IHRoaXMucnVsZXM7XHJcbiAgICAgICAgICAgIC8vIG1lZGlhIHN0b3JlZCBpbnNpZGUgb3RoZXIgYXRydWxlIHNob3VsZCBub3QgYnViYmxlIG92ZXIgaXRcclxuICAgICAgICAgICAgLy8gYmFja3B1cCBtZWRpYSBidWJibGluZyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICBtZWRpYVBhdGhCYWNrdXAgPSBjb250ZXh0Lm1lZGlhUGF0aDtcclxuICAgICAgICAgICAgbWVkaWFCbG9ja3NCYWNrdXAgPSBjb250ZXh0Lm1lZGlhQmxvY2tzO1xyXG4gICAgICAgICAgICAvLyBkZWxldGVkIG1lZGlhIGJ1YmJsaW5nIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFQYXRoID0gW107XHJcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3MgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXHJcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlc1swXS5ldmFsKGNvbnRleHQpXTtcclxuICAgICAgICAgICAgICAgIHJ1bGVzWzBdLnJvb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgbWVkaWEgYnViYmxpbmcgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgY29udGV4dC5tZWRpYVBhdGggPSBtZWRpYVBhdGhCYWNrdXA7XHJcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3MgPSBtZWRpYUJsb2Nrc0JhY2t1cDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdFJ1bGUodGhpcy5uYW1lLCB2YWx1ZSwgcnVsZXMsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmRlYnVnSW5mbywgdGhpcy5pc1Jvb3RlZCwgdGhpcy52aXNpYmlsaXR5SW5mbygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBydWxlIGF0IHRoaXMgcG9pbnQgLSB0aGF0IGlzIGhvdyBwYXJzZXIgY29uc3RydWN0cyB0aGUgcnVsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJ1bGVzZXQucHJvdG90eXBlLnZhcmlhYmxlLmNhbGwodGhpcy5ydWxlc1swXSwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcnVsZSBhdCB0aGlzIHBvaW50IC0gdGhhdCBpcyBob3cgcGFyc2VyIGNvbnN0cnVjdHMgdGhlIHJ1bGVcclxuICAgICAgICAgICAgICAgIHJldHVybiBSdWxlc2V0LnByb3RvdHlwZS5maW5kLmFwcGx5KHRoaXMucnVsZXNbMF0sIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJ1bGVzZXRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHJ1bGUgYXQgdGhpcyBwb2ludCAtIHRoYXQgaXMgaG93IHBhcnNlciBjb25zdHJ1Y3RzIHRoZSBydWxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUnVsZXNldC5wcm90b3R5cGUucnVsZXNldHMuYXBwbHkodGhpcy5ydWxlc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG91dHB1dFJ1bGVzZXQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQsIHJ1bGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlQ250ID0gcnVsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgY29udGV4dC50YWJMZXZlbCA9IChjb250ZXh0LnRhYkxldmVsIHwgMCkgKyAxO1xyXG4gICAgICAgICAgICAvLyBDb21wcmVzc2VkXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmNvbXByZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCd7Jyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCd9Jyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRhYkxldmVsLS07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm9uLWNvbXByZXNzZWRcclxuICAgICAgICAgICAgdmFyIHRhYlNldFN0ciA9IFwiXFxuXCIgKyBBcnJheShjb250ZXh0LnRhYkxldmVsKS5qb2luKCcgICcpLCB0YWJSdWxlU3RyID0gdGFiU2V0U3RyICsgXCIgIFwiO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVDbnQpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoXCIge1wiICsgdGFiU2V0U3RyICsgXCJ9XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZChcIiB7XCIgKyB0YWJSdWxlU3RyKTtcclxuICAgICAgICAgICAgICAgIHJ1bGVzWzBdLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHJ1bGVDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQodGFiUnVsZVN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRhYlNldFN0ciArIFwifVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnRhYkxldmVsLS07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgRGV0YWNoZWRSdWxlc2V0ID0gZnVuY3Rpb24gKHJ1bGVzZXQsIGZyYW1lcykge1xyXG4gICAgICAgIHRoaXMucnVsZXNldCA9IHJ1bGVzZXQ7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBmcmFtZXM7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy5ydWxlc2V0LCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBEZXRhY2hlZFJ1bGVzZXQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0RldGFjaGVkUnVsZXNldCcsXHJcbiAgICAgICAgZXZhbEZpcnN0OiB0cnVlLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5ydWxlc2V0ID0gdmlzaXRvci52aXNpdCh0aGlzLnJ1bGVzZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzIHx8IGNvcHlBcnJheShjb250ZXh0LmZyYW1lcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV0YWNoZWRSdWxlc2V0KHRoaXMucnVsZXNldCwgZnJhbWVzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbGxFdmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlc2V0LmV2YWwodGhpcy5mcmFtZXMgPyBuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCB0aGlzLmZyYW1lcy5jb25jYXQoY29udGV4dC5mcmFtZXMpKSA6IGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIFVuaXQgPSBmdW5jdGlvbiAobnVtZXJhdG9yLCBkZW5vbWluYXRvciwgYmFja3VwVW5pdCkge1xyXG4gICAgICAgIHRoaXMubnVtZXJhdG9yID0gbnVtZXJhdG9yID8gY29weUFycmF5KG51bWVyYXRvcikuc29ydCgpIDogW107XHJcbiAgICAgICAgdGhpcy5kZW5vbWluYXRvciA9IGRlbm9taW5hdG9yID8gY29weUFycmF5KGRlbm9taW5hdG9yKS5zb3J0KCkgOiBbXTtcclxuICAgICAgICBpZiAoYmFja3VwVW5pdCkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2t1cFVuaXQgPSBiYWNrdXBVbml0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3IgJiYgbnVtZXJhdG9yLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2t1cFVuaXQgPSBudW1lcmF0b3JbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFVuaXQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1VuaXQnLFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5pdChjb3B5QXJyYXkodGhpcy5udW1lcmF0b3IpLCBjb3B5QXJyYXkodGhpcy5kZW5vbWluYXRvciksIHRoaXMuYmFja3VwVW5pdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgLy8gRGltZW5zaW9uIGNoZWNrcyB0aGUgdW5pdCBpcyBzaW5ndWxhciBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIGluIHN0cmljdCBtYXRoIG1vZGUuXHJcbiAgICAgICAgICAgIHZhciBzdHJpY3RVbml0cyA9IGNvbnRleHQgJiYgY29udGV4dC5zdHJpY3RVbml0cztcclxuICAgICAgICAgICAgaWYgKHRoaXMubnVtZXJhdG9yLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLm51bWVyYXRvclswXSk7IC8vIHRoZSBpZGVhbCBzaXR1YXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghc3RyaWN0VW5pdHMgJiYgdGhpcy5iYWNrdXBVbml0KSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMuYmFja3VwVW5pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXN0cmljdFVuaXRzICYmIHRoaXMuZGVub21pbmF0b3IubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMuZGVub21pbmF0b3JbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaSwgcmV0dXJuU3RyID0gdGhpcy5udW1lcmF0b3Iuam9pbignKicpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5vbWluYXRvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuU3RyICs9IFwiL1wiICsgdGhpcy5kZW5vbWluYXRvcltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuU3RyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGFyZTogZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzKG90aGVyLnRvU3RyaW5nKCkpID8gMCA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzOiBmdW5jdGlvbiAodW5pdFN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgPT09IHVuaXRTdHJpbmcudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWdFeHAoJ14ocHh8ZW18ZXh8Y2h8cmVtfGlufGNtfG1tfHBjfHB0fGV4fHZ3fHZofHZtaW58dm1heCkkJywgJ2dpJykudGVzdCh0aGlzLnRvQ1NTKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1lcmF0b3IubGVuZ3RoID09PSAwICYmIHRoaXMuZGVub21pbmF0b3IubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNTaW5ndWxhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1lcmF0b3IubGVuZ3RoIDw9IDEgJiYgdGhpcy5kZW5vbWluYXRvci5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtZXJhdG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm51bWVyYXRvcltpXSA9IGNhbGxiYWNrKHRoaXMubnVtZXJhdG9yW2ldLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVub21pbmF0b3IubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVub21pbmF0b3JbaV0gPSBjYWxsYmFjayh0aGlzLmRlbm9taW5hdG9yW2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXNlZFVuaXRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgbWFwVW5pdDtcclxuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZTtcclxuICAgICAgICAgICAgbWFwVW5pdCA9IGZ1bmN0aW9uIChhdG9taWNVbml0KSB7XHJcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLmhhc093blByb3BlcnR5KGF0b21pY1VuaXQpICYmICFyZXN1bHRbZ3JvdXBOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtncm91cE5hbWVdID0gYXRvbWljVW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhdG9taWNVbml0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmb3IgKGdyb3VwTmFtZSBpbiB1bml0Q29udmVyc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1bml0Q29udmVyc2lvbnMuaGFzT3duUHJvcGVydHkoZ3JvdXBOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gdW5pdENvbnZlcnNpb25zW2dyb3VwTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAobWFwVW5pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY291bnRlciA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgYXRvbWljVW5pdDtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bWVyYXRvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXRvbWljVW5pdCA9IHRoaXMubnVtZXJhdG9yW2ldO1xyXG4gICAgICAgICAgICAgICAgY291bnRlclthdG9taWNVbml0XSA9IChjb3VudGVyW2F0b21pY1VuaXRdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5vbWluYXRvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYXRvbWljVW5pdCA9IHRoaXMuZGVub21pbmF0b3JbaV07XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyW2F0b21pY1VuaXRdID0gKGNvdW50ZXJbYXRvbWljVW5pdF0gfHwgMCkgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubnVtZXJhdG9yID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZGVub21pbmF0b3IgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChhdG9taWNVbml0IGluIGNvdW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyLmhhc093blByb3BlcnR5KGF0b21pY1VuaXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gY291bnRlclthdG9taWNVbml0XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm51bWVyYXRvci5wdXNoKGF0b21pY1VuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgLWNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVub21pbmF0b3IucHVzaChhdG9taWNVbml0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm51bWVyYXRvci5zb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVub21pbmF0b3Iuc29ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgLy9cclxuICAgIC8vIEEgbnVtYmVyIHdpdGggYSB1bml0XHJcbiAgICAvL1xyXG4gICAgdmFyIERpbWVuc2lvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgdW5pdCkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICBpZiAoaXNOYU4odGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gaXMgbm90IGEgbnVtYmVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVuaXQgPSAodW5pdCAmJiB1bml0IGluc3RhbmNlb2YgVW5pdCkgPyB1bml0IDpcclxuICAgICAgICAgICAgbmV3IFVuaXQodW5pdCA/IFt1bml0XSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodGhpcy51bml0LCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBEaW1lbnNpb24ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0RpbWVuc2lvbicsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnVuaXQgPSB2aXNpdG9yLnZpc2l0KHRoaXMudW5pdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvQ29sb3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihbdGhpcy52YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy52YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGlmICgoY29udGV4dCAmJiBjb250ZXh0LnN0cmljdFVuaXRzKSAmJiAhdGhpcy51bml0LmlzU2luZ3VsYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgdW5pdHMgaW4gZGltZW5zaW9uLiBDb3JyZWN0IHRoZSB1bml0cyBvciB1c2UgdGhlIHVuaXQgZnVuY3Rpb24uIEJhZCB1bml0OiBcIiArIHRoaXMudW5pdC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmZyb3VuZChjb250ZXh0LCB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlIDwgMC4wMDAwMDEgJiYgdmFsdWUgPiAtMC4wMDAwMDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIG91dHB1dCAxZS02IGV0Yy5cclxuICAgICAgICAgICAgICAgIHN0clZhbHVlID0gdmFsdWUudG9GaXhlZCgyMCkucmVwbGFjZSgvMCskLywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY29tcHJlc3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIFplcm8gdmFsdWVzIGRvZXNuJ3QgbmVlZCBhIHVuaXRcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB0aGlzLnVuaXQuaXNMZW5ndGgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoc3RyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZsb2F0IHZhbHVlcyBkb2Vzbid0IG5lZWQgYSBsZWFkaW5nIHplcm9cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDAgJiYgdmFsdWUgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyVmFsdWUgPSAoc3RyVmFsdWUpLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHN0clZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy51bml0LmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gSW4gYW4gb3BlcmF0aW9uIGJldHdlZW4gdHdvIERpbWVuc2lvbnMsXHJcbiAgICAgICAgLy8gd2UgZGVmYXVsdCB0byB0aGUgZmlyc3QgRGltZW5zaW9uJ3MgdW5pdCxcclxuICAgICAgICAvLyBzbyBgMXB4ICsgMmAgd2lsbCB5aWVsZCBgM3B4YC5cclxuICAgICAgICBvcGVyYXRlOiBmdW5jdGlvbiAoY29udGV4dCwgb3AsIG90aGVyKSB7XHJcbiAgICAgICAgICAgIC8qIGpzaGludCBub2VtcHR5OmZhbHNlICovXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wZXJhdGUoY29udGV4dCwgb3AsIHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIHVuaXQgPSB0aGlzLnVuaXQuY2xvbmUoKTtcclxuICAgICAgICAgICAgaWYgKG9wID09PSAnKycgfHwgb3AgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXQubnVtZXJhdG9yLmxlbmd0aCA9PT0gMCAmJiB1bml0LmRlbm9taW5hdG9yLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXQgPSBvdGhlci51bml0LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudW5pdC5iYWNrdXBVbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQuYmFja3VwVW5pdCA9IHRoaXMudW5pdC5iYWNrdXBVbml0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyLnVuaXQubnVtZXJhdG9yLmxlbmd0aCA9PT0gMCAmJiB1bml0LmRlbm9taW5hdG9yLmxlbmd0aCA9PT0gMCkgO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5jb252ZXJ0VG8odGhpcy51bml0LnVzZWRVbml0cygpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdHJpY3RVbml0cyAmJiBvdGhlci51bml0LnRvU3RyaW5nKCkgIT09IHVuaXQudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBhdGlibGUgdW5pdHMuIENoYW5nZSB0aGUgdW5pdHMgb3IgdXNlIHRoZSB1bml0IGZ1bmN0aW9uLiBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoXCJCYWQgdW5pdHM6ICdcIiArIHVuaXQudG9TdHJpbmcoKSArIFwiJyBhbmQgJ1wiICsgb3RoZXIudW5pdC50b1N0cmluZygpICsgXCInLlwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fb3BlcmF0ZShjb250ZXh0LCBvcCwgdGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wID09PSAnKicpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQubnVtZXJhdG9yID0gdW5pdC5udW1lcmF0b3IuY29uY2F0KG90aGVyLnVuaXQubnVtZXJhdG9yKS5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB1bml0LmRlbm9taW5hdG9yID0gdW5pdC5kZW5vbWluYXRvci5jb25jYXQob3RoZXIudW5pdC5kZW5vbWluYXRvcikuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgdW5pdC5jYW5jZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcCA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICB1bml0Lm51bWVyYXRvciA9IHVuaXQubnVtZXJhdG9yLmNvbmNhdChvdGhlci51bml0LmRlbm9taW5hdG9yKS5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB1bml0LmRlbm9taW5hdG9yID0gdW5pdC5kZW5vbWluYXRvci5jb25jYXQob3RoZXIudW5pdC5udW1lcmF0b3IpLnNvcnQoKTtcclxuICAgICAgICAgICAgICAgIHVuaXQuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odmFsdWUsIHVuaXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGFyZTogZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudW5pdC5pc0VtcHR5KCkgfHwgb3RoZXIudW5pdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGEgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgYiA9IG90aGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMudW5pZnkoKTtcclxuICAgICAgICAgICAgICAgIGIgPSBvdGhlci51bmlmeSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEudW5pdC5jb21wYXJlKGIudW5pdCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBOb2RlLm51bWVyaWNDb21wYXJlKGEudmFsdWUsIGIudmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5pZnk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRvKHsgbGVuZ3RoOiAncHgnLCBkdXJhdGlvbjogJ3MnLCBhbmdsZTogJ3JhZCcgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb252ZXJ0VG86IGZ1bmN0aW9uIChjb252ZXJzaW9ucykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgdW5pdCA9IHRoaXMudW5pdC5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0VW5pdDtcclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRDb252ZXJzaW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgYXBwbHlVbml0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnZlcnNpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIHVuaXRDb252ZXJzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bml0Q29udmVyc2lvbnNbaV0uaGFzT3duUHJvcGVydHkoY29udmVyc2lvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcml2ZWRDb252ZXJzaW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXJpdmVkQ29udmVyc2lvbnNbaV0gPSBjb252ZXJzaW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb252ZXJzaW9ucyA9IGRlcml2ZWRDb252ZXJzaW9ucztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcHBseVVuaXQgPSBmdW5jdGlvbiAoYXRvbWljVW5pdCwgZGVub21pbmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuaGFzT3duUHJvcGVydHkoYXRvbWljVW5pdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVub21pbmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIChncm91cFthdG9taWNVbml0XSAvIGdyb3VwW3RhcmdldFVuaXRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAoZ3JvdXBbYXRvbWljVW5pdF0gLyBncm91cFt0YXJnZXRVbml0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRVbml0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0b21pY1VuaXQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAoZ3JvdXBOYW1lIGluIGNvbnZlcnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udmVyc2lvbnMuaGFzT3duUHJvcGVydHkoZ3JvdXBOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVuaXQgPSBjb252ZXJzaW9uc1tncm91cE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0gdW5pdENvbnZlcnNpb25zW2dyb3VwTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdC5tYXAoYXBwbHlVbml0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1bml0LmNhbmNlbCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih2YWx1ZSwgdW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgTUFUSCQxID0gTWF0aCQxO1xyXG4gICAgdmFyIE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcCwgb3BlcmFuZHMsIGlzU3BhY2VkKSB7XHJcbiAgICAgICAgdGhpcy5vcCA9IG9wLnRyaW0oKTtcclxuICAgICAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHM7XHJcbiAgICAgICAgdGhpcy5pc1NwYWNlZCA9IGlzU3BhY2VkO1xyXG4gICAgfTtcclxuICAgIE9wZXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnT3BlcmF0aW9uJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmFuZHMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5vcGVyYW5kcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMub3BlcmFuZHNbMF0uZXZhbChjb250ZXh0KSwgYiA9IHRoaXMub3BlcmFuZHNbMV0uZXZhbChjb250ZXh0KSwgb3A7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmlzTWF0aE9uKHRoaXMub3ApKSB7XHJcbiAgICAgICAgICAgICAgICBvcCA9IHRoaXMub3AgPT09ICcuLycgPyAnLycgOiB0aGlzLm9wO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBEaW1lbnNpb24gJiYgYiBpbnN0YW5jZW9mIENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGEudG9Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBEaW1lbnNpb24gJiYgYSBpbnN0YW5jZW9mIENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGIudG9Db2xvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFhLm9wZXJhdGUgfHwgIWIub3BlcmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYSBpbnN0YW5jZW9mIE9wZXJhdGlvbiB8fCBiIGluc3RhbmNlb2YgT3BlcmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBhLm9wID09PSAnLycgJiYgY29udGV4dC5tYXRoID09PSBNQVRIJDEuUEFSRU5TX0RJVklTSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKHRoaXMub3AsIFthLCBiXSwgdGhpcy5pc1NwYWNlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ09wZXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdPcGVyYXRpb24gb24gYW4gaW52YWxpZCB0eXBlJyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEub3BlcmF0ZShjb250ZXh0LCBvcCwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbih0aGlzLm9wLCBbYSwgYl0sIHRoaXMuaXNTcGFjZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYW5kc1swXS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTcGFjZWQpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJyAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMub3ApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NwYWNlZCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmFuZHNbMV0uZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMkMSgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XG5cbiAgICB2YXIgRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbm9TcGFjaW5nKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMubm9TcGFjaW5nID0gbm9TcGFjaW5nO1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHByZXNzaW9uIHJlcXVpcmVzIGFuIGFycmF5IHBhcmFtZXRlcicpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdFeHByZXNzaW9uJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBtYXRoT24gPSBjb250ZXh0LmlzTWF0aE9uKCk7XHJcbiAgICAgICAgICAgIHZhciBpblBhcmVudGhlc2lzID0gdGhpcy5wYXJlbnM7XHJcbiAgICAgICAgICAgIHZhciBkb3VibGVQYXJlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoaW5QYXJlbnRoZXNpcykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5pblBhcmVudGhlc2lzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBuZXcgRXhwcmVzc2lvbih0aGlzLnZhbHVlLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5ldmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfSksIHRoaXMubm9TcGFjaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbMF0ucGFyZW5zICYmICF0aGlzLnZhbHVlWzBdLnBhcmVuc0luT3AgJiYgIWNvbnRleHQuaW5DYWxjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlUGFyZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLnZhbHVlWzBdLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGluUGFyZW50aGVzaXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub3V0T2ZQYXJlbnRoZXNpcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVucyAmJiB0aGlzLnBhcmVuc0luT3AgJiYgIW1hdGhPbiAmJiAhZG91YmxlUGFyZW5cclxuICAgICAgICAgICAgICAgICYmICghKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRGltZW5zaW9uKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gbmV3IFBhcmVuKHJldHVyblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5vU3BhY2luZyAmJiBpICsgMSA8IHRoaXMudmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aHJvd0F3YXlDb21tZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKHYgaW5zdGFuY2VvZiBDb21tZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgZnVuY3Rpb25DYWxsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVuY3Rpb25DYWxsZXIobmFtZSwgY29udGV4dCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IGNvbnRleHQuZnJhbWVzWzBdLmZ1bmN0aW9uUmVnaXN0cnkuZ2V0KHRoaXMubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uQ2FsbGVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZ1bmMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb25DYWxsZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGFyZ3MpKSkge1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IFthcmdzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXZhbEFyZ3MgPSB0aGlzLmZ1bmMuZXZhbEFyZ3M7XHJcbiAgICAgICAgICAgIGlmIChldmFsQXJncyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5ldmFsKF90aGlzLmNvbnRleHQpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29tbWVudEZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhKGl0ZW0udHlwZSA9PT0gJ0NvbW1lbnQnKTsgfTtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHRlcnJpYmxlIGFuZCBzaG91bGQgYmUgcmVwbGFjZWQgYXMgcGVyIHRoaXMgaXNzdWUuLi5cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xlc3MvbGVzcy5qcy9pc3N1ZXMvMjQ3N1xyXG4gICAgICAgICAgICBhcmdzID0gYXJnc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjb21tZW50RmlsdGVyKVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0V4cHJlc3Npb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Yk5vZGVzID0gaXRlbS52YWx1ZS5maWx0ZXIoY29tbWVudEZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk5vZGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViTm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24oc3ViTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGV2YWxBcmdzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYy5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5cyQxKFt0aGlzLmNvbnRleHRdLCBhcmdzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxlcjtcclxuICAgIH0oKSk7XG5cbiAgICAvL1xyXG4gICAgLy8gQSBmdW5jdGlvbiBjYWxsIG5vZGUuXHJcbiAgICAvL1xyXG4gICAgdmFyIENhbGwgPSBmdW5jdGlvbiAobmFtZSwgYXJncywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgICAgICB0aGlzLmNhbGMgPSBuYW1lID09PSAnY2FsYyc7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgIH07XHJcbiAgICBDYWxsLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdDYWxsJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJncyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdoZW4gZXZhbHVhdGluZyBhIGZ1bmN0aW9uIGNhbGwsXHJcbiAgICAgICAgLy8gd2UgZWl0aGVyIGZpbmQgdGhlIGZ1bmN0aW9uIGluIHRoZSBmdW5jdGlvblJlZ2lzdHJ5LFxyXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgY2FsbCBpdCwgcGFzc2luZyB0aGUgIGV2YWx1YXRlZCBhcmd1bWVudHMsXHJcbiAgICAgICAgLy8gaWYgdGhpcyByZXR1cm5zIG51bGwgb3Igd2UgY2Fubm90IGZpbmQgdGhlIGZ1bmN0aW9uLCB3ZVxyXG4gICAgICAgIC8vIHNpbXBseSBwcmludCBpdCBvdXQgYXMgaXQgYXBwZWFyZWQgb3JpZ2luYWxseSBbMl0uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGUgcmVhc29uIHdoeSB3ZSBldmFsdWF0ZSB0aGUgYXJndW1lbnRzLCBpcyBpbiB0aGUgY2FzZSB3aGVyZVxyXG4gICAgICAgIC8vIHdlIHRyeSB0byBwYXNzIGEgdmFyaWFibGUgdG8gYSBmdW5jdGlvbiwgbGlrZTogYHNhdHVyYXRlKEBjb2xvcilgLlxyXG4gICAgICAgIC8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVjZWl2ZSB0aGUgdmFsdWUsIG5vdCB0aGUgdmFyaWFibGUuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHVybiBvZmYgbWF0aCBmb3IgY2FsYygpLCBhbmQgc3dpdGNoIGJhY2sgb24gZm9yIGV2YWx1YXRpbmcgbmVzdGVkIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNYXRoQ29udGV4dCA9IGNvbnRleHQubWF0aE9uO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1hdGhPbiA9ICF0aGlzLmNhbGM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGMgfHwgY29udGV4dC5pbkNhbGMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW50ZXJDYWxjKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGV4aXRDYWxjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNhbGMgfHwgY29udGV4dC5pbkNhbGMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmV4aXRDYWxjKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1hdGhPbiA9IGN1cnJlbnRNYXRoQ29udGV4dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGZ1bmNDYWxsZXIgPSBuZXcgZnVuY3Rpb25DYWxsZXIodGhpcy5uYW1lLCBjb250ZXh0LCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSk7XHJcbiAgICAgICAgICAgIGlmIChmdW5jQ2FsbGVyLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jQ2FsbGVyLmNhbGwodGhpcy5hcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBleGl0Q2FsYygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5oYXNPd25Qcm9wZXJ0eSgnbGluZScpICYmIGUuaGFzT3duUHJvcGVydHkoJ2NvbHVtbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS50eXBlIHx8ICdSdW50aW1lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJFcnJvciBldmFsdWF0aW5nIGZ1bmN0aW9uIGBcIiArIHRoaXMubmFtZSArIFwiYFwiICsgKGUubWVzc2FnZSA/IFwiOiBcIiArIGUubWVzc2FnZSA6ICcnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUuY29sdW1uTnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHRzIHRoYXQgdGhhdCBhcmUgbm90IG5vZGVzIGFyZSBjYXN0IGFzIEFub255bW91cyBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLy8gRmFsc3kgdmFsdWVzIG9yIGJvb2xlYW5zIGFyZSByZXR1cm5lZCBhcyBlbXB0eSBub2Rlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFub255bW91cyhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBbm9ueW1vdXMocmVzdWx0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5faW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5fZmlsZUluZm8gPSB0aGlzLl9maWxlSW5mbztcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmV2YWwoY29udGV4dCk7IH0pO1xyXG4gICAgICAgICAgICBleGl0Q2FsYygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGwodGhpcy5uYW1lLCBhcmdzLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLm5hbWUgKyBcIihcIiwgdGhpcy5maWxlSW5mbygpLCB0aGlzLmdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmdzW2ldLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgdGhpcy5hcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJywgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LmFkZCgnKScpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIFZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICB9O1xyXG4gICAgVmFyaWFibGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1ZhcmlhYmxlJyxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgdmFyaWFibGUsIG5hbWUgPSB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ0BAJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBcIkBcIiArIG5ldyBWYXJpYWJsZShuYW1lLnNsaWNlKDEpLCB0aGlzLmdldEluZGV4KCksIHRoaXMuZmlsZUluZm8oKSkuZXZhbChjb250ZXh0KS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmFsdWF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJywgbWVzc2FnZTogXCJSZWN1cnNpdmUgdmFyaWFibGUgZGVmaW5pdGlvbiBmb3IgXCIgKyBuYW1lLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXJpYWJsZSA9IHRoaXMuZmluZChjb250ZXh0LmZyYW1lcywgZnVuY3Rpb24gKGZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGZyYW1lLnZhcmlhYmxlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5pbXBvcnRhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudFNjb3BlID0gY29udGV4dC5pbXBvcnRhbnRTY29wZVtjb250ZXh0LmltcG9ydGFudFNjb3BlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnRTY29wZS5pbXBvcnRhbnQgPSB2LmltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaW4gY2FsYywgd3JhcCB2YXJzIGluIGEgZnVuY3Rpb24gY2FsbCB0byBjYXNjYWRlIGV2YWx1YXRlIGFyZ3MgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pbkNhbGMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgQ2FsbCgnX1NFTEYnLCBbdi52YWx1ZV0pKS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYudmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZhbHVhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsIG1lc3NhZ2U6IFwidmFyaWFibGUgXCIgKyBuYW1lICsgXCIgaXMgdW5kZWZpbmVkXCIsIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5kOiBmdW5jdGlvbiAob2JqLCBmdW4pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHIgPSB2b2lkIDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHIgPSBmdW4uY2FsbChvYmosIG9ialtpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGluZGV4LCBjdXJyZW50RmlsZUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1Byb3BlcnR5JyxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzaG9ydGVuIHRoaXMgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIHZhciBtZXJnZVJ1bGVzID0gY29udGV4dC5wbHVnaW5NYW5hZ2VyLmxlc3MudmlzaXRvcnMuVG9DU1NWaXNpdG9yLnByb3RvdHlwZS5fbWVyZ2VSdWxlcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZhbHVhdGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsIG1lc3NhZ2U6IFwiUmVjdXJzaXZlIHByb3BlcnR5IHJlZmVyZW5jZSBmb3IgXCIgKyBuYW1lLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuZmluZChjb250ZXh0LmZyYW1lcywgZnVuY3Rpb24gKGZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdjtcclxuICAgICAgICAgICAgICAgIHZhciB2QXJyID0gZnJhbWUucHJvcGVydHkobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodkFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdkFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdkFycltpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdkFycltpXSA9IG5ldyBEZWNsYXJhdGlvbih2Lm5hbWUsIHYudmFsdWUsIHYuaW1wb3J0YW50LCB2Lm1lcmdlLCB2LmluZGV4LCB2LmN1cnJlbnRGaWxlSW5mbywgdi5pbmxpbmUsIHYudmFyaWFibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtZXJnZVJ1bGVzKHZBcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSB2QXJyW3ZBcnIubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuaW1wb3J0YW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRhbnRTY29wZSA9IGNvbnRleHQuaW1wb3J0YW50U2NvcGVbY29udGV4dC5pbXBvcnRhbnRTY29wZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50U2NvcGUuaW1wb3J0YW50ID0gdi5pbXBvcnRhbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHYgPSB2LnZhbHVlLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZhbHVhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsIG1lc3NhZ2U6IFwiUHJvcGVydHkgJ1wiICsgbmFtZSArIFwiJyBpcyB1bmRlZmluZWRcIiwgZmlsZW5hbWU6IHRoaXMuY3VycmVudEZpbGVJbmZvLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChvYmosIGZ1bikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciA9IHZvaWQgMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgciA9IGZ1bi5jYWxsKG9iaiwgb2JqW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKGtleSwgb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ0F0dHJpYnV0ZScsXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUodGhpcy5rZXkuZXZhbCA/IHRoaXMua2V5LmV2YWwoY29udGV4dCkgOiB0aGlzLmtleSwgdGhpcy5vcCwgKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5ldmFsKSA/IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KSA6IHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQodGhpcy50b0NTUyhjb250ZXh0KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0NTUzogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5rZXkudG9DU1MgPyB0aGlzLmtleS50b0NTUyhjb250ZXh0KSA6IHRoaXMua2V5O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5vcDtcclxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICh0aGlzLnZhbHVlLnRvQ1NTID8gdGhpcy52YWx1ZS50b0NTUyhjb250ZXh0KSA6IHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIHZhbHVlICsgXCJdXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgUXVvdGVkID0gZnVuY3Rpb24gKHN0ciwgY29udGVudCwgZXNjYXBlZCwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IChlc2NhcGVkID09IG51bGwpID8gdHJ1ZSA6IGVzY2FwZWQ7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbnRlbnQgfHwgJyc7XHJcbiAgICAgICAgdGhpcy5xdW90ZSA9IHN0ci5jaGFyQXQoMCk7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLnZhcmlhYmxlUmVnZXggPSAvQFxceyhbXFx3LV0rKVxcfS9nO1xyXG4gICAgICAgIHRoaXMucHJvcFJlZ2V4ID0gL1xcJFxceyhbXFx3LV0rKVxcfS9nO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gZXNjYXBlZDtcclxuICAgIH07XHJcbiAgICBRdW90ZWQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1F1b3RlZCcsXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lc2NhcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMucXVvdGUsIHRoaXMuZmlsZUluZm8oKSwgdGhpcy5nZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZXNjYXBlZCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCh0aGlzLnF1b3RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGFpbnNWYXJpYWJsZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWF0Y2godGhpcy52YXJpYWJsZVJlZ2V4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAoXywgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgVmFyaWFibGUoXCJAXCIgKyBuYW1lLCB0aGF0LmdldEluZGV4KCksIHRoYXQuZmlsZUluZm8oKSkuZXZhbChjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodiBpbnN0YW5jZW9mIFF1b3RlZCkgPyB2LnZhbHVlIDogdi50b0NTUygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChfLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG5ldyBQcm9wZXJ0eShcIiRcIiArIG5hbWUsIHRoYXQuZ2V0SW5kZXgoKSwgdGhhdC5maWxlSW5mbygpKS5ldmFsKGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2IGluc3RhbmNlb2YgUXVvdGVkKSA/IHYudmFsdWUgOiB2LnRvQ1NTKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGl2ZVJlcGxhY2UodmFsdWUsIHJlZ2V4cCwgcmVwbGFjZW1lbnRGbmMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmFsdWF0ZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXZhbHVhdGVkVmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXhwLCByZXBsYWNlbWVudEZuYyk7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh2YWx1ZSAhPT0gZXZhbHVhdGVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlZFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0aXZlUmVwbGFjZSh2YWx1ZSwgdGhpcy52YXJpYWJsZVJlZ2V4LCB2YXJpYWJsZVJlcGxhY2VtZW50KTtcclxuICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRpdmVSZXBsYWNlKHZhbHVlLCB0aGlzLnByb3BSZWdleCwgcHJvcGVydHlSZXBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHRoaXMucXVvdGUgKyB2YWx1ZSArIHRoaXMucXVvdGUsIHZhbHVlLCB0aGlzLmVzY2FwZWQsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAvLyB3aGVuIGNvbXBhcmluZyBxdW90ZWQgc3RyaW5ncyBhbGxvdyB0aGUgcXVvdGUgdG8gZGlmZmVyXHJcbiAgICAgICAgICAgIGlmIChvdGhlci50eXBlID09PSAnUXVvdGVkJyAmJiAhdGhpcy5lc2NhcGVkICYmICFvdGhlci5lc2NhcGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTm9kZS5udW1lcmljQ29tcGFyZSh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIudG9DU1MgJiYgdGhpcy50b0NTUygpID09PSBvdGhlci50b0NTUygpID8gMCA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXNjYXBlUGF0aChwYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvW1xcKFxcKSdcIlxcc10vZywgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBcIlxcXFxcIiArIG1hdGNoOyB9KTtcclxuICAgIH1cclxuICAgIHZhciBVUkwgPSBmdW5jdGlvbiAodmFsLCBpbmRleCwgY3VycmVudEZpbGVJbmZvLCBpc0V2YWxkKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMuaXNFdmFsZCA9IGlzRXZhbGQ7XHJcbiAgICB9O1xyXG4gICAgVVJMLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdVcmwnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZpc2l0b3IudmlzaXQodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZW5DU1M6IGZ1bmN0aW9uIChjb250ZXh0LCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmFkZCgndXJsKCcpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKCcpJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdHBhdGg7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V2YWxkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJvb3RwYXRoIGlmIHRoZSBVUkwgcmVxdWlyZXMgYSByZXdyaXRlXHJcbiAgICAgICAgICAgICAgICByb290cGF0aCA9IHRoaXMuZmlsZUluZm8oKSAmJiB0aGlzLmZpbGVJbmZvKCkucm9vdHBhdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJvb3RwYXRoID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWwudmFsdWUgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoUmVxdWlyZXNSZXdyaXRlKHZhbC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbC5xdW90ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290cGF0aCA9IGVzY2FwZVBhdGgocm9vdHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgPSBjb250ZXh0LnJld3JpdGVQYXRoKHZhbC52YWx1ZSwgcm9vdHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlID0gY29udGV4dC5ub3JtYWxpemVQYXRoKHZhbC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdXJsIGFyZ3MgaWYgZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudXJsQXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsLnZhbHVlLm1hdGNoKC9eXFxzKmRhdGE6LykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGltaXRlciA9IHZhbC52YWx1ZS5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsQXJncyA9IGRlbGltaXRlciArIGNvbnRleHQudXJsQXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC52YWx1ZS5pbmRleE9mKCcjJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgPSB2YWwudmFsdWUucmVwbGFjZSgnIycsIHVybEFyZ3MgKyBcIiNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwudmFsdWUgKz0gdXJsQXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTCh2YWwsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBNZWRpYSA9IGZ1bmN0aW9uICh2YWx1ZSwgZmVhdHVyZXMsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB2YXIgc2VsZWN0b3JzID0gKG5ldyBTZWxlY3RvcihbXSwgbnVsbCwgbnVsbCwgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvKSkuY3JlYXRlRW1wdHlTZWxlY3RvcnMoKTtcclxuICAgICAgICB0aGlzLmZlYXR1cmVzID0gbmV3IFZhbHVlKGZlYXR1cmVzKTtcclxuICAgICAgICB0aGlzLnJ1bGVzID0gW25ldyBSdWxlc2V0KHNlbGVjdG9ycywgdmFsdWUpXTtcclxuICAgICAgICB0aGlzLnJ1bGVzWzBdLmFsbG93SW1wb3J0cyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFBhcmVudChzZWxlY3RvcnMsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuZmVhdHVyZXMsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMucnVsZXMsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1lZGlhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IEF0UnVsZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ01lZGlhJyxcclxuICAgICAgICBpc1J1bGVzZXRMaWtlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHZpc2l0b3IudmlzaXQodGhpcy5mZWF0dXJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVsZXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5ydWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKCdAbWVkaWEgJywgdGhpcy5fZmlsZUluZm8sIHRoaXMuX2luZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRSdWxlc2V0KGNvbnRleHQsIG91dHB1dCwgdGhpcy5ydWxlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQubWVkaWFCbG9ja3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubWVkaWFCbG9ja3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubWVkaWFQYXRoID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1lZGlhID0gbmV3IE1lZGlhKG51bGwsIFtdLCB0aGlzLl9pbmRleCwgdGhpcy5fZmlsZUluZm8sIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnSW5mbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydWxlc1swXS5kZWJ1Z0luZm8gPSB0aGlzLmRlYnVnSW5mbztcclxuICAgICAgICAgICAgICAgIG1lZGlhLmRlYnVnSW5mbyA9IHRoaXMuZGVidWdJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lZGlhLmZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcy5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1lZGlhUGF0aC5wdXNoKG1lZGlhKTtcclxuICAgICAgICAgICAgY29udGV4dC5tZWRpYUJsb2Nrcy5wdXNoKG1lZGlhKTtcclxuICAgICAgICAgICAgdGhpcy5ydWxlc1swXS5mdW5jdGlvblJlZ2lzdHJ5ID0gY29udGV4dC5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeS5pbmhlcml0KCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZnJhbWVzLnVuc2hpZnQodGhpcy5ydWxlc1swXSk7XHJcbiAgICAgICAgICAgIG1lZGlhLnJ1bGVzID0gW3RoaXMucnVsZXNbMF0uZXZhbChjb250ZXh0KV07XHJcbiAgICAgICAgICAgIGNvbnRleHQuZnJhbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubWVkaWFQYXRoLnBvcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5tZWRpYVBhdGgubGVuZ3RoID09PSAwID8gbWVkaWEuZXZhbFRvcChjb250ZXh0KSA6XHJcbiAgICAgICAgICAgICAgICBtZWRpYS5ldmFsTmVzdGVkKGNvbnRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbFRvcDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIFJlbmRlciBhbGwgZGVwZW5kZW50IE1lZGlhIGJsb2Nrcy5cclxuICAgICAgICAgICAgaWYgKGNvbnRleHQubWVkaWFCbG9ja3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9ycyA9IChuZXcgU2VsZWN0b3IoW10sIG51bGwsIG51bGwsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKSkuY3JlYXRlRW1wdHlTZWxlY3RvcnMoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSdWxlc2V0KHNlbGVjdG9ycywgY29udGV4dC5tZWRpYUJsb2Nrcyk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlNZWRpYSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuY29weVZpc2liaWxpdHlJbmZvKHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcmVudChyZXN1bHQsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0Lm1lZGlhQmxvY2tzO1xyXG4gICAgICAgICAgICBkZWxldGUgY29udGV4dC5tZWRpYVBhdGg7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsTmVzdGVkOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGNvbnRleHQubWVkaWFQYXRoLmNvbmNhdChbdGhpc10pO1xyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBtZWRpYS1xdWVyeSBjb25kaXRpb25zIHNlcGFyYXRlZCB3aXRoIGAsYCAoT1IpLlxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXRoW2ldLmZlYXR1cmVzIGluc3RhbmNlb2YgVmFsdWUgP1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhbaV0uZmVhdHVyZXMudmFsdWUgOiBwYXRoW2ldLmZlYXR1cmVzO1xyXG4gICAgICAgICAgICAgICAgcGF0aFtpXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRyYWNlIGFsbCBwZXJtdXRhdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHJlc3VsdGluZyBtZWRpYS1xdWVyeS5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gKGEsIGIgYW5kIGMpIHdpdGggbmVzdGVkIChkLCBlKSAtPlxyXG4gICAgICAgICAgICAvLyAgICBhIGFuZCBkXHJcbiAgICAgICAgICAgIC8vICAgIGEgYW5kIGVcclxuICAgICAgICAgICAgLy8gICAgYiBhbmQgYyBhbmQgZFxyXG4gICAgICAgICAgICAvLyAgICBiIGFuZCBjIGFuZCBlXHJcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgVmFsdWUodGhpcy5wZXJtdXRlKHBhdGgpLm1hcChmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gZnJhZ21lbnQudG9DU1MgPyBmcmFnbWVudCA6IG5ldyBBbm9ueW1vdXMoZnJhZ21lbnQpOyB9KTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGguc3BsaWNlKGksIDAsIG5ldyBBbm9ueW1vdXMoJ2FuZCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihwYXRoKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFBhcmVudCh0aGlzLmZlYXR1cmVzLCB0aGlzKTtcclxuICAgICAgICAgICAgLy8gRmFrZSBhIHRyZWUtbm9kZSB0aGF0IGRvZXNuJ3Qgb3V0cHV0IGFueXRoaW5nLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bGVzZXQoW10sIFtdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBlcm11dGU6IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnBlcm11dGUoYXJyLnNsaWNlKDEpKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyWzBdLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcnJbMF1bal1dLmNvbmNhdChyZXN0W2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnViYmxlU2VsZWN0b3JzOiBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ydWxlcyA9IFtuZXcgUnVsZXNldChjb3B5QXJyYXkoc2VsZWN0b3JzKSwgW3RoaXMucnVsZXNbMF1dKV07XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMucnVsZXMsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgLy9cclxuICAgIC8vIENTUyBAaW1wb3J0IG5vZGVcclxuICAgIC8vXHJcbiAgICAvLyBUaGUgZ2VuZXJhbCBzdHJhdGVneSBoZXJlIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byB3YWl0XHJcbiAgICAvLyBmb3IgdGhlIHBhcnNpbmcgdG8gYmUgY29tcGxldGVkLCBiZWZvcmUgd2Ugc3RhcnQgaW1wb3J0aW5nXHJcbiAgICAvLyB0aGUgZmlsZS4gVGhhdCdzIGJlY2F1c2UgaW4gdGhlIGNvbnRleHQgb2YgYSBicm93c2VyLFxyXG4gICAgLy8gbW9zdCBvZiB0aGUgdGltZSB3aWxsIGJlIHNwZW50IHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgdG8gcmVzcG9uZC5cclxuICAgIC8vXHJcbiAgICAvLyBPbiBjcmVhdGlvbiwgd2UgcHVzaCB0aGUgaW1wb3J0IHBhdGggdG8gb3VyIGltcG9ydCBxdWV1ZSwgdGhvdWdoXHJcbiAgICAvLyBgaW1wb3J0LHB1c2hgLCB3ZSBhbHNvIHBhc3MgaXQgYSBjYWxsYmFjaywgd2hpY2ggaXQnbGwgY2FsbCBvbmNlXHJcbiAgICAvLyB0aGUgZmlsZSBoYXMgYmVlbiBmZXRjaGVkLCBhbmQgcGFyc2VkLlxyXG4gICAgLy9cclxuICAgIHZhciBJbXBvcnQgPSBmdW5jdGlvbiAocGF0aCwgZmVhdHVyZXMsIG9wdGlvbnMsIGluZGV4LCBjdXJyZW50RmlsZUluZm8sIHZpc2liaWxpdHlJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxlc3MgIT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3NzID0gIXRoaXMub3B0aW9ucy5sZXNzIHx8IHRoaXMub3B0aW9ucy5pbmxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcGF0aFZhbHVlID0gdGhpcy5nZXRQYXRoKCk7XHJcbiAgICAgICAgICAgIGlmIChwYXRoVmFsdWUgJiYgL1sjXFwuXFwmXFw/XWNzcyhbXFw/O10uKik/JC8udGVzdChwYXRoVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNzcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3B5VmlzaWJpbGl0eUluZm8odmlzaWJpbGl0eUluZm8pO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuZmVhdHVyZXMsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMucGF0aCwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgSW1wb3J0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdJbXBvcnQnLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSB2aXNpdG9yLnZpc2l0KHRoaXMuZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHZpc2l0b3IudmlzaXQodGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNQbHVnaW4gJiYgIXRoaXMub3B0aW9ucy5pbmxpbmUgJiYgdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSB2aXNpdG9yLnZpc2l0KHRoaXMucm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jc3MgJiYgdGhpcy5wYXRoLl9maWxlSW5mby5yZWZlcmVuY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZCgnQGltcG9ydCAnLCB0aGlzLl9maWxlSW5mbywgdGhpcy5faW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLmdlbkNTUyhjb250ZXh0LCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dHB1dC5hZGQoJzsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UGF0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucGF0aCBpbnN0YW5jZW9mIFVSTCkgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLnZhbHVlLnZhbHVlIDogdGhpcy5wYXRoLnZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNWYXJpYWJsZUltcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBVUkwpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUXVvdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5jb250YWluc1ZhcmlhYmxlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbEZvckltcG9ydDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVVJMKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltcG9ydChwYXRoLmV2YWwoY29udGV4dCksIHRoaXMuZmVhdHVyZXMsIHRoaXMub3B0aW9ucywgdGhpcy5faW5kZXgsIHRoaXMuX2ZpbGVJbmZvLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbFBhdGg6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIHZhciBmaWxlSW5mbyA9IHRoaXMuX2ZpbGVJbmZvO1xyXG4gICAgICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgVVJMKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByb290cGF0aCBpZiB0aGUgVVJMIHJlcXVpcmVzIGEgcmV3cml0ZVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhWYWx1ZSA9IHBhdGgudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUluZm8gJiZcclxuICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGhSZXF1aXJlc1Jld3JpdGUocGF0aFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGgudmFsdWUgPSBjb250ZXh0LnJld3JpdGVQYXRoKHBhdGhWYWx1ZSwgZmlsZUluZm8ucm9vdHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC52YWx1ZSA9IGNvbnRleHQubm9ybWFsaXplUGF0aChwYXRoLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRvRXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2UgfHwgdGhpcy5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZFZpc2liaWxpdHlCbG9jaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZFZpc2liaWxpdHlCbG9jaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkb0V2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlc2V0O1xyXG4gICAgICAgICAgICB2YXIgcmVnaXN0cnk7XHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXMgJiYgdGhpcy5mZWF0dXJlcy5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzUGx1Z2luKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucm9vdC5ldmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9ICdQbHVnaW4gZXJyb3IgZHVyaW5nIGV2YWx1YXRpb24nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTGVzc0Vycm9yKGUsIHRoaXMucm9vdC5pbXBvcnRzLCB0aGlzLnJvb3QuZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlZ2lzdHJ5ID0gY29udGV4dC5mcmFtZXNbMF0gJiYgY29udGV4dC5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeSAmJiB0aGlzLnJvb3QgJiYgdGhpcy5yb290LmZ1bmN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJ5LmFkZE11bHRpcGxlKHRoaXMucm9vdC5mdW5jdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5za2lwID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwID0gdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBuZXcgQW5vbnltb3VzKHRoaXMucm9vdCwgMCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmltcG9ydGVkRmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiB0aGlzLnBhdGguX2ZpbGVJbmZvICYmIHRoaXMucGF0aC5fZmlsZUluZm8ucmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzID8gbmV3IE1lZGlhKFtjb250ZW50c10sIHRoaXMuZmVhdHVyZXMudmFsdWUpIDogW2NvbnRlbnRzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNzcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0ltcG9ydCA9IG5ldyBJbXBvcnQodGhpcy5ldmFsUGF0aChjb250ZXh0KSwgZmVhdHVyZXMsIHRoaXMub3B0aW9ucywgdGhpcy5faW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdJbXBvcnQuY3NzICYmIHRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0ltcG9ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXQgPSBuZXcgUnVsZXNldChudWxsLCBjb3B5QXJyYXkodGhpcy5yb290LnJ1bGVzKSk7XHJcbiAgICAgICAgICAgICAgICBydWxlc2V0LmV2YWxJbXBvcnRzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMgPyBuZXcgTWVkaWEocnVsZXNldC5ydWxlcywgdGhpcy5mZWF0dXJlcy52YWx1ZSkgOiBydWxlc2V0LnJ1bGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgSnNFdmFsTm9kZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIEpzRXZhbE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgZXZhbHVhdGVKYXZhU2NyaXB0OiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBldmFsQ29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuamF2YXNjcmlwdEVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogJ0lubGluZSBKYXZhU2NyaXB0IGlzIG5vdCBlbmFibGVkLiBJcyBpdCBzZXQgaW4geW91ciBvcHRpb25zPycsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSgvQFxceyhbXFx3LV0rKVxcfS9nLCBmdW5jdGlvbiAoXywgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuanNpZnkobmV3IFZhcmlhYmxlKFwiQFwiICsgbmFtZSwgdGhhdC5nZXRJbmRleCgpLCB0aGF0LmZpbGVJbmZvKCkpLmV2YWwoY29udGV4dCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gKFwiICsgZXhwcmVzc2lvbiArIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcIkphdmFTY3JpcHQgZXZhbHVhdGlvbiBlcnJvcjogXCIgKyBlLm1lc3NhZ2UgKyBcIiBmcm9tIGBcIiArIGV4cHJlc3Npb24gKyBcImBcIiwgZmlsZW5hbWU6IHRoaXMuZmlsZUluZm8oKS5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IGNvbnRleHQuZnJhbWVzWzBdLnZhcmlhYmxlcygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHZhcmlhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXHJcbiAgICAgICAgICAgICAgICAgICAgZXZhbENvbnRleHRbay5zbGljZSgxKV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YXJpYWJsZXNba10udmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvSlM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmV2YWwoY29udGV4dCkudG9DU1MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHJlc3Npb24uY2FsbChldmFsQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJKYXZhU2NyaXB0IGV2YWx1YXRpb24gZXJyb3I6ICdcIiArIGUubmFtZSArIFwiOiBcIiArIGUubWVzc2FnZS5yZXBsYWNlKC9bXCJdL2csICdcXCcnKSArIFwiJ1wiLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmdldEluZGV4KCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAganNpZnk6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnZhbHVlKSAmJiAob2JqLnZhbHVlLmxlbmd0aCA+IDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBvYmoudmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnRvQ1NTKCk7IH0pLmpvaW4oJywgJykgKyBcIl1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmoudG9DU1MoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIEphdmFTY3JpcHQgPSBmdW5jdGlvbiAoc3RyaW5nLCBlc2NhcGVkLCBpbmRleCwgY3VycmVudEZpbGVJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5lc2NhcGVkID0gZXNjYXBlZDtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBzdHJpbmc7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgIH07XHJcbiAgICBKYXZhU2NyaXB0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IEpzRXZhbE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdKYXZhU2NyaXB0JyxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUphdmFTY3JpcHQodGhpcy5leHByZXNzaW9uLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUXVvdGVkKFwiXFxcIlwiICsgcmVzdWx0ICsgXCJcXFwiXCIsIHJlc3VsdCwgdGhpcy5lc2NhcGVkLCB0aGlzLl9pbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhyZXN1bHQuam9pbignLCAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFub255bW91cyhyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgQXNzaWdubWVudCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XHJcbiAgICB9O1xyXG4gICAgQXNzaWdubWVudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQXNzaWdubWVudCcsXHJcbiAgICAgICAgYWNjZXB0OiBmdW5jdGlvbiAodmlzaXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmV2YWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXNzaWdubWVudCh0aGlzLmtleSwgdGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbkNTUzogZnVuY3Rpb24gKGNvbnRleHQsIG91dHB1dCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMua2V5ICsgXCI9XCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5nZW5DU1MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZ2VuQ1NTKGNvbnRleHQsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuYWRkKHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgQ29uZGl0aW9uID0gZnVuY3Rpb24gKG9wLCBsLCByLCBpLCBuZWdhdGUpIHtcclxuICAgICAgICB0aGlzLm9wID0gb3AudHJpbSgpO1xyXG4gICAgICAgIHRoaXMubHZhbHVlID0gbDtcclxuICAgICAgICB0aGlzLnJ2YWx1ZSA9IHI7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpO1xyXG4gICAgICAgIHRoaXMubmVnYXRlID0gbmVnYXRlO1xyXG4gICAgfTtcclxuICAgIENvbmRpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnQ29uZGl0aW9uJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubHZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLmx2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucnZhbHVlID0gdmlzaXRvci52aXNpdCh0aGlzLnJ2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uIChvcCwgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FuZCc6IHJldHVybiBhICYmIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3InOiByZXR1cm4gYSB8fCBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoTm9kZS5jb21wYXJlKGEsIGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcCA9PT0gJzwnIHx8IG9wID09PSAnPTwnIHx8IG9wID09PSAnPD0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8IG9wID09PSAnPj0nIHx8IG9wID09PSAnPTwnIHx8IG9wID09PSAnPD0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcCA9PT0gJz4nIHx8IG9wID09PSAnPj0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkodGhpcy5vcCwgdGhpcy5sdmFsdWUuZXZhbChjb250ZXh0KSwgdGhpcy5ydmFsdWUuZXZhbChjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSA/ICFyZXN1bHQgOiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgVW5pY29kZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgVW5pY29kZURlc2NyaXB0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1VuaWNvZGVEZXNjcmlwdG9yJ1xyXG4gICAgfSk7XG5cbiAgICB2YXIgTmVnYXRpdmUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBub2RlO1xyXG4gICAgfTtcclxuICAgIE5lZ2F0aXZlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwge1xyXG4gICAgICAgIHR5cGU6ICdOZWdhdGl2ZScsXHJcbiAgICAgICAgZ2VuQ1NTOiBmdW5jdGlvbiAoY29udGV4dCwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5hZGQoJy0nKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZS5nZW5DU1MoY29udGV4dCwgb3V0cHV0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmlzTWF0aE9uKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IE9wZXJhdGlvbignKicsIFtuZXcgRGltZW5zaW9uKC0xKSwgdGhpcy52YWx1ZV0pKS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmVnYXRpdmUodGhpcy52YWx1ZS5ldmFsKGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBFeHRlbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdGlvbiwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRpb247XHJcbiAgICAgICAgdGhpcy5vYmplY3RfaWQgPSBFeHRlbmQubmV4dF9pZCsrO1xyXG4gICAgICAgIHRoaXMucGFyZW50X2lkcyA9IFt0aGlzLm9iamVjdF9pZF07XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9maWxlSW5mbyA9IGN1cnJlbnRGaWxlSW5mbztcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93QmVmb3JlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dBZnRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dCZWZvcmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dBZnRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuc2VsZWN0b3IsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV4dGVuZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnRXh0ZW5kJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB2aXNpdG9yLnZpc2l0KHRoaXMuc2VsZWN0b3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHRlbmQodGhpcy5zZWxlY3Rvci5ldmFsKGNvbnRleHQpLCB0aGlzLm9wdGlvbiwgdGhpcy5nZXRJbmRleCgpLCB0aGlzLmZpbGVJbmZvKCksIHRoaXMudmlzaWJpbGl0eUluZm8oKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHRlbmQodGhpcy5zZWxlY3RvciwgdGhpcy5vcHRpb24sIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpLCB0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gaXQgY29uY2F0ZW5hdGVzIChqb2lucykgYWxsIHNlbGVjdG9ycyBpbiBzZWxlY3RvciBhcnJheVxyXG4gICAgICAgIGZpbmRTZWxmU2VsZWN0b3JzOiBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmRWxlbWVudHMgPSBbXSwgaSwgc2VsZWN0b3JFbGVtZW50cztcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JFbGVtZW50cyA9IHNlbGVjdG9yc1tpXS5lbGVtZW50cztcclxuICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSB0aGUgbG9naWMgaW4gZ2VuQ1NTIGZ1bmN0aW9uIGluc2lkZSB0aGUgc2VsZWN0b3Igbm9kZS5cclxuICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSBUT0RPIC0gbW92ZSBib3RoIGxvZ2ljcyBpbnRvIHRoZSBzZWxlY3RvciBqb2luZXIgdmlzaXRvclxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIHNlbGVjdG9yRWxlbWVudHMubGVuZ3RoICYmIHNlbGVjdG9yRWxlbWVudHNbMF0uY29tYmluYXRvci52YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvckVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPSAnICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmRWxlbWVudHMgPSBzZWxmRWxlbWVudHMuY29uY2F0KHNlbGVjdG9yc1tpXS5lbGVtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZWxmU2VsZWN0b3JzID0gW25ldyBTZWxlY3RvcihzZWxmRWxlbWVudHMpXTtcclxuICAgICAgICAgICAgdGhpcy5zZWxmU2VsZWN0b3JzWzBdLmNvcHlWaXNpYmlsaXR5SW5mbyh0aGlzLnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgRXh0ZW5kLm5leHRfaWQgPSAwO1xuXG4gICAgdmFyIFZhcmlhYmxlQ2FsbCA9IGZ1bmN0aW9uICh2YXJpYWJsZSwgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX2ZpbGVJbmZvID0gY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgIHRoaXMuYWxsb3dSb290ID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBWYXJpYWJsZUNhbGwucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB7XHJcbiAgICAgICAgdHlwZTogJ1ZhcmlhYmxlQ2FsbCcsXHJcbiAgICAgICAgZXZhbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzO1xyXG4gICAgICAgICAgICB2YXIgZGV0YWNoZWRSdWxlc2V0ID0gbmV3IFZhcmlhYmxlKHRoaXMudmFyaWFibGUsIHRoaXMuZ2V0SW5kZXgoKSwgdGhpcy5maWxlSW5mbygpKS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgTGVzc0Vycm9yKHsgbWVzc2FnZTogXCJDb3VsZCBub3QgZXZhbHVhdGUgdmFyaWFibGUgY2FsbCBcIiArIHRoaXMudmFyaWFibGUgfSk7XHJcbiAgICAgICAgICAgIGlmICghZGV0YWNoZWRSdWxlc2V0LnJ1bGVzZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZXRhY2hlZFJ1bGVzZXQucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IGRldGFjaGVkUnVsZXNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGV0YWNoZWRSdWxlc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gbmV3IFJ1bGVzZXQoJycsIGRldGFjaGVkUnVsZXNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRldGFjaGVkUnVsZXNldC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IG5ldyBSdWxlc2V0KCcnLCBkZXRhY2hlZFJ1bGVzZXQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZXRhY2hlZFJ1bGVzZXQgPSBuZXcgRGV0YWNoZWRSdWxlc2V0KHJ1bGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGV0YWNoZWRSdWxlc2V0LnJ1bGVzZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXRhY2hlZFJ1bGVzZXQuY2FsbEV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XG5cbiAgICB2YXIgTmFtZXNwYWNlVmFsdWUgPSBmdW5jdGlvbiAocnVsZUNhbGwsIGxvb2t1cHMsIGluZGV4LCBmaWxlSW5mbykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBydWxlQ2FsbDtcclxuICAgICAgICB0aGlzLmxvb2t1cHMgPSBsb29rdXBzO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBmaWxlSW5mbztcclxuICAgIH07XHJcbiAgICBOYW1lc3BhY2VWYWx1ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnTmFtZXNwYWNlVmFsdWUnLFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBuYW1lLCBydWxlcyA9IHRoaXMudmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubG9va3Vwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMubG9va3Vwc1tpXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRXZhbCdkIERScyByZXR1cm4gcnVsZXNldHMuXHJcbiAgICAgICAgICAgICAgICAgKiBFdmFsJ2QgbWl4aW5zIHJldHVybiBydWxlcywgc28gbGV0J3MgbWFrZSBhIHJ1bGVzZXQgaWYgd2UgbmVlZCBpdC5cclxuICAgICAgICAgICAgICAgICAqIFdlIG5lZWQgdG8gZG8gdGhpcyBiZWNhdXNlIG9mIGxhdGUgcGFyc2luZyBvZiB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBuZXcgUnVsZXNldChbbmV3IFNlbGVjdG9yKCldLCBydWxlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmxhc3REZWNsYXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICdAJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgxKSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIkBcIiArIG5ldyBWYXJpYWJsZShuYW1lLnN1YnN0cigxKSkuZXZhbChjb250ZXh0KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzLnZhcmlhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLnZhcmlhYmxlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ05hbWUnLCBtZXNzYWdlOiBcInZhcmlhYmxlIFwiICsgbmFtZSArIFwiIG5vdCBmb3VuZFwiLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0SW5kZXgoKSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLnN1YnN0cmluZygwLCAyKSA9PT0gJyRAJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCIkXCIgKyBuZXcgVmFyaWFibGUobmFtZS5zdWJzdHIoMSkpLmV2YWwoY29udGV4dCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5jaGFyQXQoMCkgPT09ICckJyA/IG5hbWUgOiBcIiRcIiArIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlcy5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMucHJvcGVydHkobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTmFtZScsIG1lc3NhZ2U6IFwicHJvcGVydHkgXFxcIlwiICsgbmFtZS5zdWJzdHIoMSkgKyBcIlxcXCIgbm90IGZvdW5kXCIsIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXRJbmRleCgpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgYXJlIGFuIGFycmF5IG9mIHZhbHVlcywgc2luY2UgYSBydWxlc2V0IGNhbiBoYXZlIG11bHRpcGxlIHByb3BzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHBpY2sgdGhlIGxhc3Qgb25lICh0aGUgXCJjYXNjYWRlZFwiIHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXNbcnVsZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZXMudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmV2YWwoY29udGV4dCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZXMucnVsZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMucnVsZXNldC5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlcztcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciBEZWZpbml0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtcywgcnVsZXMsIGNvbmRpdGlvbiwgdmFyaWFkaWMsIGZyYW1lcywgdmlzaWJpbGl0eUluZm8pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdhbm9ueW1vdXMgbWl4aW4nO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gW25ldyBTZWxlY3RvcihbbmV3IEVsZW1lbnQobnVsbCwgbmFtZSwgZmFsc2UsIHRoaXMuX2luZGV4LCB0aGlzLl9maWxlSW5mbyldKV07XHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy52YXJpYWRpYyA9IHZhcmlhZGljO1xyXG4gICAgICAgIHRoaXMuYXJpdHkgPSBwYXJhbXMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcclxuICAgICAgICB0aGlzLl9sb29rdXBzID0ge307XHJcbiAgICAgICAgdmFyIG9wdGlvbmFsUGFyYW1ldGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSBwYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcCkge1xyXG4gICAgICAgICAgICBpZiAoIXAubmFtZSB8fCAocC5uYW1lICYmICFwLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsUGFyYW1ldGVycy5wdXNoKHAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuICAgICAgICB0aGlzLm9wdGlvbmFsUGFyYW1ldGVycyA9IG9wdGlvbmFsUGFyYW1ldGVycztcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IGZyYW1lcztcclxuICAgICAgICB0aGlzLmNvcHlWaXNpYmlsaXR5SW5mbyh2aXNpYmlsaXR5SW5mbyk7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIERlZmluaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgUnVsZXNldCgpLCB7XHJcbiAgICAgICAgdHlwZTogJ01peGluRGVmaW5pdGlvbicsXHJcbiAgICAgICAgZXZhbEZpcnN0OiB0cnVlLFxyXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zICYmIHRoaXMucGFyYW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5wYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucnVsZXMgPSB2aXNpdG9yLnZpc2l0QXJyYXkodGhpcy5ydWxlcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25kaXRpb24gPSB2aXNpdG9yLnZpc2l0KHRoaXMuY29uZGl0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXZhbFBhcmFtczogZnVuY3Rpb24gKGNvbnRleHQsIG1peGluRW52LCBhcmdzLCBldmFsZEFyZ3VtZW50cykge1xyXG4gICAgICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXHJcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IG5ldyBSdWxlc2V0KG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgdmFyYXJncztcclxuICAgICAgICAgICAgdmFyIGFyZztcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGNvcHlBcnJheSh0aGlzLnBhcmFtcyk7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgIHZhciBpc05hbWVkRm91bmQ7XHJcbiAgICAgICAgICAgIHZhciBhcmdJbmRleDtcclxuICAgICAgICAgICAgdmFyIGFyZ3NMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBpZiAobWl4aW5FbnYuZnJhbWVzICYmIG1peGluRW52LmZyYW1lc1swXSAmJiBtaXhpbkVudi5mcmFtZXNbMF0uZnVuY3Rpb25SZWdpc3RyeSkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUuZnVuY3Rpb25SZWdpc3RyeSA9IG1peGluRW52LmZyYW1lc1swXS5mdW5jdGlvblJlZ2lzdHJ5LmluaGVyaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaXhpbkVudiA9IG5ldyBjb250ZXh0cy5FdmFsKG1peGluRW52LCBbZnJhbWVdLmNvbmNhdChtaXhpbkVudi5mcmFtZXMpKTtcclxuICAgICAgICAgICAgaWYgKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBjb3B5QXJyYXkoYXJncyk7XHJcbiAgICAgICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9IChhcmcgJiYgYXJnLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmFtZWRGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFyYW1zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2YWxkQXJndW1lbnRzW2pdICYmIG5hbWUgPT09IHBhcmFtc1tqXS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbGRBcmd1bWVudHNbal0gPSBhcmcudmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgRGVjbGFyYXRpb24obmFtZSwgYXJnLnZhbHVlLmV2YWwoY29udGV4dCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05hbWVkRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hbWVkRm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdSdW50aW1lJywgbWVzc2FnZTogXCJOYW1lZCBhcmd1bWVudCBmb3IgXCIgKyB0aGlzLm5hbWUgKyBcIiBcIiArIGFyZ3NbaV0ubmFtZSArIFwiIG5vdCBmb3VuZFwiIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZhbGRBcmd1bWVudHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3MgJiYgYXJnc1thcmdJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9IHBhcmFtc1tpXS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tpXS52YXJpYWRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGFyZ0luZGV4OyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJhcmdzLnB1c2goYXJnc1tqXS52YWx1ZS5ldmFsKGNvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgRGVjbGFyYXRpb24obmFtZSwgbmV3IEV4cHJlc3Npb24odmFyYXJncykuZXZhbChjb250ZXh0KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnICYmIGFyZy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgYSBtaXhpbiBjYWxsLCBwYXNzIGluIGEgZGV0YWNoZWQgcnVsZXNldCBvZiBpdCdzIGV2YWwnZCBydWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBEZXRhY2hlZFJ1bGVzZXQobmV3IFJ1bGVzZXQoJycsIHZhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLmV2YWwoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zW2ldLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJhbXNbaV0udmFsdWUuZXZhbChtaXhpbkVudik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5yZXNldENhY2hlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdSdW50aW1lJywgbWVzc2FnZTogXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBcIiArIHRoaXMubmFtZSArIFwiIChcIiArIGFyZ3NMZW5ndGggKyBcIiBmb3IgXCIgKyB0aGlzLmFyaXR5ICsgXCIpXCIgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5wcmVwZW5kUnVsZShuZXcgRGVjbGFyYXRpb24obmFtZSwgdmFsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2ldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbaV0udmFyaWFkaWMgJiYgYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGFyZ0luZGV4OyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxkQXJndW1lbnRzW2pdID0gYXJnc1tqXS52YWx1ZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFrZUltcG9ydGFudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSAhdGhpcy5ydWxlcyA/IHRoaXMucnVsZXMgOiB0aGlzLnJ1bGVzLm1hcChmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIubWFrZUltcG9ydGFudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByLm1ha2VJbXBvcnRhbnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGVmaW5pdGlvbih0aGlzLm5hbWUsIHRoaXMucGFyYW1zLCBydWxlcywgdGhpcy5jb25kaXRpb24sIHRoaXMudmFyaWFkaWMsIHRoaXMuZnJhbWVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVmaW5pdGlvbih0aGlzLm5hbWUsIHRoaXMucGFyYW1zLCB0aGlzLnJ1bGVzLCB0aGlzLmNvbmRpdGlvbiwgdGhpcy52YXJpYWRpYywgdGhpcy5mcmFtZXMgfHwgY29weUFycmF5KGNvbnRleHQuZnJhbWVzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBldmFsQ2FsbDogZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MsIGltcG9ydGFudCkge1xyXG4gICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbWl4aW5GcmFtZXMgPSB0aGlzLmZyYW1lcyA/IHRoaXMuZnJhbWVzLmNvbmNhdChjb250ZXh0LmZyYW1lcykgOiBjb250ZXh0LmZyYW1lcztcclxuICAgICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5ldmFsUGFyYW1zKGNvbnRleHQsIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIG1peGluRnJhbWVzKSwgYXJncywgX2FyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciBydWxlcztcclxuICAgICAgICAgICAgdmFyIHJ1bGVzZXQ7XHJcbiAgICAgICAgICAgIGZyYW1lLnByZXBlbmRSdWxlKG5ldyBEZWNsYXJhdGlvbignQGFyZ3VtZW50cycsIG5ldyBFeHByZXNzaW9uKF9hcmd1bWVudHMpLmV2YWwoY29udGV4dCkpKTtcclxuICAgICAgICAgICAgcnVsZXMgPSBjb3B5QXJyYXkodGhpcy5ydWxlcyk7XHJcbiAgICAgICAgICAgIHJ1bGVzZXQgPSBuZXcgUnVsZXNldChudWxsLCBydWxlcyk7XHJcbiAgICAgICAgICAgIHJ1bGVzZXQub3JpZ2luYWxSdWxlc2V0ID0gdGhpcztcclxuICAgICAgICAgICAgcnVsZXNldCA9IHJ1bGVzZXQuZXZhbChuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCBbdGhpcywgZnJhbWVdLmNvbmNhdChtaXhpbkZyYW1lcykpKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudCkge1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldCA9IHJ1bGVzZXQubWFrZUltcG9ydGFudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlc2V0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF0Y2hDb25kaXRpb246IGZ1bmN0aW9uIChhcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbiAmJiAhdGhpcy5jb25kaXRpb24uZXZhbChuZXcgY29udGV4dHMuRXZhbChjb250ZXh0LCBbdGhpcy5ldmFsUGFyYW1zKGNvbnRleHQsIC8qIHRoZSBwYXJhbWV0ZXIgdmFyaWFibGVzICovIG5ldyBjb250ZXh0cy5FdmFsKGNvbnRleHQsIHRoaXMuZnJhbWVzID8gdGhpcy5mcmFtZXMuY29uY2F0KGNvbnRleHQuZnJhbWVzKSA6IGNvbnRleHQuZnJhbWVzKSwgYXJncywgW10pXVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmZyYW1lcyB8fCBbXSkgLy8gdGhlIHBhcmVudCBuYW1lc3BhY2UvbWl4aW4gZnJhbWVzXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KGNvbnRleHQuZnJhbWVzKSkpKSB7IC8vIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGZyYW1lc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF0Y2hBcmdzOiBmdW5jdGlvbiAoYXJncywgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgYWxsQXJnc0NudCA9IChhcmdzICYmIGFyZ3MubGVuZ3RoKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgbGVuO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbWV0ZXJzID0gdGhpcy5vcHRpb25hbFBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIHZhciByZXF1aXJlZEFyZ3NDbnQgPSAhYXJncyA/IDAgOiBhcmdzLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIHApIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbFBhcmFtZXRlcnMuaW5kZXhPZihwLm5hbWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFyaWFkaWMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZEFyZ3NDbnQgPCB0aGlzLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFsbEFyZ3NDbnQgPiB0aGlzLnBhcmFtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRBcmdzQ250IDwgKHRoaXMucmVxdWlyZWQgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayBwYXR0ZXJuc1xyXG4gICAgICAgICAgICBsZW4gPSBNYXRoLm1pbihyZXF1aXJlZEFyZ3NDbnQsIHRoaXMuYXJpdHkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyYW1zW2ldLm5hbWUgJiYgIXRoaXMucGFyYW1zW2ldLnZhcmlhZGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbaV0udmFsdWUuZXZhbChjb250ZXh0KS50b0NTUygpICE9IHRoaXMucGFyYW1zW2ldLnZhbHVlLmV2YWwoY29udGV4dCkudG9DU1MoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIE1peGluQ2FsbCA9IGZ1bmN0aW9uIChlbGVtZW50cywgYXJncywgaW5kZXgsIGN1cnJlbnRGaWxlSW5mbywgaW1wb3J0YW50KSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IG5ldyBTZWxlY3RvcihlbGVtZW50cyk7XHJcbiAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5fZmlsZUluZm8gPSBjdXJyZW50RmlsZUluZm87XHJcbiAgICAgICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQ7XHJcbiAgICAgICAgdGhpcy5hbGxvd1Jvb3QgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KHRoaXMuc2VsZWN0b3IsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1peGluQ2FsbC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHtcclxuICAgICAgICB0eXBlOiAnTWl4aW5DYWxsJyxcclxuICAgICAgICBhY2NlcHQ6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmlzaXRvci52aXNpdCh0aGlzLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IHZpc2l0b3IudmlzaXRBcnJheSh0aGlzLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV2YWw6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBtaXhpbnM7XHJcbiAgICAgICAgICAgIHZhciBtaXhpbjtcclxuICAgICAgICAgICAgdmFyIG1peGluUGF0aDtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGFyZztcclxuICAgICAgICAgICAgdmFyIGFyZ1ZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICB2YXIgbTtcclxuICAgICAgICAgICAgdmFyIGY7XHJcbiAgICAgICAgICAgIHZhciBpc1JlY3Vyc2l2ZTtcclxuICAgICAgICAgICAgdmFyIGlzT25lRm91bmQ7XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGU7XHJcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25SZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRSZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciBkZWZGYWxzZUVpdGhlckNhc2UgPSAtMTtcclxuICAgICAgICAgICAgdmFyIGRlZk5vbmUgPSAwO1xyXG4gICAgICAgICAgICB2YXIgZGVmVHJ1ZSA9IDE7XHJcbiAgICAgICAgICAgIHZhciBkZWZGYWxzZSA9IDI7XHJcbiAgICAgICAgICAgIHZhciBjb3VudDtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsUnVsZXNldDtcclxuICAgICAgICAgICAgdmFyIG5vQXJndW1lbnRzRmlsdGVyO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvci5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxjRGVmR3JvdXAobWl4aW4sIG1peGluUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYsIHAsIG5hbWVzcGFjZTtcclxuICAgICAgICAgICAgICAgIGZvciAoZiA9IDA7IGYgPCAyOyBmKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHRbZl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRGdW5jLnZhbHVlKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBtaXhpblBhdGgubGVuZ3RoICYmIGNvbmRpdGlvblJlc3VsdFtmXTsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG1peGluUGF0aFtwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZS5tYXRjaENvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0W2ZdID0gY29uZGl0aW9uUmVzdWx0W2ZdICYmIG5hbWVzcGFjZS5tYXRjaENvbmRpdGlvbihudWxsLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWl4aW4ubWF0Y2hDb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0W2ZdID0gY29uZGl0aW9uUmVzdWx0W2ZdICYmIG1peGluLm1hdGNoQ29uZGl0aW9uKGFyZ3MsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHRbMF0gfHwgY29uZGl0aW9uUmVzdWx0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdFswXSAhPSBjb25kaXRpb25SZXN1bHRbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvblJlc3VsdFsxXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZUcnVlIDogZGVmRmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZOb25lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZkZhbHNlRWl0aGVyQ2FzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMuYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgYXJnVmFsdWUgPSBhcmcudmFsdWUuZXZhbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmcuZXhwYW5kICYmIEFycmF5LmlzQXJyYXkoYXJnVmFsdWUudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnVmFsdWUgPSBhcmdWYWx1ZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgYXJnVmFsdWUubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHsgdmFsdWU6IGFyZ1ZhbHVlW21dIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IG5hbWU6IGFyZy5uYW1lLCB2YWx1ZTogYXJnVmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9Bcmd1bWVudHNGaWx0ZXIgPSBmdW5jdGlvbiAocnVsZSkgeyByZXR1cm4gcnVsZS5tYXRjaEFyZ3MobnVsbCwgY29udGV4dCk7IH07XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0LmZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChtaXhpbnMgPSBjb250ZXh0LmZyYW1lc1tpXS5maW5kKHRoaXMuc2VsZWN0b3IsIG51bGwsIG5vQXJndW1lbnRzRmlsdGVyKSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzT25lRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIG1ha2UgYGRlZmF1bHQoKWAgZnVuY3Rpb24gaW5kZXBlbmRlbnQgb2YgZGVmaW5pdGlvbiBvcmRlciB3ZSBoYXZlIHR3byBcInN1YnBhc3Nlc1wiIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgZmlyc3Qgd2UgZXZhbHVhdGUgZWFjaCBndWFyZCAqdHdpY2UqICh3aXRoIGBkZWZhdWx0KCkgPT0gdHJ1ZWAgYW5kIGBkZWZhdWx0KCkgPT0gZmFsc2VgKSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYnVpbGQgY2FuZGlkYXRlIGxpc3Qgd2l0aCBjb3JyZXNwb25kaW5nIGZsYWdzLiBUaGVuLCB3aGVuIHdlIGtub3cgYWxsIHBvc3NpYmxlIG1hdGNoZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbWFrZSBhIGZpbmFsIGRlY2lzaW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBtaXhpbnMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4gPSBtaXhpbnNbbV0ucnVsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW5QYXRoID0gbWl4aW5zW21dLnBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVjdXJzaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoZiA9IDA7IGYgPCBjb250ZXh0LmZyYW1lcy5sZW5ndGg7IGYrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCghKG1peGluIGluc3RhbmNlb2YgRGVmaW5pdGlvbikpICYmIG1peGluID09PSAoY29udGV4dC5mcmFtZXNbZl0ub3JpZ2luYWxSdWxlc2V0IHx8IGNvbnRleHQuZnJhbWVzW2ZdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVjdXJzaXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWN1cnNpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXhpbi5tYXRjaEFyZ3MoYXJncywgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IHsgbWl4aW46IG1peGluLCBncm91cDogY2FsY0RlZkdyb3VwKG1peGluLCBtaXhpblBhdGgpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmdyb3VwICE9PSBkZWZGYWxzZUVpdGhlckNhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RnVuYy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gWzAsIDAsIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBjYW5kaWRhdGVzLmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50W2NhbmRpZGF0ZXNbbV0uZ3JvdXBdKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudFtkZWZOb25lXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFJlc3VsdCA9IGRlZkZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFJlc3VsdCA9IGRlZlRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRbZGVmVHJ1ZV0gKyBjb3VudFtkZWZGYWxzZV0pID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnUnVudGltZScsIG1lc3NhZ2U6IFwiQW1iaWd1b3VzIHVzZSBvZiBgZGVmYXVsdCgpYCBmb3VuZCB3aGVuIG1hdGNoaW5nIGZvciBgXCIgKyB0aGlzLmZvcm1hdChhcmdzKSArIFwiYFwiLCBpbmRleDogdGhpcy5nZXRJbmRleCgpLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMDsgbSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1ttXS5ncm91cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUgPT09IGRlZk5vbmUpIHx8IChjYW5kaWRhdGUgPT09IGRlZmF1bHRSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peGluID0gY2FuZGlkYXRlc1ttXS5taXhpbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtaXhpbiBpbnN0YW5jZW9mIERlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUnVsZXNldCA9IG1peGluLm9yaWdpbmFsUnVsZXNldCB8fCBtaXhpbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWl4aW4gPSBuZXcgRGVmaW5pdGlvbignJywgW10sIG1peGluLnJ1bGVzLCBudWxsLCBmYWxzZSwgbnVsbCwgb3JpZ2luYWxSdWxlc2V0LnZpc2liaWxpdHlJbmZvKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXhpbi5vcmlnaW5hbFJ1bGVzZXQgPSBvcmlnaW5hbFJ1bGVzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdSdWxlcyA9IG1peGluLmV2YWxDYWxsKGNvbnRleHQsIGFyZ3MsIHRoaXMuaW1wb3J0YW50KS5ydWxlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5VG9SZXBsYWNlbWVudChuZXdSdWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocnVsZXMsIG5ld1J1bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBlLm1lc3NhZ2UsIGluZGV4OiB0aGlzLmdldEluZGV4KCksIGZpbGVuYW1lOiB0aGlzLmZpbGVJbmZvKCkuZmlsZW5hbWUsIHN0YWNrOiBlLnN0YWNrIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzT25lRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ1J1bnRpbWUnLCBtZXNzYWdlOiBcIk5vIG1hdGNoaW5nIGRlZmluaXRpb24gd2FzIGZvdW5kIGZvciBgXCIgKyB0aGlzLmZvcm1hdChhcmdzKSArIFwiYFwiLCBpbmRleDogdGhpcy5nZXRJbmRleCgpLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdOYW1lJywgbWVzc2FnZTogdGhpcy5zZWxlY3Rvci50b0NTUygpLnRyaW0oKSArIFwiIGlzIHVuZGVmaW5lZFwiLCBpbmRleDogdGhpcy5nZXRJbmRleCgpLCBmaWxlbmFtZTogdGhpcy5maWxlSW5mbygpLmZpbGVuYW1lIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zZXRWaXNpYmlsaXR5VG9SZXBsYWNlbWVudDogZnVuY3Rpb24gKHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBydWxlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBsYWNlbWVudC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUgPSByZXBsYWNlbWVudFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBydWxlLmFkZFZpc2liaWxpdHlCbG9jaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yLnRvQ1NTKCkudHJpbSgpICsgXCIoXCIgKyAoYXJncyA/IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnVmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIGlmIChhLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZSArPSBhLm5hbWUgKyBcIjpcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhLnZhbHVlLnRvQ1NTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnVmFsdWUgKz0gYS52YWx1ZS50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnVmFsdWUgKz0gJz8/Pyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVmFsdWU7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJywgJykgOiAnJykgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcblxuICAgIHZhciB0cmVlID0ge1xyXG4gICAgICAgIE5vZGU6IE5vZGUsIENvbG9yOiBDb2xvciwgQXRSdWxlOiBBdFJ1bGUsIERldGFjaGVkUnVsZXNldDogRGV0YWNoZWRSdWxlc2V0LCBPcGVyYXRpb246IE9wZXJhdGlvbixcclxuICAgICAgICBEaW1lbnNpb246IERpbWVuc2lvbiwgVW5pdDogVW5pdCwgS2V5d29yZDogS2V5d29yZCwgVmFyaWFibGU6IFZhcmlhYmxlLCBQcm9wZXJ0eTogUHJvcGVydHksXHJcbiAgICAgICAgUnVsZXNldDogUnVsZXNldCwgRWxlbWVudDogRWxlbWVudCwgQXR0cmlidXRlOiBBdHRyaWJ1dGUsIENvbWJpbmF0b3I6IENvbWJpbmF0b3IsIFNlbGVjdG9yOiBTZWxlY3RvcixcclxuICAgICAgICBRdW90ZWQ6IFF1b3RlZCwgRXhwcmVzc2lvbjogRXhwcmVzc2lvbiwgRGVjbGFyYXRpb246IERlY2xhcmF0aW9uLCBDYWxsOiBDYWxsLCBVUkw6IFVSTCwgSW1wb3J0OiBJbXBvcnQsXHJcbiAgICAgICAgQ29tbWVudDogQ29tbWVudCwgQW5vbnltb3VzOiBBbm9ueW1vdXMsIFZhbHVlOiBWYWx1ZSwgSmF2YVNjcmlwdDogSmF2YVNjcmlwdCwgQXNzaWdubWVudDogQXNzaWdubWVudCxcclxuICAgICAgICBDb25kaXRpb246IENvbmRpdGlvbiwgUGFyZW46IFBhcmVuLCBNZWRpYTogTWVkaWEsIFVuaWNvZGVEZXNjcmlwdG9yOiBVbmljb2RlRGVzY3JpcHRvciwgTmVnYXRpdmU6IE5lZ2F0aXZlLFxyXG4gICAgICAgIEV4dGVuZDogRXh0ZW5kLCBWYXJpYWJsZUNhbGw6IFZhcmlhYmxlQ2FsbCwgTmFtZXNwYWNlVmFsdWU6IE5hbWVzcGFjZVZhbHVlLFxyXG4gICAgICAgIG1peGluOiB7XHJcbiAgICAgICAgICAgIENhbGw6IE1peGluQ2FsbCxcclxuICAgICAgICAgICAgRGVmaW5pdGlvbjogRGVmaW5pdGlvblxyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgQWJzdHJhY3RGaWxlTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdEZpbGVNYW5hZ2VyKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJz8nKTtcclxuICAgICAgICAgICAgaWYgKGogPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNsaWNlKDAsIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGogPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignLycpO1xyXG4gICAgICAgICAgICBpZiAoaiA8IDApIHtcclxuICAgICAgICAgICAgICAgIGogPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignXFxcXCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChqIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmaWxlbmFtZS5zbGljZSgwLCBqICsgMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS50cnlBcHBlbmRFeHRlbnNpb24gPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAvKFxcLlthLXpdKiQpfChbXFw/O10uKikkLy50ZXN0KHBhdGgpID8gcGF0aCA6IHBhdGggKyBleHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS50cnlBcHBlbmRMZXNzRXh0ZW5zaW9uID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ5QXBwZW5kRXh0ZW5zaW9uKHBhdGgsICcubGVzcycpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuc3VwcG9ydHNTeW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdEZpbGVNYW5hZ2VyLnByb3RvdHlwZS5hbHdheXNNYWtlUGF0aHNBYnNvbHV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuaXNQYXRoQWJzb2x1dGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgvXig/OlthLXotXSs6fFxcL3xcXFxcfCMpL2kpLnRlc3QoZmlsZW5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVE9ETzogcHVsbCBvdXQgLyByZXBsYWNlP1xyXG4gICAgICAgIEFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAoYmFzZVBhdGgsIGxhdGVyUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoIWJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXJQYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlUGF0aCArIGxhdGVyUGF0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0RmlsZU1hbmFnZXIucHJvdG90eXBlLnBhdGhEaWZmID0gZnVuY3Rpb24gKHVybCwgYmFzZVVybCkge1xyXG4gICAgICAgICAgICAvLyBkaWZmIGJldHdlZW4gdHdvIHBhdGhzIHRvIGNyZWF0ZSBhIHJlbGF0aXZlIHBhdGhcclxuICAgICAgICAgICAgdmFyIHVybFBhcnRzID0gdGhpcy5leHRyYWN0VXJsUGFydHModXJsKTtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxQYXJ0cyA9IHRoaXMuZXh0cmFjdFVybFBhcnRzKGJhc2VVcmwpO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIG1heDtcclxuICAgICAgICAgICAgdmFyIHVybERpcmVjdG9yaWVzO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybERpcmVjdG9yaWVzO1xyXG4gICAgICAgICAgICB2YXIgZGlmZiA9ICcnO1xyXG4gICAgICAgICAgICBpZiAodXJsUGFydHMuaG9zdFBhcnQgIT09IGJhc2VVcmxQYXJ0cy5ob3N0UGFydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KGJhc2VVcmxQYXJ0cy5kaXJlY3Rvcmllcy5sZW5ndGgsIHVybFBhcnRzLmRpcmVjdG9yaWVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VVcmxQYXJ0cy5kaXJlY3Rvcmllc1tpXSAhPT0gdXJsUGFydHMuZGlyZWN0b3JpZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYXNlVXJsRGlyZWN0b3JpZXMgPSBiYXNlVXJsUGFydHMuZGlyZWN0b3JpZXMuc2xpY2UoaSk7XHJcbiAgICAgICAgICAgIHVybERpcmVjdG9yaWVzID0gdXJsUGFydHMuZGlyZWN0b3JpZXMuc2xpY2UoaSk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlVXJsRGlyZWN0b3JpZXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmICs9ICcuLi8nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB1cmxEaXJlY3Rvcmllcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgKz0gdXJsRGlyZWN0b3JpZXNbaV0gKyBcIi9cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGhlbHBlciBmdW5jdGlvbiwgbm90IHBhcnQgb2YgQVBJXHJcbiAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlci5wcm90b3R5cGUuZXh0cmFjdFVybFBhcnRzID0gZnVuY3Rpb24gKHVybCwgYmFzZVVybCkge1xyXG4gICAgICAgICAgICAvLyB1cmxQYXJ0c1sxXSA9IHByb3RvY29sOi8vaG9zdG5hbWUvIE9SIC9cclxuICAgICAgICAgICAgLy8gdXJsUGFydHNbMl0gPSAvIGlmIHBhdGggcmVsYXRpdmUgdG8gaG9zdCBiYXNlXHJcbiAgICAgICAgICAgIC8vIHVybFBhcnRzWzNdID0gZGlyZWN0b3JpZXNcclxuICAgICAgICAgICAgLy8gdXJsUGFydHNbNF0gPSBmaWxlbmFtZVxyXG4gICAgICAgICAgICAvLyB1cmxQYXJ0c1s1XSA9IHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgdmFyIHVybFBhcnRzUmVnZXggPSAvXigoPzpbYS16LV0rOik/XFwvezJ9KD86W15cXC9cXD8jXSpcXC8pfChbXFwvXFxcXF0pKT8oKD86W15cXC9cXFxcXFw/I10qW1xcL1xcXFxdKSopKFteXFwvXFxcXFxcPyNdKikoWyNcXD9dLiopPyQvaTtcclxuICAgICAgICAgICAgdmFyIHVybFBhcnRzID0gdXJsLm1hdGNoKHVybFBhcnRzUmVnZXgpO1xyXG4gICAgICAgICAgICB2YXIgcmV0dXJuZXIgPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJhd0RpcmVjdG9yaWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBkaXJlY3RvcmllcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxQYXJ0cztcclxuICAgICAgICAgICAgaWYgKCF1cmxQYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHNoZWV0IGhyZWYgLSAnXCIgKyB1cmwgKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3R5bGVzaGVldHMgaW4gSUUgZG9uJ3QgYWx3YXlzIHJldHVybiB0aGUgZnVsbCBwYXRoXHJcbiAgICAgICAgICAgIGlmIChiYXNlVXJsICYmICghdXJsUGFydHNbMV0gfHwgdXJsUGFydHNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsUGFydHMgPSBiYXNlVXJsLm1hdGNoKHVybFBhcnRzUmVnZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlVXJsUGFydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgcGFnZSB1cmwgLSAnXCIgKyBiYXNlVXJsICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXJsUGFydHNbMV0gPSB1cmxQYXJ0c1sxXSB8fCBiYXNlVXJsUGFydHNbMV0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVybFBhcnRzWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsUGFydHNbM10gPSBiYXNlVXJsUGFydHNbM10gKyB1cmxQYXJ0c1szXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXJsUGFydHNbM10pIHtcclxuICAgICAgICAgICAgICAgIHJhd0RpcmVjdG9yaWVzID0gdXJsUGFydHNbM10ucmVwbGFjZSgvXFxcXC9nLCAnLycpLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSAnLi4nIGFuZCBza2lwICcuJ1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhd0RpcmVjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0RpcmVjdG9yaWVzW2ldID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdEaXJlY3Rvcmllc1tpXSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzLnB1c2gocmF3RGlyZWN0b3JpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm5lci5ob3N0UGFydCA9IHVybFBhcnRzWzFdO1xyXG4gICAgICAgICAgICByZXR1cm5lci5kaXJlY3RvcmllcyA9IGRpcmVjdG9yaWVzO1xyXG4gICAgICAgICAgICByZXR1cm5lci5yYXdQYXRoID0gKHVybFBhcnRzWzFdIHx8ICcnKSArIHJhd0RpcmVjdG9yaWVzLmpvaW4oJy8nKTtcclxuICAgICAgICAgICAgcmV0dXJuZXIucGF0aCA9ICh1cmxQYXJ0c1sxXSB8fCAnJykgKyBkaXJlY3Rvcmllcy5qb2luKCcvJyk7XHJcbiAgICAgICAgICAgIHJldHVybmVyLmZpbGVuYW1lID0gdXJsUGFydHNbNF07XHJcbiAgICAgICAgICAgIHJldHVybmVyLmZpbGVVcmwgPSByZXR1cm5lci5wYXRoICsgKHVybFBhcnRzWzRdIHx8ICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuZXIudXJsID0gcmV0dXJuZXIuZmlsZVVybCArICh1cmxQYXJ0c1s1XSB8fCAnJyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5lcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBYnN0cmFjdEZpbGVNYW5hZ2VyO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBBYnN0cmFjdFBsdWdpbkxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdFBsdWdpbkxvYWRlcigpIHtcclxuICAgICAgICAgICAgLy8gSW1wbGVtZW50ZWQgYnkgTm9kZS5qcyBwbHVnaW4gbG9hZGVyXHJcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlci5wcm90b3R5cGUuZXZhbFBsdWdpbiA9IGZ1bmN0aW9uIChjb250ZW50cywgY29udGV4dCwgaW1wb3J0cywgcGx1Z2luT3B0aW9ucywgZmlsZUluZm8pIHtcclxuICAgICAgICAgICAgdmFyIGxvYWRlciwgcmVnaXN0cnksIHBsdWdpbk9iaiwgbG9jYWxNb2R1bGUsIHBsdWdpbk1hbmFnZXIsIGZpbGVuYW1lLCByZXN1bHQ7XHJcbiAgICAgICAgICAgIHBsdWdpbk1hbmFnZXIgPSBjb250ZXh0LnBsdWdpbk1hbmFnZXI7XHJcbiAgICAgICAgICAgIGlmIChmaWxlSW5mbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlSW5mbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlSW5mby5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2hvcnRuYW1lID0gKG5ldyB0aGlzLmxlc3MuRmlsZU1hbmFnZXIoKSkuZXh0cmFjdFVybFBhcnRzKGZpbGVuYW1lKS5maWxlbmFtZTtcclxuICAgICAgICAgICAgaWYgKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW5PYmogPSBwbHVnaW5NYW5hZ2VyLmdldChmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy50cnlTZXRPcHRpb25zKHBsdWdpbk9iaiwgZmlsZW5hbWUsIHNob3J0bmFtZSwgcGx1Z2luT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luT2JqLnVzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luT2JqLnVzZS5jYWxsKHRoaXMuY29udGV4dCwgcGx1Z2luT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBlLm1lc3NhZ2UgfHwgJ0Vycm9yIGR1cmluZyBAcGx1Z2luIGNhbGwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5PYmo7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9jYWxNb2R1bGUgPSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzOiB7fSxcclxuICAgICAgICAgICAgICAgIHBsdWdpbk1hbmFnZXI6IHBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBmaWxlSW5mbzogZmlsZUluZm9cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVnaXN0cnkgPSBmdW5jdGlvblJlZ2lzdHJ5LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW5PYmogPSBvYmo7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkZXIgPSBuZXcgRnVuY3Rpb24oJ21vZHVsZScsICdyZXF1aXJlJywgJ3JlZ2lzdGVyUGx1Z2luJywgJ2Z1bmN0aW9ucycsICd0cmVlJywgJ2xlc3MnLCAnZmlsZUluZm8nLCBjb250ZW50cyk7XHJcbiAgICAgICAgICAgICAgICBsb2FkZXIobG9jYWxNb2R1bGUsIHRoaXMucmVxdWlyZShmaWxlbmFtZSksIHJlZ2lzdGVyUGx1Z2luLCByZWdpc3RyeSwgdGhpcy5sZXNzLnRyZWUsIHRoaXMubGVzcywgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFwbHVnaW5PYmopIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbk9iaiA9IGxvY2FsTW9kdWxlLmV4cG9ydHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGx1Z2luT2JqID0gdGhpcy52YWxpZGF0ZVBsdWdpbihwbHVnaW5PYmosIGZpbGVuYW1lLCBzaG9ydG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAocGx1Z2luT2JqIGluc3RhbmNlb2YgTGVzc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW5PYmopIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbk9iai5pbXBvcnRzID0gaW1wb3J0cztcclxuICAgICAgICAgICAgICAgIHBsdWdpbk9iai5maWxlbmFtZSA9IGZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIDwgMy54IChvciB1bnNwZWNpZmllZCBtaW5WZXJzaW9uKSAtIHNldE9wdGlvbnMoKSBiZWZvcmUgaW5zdGFsbCgpXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBsdWdpbk9iai5taW5WZXJzaW9uIHx8IHRoaXMuY29tcGFyZVZlcnNpb24oJzMuMC4wJywgcGx1Z2luT2JqLm1pblZlcnNpb24pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudHJ5U2V0T3B0aW9ucyhwbHVnaW5PYmosIGZpbGVuYW1lLCBzaG9ydG5hbWUsIHBsdWdpbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSdW4gb24gZmlyc3QgbG9hZFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luTWFuYWdlci5hZGRQbHVnaW4ocGx1Z2luT2JqLCBmaWxlSW5mby5maWxlbmFtZSwgcmVnaXN0cnkpO1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luT2JqLmZ1bmN0aW9ucyA9IHJlZ2lzdHJ5LmdldExvY2FsRnVuY3Rpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNhbGwgc2V0T3B0aW9ucyBhZ2FpbiBiZWNhdXNlIHRoZSBwbHVnaW5PYmogbWlnaHQgaGF2ZSBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudHJ5U2V0T3B0aW9ucyhwbHVnaW5PYmosIGZpbGVuYW1lLCBzaG9ydG5hbWUsIHBsdWdpbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSdW4gZXZlcnkgQHBsdWdpbiBjYWxsXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW5PYmoudXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbk9iai51c2UuY2FsbCh0aGlzLmNvbnRleHQsIHBsdWdpbk9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBlLm1lc3NhZ2UgfHwgJ0Vycm9yIGR1cmluZyBAcGx1Z2luIGNhbGwnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKGUsIGltcG9ydHMsIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGVzc0Vycm9yKHsgbWVzc2FnZTogJ05vdCBhIHZhbGlkIHBsdWdpbicgfSwgaW1wb3J0cywgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5PYmo7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlci5wcm90b3R5cGUudHJ5U2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChwbHVnaW4sIGZpbGVuYW1lLCBuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmICFwbHVnaW4uc2V0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMZXNzRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiT3B0aW9ucyBoYXZlIGJlZW4gcHJvdmlkZWQgYnV0IHRoZSBwbHVnaW4gXCIgKyBuYW1lICsgXCIgZG9lcyBub3Qgc3VwcG9ydCBhbnkgb3B0aW9ucy5cIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5zZXRPcHRpb25zICYmIHBsdWdpbi5zZXRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExlc3NFcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWJzdHJhY3RQbHVnaW5Mb2FkZXIucHJvdG90eXBlLnZhbGlkYXRlUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbiwgZmlsZW5hbWUsIG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHBsdWdpbikge1xyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBwbHVnaW5zIGJlaW5nIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIHBsdWdpbiBjYW4gYmUgbW9yZSB1c2FibGUgcHJvZ3JhbW1hdGljYWxseVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSBuZXcgcGx1Z2luKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLm1pblZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlVmVyc2lvbihwbHVnaW4ubWluVmVyc2lvbiwgdGhpcy5sZXNzLnZlcnNpb24pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlBsdWdpbiBcIiArIG5hbWUgKyBcIiByZXF1aXJlcyB2ZXJzaW9uIFwiICsgdGhpcy52ZXJzaW9uVG9TdHJpbmcocGx1Z2luLm1pblZlcnNpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBBYnN0cmFjdFBsdWdpbkxvYWRlci5wcm90b3R5cGUuY29tcGFyZVZlcnNpb24gPSBmdW5jdGlvbiAoYVZlcnNpb24sIGJWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYVZlcnNpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBhVmVyc2lvbiA9IGFWZXJzaW9uLm1hdGNoKC9eKFxcZCspXFwuPyhcXGQrKT9cXC4/KFxcZCspPy8pO1xyXG4gICAgICAgICAgICAgICAgYVZlcnNpb24uc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFWZXJzaW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYVZlcnNpb25baV0gIT09IGJWZXJzaW9uW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGFWZXJzaW9uW2ldKSA+IHBhcnNlSW50KGJWZXJzaW9uW2ldKSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFic3RyYWN0UGx1Z2luTG9hZGVyLnByb3RvdHlwZS52ZXJzaW9uVG9TdHJpbmcgPSBmdW5jdGlvbiAodmVyc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgdmVyc2lvblN0cmluZyA9ICcnO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnNpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnNpb25TdHJpbmcgKz0gKHZlcnNpb25TdHJpbmcgPyAnLicgOiAnJykgKyB2ZXJzaW9uW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uU3RyaW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQWJzdHJhY3RQbHVnaW5Mb2FkZXIucHJvdG90eXBlLnByaW50VXNhZ2UgPSBmdW5jdGlvbiAocGx1Z2lucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5wcmludFVzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnByaW50VXNhZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0UGx1Z2luTG9hZGVyO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBfdmlzaXRBcmdzID0geyB2aXNpdERlZXBlcjogdHJ1ZSB9O1xyXG4gICAgdmFyIF9oYXNJbmRleGVkID0gZmFsc2U7XHJcbiAgICBmdW5jdGlvbiBfbm9vcChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbmRleE5vZGVUeXBlcyhwYXJlbnQsIHRpY2tlcikge1xyXG4gICAgICAgIC8vIGFkZCAudHlwZUluZGV4IHRvIHRyZWUgbm9kZSB0eXBlcyBmb3IgbG9va3VwIHRhYmxlXHJcbiAgICAgICAgdmFyIGtleSwgY2hpbGQ7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cclxuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnRba2V5XTtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYm91bmQgZnVuY3Rpb25zIGRpcmVjdGx5IG9uIHRyZWUgd2hpY2ggZG8gbm90IGhhdmUgYSBwcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBvciBhcmVuJ3Qgbm9kZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucHJvdG90eXBlICYmIGNoaWxkLnByb3RvdHlwZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZS50eXBlSW5kZXggPSB0aWNrZXIrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRpY2tlciA9IGluZGV4Tm9kZVR5cGVzKGNoaWxkLCB0aWNrZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWNrZXI7XHJcbiAgICB9XHJcbiAgICB2YXIgVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBWaXNpdG9yKGltcGxlbWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0SW5DYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpdE91dENhY2hlID0ge307XHJcbiAgICAgICAgICAgIGlmICghX2hhc0luZGV4ZWQpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4Tm9kZVR5cGVzKHRyZWUsIDEpO1xyXG4gICAgICAgICAgICAgICAgX2hhc0luZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbm9kZVR5cGVJbmRleCA9IG5vZGUudHlwZUluZGV4O1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVUeXBlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1peGluQ2FsbCBhcmdzIGFyZW4ndCBhIG5vZGUgdHlwZT9cclxuICAgICAgICAgICAgICAgIGlmIChub2RlLnZhbHVlICYmIG5vZGUudmFsdWUudHlwZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbXBsID0gdGhpcy5faW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gdGhpcy5fdmlzaXRJbkNhY2hlW25vZGVUeXBlSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgZnVuY091dCA9IHRoaXMuX3Zpc2l0T3V0Q2FjaGVbbm9kZVR5cGVJbmRleF07XHJcbiAgICAgICAgICAgIHZhciB2aXNpdEFyZ3MgPSBfdmlzaXRBcmdzO1xyXG4gICAgICAgICAgICB2YXIgZm5OYW1lO1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwidmlzaXRcIiArIG5vZGUudHlwZTtcclxuICAgICAgICAgICAgICAgIGZ1bmMgPSBpbXBsW2ZuTmFtZV0gfHwgX25vb3A7XHJcbiAgICAgICAgICAgICAgICBmdW5jT3V0ID0gaW1wbFtmbk5hbWUgKyBcIk91dFwiXSB8fCBfbm9vcDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0SW5DYWNoZVtub2RlVHlwZUluZGV4XSA9IGZ1bmM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpdE91dENhY2hlW25vZGVUeXBlSW5kZXhdID0gZnVuY091dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnVuYyAhPT0gX25vb3ApIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZnVuYy5jYWxsKGltcGwsIG5vZGUsIHZpc2l0QXJncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBpbXBsLmlzUmVwbGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZpc2l0QXJncy52aXNpdERlZXBlciAmJiBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgY250ID0gbm9kZS5sZW5ndGg7IGkgPCBjbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVtpXS5hY2NlcHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbaV0uYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5hY2NlcHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmFjY2VwdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnVuY091dCAhPSBfbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY091dC5jYWxsKGltcGwsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmlzaXRvci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uIChub2Rlcywgbm9uUmVwbGFjaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY250ID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgLy8gTm9uLXJlcGxhY2luZ1xyXG4gICAgICAgICAgICBpZiAobm9uUmVwbGFjaW5nIHx8ICF0aGlzLl9pbXBsZW1lbnRhdGlvbi5pc1JlcGxhY2luZykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdChub2Rlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVwbGFjaW5nXHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZhbGQgPSB0aGlzLnZpc2l0KG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmFsZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2YWxkLnNwbGljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGV2YWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2YWxkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhdHRlbihldmFsZCwgb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVmlzaXRvci5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnIsIG91dCkge1xyXG4gICAgICAgICAgICBpZiAoIW91dCkge1xyXG4gICAgICAgICAgICAgICAgb3V0ID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNudCwgaSwgaXRlbSwgbmVzdGVkQ250LCBqLCBuZXN0ZWRJdGVtO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBjbnQgPSBhcnIubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSBhcnJbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uc3BsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBuZXN0ZWRDbnQgPSBpdGVtLmxlbmd0aDsgaiA8IG5lc3RlZENudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkSXRlbSA9IGl0ZW1bal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZEl0ZW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0ZWRJdGVtLnNwbGljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChuZXN0ZWRJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmVzdGVkSXRlbS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuKG5lc3RlZEl0ZW0sIG91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVmlzaXRvcjtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgSW1wb3J0U2VxdWVuY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEltcG9ydFNlcXVlbmNlcihvblNlcXVlbmNlckVtcHR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlSW1wb3J0cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNlcXVlbmNlckVtcHR5ID0gb25TZXF1ZW5jZXJFbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudERlcHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgSW1wb3J0U2VxdWVuY2VyLnByb3RvdHlwZS5hZGRJbXBvcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGltcG9ydFNlcXVlbmNlciA9IHRoaXMsIGltcG9ydEl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaXNSZWFkeTogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbXBvcnRzLnB1c2goaW1wb3J0SXRlbSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRJdGVtLmFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0SXRlbS5pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGltcG9ydFNlcXVlbmNlci50cnlSdW4oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEltcG9ydFNlcXVlbmNlci5wcm90b3R5cGUuYWRkVmFyaWFibGVJbXBvcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZUltcG9ydHMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBJbXBvcnRTZXF1ZW5jZXIucHJvdG90eXBlLnRyeVJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudERlcHRoKys7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmltcG9ydHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0SXRlbSA9IHRoaXMuaW1wb3J0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRJdGVtLmlzUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHMgPSB0aGlzLmltcG9ydHMuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEl0ZW0uY2FsbGJhY2suYXBwbHkobnVsbCwgaW1wb3J0SXRlbS5hcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFyaWFibGVJbXBvcnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlSW1wb3J0ID0gdGhpcy52YXJpYWJsZUltcG9ydHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZUltcG9ydHMgPSB0aGlzLnZhcmlhYmxlSW1wb3J0cy5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZUltcG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudERlcHRoLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnREZXB0aCA9PT0gMCAmJiB0aGlzLl9vblNlcXVlbmNlckVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblNlcXVlbmNlckVtcHR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBJbXBvcnRTZXF1ZW5jZXI7XHJcbiAgICB9KCkpO1xuXG4gICAgdmFyIEltcG9ydFZpc2l0b3IgPSBmdW5jdGlvbiAoaW1wb3J0ZXIsIGZpbmlzaCkge1xyXG4gICAgICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9pbXBvcnRlciA9IGltcG9ydGVyO1xyXG4gICAgICAgIHRoaXMuX2ZpbmlzaCA9IGZpbmlzaDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgY29udGV4dHMuRXZhbCgpO1xyXG4gICAgICAgIHRoaXMuaW1wb3J0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMub25jZUZpbGVEZXRlY3Rpb25NYXAgPSB7fTtcclxuICAgICAgICB0aGlzLnJlY3Vyc2lvbkRldGVjdG9yID0ge307XHJcbiAgICAgICAgdGhpcy5fc2VxdWVuY2VyID0gbmV3IEltcG9ydFNlcXVlbmNlcih0aGlzLl9vblNlcXVlbmNlckVtcHR5LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEltcG9ydFZpc2l0b3IucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGlzUmVwbGFjaW5nOiBmYWxzZSxcclxuICAgICAgICBydW46IGZ1bmN0aW9uIChyb290KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2VyLnRyeVJ1bigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX29uU2VxdWVuY2VyRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9maW5pc2godGhpcy5lcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdEltcG9ydDogZnVuY3Rpb24gKGltcG9ydE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2YXIgaW5saW5lQ1NTID0gaW1wb3J0Tm9kZS5vcHRpb25zLmlubGluZTtcclxuICAgICAgICAgICAgaWYgKCFpbXBvcnROb2RlLmNzcyB8fCBpbmxpbmVDU1MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IGNvbnRleHRzLkV2YWwodGhpcy5jb250ZXh0LCBjb3B5QXJyYXkodGhpcy5jb250ZXh0LmZyYW1lcykpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydFBhcmVudCA9IGNvbnRleHQuZnJhbWVzWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydE5vZGUuaXNWYXJpYWJsZUltcG9ydCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2VyLmFkZFZhcmlhYmxlSW1wb3J0KHRoaXMucHJvY2Vzc0ltcG9ydE5vZGUuYmluZCh0aGlzLCBpbXBvcnROb2RlLCBjb250ZXh0LCBpbXBvcnRQYXJlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ltcG9ydE5vZGUoaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb2Nlc3NJbXBvcnROb2RlOiBmdW5jdGlvbiAoaW1wb3J0Tm9kZSwgY29udGV4dCwgaW1wb3J0UGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBldmFsZEltcG9ydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBpbmxpbmVDU1MgPSBpbXBvcnROb2RlLm9wdGlvbnMuaW5saW5lO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZXZhbGRJbXBvcnROb2RlID0gaW1wb3J0Tm9kZS5ldmFsRm9ySW1wb3J0KGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWUuZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLmluZGV4ID0gaW1wb3J0Tm9kZS5nZXRJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuZmlsZW5hbWUgPSBpbXBvcnROb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGV2YWwgcHJvcGVybHkgYW5kIHRyZWF0IGFzIGNzc1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZS5jc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBmYWlscywgdGhpcyBlcnJvciB3aWxsIGJlIHRocm93blxyXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZS5lcnJvciA9IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2YWxkSW1wb3J0Tm9kZSAmJiAoIWV2YWxkSW1wb3J0Tm9kZS5jc3MgfHwgaW5saW5lQ1NTKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2YWxkSW1wb3J0Tm9kZS5vcHRpb25zLm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbXBvcnRNdWx0aXBsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0cnkgYXBwZW5kaW5nIGlmIHdlIGhhdmVuJ3QgZGV0ZXJtaW5lZCBpZiBpdCBpcyBjc3Mgb3Igbm90XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJ5QXBwZW5kTGVzc0V4dGVuc2lvbiA9IGV2YWxkSW1wb3J0Tm9kZS5jc3MgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1wb3J0UGFyZW50LnJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydFBhcmVudC5ydWxlc1tpXSA9PT0gaW1wb3J0Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRQYXJlbnQucnVsZXNbaV0gPSBldmFsZEltcG9ydE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBvbkltcG9ydGVkID0gdGhpcy5vbkltcG9ydGVkLmJpbmQodGhpcywgZXZhbGRJbXBvcnROb2RlLCBjb250ZXh0KSwgc2VxdWVuY2VkT25JbXBvcnRlZCA9IHRoaXMuX3NlcXVlbmNlci5hZGRJbXBvcnQob25JbXBvcnRlZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbXBvcnRlci5wdXNoKGV2YWxkSW1wb3J0Tm9kZS5nZXRQYXRoKCksIHRyeUFwcGVuZExlc3NFeHRlbnNpb24sIGV2YWxkSW1wb3J0Tm9kZS5maWxlSW5mbygpLCBldmFsZEltcG9ydE5vZGUub3B0aW9ucywgc2VxdWVuY2VkT25JbXBvcnRlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydENvdW50LS07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2VyLnRyeVJ1bigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkltcG9ydGVkOiBmdW5jdGlvbiAoaW1wb3J0Tm9kZSwgY29udGV4dCwgZSwgcm9vdCwgaW1wb3J0ZWRBdFJvb3QsIGZ1bGxQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWUuZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLmluZGV4ID0gaW1wb3J0Tm9kZS5nZXRJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuZmlsZW5hbWUgPSBpbXBvcnROb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW1wb3J0VmlzaXRvciA9IHRoaXMsIGlubGluZUNTUyA9IGltcG9ydE5vZGUub3B0aW9ucy5pbmxpbmUsIGlzUGx1Z2luID0gaW1wb3J0Tm9kZS5vcHRpb25zLmlzUGx1Z2luLCBpc09wdGlvbmFsID0gaW1wb3J0Tm9kZS5vcHRpb25zLm9wdGlvbmFsLCBkdXBsaWNhdGVJbXBvcnQgPSBpbXBvcnRlZEF0Um9vdCB8fCBmdWxsUGF0aCBpbiBpbXBvcnRWaXNpdG9yLnJlY3Vyc2lvbkRldGVjdG9yO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW1wb3J0TXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGVJbXBvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlLnNraXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0Tm9kZS5za2lwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVsbFBhdGggaW4gaW1wb3J0VmlzaXRvci5vbmNlRmlsZURldGVjdGlvbk1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0VmlzaXRvci5vbmNlRmlsZURldGVjdGlvbk1hcFtmdWxsUGF0aF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWZ1bGxQYXRoICYmIGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydE5vZGUuc2tpcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcclxuICAgICAgICAgICAgICAgIGltcG9ydE5vZGUucm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlLmltcG9ydGVkRmlsZW5hbWUgPSBmdWxsUGF0aDtcclxuICAgICAgICAgICAgICAgIGlmICghaW5saW5lQ1NTICYmICFpc1BsdWdpbiAmJiAoY29udGV4dC5pbXBvcnRNdWx0aXBsZSB8fCAhZHVwbGljYXRlSW1wb3J0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFZpc2l0b3IucmVjdXJzaW9uRGV0ZWN0b3JbZnVsbFBhdGhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBvbGRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGltcG9ydFZpc2l0b3IuaW1wb3J0Q291bnQtLTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydFZpc2l0b3IuaXNGaW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0VmlzaXRvci5fc2VxdWVuY2VyLnRyeVJ1bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICBpZiAoZGVjbE5vZGUudmFsdWUudHlwZSA9PT0gJ0RldGFjaGVkUnVsZXNldCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMudW5zaGlmdChkZWNsTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXREZWNsYXJhdGlvbk91dDogZnVuY3Rpb24gKGRlY2xOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWNsTm9kZS52YWx1ZS50eXBlID09PSAnRGV0YWNoZWRSdWxlc2V0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdEF0UnVsZTogZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnVuc2hpZnQoYXRSdWxlTm9kZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdEF0UnVsZU91dDogZnVuY3Rpb24gKGF0UnVsZU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRNaXhpbkRlZmluaXRpb246IGZ1bmN0aW9uIChtaXhpbkRlZmluaXRpb25Ob2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KG1peGluRGVmaW5pdGlvbk5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRNaXhpbkRlZmluaXRpb25PdXQ6IGZ1bmN0aW9uIChtaXhpbkRlZmluaXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0UnVsZXNldDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy51bnNoaWZ0KHJ1bGVzZXROb2RlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0UnVsZXNldE91dDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZXMuc2hpZnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVzLnVuc2hpZnQobWVkaWFOb2RlLnJ1bGVzWzBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0TWVkaWFPdXQ6IGZ1bmN0aW9uIChtZWRpYU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lcy5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICB2YXIgU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvcih2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpdChyb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNudCA9IG5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdChub2Rlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2V0VHJlZVZpc2liaWxpdHlWaXNpdG9yLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFycmF5KG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbm9kZS5ibG9ja3NWaXNpYmlsaXR5IHx8IG5vZGUuYmxvY2tzVmlzaWJpbGl0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmVuc3VyZVZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZW5zdXJlSW52aXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvcjtcclxuICAgIH0oKSk7XG5cbiAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xyXG4gICAgdmFyIEV4dGVuZEZpbmRlclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRXh0ZW5kRmluZGVyVmlzaXRvcigpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrID0gW1tdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgICAgICAgcm9vdCA9IHRoaXMuX3Zpc2l0b3IudmlzaXQocm9vdCk7XHJcbiAgICAgICAgICAgIHJvb3QuYWxsRXh0ZW5kcyA9IHRoaXMuYWxsRXh0ZW5kc1N0YWNrWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoZGVjbE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWl4aW5EZWZpbml0aW9uID0gZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UnVsZXNldCA9IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5yb290KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBqO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kO1xyXG4gICAgICAgICAgICB2YXIgYWxsU2VsZWN0b3JzRXh0ZW5kTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgLy8gZ2V0ICY6ZXh0ZW5kKC5hKTsgcnVsZXMgd2hpY2ggYXBwbHkgdG8gYWxsIHNlbGVjdG9ycyBpbiB0aGlzIHJ1bGVzZXRcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gcnVsZXNldE5vZGUucnVsZXMsIHJ1bGVDbnQgPSBydWxlcyA/IHJ1bGVzLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5ydWxlc1tpXSBpbnN0YW5jZW9mIHRyZWUuRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU2VsZWN0b3JzRXh0ZW5kTGlzdC5wdXNoKHJ1bGVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5leHRlbmRPbkV2ZXJ5UGF0aCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm93IGZpbmQgZXZlcnkgc2VsZWN0b3IgYW5kIGFwcGx5IHRoZSBleHRlbmRzIHRoYXQgYXBwbHkgdG8gYWxsIGV4dGVuZHNcclxuICAgICAgICAgICAgLy8gYW5kIHRoZSBvbmVzIHdoaWNoIGFwcGx5IHRvIGFuIGluZGl2aWR1YWwgZXh0ZW5kXHJcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHJ1bGVzZXROb2RlLnBhdGhzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclBhdGggPSBwYXRoc1tpXSwgc2VsZWN0b3IgPSBzZWxlY3RvclBhdGhbc2VsZWN0b3JQYXRoLmxlbmd0aCAtIDFdLCBzZWxFeHRlbmRMaXN0ID0gc2VsZWN0b3IuZXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgICAgIGV4dGVuZExpc3QgPSBzZWxFeHRlbmRMaXN0ID8gY29weUFycmF5KHNlbEV4dGVuZExpc3QpLmNvbmNhdChhbGxTZWxlY3RvcnNFeHRlbmRMaXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIDogYWxsU2VsZWN0b3JzRXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IGV4dGVuZExpc3QubWFwKGZ1bmN0aW9uIChhbGxTZWxlY3RvcnNFeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbFNlbGVjdG9yc0V4dGVuZC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGV4dGVuZExpc3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvdW5kRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kID0gZXh0ZW5kTGlzdFtqXTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQuZmluZFNlbGZTZWxlY3RvcnMoc2VsZWN0b3JQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQucnVsZXNldCA9IHJ1bGVzZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZC5maXJzdEV4dGVuZE9uVGhpc1NlbGVjdG9yUGF0aCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdLnB1c2goZXh0ZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2gocnVsZXNldE5vZGUuc2VsZWN0b3JzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UnVsZXNldE91dCA9IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGVuZ3RoID0gdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBFeHRlbmRGaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1lZGlhID0gZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIG1lZGlhTm9kZS5hbGxFeHRlbmRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYWxsRXh0ZW5kc1N0YWNrLnB1c2gobWVkaWFOb2RlLmFsbEV4dGVuZHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNZWRpYU91dCA9IGZ1bmN0aW9uIChtZWRpYU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoID0gdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEV4dGVuZEZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXRSdWxlID0gZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICBhdFJ1bGVOb2RlLmFsbEV4dGVuZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChhdFJ1bGVOb2RlLmFsbEV4dGVuZHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRXh0ZW5kRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdFJ1bGVPdXQgPSBmdW5jdGlvbiAoYXRSdWxlTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggPSB0aGlzLmFsbEV4dGVuZHNTdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEV4dGVuZEZpbmRlclZpc2l0b3I7XHJcbiAgICB9KCkpO1xyXG4gICAgdmFyIFByb2Nlc3NFeHRlbmRzVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kRmluZGVyID0gbmV3IEV4dGVuZEZpbmRlclZpc2l0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5leHRlbmRJbmRpY2VzID0ge307XHJcbiAgICAgICAgICAgIGV4dGVuZEZpbmRlci5ydW4ocm9vdCk7XHJcbiAgICAgICAgICAgIGlmICghZXh0ZW5kRmluZGVyLmZvdW5kRXh0ZW5kcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5hbGxFeHRlbmRzID0gcm9vdC5hbGxFeHRlbmRzLmNvbmNhdCh0aGlzLmRvRXh0ZW5kQ2hhaW5pbmcocm9vdC5hbGxFeHRlbmRzLCByb290LmFsbEV4dGVuZHMpKTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sgPSBbcm9vdC5hbGxFeHRlbmRzXTtcclxuICAgICAgICAgICAgdmFyIG5ld1Jvb3QgPSB0aGlzLl92aXNpdG9yLnZpc2l0KHJvb3QpO1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrRXh0ZW5kc0Zvck5vbk1hdGNoZWQocm9vdC5hbGxFeHRlbmRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Jvb3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLmNoZWNrRXh0ZW5kc0Zvck5vbk1hdGNoZWQgPSBmdW5jdGlvbiAoZXh0ZW5kTGlzdCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZXh0ZW5kSW5kaWNlcztcclxuICAgICAgICAgICAgZXh0ZW5kTGlzdC5maWx0ZXIoZnVuY3Rpb24gKGV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFleHRlbmQuaGFzRm91bmRNYXRjaGVzICYmIGV4dGVuZC5wYXJlbnRfaWRzLmxlbmd0aCA9PSAxO1xyXG4gICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChleHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9ICdfdW5rbm93bl8nO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGV4dGVuZC5zZWxlY3Rvci50b0NTUyh7fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluZGljZXNbZXh0ZW5kLmluZGV4ICsgXCIgXCIgKyBzZWxlY3Rvcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzW2V4dGVuZC5pbmRleCArIFwiIFwiICsgc2VsZWN0b3JdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcImV4dGVuZCAnXCIgKyBzZWxlY3RvciArIFwiJyBoYXMgbm8gbWF0Y2hlc1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLmRvRXh0ZW5kQ2hhaW5pbmcgPSBmdW5jdGlvbiAoZXh0ZW5kc0xpc3QsIGV4dGVuZHNMaXN0VGFyZ2V0LCBpdGVyYXRpb25Db3VudCkge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBjaGFpbmluZyBpcyBkaWZmZXJlbnQgZnJvbSBub3JtYWwgZXh0ZW5zaW9uLi4gaWYgd2UgZXh0ZW5kIGFuIGV4dGVuZCB0aGVuIHdlIGFyZSBub3QganVzdCBjb3B5aW5nLCBhbHRlcmluZ1xyXG4gICAgICAgICAgICAvLyBhbmQgcGFzdGluZyB0aGUgc2VsZWN0b3Igd2Ugd291bGQgZG8gbm9ybWFsbHksIGJ1dCB3ZSBhcmUgYWxzbyBhZGRpbmcgYW4gZXh0ZW5kIHdpdGggdGhlIHNhbWUgdGFyZ2V0IHNlbGVjdG9yXHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhpcyBuZXcgZXh0ZW5kIGNhbiB0aGVuIGdvIGFuZCBhbHRlciBvdGhlciBleHRlbmRzXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIGRlYWxzIHdpdGggYWxsIHRoZSBjaGFpbmluZyB3b3JrIC0gd2l0aG91dCBpdCwgZXh0ZW5kIGlzIGZsYXQgYW5kIGRvZXNuJ3Qgd29yayBvbiBvdGhlciBleHRlbmQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYWxzbyB0aGUgbW9zdCBleHBlbnNpdmUuLiBhbmQgYSBtYXRjaCBvbiBvbmUgc2VsZWN0b3IgY2FuIGNhdXNlIGFuIGV4dGVuc2lvbiBvZiBhIHNlbGVjdG9yIHdlIGhhZCBhbHJlYWR5XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3NlZCBpZiB3ZSBsb29rIGF0IGVhY2ggc2VsZWN0b3IgYXQgYSB0aW1lLCBhcyBpcyBkb25lIGluIHZpc2l0UnVsZXNldFxyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kSW5kZXg7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRFeHRlbmRJbmRleDtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXM7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmRzVG9BZGQgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9yO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kVmlzaXRvciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvclBhdGg7XHJcbiAgICAgICAgICAgIHZhciBleHRlbmQ7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRFeHRlbmQ7XHJcbiAgICAgICAgICAgIHZhciBuZXdFeHRlbmQ7XHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbkNvdW50ID0gaXRlcmF0aW9uQ291bnQgfHwgMDtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGNvbXBhcmluZyBldmVyeSBleHRlbmQgd2l0aCBldmVyeSB0YXJnZXQgZXh0ZW5kLlxyXG4gICAgICAgICAgICAvLyBhIHRhcmdldCBleHRlbmQgaXMgdGhlIG9uZSBvbiB0aGUgcnVsZXNldCB3ZSBhcmUgbG9va2luZyBhdCBjb3B5L2VkaXQvcGFzdGluZyBpbiBwbGFjZVxyXG4gICAgICAgICAgICAvLyBlLmcuICAuYTpleHRlbmQoLmIpIHt9ICBhbmQgLmI6ZXh0ZW5kKC5jKSB7fSB0aGVuIHRoZSBmaXJzdCBleHRlbmQgZXh0ZW5kcyB0aGUgc2Vjb25kIG9uZVxyXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAvLyB0aGUgc2VwYXJhdGlvbiBpbnRvIHR3byBsaXN0cyBhbGxvd3MgdXMgdG8gcHJvY2VzcyBhIHN1YnNldCBvZiBjaGFpbnMgd2l0aCBhIGJpZ2dlciBzZXQsIGFzIGlzIHRoZVxyXG4gICAgICAgICAgICAvLyBjYXNlIHdoZW4gcHJvY2Vzc2luZyBtZWRpYSBxdWVyaWVzXHJcbiAgICAgICAgICAgIGZvciAoZXh0ZW5kSW5kZXggPSAwOyBleHRlbmRJbmRleCA8IGV4dGVuZHNMaXN0Lmxlbmd0aDsgZXh0ZW5kSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh0YXJnZXRFeHRlbmRJbmRleCA9IDA7IHRhcmdldEV4dGVuZEluZGV4IDwgZXh0ZW5kc0xpc3RUYXJnZXQubGVuZ3RoOyB0YXJnZXRFeHRlbmRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kID0gZXh0ZW5kc0xpc3RbZXh0ZW5kSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEV4dGVuZCA9IGV4dGVuZHNMaXN0VGFyZ2V0W3RhcmdldEV4dGVuZEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZC5wYXJlbnRfaWRzLmluZGV4T2YodGFyZ2V0RXh0ZW5kLm9iamVjdF9pZCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBhIG1hdGNoIGluIHRoZSB0YXJnZXQgZXh0ZW5kcyBzZWxmIHNlbGVjdG9yICh0aGUgYml0IGJlZm9yZSA6ZXh0ZW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yUGF0aCA9IFt0YXJnZXRFeHRlbmQuc2VsZlNlbGVjdG9yc1swXV07XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGV4dGVuZFZpc2l0b3IuZmluZE1hdGNoKGV4dGVuZCwgc2VsZWN0b3JQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kLmhhc0ZvdW5kTWF0Y2hlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbWF0Y2gsIHNvIGZvciBlYWNoIHNlbGYgc2VsZWN0b3IuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQuc2VsZlNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxmU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGFyZ2V0RXh0ZW5kLnZpc2liaWxpdHlJbmZvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBleHRlbmQgYXMgdXN1YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gZXh0ZW5kVmlzaXRvci5leHRlbmRTZWxlY3RvcihtYXRjaGVzLCBzZWxlY3RvclBhdGgsIHNlbGZTZWxlY3RvciwgZXh0ZW5kLmlzVmlzaWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBub3cgd2UgY3JlYXRlIGEgbmV3IGV4dGVuZCBmcm9tIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQgPSBuZXcgKHRyZWUuRXh0ZW5kKSh0YXJnZXRFeHRlbmQuc2VsZWN0b3IsIHRhcmdldEV4dGVuZC5vcHRpb24sIDAsIHRhcmdldEV4dGVuZC5maWxlSW5mbygpLCBpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5zZWxmU2VsZWN0b3JzID0gbmV3U2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGV4dGVuZCBvbnRvIHRoZSBsaXN0IG9mIGV4dGVuZHMgZm9yIHRoYXQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yW25ld1NlbGVjdG9yLmxlbmd0aCAtIDFdLmV4dGVuZExpc3QgPSBbbmV3RXh0ZW5kXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29yZCB0aGF0IHdlIG5lZWQgdG8gYWRkIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kc1RvQWRkLnB1c2gobmV3RXh0ZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V4dGVuZC5ydWxlc2V0ID0gdGFyZ2V0RXh0ZW5kLnJ1bGVzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciBpdHMgcGFyZW50cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXh0ZW5kLnBhcmVudF9pZHMgPSBuZXdFeHRlbmQucGFyZW50X2lkcy5jb25jYXQodGFyZ2V0RXh0ZW5kLnBhcmVudF9pZHMsIGV4dGVuZC5wYXJlbnRfaWRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJvY2VzcyB0aGUgc2VsZWN0b3Igb25jZS4uIGlmIHdlIGhhdmUgOmV4dGVuZCguYSwuYikgdGhlbiBtdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kcyB3aWxsIGxvb2sgYXQgdGhlIHNhbWUgc2VsZWN0b3IgcGF0aCwgc28gd2hlbiBleHRlbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCBhbnkgb3RoZXJzIHdpbGwgYmUgZHVwbGljYXRlcyBpbiB0ZXJtcyBvZiB3aGF0IGlzIGFkZGVkIHRvIHRoZSBjc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFeHRlbmQuZmlyc3RFeHRlbmRPblRoaXNTZWxlY3RvclBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFeHRlbmQuZmlyc3RFeHRlbmRPblRoaXNTZWxlY3RvclBhdGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEV4dGVuZC5ydWxlc2V0LnBhdGhzLnB1c2gobmV3U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4dGVuZHNUb0FkZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBkZXRlY3QgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBzdG9wIGEgc3RhY2sgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBtYXkgbm8gbG9uZ2VyIGJlIG5lZWRlZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kQ2hhaW5Db3VudCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbkNvdW50ID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yT25lID0gJ3t1bmFibGUgdG8gY2FsY3VsYXRlfSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yVHdvID0gJ3t1bmFibGUgdG8gY2FsY3VsYXRlfSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JPbmUgPSBleHRlbmRzVG9BZGRbMF0uc2VsZlNlbGVjdG9yc1swXS50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclR3byA9IGV4dGVuZHNUb0FkZFswXS5zZWxlY3Rvci50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBcImV4dGVuZCBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQuIE9uZSBvZiB0aGUgY2lyY3VsYXIgZXh0ZW5kcyBpcyBjdXJyZW50bHk6XCIgKyBzZWxlY3Rvck9uZSArIFwiOmV4dGVuZChcIiArIHNlbGVjdG9yVHdvICsgXCIpXCIgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG5vdyBwcm9jZXNzIHRoZSBuZXcgZXh0ZW5kcyBvbiB0aGUgZXhpc3RpbmcgcnVsZXMgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIGEgZXh0ZW5kaW5nIGIgZXh0ZW5kaW5nIGMgZXh0ZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBkIGV4dGVuZGluZyBlLi4uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kc1RvQWRkLmNvbmNhdChleHRlbmRWaXNpdG9yLmRvRXh0ZW5kQ2hhaW5pbmcoZXh0ZW5kc1RvQWRkLCBleHRlbmRzTGlzdFRhcmdldCwgaXRlcmF0aW9uQ291bnQgKyAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kc1RvQWRkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAocnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUudmlzaXRNaXhpbkRlZmluaXRpb24gPSBmdW5jdGlvbiAobWl4aW5EZWZpbml0aW9uTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJ1bGVzZXQgPSBmdW5jdGlvbiAocnVsZXNldE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICBpZiAocnVsZXNldE5vZGUucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVzO1xyXG4gICAgICAgICAgICB2YXIgcGF0aEluZGV4O1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kSW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBhbGxFeHRlbmRzID0gdGhpcy5hbGxFeHRlbmRzU3RhY2tbdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnNUb0FkZCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZW5kVmlzaXRvciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvclBhdGg7XHJcbiAgICAgICAgICAgIC8vIGxvb2sgYXQgZWFjaCBzZWxlY3RvciBwYXRoIGluIHRoZSBydWxlc2V0LCBmaW5kIGFueSBleHRlbmQgbWF0Y2hlcyBhbmQgdGhlbiBjb3B5LCBmaW5kIGFuZCByZXBsYWNlXHJcbiAgICAgICAgICAgIGZvciAoZXh0ZW5kSW5kZXggPSAwOyBleHRlbmRJbmRleCA8IGFsbEV4dGVuZHMubGVuZ3RoOyBleHRlbmRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCA8IHJ1bGVzZXROb2RlLnBhdGhzLmxlbmd0aDsgcGF0aEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclBhdGggPSBydWxlc2V0Tm9kZS5wYXRoc1twYXRoSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZGluZyBleHRlbmRzIGhhcHBlbnMgaW5pdGlhbGx5LCBiZWZvcmUgdGhlIG1haW4gcGFzc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5leHRlbmRPbkV2ZXJ5UGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZExpc3QgPSBzZWxlY3RvclBhdGhbc2VsZWN0b3JQYXRoLmxlbmd0aCAtIDFdLmV4dGVuZExpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZExpc3QgJiYgZXh0ZW5kTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLmZpbmRNYXRjaChhbGxFeHRlbmRzW2V4dGVuZEluZGV4XSwgc2VsZWN0b3JQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kc1tleHRlbmRJbmRleF0uaGFzRm91bmRNYXRjaGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kc1tleHRlbmRJbmRleF0uc2VsZlNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxmU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRlZFNlbGVjdG9ycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2VsZWN0b3JzID0gZXh0ZW5kVmlzaXRvci5leHRlbmRTZWxlY3RvcihtYXRjaGVzLCBzZWxlY3RvclBhdGgsIHNlbGZTZWxlY3RvciwgYWxsRXh0ZW5kc1tleHRlbmRJbmRleF0uaXNWaXNpYmxlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzVG9BZGQucHVzaChleHRlbmRlZFNlbGVjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBydWxlc2V0Tm9kZS5wYXRocyA9IHJ1bGVzZXROb2RlLnBhdGhzLmNvbmNhdChzZWxlY3RvcnNUb0FkZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLmZpbmRNYXRjaCA9IGZ1bmN0aW9uIChleHRlbmQsIGhheXN0YWNrU2VsZWN0b3JQYXRoKSB7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIGxvb2sgdGhyb3VnaCB0aGUgaGF5c3RhY2sgc2VsZWN0b3IgcGF0aCB0byB0cnkgYW5kIGZpbmQgdGhlIG5lZWRsZSAtIGV4dGVuZC5zZWxlY3RvclxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIGFuIGFycmF5IG9mIHNlbGVjdG9yIG1hdGNoZXMgdGhhdCBjYW4gdGhlbiBiZSByZXBsYWNlZFxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB2YXIgaGF5c3RhY2tTZWxlY3RvckluZGV4O1xyXG4gICAgICAgICAgICB2YXIgaGFja3N0YWNrU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBoYWNrc3RhY2tFbGVtZW50SW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBoYXlzdGFja0VsZW1lbnQ7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRDb21iaW5hdG9yO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgdmFyIGV4dGVuZFZpc2l0b3IgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbmVlZGxlRWxlbWVudHMgPSBleHRlbmQuc2VsZWN0b3IuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxNYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxNYXRjaDtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBoYXlzdGFjayBlbGVtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGhheXN0YWNrU2VsZWN0b3JJbmRleCA9IDA7IGhheXN0YWNrU2VsZWN0b3JJbmRleCA8IGhheXN0YWNrU2VsZWN0b3JQYXRoLmxlbmd0aDsgaGF5c3RhY2tTZWxlY3RvckluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGhhY2tzdGFja1NlbGVjdG9yID0gaGF5c3RhY2tTZWxlY3RvclBhdGhbaGF5c3RhY2tTZWxlY3RvckluZGV4XTtcclxuICAgICAgICAgICAgICAgIGZvciAoaGFja3N0YWNrRWxlbWVudEluZGV4ID0gMDsgaGFja3N0YWNrRWxlbWVudEluZGV4IDwgaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoOyBoYWNrc3RhY2tFbGVtZW50SW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhheXN0YWNrRWxlbWVudCA9IGhhY2tzdGFja1NlbGVjdG9yLmVsZW1lbnRzW2hhY2tzdGFja0VsZW1lbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxsb3cgZWxlbWVudHMgYmVmb3JlIG91ciBtYXRjaCB3ZSBjYW4gYWRkIGEgcG90ZW50aWFsIG1hdGNoIGV2ZXJ5IHRpbWUuIG90aGVyd2lzZSBvbmx5IGF0IHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmQuYWxsb3dCZWZvcmUgfHwgKGhheXN0YWNrU2VsZWN0b3JJbmRleCA9PT0gMCAmJiBoYWNrc3RhY2tFbGVtZW50SW5kZXggPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoZXMucHVzaCh7IHBhdGhJbmRleDogaGF5c3RhY2tTZWxlY3RvckluZGV4LCBpbmRleDogaGFja3N0YWNrRWxlbWVudEluZGV4LCBtYXRjaGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbWJpbmF0b3I6IGhheXN0YWNrRWxlbWVudC5jb21iaW5hdG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG90ZW50aWFsTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaCA9IHBvdGVudGlhbE1hdGNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9ycyBhZGQgXCIgXCIgb250byB0aGUgZmlyc3QgZWxlbWVudC4gV2hlbiB3ZSB1c2UgJiBpdCBqb2lucyB0aGUgc2VsZWN0b3JzIHRvZ2V0aGVyLCBidXQgaWYgd2UgZG9uJ3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBlYWNoIHNlbGVjdG9yIGluIGhheXN0YWNrU2VsZWN0b3JQYXRoIGhhcyBhIHNwYWNlIGJlZm9yZSBpdCBhZGRlZCBpbiB0aGUgdG9DU1MgcGhhc2UuIHNvIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBvdXQgd2hhdCB0aGUgcmVzdWx0aW5nIGNvbWJpbmF0b3Igd2lsbCBiZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21iaW5hdG9yID0gaGF5c3RhY2tFbGVtZW50LmNvbWJpbmF0b3IudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDb21iaW5hdG9yID09PSAnJyAmJiBoYWNrc3RhY2tFbGVtZW50SW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbWJpbmF0b3IgPSAnICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgbWF0Y2gsIG51bGwgb3VyIG1hdGNoIHRvIGluZGljYXRlIGZhaWx1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHRlbmRWaXNpdG9yLmlzRWxlbWVudFZhbHVlc0VxdWFsKG5lZWRsZUVsZW1lbnRzW3BvdGVudGlhbE1hdGNoLm1hdGNoZWRdLnZhbHVlLCBoYXlzdGFja0VsZW1lbnQudmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG90ZW50aWFsTWF0Y2gubWF0Y2hlZCA+IDAgJiYgbmVlZGxlRWxlbWVudHNbcG90ZW50aWFsTWF0Y2gubWF0Y2hlZF0uY29tYmluYXRvci52YWx1ZSAhPT0gdGFyZ2V0Q29tYmluYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLm1hdGNoZWQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgc3RpbGwgdmFsaWQgYW5kIGhhdmUgZmluaXNoZWQsIHRlc3Qgd2hldGhlciB3ZSBoYXZlIGVsZW1lbnRzIGFmdGVyIGFuZCB3aGV0aGVyIHRoZXNlIGFyZSBhbGxvd2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2guZmluaXNoZWQgPSBwb3RlbnRpYWxNYXRjaC5tYXRjaGVkID09PSBuZWVkbGVFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTWF0Y2guZmluaXNoZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWV4dGVuZC5hbGxvd0FmdGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChoYWNrc3RhY2tFbGVtZW50SW5kZXggKyAxIDwgaGFja3N0YWNrU2VsZWN0b3IuZWxlbWVudHMubGVuZ3RoIHx8IGhheXN0YWNrU2VsZWN0b3JJbmRleCArIDEgPCBoYXlzdGFja1NlbGVjdG9yUGF0aC5sZW5ndGgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBudWxsIHdlIHJlbW92ZSwgaWYgbm90LCB3ZSBhcmUgc3RpbGwgdmFsaWQsIHNvIGVpdGhlciBwdXNoIGFzIGEgdmFsaWQgbWF0Y2ggb3IgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTWF0Y2guZmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaC5sZW5ndGggPSBuZWVkbGVFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2guZW5kUGF0aEluZGV4ID0gaGF5c3RhY2tTZWxlY3RvckluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE1hdGNoLmVuZFBhdGhFbGVtZW50SW5kZXggPSBoYWNrc3RhY2tFbGVtZW50SW5kZXggKyAxOyAvLyBpbmRleCBhZnRlciBlbmQgb2YgbWF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxNYXRjaGVzLmxlbmd0aCA9IDA7IC8vIHdlIGRvbid0IGFsbG93IG1hdGNoZXMgdG8gb3ZlcmxhcCwgc28gc3RhcnQgbWF0Y2hpbmcgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gocG90ZW50aWFsTWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsTWF0Y2hlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IucHJvdG90eXBlLmlzRWxlbWVudFZhbHVlc0VxdWFsID0gZnVuY3Rpb24gKGVsZW1lbnRWYWx1ZTEsIGVsZW1lbnRWYWx1ZTIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VmFsdWUxID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudFZhbHVlMiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50VmFsdWUxID09PSBlbGVtZW50VmFsdWUyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxIGluc3RhbmNlb2YgdHJlZS5BdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxLm9wICE9PSBlbGVtZW50VmFsdWUyLm9wIHx8IGVsZW1lbnRWYWx1ZTEua2V5ICE9PSBlbGVtZW50VmFsdWUyLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudFZhbHVlMS52YWx1ZSB8fCAhZWxlbWVudFZhbHVlMi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VmFsdWUxLnZhbHVlIHx8IGVsZW1lbnRWYWx1ZTIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnRWYWx1ZTEgPSBlbGVtZW50VmFsdWUxLnZhbHVlLnZhbHVlIHx8IGVsZW1lbnRWYWx1ZTEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50VmFsdWUyID0gZWxlbWVudFZhbHVlMi52YWx1ZS52YWx1ZSB8fCBlbGVtZW50VmFsdWUyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRWYWx1ZTEgPT09IGVsZW1lbnRWYWx1ZTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudFZhbHVlMSA9IGVsZW1lbnRWYWx1ZTEudmFsdWU7XHJcbiAgICAgICAgICAgIGVsZW1lbnRWYWx1ZTIgPSBlbGVtZW50VmFsdWUyLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlMSBpbnN0YW5jZW9mIHRyZWUuU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGVsZW1lbnRWYWx1ZTIgaW5zdGFuY2VvZiB0cmVlLlNlbGVjdG9yKSB8fCBlbGVtZW50VmFsdWUxLmVsZW1lbnRzLmxlbmd0aCAhPT0gZWxlbWVudFZhbHVlMi5lbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRWYWx1ZTEuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFZhbHVlMS5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlICE9PSBlbGVtZW50VmFsdWUyLmVsZW1lbnRzW2ldLmNvbWJpbmF0b3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDAgfHwgKGVsZW1lbnRWYWx1ZTEuZWxlbWVudHNbaV0uY29tYmluYXRvci52YWx1ZSB8fCAnICcpICE9PSAoZWxlbWVudFZhbHVlMi5lbGVtZW50c1tpXS5jb21iaW5hdG9yLnZhbHVlIHx8ICcgJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNFbGVtZW50VmFsdWVzRXF1YWwoZWxlbWVudFZhbHVlMS5lbGVtZW50c1tpXS52YWx1ZSwgZWxlbWVudFZhbHVlMi5lbGVtZW50c1tpXS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUuZXh0ZW5kU2VsZWN0b3IgPSBmdW5jdGlvbiAobWF0Y2hlcywgc2VsZWN0b3JQYXRoLCByZXBsYWNlbWVudFNlbGVjdG9yLCBpc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gZm9yIGEgc2V0IG9mIG1hdGNoZXMsIHJlcGxhY2UgZWFjaCBtYXRjaCB3aXRoIHRoZSByZXBsYWNlbWVudCBzZWxlY3RvclxyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdG9yUGF0aEluZGV4ID0gMCwgY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCA9IDAsIHBhdGggPSBbXSwgbWF0Y2hJbmRleCwgc2VsZWN0b3IsIGZpcnN0RWxlbWVudCwgbWF0Y2gsIG5ld0VsZW1lbnRzO1xyXG4gICAgICAgICAgICBmb3IgKG1hdGNoSW5kZXggPSAwOyBtYXRjaEluZGV4IDwgbWF0Y2hlcy5sZW5ndGg7IG1hdGNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzW21hdGNoSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvclBhdGhbbWF0Y2gucGF0aEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudCA9IG5ldyB0cmVlLkVsZW1lbnQobWF0Y2guaW5pdGlhbENvbWJpbmF0b3IsIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0udmFsdWUsIHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHNbMF0uaXNWYXJpYWJsZSwgcmVwbGFjZW1lbnRTZWxlY3Rvci5lbGVtZW50c1swXS5nZXRJbmRleCgpLCByZXBsYWNlbWVudFNlbGVjdG9yLmVsZW1lbnRzWzBdLmZpbGVJbmZvKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLnBhdGhJbmRleCA+IGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCAmJiBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXS5lbGVtZW50cyA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxlbWVudHMuY29uY2F0KHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzID0gc2VsZWN0b3IuZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEVsZW1lbnRJbmRleCwgbWF0Y2guaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChbZmlyc3RFbGVtZW50XSlcclxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcGxhY2VtZW50U2VsZWN0b3IuZWxlbWVudHMuc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCA9PT0gbWF0Y2gucGF0aEluZGV4ICYmIG1hdGNoSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdLmVsZW1lbnRzID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdLmVsZW1lbnRzLmNvbmNhdChuZXdFbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5jb25jYXQoc2VsZWN0b3JQYXRoLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCwgbWF0Y2gucGF0aEluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5ldyB0cmVlLlNlbGVjdG9yKG5ld0VsZW1lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPSBtYXRjaC5lbmRQYXRoSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID0gbWF0Y2guZW5kUGF0aEVsZW1lbnRJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JQYXRoRWxlbWVudEluZGV4ID49IHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXggPCBzZWxlY3RvclBhdGgubGVuZ3RoICYmIGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uZWxlbWVudHMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgICAgICAgICAuZWxlbWVudHMuY29uY2F0KHNlbGVjdG9yUGF0aFtjdXJyZW50U2VsZWN0b3JQYXRoSW5kZXhdLmVsZW1lbnRzLnNsaWNlKGN1cnJlbnRTZWxlY3RvclBhdGhFbGVtZW50SW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvclBhdGhJbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLmNvbmNhdChzZWxlY3RvclBhdGguc2xpY2UoY3VycmVudFNlbGVjdG9yUGF0aEluZGV4LCBzZWxlY3RvclBhdGgubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLm1hcChmdW5jdGlvbiAoY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gcmUtdXNlIGVsZW1lbnRzIGhlcmUsIGJlY2F1c2UgdGhlIHZpc2liaWxpdHkgcHJvcGVydHkgbWF0dGVycyBvbmx5IGZvciBzZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgIHZhciBkZXJpdmVkID0gY3VycmVudFZhbHVlLmNyZWF0ZURlcml2ZWQoY3VycmVudFZhbHVlLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXJpdmVkLmVuc3VyZVZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcml2ZWQuZW5zdXJlSW52aXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVyaXZlZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1lZGlhID0gZnVuY3Rpb24gKG1lZGlhTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdBbGxFeHRlbmRzID0gbWVkaWFOb2RlLmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAgICAgbmV3QWxsRXh0ZW5kcyA9IG5ld0FsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhuZXdBbGxFeHRlbmRzLCBtZWRpYU5vZGUuYWxsRXh0ZW5kcykpO1xyXG4gICAgICAgICAgICB0aGlzLmFsbEV4dGVuZHNTdGFjay5wdXNoKG5ld0FsbEV4dGVuZHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1lZGlhT3V0ID0gZnVuY3Rpb24gKG1lZGlhTm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoID0gbGFzdEluZGV4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUHJvY2Vzc0V4dGVuZHNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0UnVsZSA9IGZ1bmN0aW9uIChhdFJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0FsbEV4dGVuZHMgPSBhdFJ1bGVOb2RlLmFsbEV4dGVuZHMuY29uY2F0KHRoaXMuYWxsRXh0ZW5kc1N0YWNrW3RoaXMuYWxsRXh0ZW5kc1N0YWNrLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAgICAgbmV3QWxsRXh0ZW5kcyA9IG5ld0FsbEV4dGVuZHMuY29uY2F0KHRoaXMuZG9FeHRlbmRDaGFpbmluZyhuZXdBbGxFeHRlbmRzLCBhdFJ1bGVOb2RlLmFsbEV4dGVuZHMpKTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2sucHVzaChuZXdBbGxFeHRlbmRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFByb2Nlc3NFeHRlbmRzVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdFJ1bGVPdXQgPSBmdW5jdGlvbiAoYXRSdWxlTm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdGhpcy5hbGxFeHRlbmRzU3RhY2subGVuZ3RoID0gbGFzdEluZGV4O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFByb2Nlc3NFeHRlbmRzVmlzaXRvcjtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgSm9pblNlbGVjdG9yVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBKb2luU2VsZWN0b3JWaXNpdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gW1tdXTtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBKb2luU2VsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEpvaW5TZWxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoZGVjbE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEpvaW5TZWxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWl4aW5EZWZpbml0aW9uID0gZnVuY3Rpb24gKG1peGluRGVmaW5pdGlvbk5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2aXNpdEFyZ3MudmlzaXREZWVwZXIgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEpvaW5TZWxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UnVsZXNldCA9IGZ1bmN0aW9uIChydWxlc2V0Tm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9ycztcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKHBhdGhzKTtcclxuICAgICAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBydWxlc2V0Tm9kZS5zZWxlY3RvcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gc2VsZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmdldElzT3V0cHV0KCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLnNlbGVjdG9ycyA9IHNlbGVjdG9ycy5sZW5ndGggPyBzZWxlY3RvcnMgOiAoc2VsZWN0b3JzID0gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5qb2luU2VsZWN0b3JzKHBhdGhzLCBjb250ZXh0LCBzZWxlY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldE5vZGUucnVsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcnVsZXNldE5vZGUucGF0aHMgPSBwYXRocztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSdWxlc2V0T3V0ID0gZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGVuZ3RoID0gdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRNZWRpYSA9IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgbWVkaWFOb2RlLnJ1bGVzWzBdLnJvb3QgPSAoY29udGV4dC5sZW5ndGggPT09IDAgfHwgY29udGV4dFswXS5tdWx0aU1lZGlhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEpvaW5TZWxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXRSdWxlID0gZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGF0UnVsZU5vZGUucnVsZXMgJiYgYXRSdWxlTm9kZS5ydWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGF0UnVsZU5vZGUucnVsZXNbMF0ucm9vdCA9IChhdFJ1bGVOb2RlLmlzUm9vdGVkIHx8IGNvbnRleHQubGVuZ3RoID09PSAwIHx8IG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSm9pblNlbGVjdG9yVmlzaXRvcjtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgQ1NTVmlzaXRvclV0aWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIENTU1Zpc2l0b3JVdGlscyhjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0b3IgPSBuZXcgVmlzaXRvcih0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENTU1Zpc2l0b3JVdGlscy5wcm90b3R5cGUuY29udGFpbnNTaWxlbnROb25CbG9ja2VkQ2hpbGQgPSBmdW5jdGlvbiAoYm9keVJ1bGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICBpZiAoIWJvZHlSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgYm9keVJ1bGVzLmxlbmd0aDsgcisrKSB7XHJcbiAgICAgICAgICAgICAgICBydWxlID0gYm9keVJ1bGVzW3JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaXNTaWxlbnQgJiYgcnVsZS5pc1NpbGVudCh0aGlzLl9jb250ZXh0KSAmJiAhcnVsZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYXRydWxlIGNvbnRhaW5zIHNvbWV0aGluZyB0aGF0IHdhcyByZWZlcmVuY2VkIChsaWtlbHkgYnkgZXh0ZW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSBpdCBuZWVkcyB0byBiZSBzaG93biBpbiBvdXRwdXQgdG9vXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZS5rZWVwT25seVZpc2libGVDaGlsZHMgPSBmdW5jdGlvbiAob3duZXIpIHtcclxuICAgICAgICAgICAgaWYgKG93bmVyICYmIG93bmVyLnJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lci5ydWxlcyA9IG93bmVyLnJ1bGVzLmZpbHRlcihmdW5jdGlvbiAodGhpbmcpIHsgcmV0dXJuIHRoaW5nLmlzVmlzaWJsZSgpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAob3duZXIgJiYgb3duZXIucnVsZXMpXHJcbiAgICAgICAgICAgICAgICA/IChvd25lci5ydWxlcy5sZW5ndGggPT09IDApIDogdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENTU1Zpc2l0b3JVdGlscy5wcm90b3R5cGUuaGFzVmlzaWJsZVNlbGVjdG9yID0gZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocnVsZXNldE5vZGUgJiYgcnVsZXNldE5vZGUucGF0aHMpXHJcbiAgICAgICAgICAgICAgICA/IChydWxlc2V0Tm9kZS5wYXRocy5sZW5ndGggPiAwKSA6IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZS5yZXNvbHZlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChub2RlLCBvcmlnaW5hbFJ1bGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkobm9kZSkgJiYgIXRoaXMuY29udGFpbnNTaWxlbnROb25CbG9ja2VkQ2hpbGQob3JpZ2luYWxSdWxlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29tcGlsZWRSdWxlc0JvZHkgPSBub2RlLnJ1bGVzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLmtlZXBPbmx5VmlzaWJsZUNoaWxkcyhjb21waWxlZFJ1bGVzQm9keSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkoY29tcGlsZWRSdWxlc0JvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5lbnN1cmVWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlVmlzaWJpbGl0eUJsb2NrKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ1NTVmlzaXRvclV0aWxzLnByb3RvdHlwZS5pc1Zpc2libGVSdWxlc2V0ID0gZnVuY3Rpb24gKHJ1bGVzZXROb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5maXJzdFJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkocnVsZXNldE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFydWxlc2V0Tm9kZS5yb290ICYmICF0aGlzLmhhc1Zpc2libGVTZWxlY3RvcihydWxlc2V0Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDU1NWaXNpdG9yVXRpbHM7XHJcbiAgICB9KCkpO1xyXG4gICAgdmFyIFRvQ1NTVmlzaXRvciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fdmlzaXRvciA9IG5ldyBWaXNpdG9yKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMudXRpbHMgPSBuZXcgQ1NTVmlzaXRvclV0aWxzKGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIFRvQ1NTVmlzaXRvci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgaXNSZXBsYWNpbmc6IHRydWUsXHJcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChyb290KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWNsTm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkgfHwgZGVjbE5vZGUudmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGVjbE5vZGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdE1peGluRGVmaW5pdGlvbjogZnVuY3Rpb24gKG1peGluTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIC8vIG1peGluIGRlZmluaXRpb25zIGRvIG5vdCBnZXQgZXZhbCdkIC0gdGhpcyBtZWFucyB0aGV5IGtlZXAgc3RhdGVcclxuICAgICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBjbGVhciB0aGF0IHN0YXRlIGhlcmUgc28gaXQgaXNuJ3QgdXNlZCBpZiB0b0NTUyBpcyBjYWxsZWQgdHdpY2VcclxuICAgICAgICAgICAgbWl4aW5Ob2RlLmZyYW1lcyA9IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRFeHRlbmQ6IGZ1bmN0aW9uIChleHRlbmROb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0Q29tbWVudDogZnVuY3Rpb24gKGNvbW1lbnROb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGNvbW1lbnROb2RlLmJsb2Nrc1Zpc2liaWxpdHkoKSB8fCBjb21tZW50Tm9kZS5pc1NpbGVudCh0aGlzLl9jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb21tZW50Tm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0TWVkaWE6IGZ1bmN0aW9uIChtZWRpYU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxSdWxlcyA9IG1lZGlhTm9kZS5ydWxlc1swXS5ydWxlcztcclxuICAgICAgICAgICAgbWVkaWFOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcclxuICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnV0aWxzLnJlc29sdmVWaXNpYmlsaXR5KG1lZGlhTm9kZSwgb3JpZ2luYWxSdWxlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aXNpdEltcG9ydDogZnVuY3Rpb24gKGltcG9ydE5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICBpZiAoaW1wb3J0Tm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0Tm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0QXRSdWxlOiBmdW5jdGlvbiAoYXRSdWxlTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChhdFJ1bGVOb2RlLnJ1bGVzICYmIGF0UnVsZU5vZGUucnVsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEF0UnVsZVdpdGhCb2R5KGF0UnVsZU5vZGUsIHZpc2l0QXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEF0UnVsZVdpdGhvdXRCb2R5KGF0UnVsZU5vZGUsIHZpc2l0QXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0QW5vbnltb3VzOiBmdW5jdGlvbiAoYW5vbnltb3VzTm9kZSwgdmlzaXRBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmICghYW5vbnltb3VzTm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGFub255bW91c05vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFub255bW91c05vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0QXRSdWxlV2l0aEJvZHk6IGZ1bmN0aW9uIChhdFJ1bGVOb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgbmVzdGVkIHJ1bGVzZXQgYW5kIHRoYXQgb25lIGhhcyBubyBwYXRoLCB0aGVuIGl0IGlzXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZmFrZSBydWxlc2V0XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc0Zha2VSdWxlc2V0KGF0UnVsZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBib2R5UnVsZXMgPSBhdFJ1bGVOb2RlLnJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHlSdWxlcy5sZW5ndGggPT09IDEgJiYgKCFib2R5UnVsZXNbMF0ucGF0aHMgfHwgYm9keVJ1bGVzWzBdLnBhdGhzLmxlbmd0aCA9PT0gMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Qm9keVJ1bGVzKGF0UnVsZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlUnVsZXMgPSBhdFJ1bGVOb2RlLnJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0Zha2VSdWxlc2V0KGF0UnVsZU5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVSdWxlc1swXS5ydWxlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlUnVsZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaXQgaXMgc3RpbGwgdHJ1ZSB0aGF0IGl0IGlzIG9ubHkgb25lIHJ1bGVzZXQgaW4gYXJyYXlcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBsYXN0IHN1Y2ggbW9tZW50XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgY2hpbGRzXHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFJ1bGVzID0gZ2V0Qm9keVJ1bGVzKGF0UnVsZU5vZGUpO1xyXG4gICAgICAgICAgICBhdFJ1bGVOb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcclxuICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc0VtcHR5KGF0UnVsZU5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXJnZVJ1bGVzKGF0UnVsZU5vZGUucnVsZXNbMF0ucnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnV0aWxzLnJlc29sdmVWaXNpYmlsaXR5KGF0UnVsZU5vZGUsIG9yaWdpbmFsUnVsZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlzaXRBdFJ1bGVXaXRob3V0Qm9keTogZnVuY3Rpb24gKGF0UnVsZU5vZGUsIHZpc2l0QXJncykge1xyXG4gICAgICAgICAgICBpZiAoYXRSdWxlTm9kZS5ibG9ja3NWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXRSdWxlTm9kZS5uYW1lID09PSAnQGNoYXJzZXQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IG91dHB1dCB0aGUgZGVidWcgaW5mbyB0b2dldGhlciB3aXRoIHN1YnNlcXVlbnQgQGNoYXJzZXQgZGVmaW5pdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIGEgY29tbWVudCAob3IgQG1lZGlhIHN0YXRlbWVudCkgYmVmb3JlIHRoZSBhY3R1YWwgQGNoYXJzZXQgYXRydWxlIHdvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBiZSBjb25zaWRlcmVkIGlsbGVnYWwgY3NzIGFzIGl0IGhhcyB0byBiZSBvbiB0aGUgZmlyc3QgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdFJ1bGVOb2RlLmRlYnVnSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IG5ldyB0cmVlLkNvbW1lbnQoXCIvKiBcIiArIGF0UnVsZU5vZGUudG9DU1ModGhpcy5fY29udGV4dCkucmVwbGFjZSgvXFxuL2csICcnKSArIFwiICovXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LmRlYnVnSW5mbyA9IGF0UnVsZU5vZGUuZGVidWdJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRvci52aXNpdChjb21tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXRSdWxlTm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrVmFsaWROb2RlczogZnVuY3Rpb24gKHJ1bGVzLCBpc1Jvb3QpIHtcclxuICAgICAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBydWxlTm9kZSA9IHJ1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUm9vdCAmJiBydWxlTm9kZSBpbnN0YW5jZW9mIHRyZWUuRGVjbGFyYXRpb24gJiYgIXJ1bGVOb2RlLnZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnUHJvcGVydGllcyBtdXN0IGJlIGluc2lkZSBzZWxlY3RvciBibG9ja3MuIFRoZXkgY2Fubm90IGJlIGluIHRoZSByb290JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHJ1bGVOb2RlLmdldEluZGV4KCksIGZpbGVuYW1lOiBydWxlTm9kZS5maWxlSW5mbygpICYmIHJ1bGVOb2RlLmZpbGVJbmZvKCkuZmlsZW5hbWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChydWxlTm9kZSBpbnN0YW5jZW9mIHRyZWUuQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJGdW5jdGlvbiAnXCIgKyBydWxlTm9kZS5uYW1lICsgXCInIGRpZCBub3QgcmV0dXJuIGEgcm9vdCBub2RlXCIsIGluZGV4OiBydWxlTm9kZS5nZXRJbmRleCgpLCBmaWxlbmFtZTogcnVsZU5vZGUuZmlsZUluZm8oKSAmJiBydWxlTm9kZS5maWxlSW5mbygpLmZpbGVuYW1lIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocnVsZU5vZGUudHlwZSAmJiAhcnVsZU5vZGUuYWxsb3dSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiBydWxlTm9kZS50eXBlICsgXCIgbm9kZSByZXR1cm5lZCBieSBhIGZ1bmN0aW9uIGlzIG5vdCB2YWxpZCBoZXJlXCIsIGluZGV4OiBydWxlTm9kZS5nZXRJbmRleCgpLCBmaWxlbmFtZTogcnVsZU5vZGUuZmlsZUluZm8oKSAmJiBydWxlTm9kZS5maWxlSW5mbygpLmZpbGVuYW1lIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2l0UnVsZXNldDogZnVuY3Rpb24gKHJ1bGVzZXROb2RlLCB2aXNpdEFyZ3MpIHtcclxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCBydWxlc2V0cyBhcmUgbmVzdGVkIGludG8gZWFjaCBvdGhlclxyXG4gICAgICAgICAgICB2YXIgcnVsZTtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzZXRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWxpZE5vZGVzKHJ1bGVzZXROb2RlLnJ1bGVzLCBydWxlc2V0Tm9kZS5maXJzdFJvb3QpO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzZXROb2RlLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpbnZpc2libGUgcGF0aHNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVSdWxlc2V0UGF0aHMocnVsZXNldE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJ1bGVzZXRzIGZyb20gdGhpcyBydWxlc2V0IGJvZHkgYW5kIGNvbXBpbGUgdGhlbSBzZXBhcmF0ZWx5XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVJ1bGVzID0gcnVsZXNldE5vZGUucnVsZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVJ1bGVDbnQgPSBub2RlUnVsZXMgPyBub2RlUnVsZXMubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVJ1bGVDbnQ7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IG5vZGVSdWxlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLnJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2l0IGJlY2F1c2Ugd2UgYXJlIG1vdmluZyB0aGVtIG91dCBmcm9tIGJlaW5nIGEgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNldHMucHVzaCh0aGlzLl92aXNpdG9yLnZpc2l0KHJ1bGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJ1bGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJ1bGVDbnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdCB0aGUgdmlzaXRvciB0byByZW1vdmUgcnVsZXMgYW5kIHJlZmFjdG9yIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gZGVjaWRlIG5vZ3cgd2hldGhlciB3ZSB3YW50IGl0IG9yIG5vdFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZSBib2R5XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVJ1bGVDbnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldE5vZGUuYWNjZXB0KHRoaXMuX3Zpc2l0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNldE5vZGUucnVsZXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmlzaXRBcmdzLnZpc2l0RGVlcGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIGlmICghIHJ1bGVzZXROb2RlLnJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLmFjY2VwdCh0aGlzLl92aXNpdG9yKTtcclxuICAgICAgICAgICAgICAgIHZpc2l0QXJncy52aXNpdERlZXBlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChydWxlc2V0Tm9kZS5ydWxlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVyZ2VSdWxlcyhydWxlc2V0Tm9kZS5ydWxlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVEdXBsaWNhdGVSdWxlcyhydWxlc2V0Tm9kZS5ydWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm93IGRlY2lkZSB3aGV0aGVyIHdlIGtlZXAgdGhlIHJ1bGVzZXRcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNWaXNpYmxlUnVsZXNldChydWxlc2V0Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXROb2RlLmVuc3VyZVZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgICAgIHJ1bGVzZXRzLnNwbGljZSgwLCAwLCBydWxlc2V0Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGVzZXRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVzZXRzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlc2V0cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9jb21waWxlUnVsZXNldFBhdGhzOiBmdW5jdGlvbiAocnVsZXNldE5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzZXROb2RlLnBhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICBydWxlc2V0Tm9kZS5wYXRocyA9IHJ1bGVzZXROb2RlLnBhdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwWzBdLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IudmFsdWUgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwWzBdLmVsZW1lbnRzWzBdLmNvbWJpbmF0b3IgPSBuZXcgKHRyZWUuQ29tYmluYXRvcikoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtpXS5pc1Zpc2libGUoKSAmJiBwW2ldLmdldElzT3V0cHV0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfcmVtb3ZlRHVwbGljYXRlUnVsZXM6IGZ1bmN0aW9uIChydWxlcykge1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgdmFyIHJ1bGVDYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgcnVsZUxpc3Q7XHJcbiAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gcnVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHJ1bGUgPSBydWxlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgdHJlZS5EZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZUNhY2hlW3J1bGUubmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW3J1bGUubmFtZV0gPSBydWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QgPSBydWxlQ2FjaGVbcnVsZS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVMaXN0IGluc3RhbmNlb2YgdHJlZS5EZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUxpc3QgPSBydWxlQ2FjaGVbcnVsZS5uYW1lXSA9IFtydWxlQ2FjaGVbcnVsZS5uYW1lXS50b0NTUyh0aGlzLl9jb250ZXh0KV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVDU1MgPSBydWxlLnRvQ1NTKHRoaXMuX2NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUxpc3QuaW5kZXhPZihydWxlQ1NTKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVMaXN0LnB1c2gocnVsZUNTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9tZXJnZVJ1bGVzOiBmdW5jdGlvbiAocnVsZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBncm91cHMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGdyb3Vwc0FyciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUubWVyZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gcnVsZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID8gcnVsZXMuc3BsaWNlKGktLSwgMSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHNBcnIucHVzaChncm91cHNba2V5XSA9IFtdKTtcclxuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XS5wdXNoKHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3Vwc0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBncm91cFswXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VfMSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tYV8xID0gW25ldyB0cmVlLkV4cHJlc3Npb24oc3BhY2VfMSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChydWxlLm1lcmdlID09PSAnKycpICYmIChzcGFjZV8xLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYV8xLnB1c2gobmV3IHRyZWUuRXhwcmVzc2lvbihzcGFjZV8xID0gW10pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZV8xLnB1c2gocnVsZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xLmltcG9ydGFudCA9IHJlc3VsdF8xLmltcG9ydGFudCB8fCBydWxlLmltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRfMS52YWx1ZSA9IG5ldyB0cmVlLlZhbHVlKGNvbW1hXzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIHZpc2l0b3JzID0ge1xyXG4gICAgICAgIFZpc2l0b3I6IFZpc2l0b3IsXHJcbiAgICAgICAgSW1wb3J0VmlzaXRvcjogSW1wb3J0VmlzaXRvcixcclxuICAgICAgICBNYXJrVmlzaWJsZVNlbGVjdG9yc1Zpc2l0b3I6IFNldFRyZWVWaXNpYmlsaXR5VmlzaXRvcixcclxuICAgICAgICBFeHRlbmRWaXNpdG9yOiBQcm9jZXNzRXh0ZW5kc1Zpc2l0b3IsXHJcbiAgICAgICAgSm9pblNlbGVjdG9yVmlzaXRvcjogSm9pblNlbGVjdG9yVmlzaXRvcixcclxuICAgICAgICBUb0NTU1Zpc2l0b3I6IFRvQ1NTVmlzaXRvclxyXG4gICAgfTtcblxuICAgIC8vIFNwbGl0IHRoZSBpbnB1dCBpbnRvIGNodW5rcy5cclxuICAgIGZ1bmN0aW9uIGNodW5rZXIgKGlucHV0LCBmYWlsKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICB2YXIgbGV2ZWwgPSAwO1xyXG4gICAgICAgIHZhciBwYXJlbkxldmVsID0gMDtcclxuICAgICAgICB2YXIgbGFzdE9wZW5pbmc7XHJcbiAgICAgICAgdmFyIGxhc3RPcGVuaW5nUGFyZW47XHJcbiAgICAgICAgdmFyIGxhc3RNdWx0aUNvbW1lbnQ7XHJcbiAgICAgICAgdmFyIGxhc3RNdWx0aUNvbW1lbnRFbmRCcmFjZTtcclxuICAgICAgICB2YXIgY2h1bmtzID0gW107XHJcbiAgICAgICAgdmFyIGVtaXRGcm9tID0gMDtcclxuICAgICAgICB2YXIgY2h1bmtlckN1cnJlbnRJbmRleDtcclxuICAgICAgICB2YXIgY3VycmVudENodW5rU3RhcnRJbmRleDtcclxuICAgICAgICB2YXIgY2M7XHJcbiAgICAgICAgdmFyIGNjMjtcclxuICAgICAgICB2YXIgbWF0Y2hlZDtcclxuICAgICAgICBmdW5jdGlvbiBlbWl0Q2h1bmsoZm9yY2UpIHtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGNodW5rZXJDdXJyZW50SW5kZXggLSBlbWl0RnJvbTtcclxuICAgICAgICAgICAgaWYgKCgobGVuIDwgNTEyKSAmJiAhZm9yY2UpIHx8ICFsZW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaHVua3MucHVzaChpbnB1dC5zbGljZShlbWl0RnJvbSwgY2h1bmtlckN1cnJlbnRJbmRleCArIDEpKTtcclxuICAgICAgICAgICAgZW1pdEZyb20gPSBjaHVua2VyQ3VycmVudEluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjaHVua2VyQ3VycmVudEluZGV4ID0gMDsgY2h1bmtlckN1cnJlbnRJbmRleCA8IGxlbjsgY2h1bmtlckN1cnJlbnRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNjID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcclxuICAgICAgICAgICAgaWYgKCgoY2MgPj0gOTcpICYmIChjYyA8PSAxMjIpKSB8fCAoY2MgPCAzNCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGEteiBvciB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKGNjKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwOiAvLyAoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW5MZXZlbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcGVuaW5nUGFyZW4gPSBjaHVua2VyQ3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0MTogLy8gKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLXBhcmVuTGV2ZWwgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCdtaXNzaW5nIG9wZW5pbmcgYChgJywgY2h1bmtlckN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OTogLy8gO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW5MZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Q2h1bmsoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyMzogLy8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9wZW5pbmcgPSBjaHVua2VyQ3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjU6IC8vIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZXZlbCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ21pc3Npbmcgb3BlbmluZyBge2AnLCBjaHVua2VyQ3VycmVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZXZlbCAmJiAhcGFyZW5MZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Q2h1bmsoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkyOiAvLyBcXFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VyQ3VycmVudEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgndW5lc2NhcGVkIGBcXFxcYCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDk2OiAvLyBcIiwgJyBhbmQgYFxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1N0YXJ0SW5kZXggPSBjaHVua2VyQ3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAxOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MyID0gaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA+IDk2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MyID09IGNjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gOTIpIHsgLy8gXFxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua2VyQ3VycmVudEluZGV4ID09IGxlbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgndW5lc2NhcGVkIGBcXFxcYCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlckN1cnJlbnRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChcInVubWF0Y2hlZCBgXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNjKSArIFwiYFwiLCBjdXJyZW50Q2h1bmtTdGFydEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDc6IC8vIC8sIGNoZWNrIGZvciBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVuTGV2ZWwgfHwgKGNodW5rZXJDdXJyZW50SW5kZXggPT0gbGVuIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYzIgPT0gNDcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLy8sIGZpbmQgbG5mZWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAyOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuOyBjaHVua2VyQ3VycmVudEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjMiA9IGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNjMiA8PSAxMykgJiYgKChjYzIgPT0gMTApIHx8IChjYzIgPT0gMTMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNjMiA9PSA0Mikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAvKiwgZmluZCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TXVsdGlDb21tZW50ID0gY3VycmVudENodW5rU3RhcnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY2h1bmtlckN1cnJlbnRJbmRleCA9IGNodW5rZXJDdXJyZW50SW5kZXggKyAyOyBjaHVua2VyQ3VycmVudEluZGV4IDwgbGVuIC0gMTsgY2h1bmtlckN1cnJlbnRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYzIgPSBpbnB1dC5jaGFyQ29kZUF0KGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiA9PSAxMjUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TXVsdGlDb21tZW50RW5kQnJhY2UgPSBjaHVua2VyQ3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjMiAhPSA0Mikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoY2h1bmtlckN1cnJlbnRJbmRleCArIDEpID09IDQ3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rZXJDdXJyZW50SW5kZXggPT0gbGVuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ21pc3NpbmcgY2xvc2luZyBgKi9gJywgY3VycmVudENodW5rU3RhcnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlckN1cnJlbnRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDI6IC8vICosIGNoZWNrIGZvciB1bm1hdGNoZWQgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGNodW5rZXJDdXJyZW50SW5kZXggPCBsZW4gLSAxKSAmJiAoaW5wdXQuY2hhckNvZGVBdChjaHVua2VyQ3VycmVudEluZGV4ICsgMSkgPT0gNDcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCd1bm1hdGNoZWQgYC8qYCcsIGNodW5rZXJDdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGV2ZWwgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKChsYXN0TXVsdGlDb21tZW50ID4gbGFzdE9wZW5pbmcpICYmIChsYXN0TXVsdGlDb21tZW50RW5kQnJhY2UgPiBsYXN0TXVsdGlDb21tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ21pc3NpbmcgY2xvc2luZyBgfWAgb3IgYCovYCcsIGxhc3RPcGVuaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCdtaXNzaW5nIGNsb3NpbmcgYH1gJywgbGFzdE9wZW5pbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVuTGV2ZWwgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoJ21pc3NpbmcgY2xvc2luZyBgKWAnLCBsYXN0T3BlbmluZ1BhcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW1pdENodW5rKHRydWUpO1xyXG4gICAgICAgIHJldHVybiBjaHVua3M7XHJcbiAgICB9XG5cbiAgICB2YXIgZ2V0UGFyc2VySW5wdXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciAvLyBMZXNzIGlucHV0IHN0cmluZ1xyXG4gICAgICAgIGlucHV0O1xyXG4gICAgICAgIHZhciAvLyBjdXJyZW50IGNodW5rXHJcbiAgICAgICAgajtcclxuICAgICAgICB2YXIgLy8gaG9sZHMgc3RhdGUgZm9yIGJhY2t0cmFja2luZ1xyXG4gICAgICAgIHNhdmVTdGFjayA9IFtdO1xyXG4gICAgICAgIHZhciAvLyBmdXJ0aGVzdCBpbmRleCB0aGUgcGFyc2VyIGhhcyBnb25lIHRvXHJcbiAgICAgICAgZnVydGhlc3Q7XHJcbiAgICAgICAgdmFyIC8vIGlmIHRoaXMgaXMgZnVydGhlc3Qgd2UgZ290IHRvLCB0aGlzIGlzIHRoZSBwcm9iYWJseSBjYXVzZVxyXG4gICAgICAgIGZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgdmFyIC8vIGNodW5raWZpZWQgaW5wdXRcclxuICAgICAgICBjaHVua3M7XHJcbiAgICAgICAgdmFyIC8vIGN1cnJlbnQgY2h1bmtcclxuICAgICAgICBjdXJyZW50O1xyXG4gICAgICAgIHZhciAvLyBpbmRleCBvZiBjdXJyZW50IGNodW5rLCBpbiBgaW5wdXRgXHJcbiAgICAgICAgY3VycmVudFBvcztcclxuICAgICAgICB2YXIgcGFyc2VySW5wdXQgPSB7fTtcclxuICAgICAgICB2YXIgQ0hBUkNPREVfU1BBQ0UgPSAzMjtcclxuICAgICAgICB2YXIgQ0hBUkNPREVfVEFCID0gOTtcclxuICAgICAgICB2YXIgQ0hBUkNPREVfTEYgPSAxMDtcclxuICAgICAgICB2YXIgQ0hBUkNPREVfQ1IgPSAxMztcclxuICAgICAgICB2YXIgQ0hBUkNPREVfUExVUyA9IDQzO1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9DT01NQSA9IDQ0O1xyXG4gICAgICAgIHZhciBDSEFSQ09ERV9GT1JXQVJEX1NMQVNIID0gNDc7XHJcbiAgICAgICAgdmFyIENIQVJDT0RFXzkgPSA1NztcclxuICAgICAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZShsZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIG9sZGkgPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICB2YXIgb2xkaiA9IGo7XHJcbiAgICAgICAgICAgIHZhciBjdXJyID0gcGFyc2VySW5wdXQuaSAtIGN1cnJlbnRQb3M7XHJcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHBhcnNlcklucHV0LmkgKyBjdXJyZW50Lmxlbmd0aCAtIGN1cnI7XHJcbiAgICAgICAgICAgIHZhciBtZW0gPSAocGFyc2VySW5wdXQuaSArPSBsZW5ndGgpO1xyXG4gICAgICAgICAgICB2YXIgaW5wID0gaW5wdXQ7XHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICB2YXIgbmV4dENoYXI7XHJcbiAgICAgICAgICAgIHZhciBjb21tZW50O1xyXG4gICAgICAgICAgICBmb3IgKDsgcGFyc2VySW5wdXQuaSA8IGVuZEluZGV4OyBwYXJzZXJJbnB1dC5pKyspIHtcclxuICAgICAgICAgICAgICAgIGMgPSBpbnAuY2hhckNvZGVBdChwYXJzZXJJbnB1dC5pKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiAmJiBjID09PSBDSEFSQ09ERV9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIgPSBpbnAuY2hhckF0KHBhcnNlcklucHV0LmkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0geyBpbmRleDogcGFyc2VySW5wdXQuaSwgaXNMaW5lQ29tbWVudDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dE5ld0xpbmUgPSBpbnAuaW5kZXhPZignXFxuJywgcGFyc2VySW5wdXQuaSArIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dE5ld0xpbmUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TmV3TGluZSA9IGVuZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBuZXh0TmV3TGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC50ZXh0ID0gaW5wLnN1YnN0cihjb21tZW50LmluZGV4LCBwYXJzZXJJbnB1dC5pIC0gY29tbWVudC5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5wdXNoKGNvbW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dENoYXIgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXJTbGFzaCA9IGlucC5pbmRleE9mKCcqLycsIHBhcnNlcklucHV0LmkgKyAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGFyU2xhc2ggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcGFyc2VySW5wdXQuaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpbnAuc3Vic3RyKHBhcnNlcklucHV0LmksIG5leHRTdGFyU2xhc2ggKyAyIC0gcGFyc2VySW5wdXQuaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMaW5lQ29tbWVudDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pICs9IGNvbW1lbnQudGV4dC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLnB1c2goY29tbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgoYyAhPT0gQ0hBUkNPREVfU1BBQ0UpICYmIChjICE9PSBDSEFSQ09ERV9MRikgJiYgKGMgIT09IENIQVJDT0RFX1RBQikgJiYgKGMgIT09IENIQVJDT0RFX0NSKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNsaWNlKGxlbmd0aCArIHBhcnNlcklucHV0LmkgLSBtZW0gKyBjdXJyKTtcclxuICAgICAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgY2h1bmtzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2h1bmtzWysral07XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoMCk7IC8vIHNraXAgc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGNodW5rXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHRoaW5ncyBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5maW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9sZGkgIT09IHBhcnNlcklucHV0LmkgfHwgb2xkaiAhPT0gajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgIHNhdmVTdGFjay5wdXNoKHsgY3VycmVudDogY3VycmVudCwgaTogcGFyc2VySW5wdXQuaSwgajogaiB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUgPSBmdW5jdGlvbiAocG9zc2libGVFcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmkgPiBmdXJ0aGVzdCB8fCAocGFyc2VySW5wdXQuaSA9PT0gZnVydGhlc3QgJiYgcG9zc2libGVFcnJvck1lc3NhZ2UgJiYgIWZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdFBvc3NpYmxlRXJyb3JNZXNzYWdlID0gcG9zc2libGVFcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gc2F2ZVN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gc3RhdGUuY3VycmVudDtcclxuICAgICAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0LmkgPSBzdGF0ZS5pO1xyXG4gICAgICAgICAgICBqID0gc3RhdGUuajtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnNlcklucHV0LmZvcmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2F2ZVN0YWNrLnBvcCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gcGFyc2VySW5wdXQuaSArIChvZmZzZXQgfHwgMCk7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvZGUgPT09IENIQVJDT0RFX1NQQUNFIHx8IGNvZGUgPT09IENIQVJDT0RFX0NSIHx8IGNvZGUgPT09IENIQVJDT0RFX1RBQiB8fCBjb2RlID09PSBDSEFSQ09ERV9MRik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTcGVjaWFsaXphdGlvbiBvZiAkKHRvaylcclxuICAgICAgICBwYXJzZXJJbnB1dC4kcmUgPSBmdW5jdGlvbiAodG9rKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5pID4gY3VycmVudFBvcykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2xpY2UocGFyc2VySW5wdXQuaSAtIGN1cnJlbnRQb3MpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG0gPSB0b2suZXhlYyhjdXJyZW50KTtcclxuICAgICAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBza2lwV2hpdGVzcGFjZShtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtLmxlbmd0aCA9PT0gMSA/IG1bMF0gOiBtO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuJGNoYXIgPSBmdW5jdGlvbiAodG9rKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSkgIT09IHRvaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b2s7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC4kc3RyID0gZnVuY3Rpb24gKHRvaykge1xyXG4gICAgICAgICAgICB2YXIgdG9rTGVuZ3RoID0gdG9rLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3N0cmluZy1zdGFydHN3aXRoLzIxXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSArIGkpICE9PSB0b2suY2hhckF0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UodG9rTGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvaztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnNlcklucHV0LiRxdW90ZWQgPSBmdW5jdGlvbiAobG9jKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBsb2MgfHwgcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IGlucHV0LmNoYXJBdChwb3MpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRDaGFyICE9PSAnXFwnJyAmJiBzdGFydENoYXIgIT09ICdcIicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSArIGN1cnJlbnRQb3NpdGlvbiA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBpbnB1dC5jaGFyQXQoaSArIGN1cnJlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHN0YXJ0Q2hhcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IGlucHV0LnN1YnN0cihjdXJyZW50UG9zaXRpb24sIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2MgJiYgbG9jICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwV2hpdGVzcGFjZShpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RhcnRDaGFyLCBzdHJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVybWlzc2l2ZSBwYXJzaW5nLiBJZ25vcmVzIGV2ZXJ5dGhpbmcgZXhjZXB0IG1hdGNoaW5nIHt9IFtdICgpIGFuZCBxdW90ZXNcclxuICAgICAgICAgKiB1bnRpbCBtYXRjaGluZyB0b2tlbiAob3V0c2lkZSBvZiBibG9ja3MpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2VySW5wdXQuJHBhcnNlVW50aWwgPSBmdW5jdGlvbiAodG9rKSB7XHJcbiAgICAgICAgICAgIHZhciBxdW90ZSA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGluQ29tbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tEZXB0aCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBibG9ja1N0YWNrID0gW107XHJcbiAgICAgICAgICAgIHZhciBwYXJzZUdyb3VwcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICB2YXIgbGFzdFBvcyA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgIHZhciBpID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgdmFyIGxvb3AgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdGVzdENoYXI7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGVzdENoYXIgPSBmdW5jdGlvbiAoY2hhcikgeyByZXR1cm4gY2hhciA9PT0gdG9rOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGVzdENoYXIgPSBmdW5jdGlvbiAoY2hhcikgeyByZXR1cm4gdG9rLnRlc3QoY2hhcik7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gaW5wdXQuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrRGVwdGggPT09IDAgJiYgdGVzdENoYXIobmV4dENoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gaW5wdXQuc3Vic3RyKGxhc3RQb3MsIGkgLSBsYXN0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2gocmV0dXJuVmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2goJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gcGFyc2VHcm91cHM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoaSAtIHN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5Db21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gJyonICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQXQoaSArIDEpID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRGVwdGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQ29tbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmV4dENoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhciA9IGlucHV0LmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlR3JvdXBzLnB1c2goaW5wdXQuc3Vic3RyKGxhc3RQb3MsIGkgLSBsYXN0UG9zICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChpICsgMSkgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbkNvbW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRGVwdGgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdcXCcnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdcIic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IHBhcnNlcklucHV0LiRxdW90ZWQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVvdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUdyb3Vwcy5wdXNoKGlucHV0LnN1YnN0cihsYXN0UG9zLCBpIC0gbGFzdFBvcyksIHF1b3RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IHF1b3RlWzFdLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoaSAtIHN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBuZXh0Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1N0YWNrLnB1c2goJ30nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRGVwdGgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU3RhY2sucHVzaCgnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTdGFjay5wdXNoKCddJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0RlcHRoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnfSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICddJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPT09IGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tEZXB0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgcGFyc2VyIHRvIHRoZSBlcnJvciBhbmQgcmV0dXJuIGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoaSAtIHN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBleHBlY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChsb29wKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbCA/IHJldHVyblZhbCA6IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IHRydWU7XHJcbiAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlID0gW107XHJcbiAgICAgICAgcGFyc2VySW5wdXQuZmluaXNoZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBTYW1lIGFzICQoKSwgYnV0IGRvbid0IGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlcixcclxuICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgbWF0Y2guXHJcbiAgICAgICAgcGFyc2VySW5wdXQucGVlayA9IGZ1bmN0aW9uICh0b2spIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLXN0YXJ0c3dpdGgvMjFcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJBdChwYXJzZXJJbnB1dC5pICsgaSkgIT09IHRvay5jaGFyQXQoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvay50ZXN0KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTcGVjaWFsaXphdGlvbiBvZiBwZWVrKClcclxuICAgICAgICAvLyBUT0RPIHJlbW92ZSBvciBjaGFuZ2Ugc29tZSBjdXJyZW50Q2hhciBjYWxscyB0byBwZWVrQ2hhclxyXG4gICAgICAgIHBhcnNlcklucHV0LnBlZWtDaGFyID0gZnVuY3Rpb24gKHRvaykgeyByZXR1cm4gaW5wdXQuY2hhckF0KHBhcnNlcklucHV0LmkpID09PSB0b2s7IH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuY3VycmVudENoYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSk7IH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQucHJldkNoYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5jaGFyQXQocGFyc2VySW5wdXQuaSAtIDEpOyB9O1xyXG4gICAgICAgIHBhcnNlcklucHV0LmdldElucHV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQ7IH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQucGVla05vdE51bWVyaWMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gaW5wdXQuY2hhckNvZGVBdChwYXJzZXJJbnB1dC5pKTtcclxuICAgICAgICAgICAgLy8gSXMgdGhlIGZpcnN0IGNoYXIgb2YgdGhlIGRpbWVuc2lvbiAwLTksICcuJywgJysnIG9yICctJ1xyXG4gICAgICAgICAgICByZXR1cm4gKGMgPiBDSEFSQ09ERV85IHx8IGMgPCBDSEFSQ09ERV9QTFVTKSB8fCBjID09PSBDSEFSQ09ERV9GT1JXQVJEX1NMQVNIIHx8IGMgPT09IENIQVJDT0RFX0NPTU1BO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuc3RhcnQgPSBmdW5jdGlvbiAoc3RyLCBjaHVua0lucHV0LCBmYWlsRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBzdHI7XHJcbiAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBqID0gY3VycmVudFBvcyA9IGZ1cnRoZXN0ID0gMDtcclxuICAgICAgICAgICAgLy8gY2h1bmtpbmcgYXBwYXJlbnRseSBtYWtlcyB0aGluZ3MgcXVpY2tlciAoYnV0IG15IHRlc3RzIGluZGljYXRlXHJcbiAgICAgICAgICAgIC8vIGl0IG1pZ2h0IGFjdHVhbGx5IG1ha2UgdGhpbmdzIHNsb3dlciBpbiBub2RlIGF0IGxlYXN0KVxyXG4gICAgICAgICAgICAvLyBhbmQgaXQgaXMgYSBub24tcGVyZmVjdCBwYXJzZSAtIGl0IGNhbid0IHJlY29nbmlzZVxyXG4gICAgICAgICAgICAvLyB1bnF1b3RlZCB1cmxzLCBtZWFuaW5nIGl0IGNhbid0IGRpc3Rpbmd1aXNoIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIC8vIG1lYW5pbmcgY29tbWVudHMgd2l0aCBxdW90ZXMgb3Ige30oKSBpbiB0aGVtIGdldCAnY291bnRlZCdcclxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gbGVhZCB0byBwYXJzZSBlcnJvcnMuXHJcbiAgICAgICAgICAgIC8vIEluIGFkZGl0aW9uIGlmIHRoZSBjaHVua2luZyBjaHVua3MgaW4gdGhlIHdyb25nIHBsYWNlIHdlIG1pZ2h0XHJcbiAgICAgICAgICAgIC8vIG5vdCBiZSBhYmxlIHRvIHBhcnNlIGEgcGFyc2VyIHN0YXRlbWVudCBpbiBvbmUgZ29cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvZmZpY2lhbGx5IGRlcHJlY2F0ZWQgYnV0IGNhbiBiZSBzd2l0Y2hlZCBvbiB2aWEgYW4gb3B0aW9uXHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIGl0IGNhdXNlcyB0b28gbXVjaCBwZXJmb3JtYW5jZSBpc3N1ZXMuXHJcbiAgICAgICAgICAgIGlmIChjaHVua0lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBjaHVua2VyKHN0ciwgZmFpbEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNodW5rcyA9IFtzdHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjaHVua3NbMF07XHJcbiAgICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFyc2VySW5wdXQuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZTtcclxuICAgICAgICAgICAgdmFyIGlzRmluaXNoZWQgPSBwYXJzZXJJbnB1dC5pID49IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmkgPCBmdXJ0aGVzdCkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gZnVydGhlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzRmluaXNoZWQ6IGlzRmluaXNoZWQsXHJcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdDogcGFyc2VySW5wdXQuaSxcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdFJlYWNoZWRFbmQ6IHBhcnNlcklucHV0LmkgPj0gaW5wdXQubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0Q2hhcjogaW5wdXRbcGFyc2VySW5wdXQuaV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwYXJzZXJJbnB1dDtcclxuICAgIH0pO1xuXG4gICAgLy9cclxuICAgIC8vIGxlc3MuanMgLSBwYXJzZXJcclxuICAgIC8vXHJcbiAgICAvLyAgICBBIHJlbGF0aXZlbHkgc3RyYWlnaHQtZm9yd2FyZCBwcmVkaWN0aXZlIHBhcnNlci5cclxuICAgIC8vICAgIFRoZXJlIGlzIG5vIHRva2VuaXphdGlvbi9sZXhpbmcgc3RhZ2UsIHRoZSBpbnB1dCBpcyBwYXJzZWRcclxuICAgIC8vICAgIGluIG9uZSBzd2VlcC5cclxuICAgIC8vXHJcbiAgICAvLyAgICBUbyBtYWtlIHRoZSBwYXJzZXIgZmFzdCBlbm91Z2ggdG8gcnVuIGluIHRoZSBicm93c2VyLCBzZXZlcmFsXHJcbiAgICAvLyAgICBvcHRpbWl6YXRpb24gaGFkIHRvIGJlIG1hZGU6XHJcbiAgICAvL1xyXG4gICAgLy8gICAgLSBNYXRjaGluZyBhbmQgc2xpY2luZyBvbiBhIGh1Z2UgaW5wdXQgaXMgb2Z0ZW4gY2F1c2Ugb2Ygc2xvd2Rvd25zLlxyXG4gICAgLy8gICAgICBUaGUgc29sdXRpb24gaXMgdG8gY2h1bmtpZnkgdGhlIGlucHV0IGludG8gc21hbGxlciBzdHJpbmdzLlxyXG4gICAgLy8gICAgICBUaGUgY2h1bmtzIGFyZSBzdG9yZWQgaW4gdGhlIGBjaHVua3NgIHZhcixcclxuICAgIC8vICAgICAgYGpgIGhvbGRzIHRoZSBjdXJyZW50IGNodW5rIGluZGV4LCBhbmQgYGN1cnJlbnRQb3NgIGhvbGRzXHJcbiAgICAvLyAgICAgIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaHVuayBpbiByZWxhdGlvbiB0byBgaW5wdXRgLlxyXG4gICAgLy8gICAgICBUaGlzIGdpdmVzIHVzIGFuIGFsbW9zdCA0eCBzcGVlZC11cC5cclxuICAgIC8vXHJcbiAgICAvLyAgICAtIEluIG1hbnkgY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gbWF0Y2ggaW5kaXZpZHVhbCB0b2tlbnM7XHJcbiAgICAvLyAgICAgIGZvciBleGFtcGxlLCBpZiBhIHZhbHVlIGRvZXNuJ3QgaG9sZCBhbnkgdmFyaWFibGVzLCBvcGVyYXRpb25zXHJcbiAgICAvLyAgICAgIG9yIGR5bmFtaWMgcmVmZXJlbmNlcywgdGhlIHBhcnNlciBjYW4gZWZmZWN0aXZlbHkgJ3NraXAnIGl0LFxyXG4gICAgLy8gICAgICB0cmVhdGluZyBpdCBhcyBhIGxpdGVyYWwuXHJcbiAgICAvLyAgICAgIEFuIGV4YW1wbGUgd291bGQgYmUgJzFweCBzb2xpZCAjMDAwJyAtIHdoaWNoIGV2YWx1YXRlcyB0byBpdHNlbGYsXHJcbiAgICAvLyAgICAgIHdlIGRvbid0IG5lZWQgdG8ga25vdyB3aGF0IHRoZSBpbmRpdmlkdWFsIGNvbXBvbmVudHMgYXJlLlxyXG4gICAgLy8gICAgICBUaGUgZHJhd2JhY2ssIG9mIGNvdXJzZSBpcyB0aGF0IHlvdSBkb24ndCBnZXQgdGhlIGJlbmVmaXRzIG9mXHJcbiAgICAvLyAgICAgIHN5bnRheC1jaGVja2luZyBvbiB0aGUgQ1NTLiBUaGlzIGdpdmVzIHVzIGEgNTAlIHNwZWVkLXVwIGluIHRoZSBwYXJzZXIsXHJcbiAgICAvLyAgICAgIGFuZCBhIHNtYWxsZXIgc3BlZWQtdXAgaW4gdGhlIGNvZGUtZ2VuLlxyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvLyAgICBUb2tlbiBtYXRjaGluZyBpcyBkb25lIHdpdGggdGhlIGAkYCBmdW5jdGlvbiwgd2hpY2ggZWl0aGVyIHRha2VzXHJcbiAgICAvLyAgICBhIHRlcm1pbmFsIHN0cmluZyBvciByZWdleHAsIG9yIGEgbm9uLXRlcm1pbmFsIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAvLyAgICBJdCBhbHNvIHRha2VzIGNhcmUgb2YgbW92aW5nIGFsbCB0aGUgaW5kaWNlcyBmb3J3YXJkcy5cclxuICAgIC8vXHJcbiAgICB2YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKGNvbnRleHQsIGltcG9ydHMsIGZpbGVJbmZvKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlcnM7XHJcbiAgICAgICAgdmFyIHBhcnNlcklucHV0ID0gZ2V0UGFyc2VySW5wdXQoKTtcclxuICAgICAgICBmdW5jdGlvbiBlcnJvcihtc2csIHR5cGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyc2VySW5wdXQuaSxcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlSW5mby5maWxlbmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgJ1N5bnRheCcsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcclxuICAgICAgICAgICAgfSwgaW1wb3J0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdChhcmcsIG1zZykge1xyXG4gICAgICAgICAgICAvLyBzb21lIG9sZGVyIGJyb3dzZXJzIHJldHVybiB0eXBlb2YgJ2Z1bmN0aW9uJyBmb3IgUmVnRXhwXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gYXJnLmNhbGwocGFyc2VycykgOiBwYXJzZXJJbnB1dC4kcmUoYXJnKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcnJvcihtc2cgfHwgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICA/IFwiZXhwZWN0ZWQgJ1wiICsgYXJnICsgXCInIGdvdCAnXCIgKyBwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICsgXCInXCJcclxuICAgICAgICAgICAgICAgIDogJ3VuZXhwZWN0ZWQgdG9rZW4nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNwZWNpYWxpemF0aW9uIG9mIGV4cGVjdCgpXHJcbiAgICAgICAgZnVuY3Rpb24gZXhwZWN0Q2hhcihhcmcsIG1zZykge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcnJvcihtc2cgfHwgXCJleHBlY3RlZCAnXCIgKyBhcmcgKyBcIicgZ290ICdcIiArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldERlYnVnSW5mbyhpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlSW5mby5maWxlbmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGdldExvY2F0aW9uKGluZGV4LCBwYXJzZXJJbnB1dC5nZXRJbnB1dCgpKS5saW5lICsgMSxcclxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlbmFtZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgVXNlZCBhZnRlciBpbml0aWFsIHBhcnNpbmcgdG8gY3JlYXRlIG5vZGVzIG9uIHRoZSBmbHlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgIC0gc3RyaW5nIHRvIHBhcnNlXHJcbiAgICAgICAgICogIEBwYXJhbSB7QXJyYXl9ICBwYXJzZUxpc3QgICAgLSBhcnJheSBvZiBwYXJzZXJzIHRvIHJ1biBpbnB1dCB0aHJvdWdoIGUuZy4gW1widmFsdWVcIiwgXCJpbXBvcnRhbnRcIl1cclxuICAgICAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnRJbmRleCAtIHN0YXJ0IG51bWJlciB0byBiZWdpbiBpbmRleGluZ1xyXG4gICAgICAgICAqICBAcGFyYW0ge09iamVjdH0gZmlsZUluZm8gICAgIC0gZmlsZUluZm8gdG8gYXR0YWNoIHRvIGNyZWF0ZWQgbm9kZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZU5vZGUoc3RyLCBwYXJzZUxpc3QsIGN1cnJlbnRJbmRleCwgZmlsZUluZm8sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciByZXR1cm5Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gcGFyc2VySW5wdXQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhcnQoc3RyLCBmYWxzZSwgZnVuY3Rpb24gZmFpbChtc2csIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCArIGN1cnJlbnRJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgcCA9IHZvaWQgMCwgaSA9IHZvaWQgMDsgKHAgPSBwYXJzZUxpc3RbeF0pOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gcGFyc2VyLmk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2Vyc1twXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5faW5kZXggPSBpICsgY3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9maWxlSW5mbyA9IGZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuTm9kZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuTm9kZXMucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5mbyA9IHBhcnNlci5lbmQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbmRJbmZvLmlzRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXR1cm5Ob2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGUuaW5kZXggKyBjdXJyZW50SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB9LCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGUgUGFyc2VyXHJcbiAgICAgICAgLy9cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwYXJzZXJJbnB1dDogcGFyc2VySW5wdXQsXHJcbiAgICAgICAgICAgIGltcG9ydHM6IGltcG9ydHMsXHJcbiAgICAgICAgICAgIGZpbGVJbmZvOiBmaWxlSW5mbyxcclxuICAgICAgICAgICAgcGFyc2VOb2RlOiBwYXJzZU5vZGUsXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlLFxyXG4gICAgICAgICAgICAvLyBAcGFyYW0gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgJ2xlc3MnIG1hcmt1cFxyXG4gICAgICAgICAgICAvLyBAcGFyYW0gY2FsbGJhY2sgY2FsbCBgY2FsbGJhY2tgIHdoZW4gZG9uZS5cclxuICAgICAgICAgICAgLy8gQHBhcmFtIFthZGRpdGlvbmFsRGF0YV0gQW4gb3B0aW9uYWwgbWFwIHdoaWNoIGNhbiBjb250YWlucyB2YXJzIC0gYSBtYXAgKGtleSwgdmFsdWUpIG9mIHZhcmlhYmxlcyB0byBhcHBseVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2ssIGFkZGl0aW9uYWxEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdDtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsVmFycztcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZnlWYXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlVGV4dCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgZ2xvYmFsVmFycyA9IChhZGRpdGlvbmFsRGF0YSAmJiBhZGRpdGlvbmFsRGF0YS5nbG9iYWxWYXJzKSA/IFBhcnNlci5zZXJpYWxpemVWYXJzKGFkZGl0aW9uYWxEYXRhLmdsb2JhbFZhcnMpICsgXCJcXG5cIiA6ICcnO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZ5VmFycyA9IChhZGRpdGlvbmFsRGF0YSAmJiBhZGRpdGlvbmFsRGF0YS5tb2RpZnlWYXJzKSA/IFwiXFxuXCIgKyBQYXJzZXIuc2VyaWFsaXplVmFycyhhZGRpdGlvbmFsRGF0YS5tb2RpZnlWYXJzKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQucGx1Z2luTWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVQcm9jZXNzb3JzID0gY29udGV4dC5wbHVnaW5NYW5hZ2VyLmdldFByZVByb2Nlc3NvcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gcHJlUHJvY2Vzc29yc1tpXS5wcm9jZXNzKHN0ciwgeyBjb250ZXh0OiBjb250ZXh0LCBpbXBvcnRzOiBpbXBvcnRzLCBmaWxlSW5mbzogZmlsZUluZm8gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbFZhcnMgfHwgKGFkZGl0aW9uYWxEYXRhICYmIGFkZGl0aW9uYWxEYXRhLmJhbm5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVUZXh0ID0gKChhZGRpdGlvbmFsRGF0YSAmJiBhZGRpdGlvbmFsRGF0YS5iYW5uZXIpID8gYWRkaXRpb25hbERhdGEuYmFubmVyIDogJycpICsgZ2xvYmFsVmFycztcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkID0gaW1wb3J0cy5jb250ZW50c0lnbm9yZWRDaGFycztcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVkW2ZpbGVJbmZvLmZpbGVuYW1lXSA9IGlnbm9yZWRbZmlsZUluZm8uZmlsZW5hbWVdIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZFtmaWxlSW5mby5maWxlbmFtZV0gKz0gcHJlVGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcG90ZW50aWFsIFVURiBCeXRlIE9yZGVyIE1hcmtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHByZVRleHQgKyBzdHIucmVwbGFjZSgvXlxcdUZFRkYvLCAnJykgKyBtb2RpZnlWYXJzO1xyXG4gICAgICAgICAgICAgICAgaW1wb3J0cy5jb250ZW50c1tmaWxlSW5mby5maWxlbmFtZV0gPSBzdHI7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIHRoZSBwcmltYXJ5IHJ1bGUuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2hvbGUgc3ludGF4IHRyZWUgaXMgaGVsZCB1bmRlciBhIFJ1bGVzZXQgbm9kZSxcclxuICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGByb290YCBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSwgc28gbm8gYHt9YCBhcmVcclxuICAgICAgICAgICAgICAgIC8vIG91dHB1dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBpbnB1dCBpcyBwYXJzZWQuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnN0YXJ0KHN0ciwgY29udGV4dC5jaHVua0lucHV0LCBmdW5jdGlvbiBmYWlsKG1zZywgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUGFyc2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVJbmZvLmZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGltcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWUuTm9kZS5wcm90b3R5cGUucGFyc2UgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBuZXcgdHJlZS5SdWxlc2V0KG51bGwsIHRoaXMucGFyc2Vycy5wcmltYXJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWUuTm9kZS5wcm90b3R5cGUucm9vdE5vZGUgPSByb290O1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3Qucm9vdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5maXJzdFJvb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZnVuY3Rpb25SZWdpc3RyeSA9IGZ1bmN0aW9uUmVnaXN0cnkuaW5oZXJpdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYGlgIGlzIHNtYWxsZXIgdGhhbiB0aGUgYGlucHV0Lmxlbmd0aCAtIDFgLFxyXG4gICAgICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhlIHBhcnNlciB3YXNuJ3QgYWJsZSB0byBwYXJzZSB0aGUgd2hvbGVcclxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgc28gd2UndmUgZ290IGEgcGFyc2luZyBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBXZSB0cnkgdG8gZXh0cmFjdCBhIFxcbiBkZWxpbWl0ZWQgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgLy8gc2hvd2luZyB0aGUgbGluZSB3aGVyZSB0aGUgcGFyc2UgZXJyb3Igb2NjdXJyZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzcGxpdCBpdCB1cCBpbnRvIHR3byBwYXJ0cyAodGhlIHBhcnQgd2hpY2ggcGFyc2VkLFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBwYXJ0IHdoaWNoIGRpZG4ndCksIHNvIHdlIGNhbiBjb2xvciB0aGVtIGRpZmZlcmVudGx5LlxyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZm8gPSBwYXJzZXJJbnB1dC5lbmQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghZW5kSW5mby5pc0ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlbmRJbmZvLmZ1cnRoZXN0UG9zc2libGVFcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnVW5yZWNvZ25pc2VkIGlucHV0JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZm8uZnVydGhlc3RDaGFyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJy4gUG9zc2libHkgbWlzc2luZyBvcGVuaW5nIFxcJ3tcXCcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZEluZm8uZnVydGhlc3RDaGFyID09PSAnKScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJy4gUG9zc2libHkgbWlzc2luZyBvcGVuaW5nIFxcJyhcXCcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZEluZm8uZnVydGhlc3RSZWFjaGVkRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICcuIFBvc3NpYmx5IG1pc3Npbmcgc29tZXRoaW5nJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBMZXNzRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUGFyc2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZW5kSW5mby5mdXJ0aGVzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVJbmZvLmZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gZXJyb3IgfHwgZSB8fCBpbXBvcnRzLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBMZXNzRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IExlc3NFcnJvcihlLCBpbXBvcnRzLCBmaWxlSW5mby5maWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5wcm9jZXNzSW1wb3J0cyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgdmlzaXRvcnMuSW1wb3J0VmlzaXRvcihpbXBvcnRzLCBmaW5pc2gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5ydW4ocm9vdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEhlcmUgaW4sIHRoZSBwYXJzaW5nIHJ1bGVzL2Z1bmN0aW9uc1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBUaGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSBzeW50YXggdHJlZSBnZW5lcmF0ZWQgaXMgYXMgZm9sbG93czpcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gICBSdWxlc2V0IC0+ICBEZWNsYXJhdGlvbiAtPiBWYWx1ZSAtPiBFeHByZXNzaW9uIC0+IEVudGl0eVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBIZXJlJ3Mgc29tZSBMZXNzIGNvZGU6XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICAgIC5jbGFzcyB7XHJcbiAgICAgICAgICAgIC8vICAgICAgY29sb3I6ICNmZmY7XHJcbiAgICAgICAgICAgIC8vICAgICAgYm9yZGVyOiAxcHggc29saWQgIzAwMDtcclxuICAgICAgICAgICAgLy8gICAgICB3aWR0aDogQHcgKyA0cHg7XHJcbiAgICAgICAgICAgIC8vICAgICAgPiAuY2hpbGQgey4uLn1cclxuICAgICAgICAgICAgLy8gICAgfVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBBbmQgaGVyZSdzIHdoYXQgdGhlIHBhcnNlIHRyZWUgbWlnaHQgbG9vayBsaWtlOlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgICAgUnVsZXNldCAoU2VsZWN0b3IgJy5jbGFzcycsIFtcclxuICAgICAgICAgICAgLy8gICAgICAgICBEZWNsYXJhdGlvbiAoXCJjb2xvclwiLCAgVmFsdWUgKFtFeHByZXNzaW9uIFtDb2xvciAjZmZmXV0pKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgIERlY2xhcmF0aW9uIChcImJvcmRlclwiLCBWYWx1ZSAoW0V4cHJlc3Npb24gW0RpbWVuc2lvbiAxcHhdW0tleXdvcmQgXCJzb2xpZFwiXVtDb2xvciAjMDAwXV0pKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgIERlY2xhcmF0aW9uIChcIndpZHRoXCIsICBWYWx1ZSAoW0V4cHJlc3Npb24gW09wZXJhdGlvbiBcIiArIFwiIFtWYXJpYWJsZSBcIkB3XCJdW0RpbWVuc2lvbiA0cHhdXV0pKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFJ1bGVzZXQgKFNlbGVjdG9yIFtFbGVtZW50ICc+JywgJy5jaGlsZCddLCBbLi4uXSlcclxuICAgICAgICAgICAgLy8gICAgIF0pXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vICBJbiBnZW5lcmFsLCBtb3N0IHJ1bGVzIHdpbGwgdHJ5IHRvIHBhcnNlIGEgdG9rZW4gd2l0aCB0aGUgYCRyZSgpYCBmdW5jdGlvbiwgYW5kIGlmIHRoZSByZXR1cm5cclxuICAgICAgICAgICAgLy8gIHZhbHVlIGlzIHRydWx5LCB3aWxsIHJldHVybiBhIG5ldyBub2RlLCBvZiB0aGUgcmVsZXZhbnQgdHlwZS4gU29tZXRpbWVzLCB3ZSBuZWVkIHRvIGNoZWNrXHJcbiAgICAgICAgICAgIC8vICBmaXJzdCwgYmVmb3JlIHBhcnNpbmcsIHRoYXQncyB3aGVuIHdlIHVzZSBgcGVlaygpYC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgcGFyc2VyczogcGFyc2VycyA9IHtcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHByaW1hcnlgIHJ1bGUgaXMgdGhlICplbnRyeSogYW5kICpleGl0KiBwb2ludCBvZiB0aGUgcGFyc2VyLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJ1bGVzIGhlcmUgY2FuIGFwcGVhciBhdCBhbnkgbGV2ZWwgb2YgdGhlIHBhcnNlIHRyZWUuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlY3Vyc2l2ZSBuYXR1cmUgb2YgdGhlIGdyYW1tYXIgaXMgYW4gaW50ZXJwbGF5IGJldHdlZW4gdGhlIGBibG9ja2BcclxuICAgICAgICAgICAgICAgIC8vIHJ1bGUsIHdoaWNoIHJlcHJlc2VudHMgYHsgLi4uIH1gLCB0aGUgYHJ1bGVzZXRgIHJ1bGUsIGFuZCB0aGlzIGBwcmltYXJ5YCBydWxlLFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgcmVwcmVzZW50ZWQgYnkgdGhpcyBzaW1wbGlmaWVkIGdyYW1tYXI6XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHByaW1hcnkgIOKGkiAgKHJ1bGVzZXQgfCBkZWNsYXJhdGlvbikrXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgcnVsZXNldCAg4oaSICBzZWxlY3RvcisgYmxvY2tcclxuICAgICAgICAgICAgICAgIC8vICAgICBibG9jayAgICDihpIgICd7JyBwcmltYXJ5ICd9J1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXQgb25lIHBvaW50IGlzIHRoZSBwcmltYXJ5IHJ1bGUgbm90IGNhbGxlZCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gYmxvY2sgcnVsZTogYXQgdGhlIHJvb3QgbGV2ZWwuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgcHJpbWFyeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaXhpbiA9IHRoaXMubWl4aW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuY29tbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHByb2Nlc3MgY29tbWVudHMgYmVmb3JlIGRlY2lkaW5nIGlmIGZpbmlzaGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5maW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnBlZWsoJ30nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZXh0ZW5kUnVsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY29uY2F0KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG1peGluLmRlZmluaXRpb24oKSB8fCB0aGlzLmRlY2xhcmF0aW9uKCkgfHwgbWl4aW4uY2FsbChmYWxzZSwgZmFsc2UpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzZXQoKSB8fCB0aGlzLnZhcmlhYmxlQ2FsbCgpIHx8IHRoaXMuZW50aXRpZXMuY2FsbCgpIHx8IHRoaXMuYXRydWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRTZW1pQ29sb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJzZXJJbnB1dC4kY2hhcignOycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTZW1pQ29sb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFNlbWlDb2xvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRzIGFyZSBjb2xsZWN0ZWQgYnkgdGhlIG1haW4gcGFyc2luZyBtZWNoYW5pc20gYW5kIHRoZW4gYXNzaWduZWQgdG8gbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IHN0cnVjdHVyZSBhbGxvd3MgaXRcclxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkNvbW1lbnQpKGNvbW1lbnQudGV4dCwgY29tbWVudC5pc0xpbmVDb21tZW50LCBjb21tZW50LmluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBFbnRpdGllcyBhcmUgdG9rZW5zIHdoaWNoIGNhbiBiZSBmb3VuZCBpbnNpZGUgYW4gRXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGVudGl0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWl4aW5Mb29rdXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcnMubWl4aW4uY2FsbCh0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzdHJpbmcsIHdoaWNoIHN1cHBvcnRzIGVzY2FwaW5nIFwiIGFuZCAnXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgXCJtaWxreSB3YXlcIiAnaGVcXCdzIHRoZSBvbmUhJ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVkOiBmdW5jdGlvbiAoZm9yY2VFc2NhcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VzY2FwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJ34nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JjZUVzY2FwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBwYXJzZXJJbnB1dC4kcXVvdGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuUXVvdGVkKShzdHIuY2hhckF0KDApLCBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKSwgaXNFc2NhcGVkLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIGNhdGNoLWFsbCB3b3JkLCBzdWNoIGFzOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJsYWNrIGJvcmRlci1jb2xsYXBzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHBhcnNlcklucHV0LiRjaGFyKCclJykgfHwgcGFyc2VySW5wdXQuJHJlKC9eXFxbPyg/OltcXHctXXxcXFxcKD86W0EtRmEtZjAtOV17MSw2fSA/fFteQS1GYS1mMC05XSkpK1xcXT8vKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmVlLkNvbG9yLmZyb21LZXl3b3JkKGspIHx8IG5ldyAodHJlZS5LZXl3b3JkKShrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICByZ2IoMjU1LCAwLCAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgd2l0aCB0aGUgYGVudGl0aWVzLmFyZ3VtZW50c2AgcGFyc2VyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdW5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jYXNlLWluc2Vuc2l0aXZlLXJlZ2V4LXZzLXN0cnRvbG93ZXItdGhlbi1yZWdleC8xOFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygvXnVybFxcKC9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXihbXFx3LV0rfCV8fnxwcm9naWQ6W1xcd1xcLl0rKVxcKC8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gdGhpcy5jdXN0b21GdW5jQ2FsbChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBmdW5jLnBhcnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyAmJiBmdW5jLnN0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5hcmd1bWVudHMoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgnQ291bGQgbm90IHBhcnNlIGNhbGwgYXJndW1lbnRzIG9yIG1pc3NpbmcgXFwnKVxcJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkNhbGwpKG5hbWUsIGFyZ3MsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNpbmcgcnVsZXMgZm9yIGZ1bmN0aW9ucyB3aXRoIG5vbi1zdGFuZGFyZCBhcmdzLCBlLmcuOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJvb2xlYW4obm90KDIgPiAxKSlcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBUaGlzIGlzIGEgcXVpY2sgcHJvdG90eXBlLCB0byBiZSBtb2RpZmllZC9pbXByb3ZlZCB3aGVuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIG1vcmUgY3VzdG9tLXBhcnNlZCBmdW5jcyBjb21lIChlLmcuIGBzZWxlY3RvciguLi4pYClcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUZ1bmNDYWxsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBJZGVhbGx5IHRoZSB0YWJsZSBpcyB0byBiZSBtb3ZlZCBvdXQgb2YgaGVyZSBmb3IgZmFzdGVyIHBlcmYuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBidXQgaXQncyBxdWl0ZSB0cmlja3kgc2luY2UgaXQgcmVsaWVzIG9uIGFsbCB0aGVzZSBgcGFyc2Vyc2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBleHBlY3RgIGF2YWlsYWJsZSBvbmx5IGhlcmUgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiBmKHBhcnNlcnMuaWVBbHBoYSwgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sZWFuOiBmKGNvbmRpdGlvbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWYnOiBmKGNvbmRpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVtuYW1lLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKHBhcnNlLCBzdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiBwYXJzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wOiBzdG9wIC8vIHdoZW4gdHJ1ZSAtIHN0b3AgYWZ0ZXIgcGFyc2UoKSBhbmQgcmV0dXJuIGl0cyByZXN1bHQsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjb250aW51ZSBmb3IgcGxhaW4gYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25kaXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2V4cGVjdChwYXJzZXJzLmNvbmRpdGlvbiwgJ2V4cGVjdGVkIGNvbmRpdGlvbicpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbiAocHJldkFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NDb21tYSA9IHByZXZBcmdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc1NlbWlDb2xvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNTZW1pQ29sb25TZXBhcmF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkFyZ3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Vycy5kZXRhY2hlZFJ1bGVzZXQoKSB8fCB0aGlzLmFzc2lnbm1lbnQoKSB8fCBwYXJzZXJzLmV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUgJiYgdmFsdWUudmFsdWUubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc0NvbW1hLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignOycpIHx8IGlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKGFyZ3NDb21tYS5sZW5ndGggPCAxKSA/IGFyZ3NDb21tYVswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyB0cmVlLlZhbHVlKGFyZ3NDb21tYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1NlbWlDb2xvbi5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzQ29tbWEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdW90ZWQoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmljb2RlRGVzY3JpcHRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWdubWVudHMgYXJlIGFyZ3VtZW50IGVudGl0aWVzIGZvciBjYWxscy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IGFyZSBwcmVzZW50IGluIGllIGZpbHRlciBwcm9wZXJ0aWVzIGFzIHNob3duIGJlbG93LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKCAqb3BhY2l0eT01MCogKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gcGFyc2VySW5wdXQuJHJlKC9eXFx3Kyg/PVxccz89KS9pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlcnMuZW50aXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkFzc2lnbm1lbnQpKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHVybCgpIHRva2Vuc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgc3BlY2lmaWMgcnVsZSBmb3IgdXJscywgYmVjYXVzZSB0aGV5IGRvbid0IHJlYWxseSBiZWhhdmUgbGlrZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkIGZ1bmN0aW9uIGNhbGxzLiBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBhcmd1bWVudCBkb2Vzbid0IGhhdmVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBlbmNsb3NlZCB3aXRoaW4gYSBzdHJpbmcsIHNvIGl0IGNhbid0IGJlIHBhcnNlZCBhcyBhbiBFeHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuYXV0b0NvbW1lbnRBYnNvcmIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kc3RyKCd1cmwoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucXVvdGVkKCkgfHwgdGhpcy52YXJpYWJsZSgpIHx8IHRoaXMucHJvcGVydHkoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuJHJlKC9eKD86KD86XFxcXFtcXChcXCknXCJdKXxbXlxcKFxcKSdcIl0pKy8pIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5VUkwpKCh2YWx1ZS52YWx1ZSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIHRyZWUuVmFyaWFibGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgdHJlZS5Qcm9wZXJ0eSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiBuZXcgKHRyZWUuQW5vbnltb3VzKSh2YWx1ZSwgaW5kZXgpLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIFZhcmlhYmxlIGVudGl0eSwgc3VjaCBhcyBgQGZpbmtgLCBpblxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHdpZHRoOiBAZmluayArIDJweFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgZGlmZmVyZW50IHBhcnNlciBmb3IgdmFyaWFibGUgZGVmaW5pdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGBwYXJzZXJzLnZhcmlhYmxlYC5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdAJyAmJiAobmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXkBAP1tcXHctXSsvKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJygnIHx8IGNoID09PSAnWycgJiYgIXBhcnNlcklucHV0LnByZXZDaGFyKCkubWF0Y2goL15cXHMvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWF5IGJlIGEgVmFyaWFibGVDYWxsIGxvb2t1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZXJzLnZhcmlhYmxlQ2FsbChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5WYXJpYWJsZSkobmFtZSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBBIHZhcmlhYmxlIGVudGl0eSB1c2luZyB0aGUgcHJvdGVjdGl2ZSB7fSBlLmcuIEB7dmFyfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlQ3VybHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cmx5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJ0AnICYmIChjdXJseSA9IHBhcnNlcklucHV0LiRyZSgvXkBcXHsoW1xcdy1dKylcXH0vKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuVmFyaWFibGUpKFwiQFwiICsgY3VybHlbMV0sIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBQcm9wZXJ0eSBhY2Nlc3Nvciwgc3VjaCBhcyBgJGNvbG9yYCwgaW5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJyQnICYmIChuYW1lID0gcGFyc2VySW5wdXQuJHJlKC9eXFwkW1xcdy1dKy8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5Qcm9wZXJ0eSkobmFtZSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBwcm9wZXJ0eSBlbnRpdHkgdXNlaW5nIHRoZSBwcm90ZWN0aXZlIHt9IGUuZy4gJHtwcm9wfVxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q3VybHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cmx5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSA9PT0gJyQnICYmIChjdXJseSA9IHBhcnNlcklucHV0LiRyZSgvXlxcJFxceyhbXFx3LV0rKVxcfS8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5Qcm9wZXJ0eSkoXCIkXCIgKyBjdXJseVsxXSwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIEhleGFkZWNpbWFsIGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIzRGM0MyRlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHJnYmAgYW5kIGBoc2xgIGNvbG9ycyBhcmUgcGFyc2VkIHRocm91Z2ggdGhlIGBlbnRpdGllcy5jYWxsYCBwYXJzZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmdiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnIycgJiYgKHJnYiA9IHBhcnNlcklucHV0LiRyZSgvXiMoW0EtRmEtZjAtOV17OH18W0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17Myw0fSkoW1xcdy4jXFxbXSk/LykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJnYlsyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQ29sb3IpKHJnYlsxXSwgdW5kZWZpbmVkLCByZ2JbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yS2V5d29yZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdXRvQ29tbWVudEFic29yYiA9IHBhcnNlcklucHV0LmF1dG9Db21tZW50QWJzb3JiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IHBhcnNlcklucHV0LiRyZSgvXltfQS1aYS16LV1bX0EtWmEtejAtOS1dKy8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5hdXRvQ29tbWVudEFic29yYiA9IGF1dG9Db21tZW50QWJzb3JiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdHJlZS5Db2xvci5mcm9tS2V5d29yZChrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kc3RyKGspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgRGltZW5zaW9uLCB0aGF0IGlzLCBhIG51bWJlciBhbmQgYSB1bml0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgMC41ZW0gOTUlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnBlZWtOb3ROdW1lcmljKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oWystXT9cXGQqXFwuP1xcZCspKCV8W2Etel9dKyk/L2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuRGltZW5zaW9uKSh2YWx1ZVsxXSwgdmFsdWVbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgdW5pY29kZSBkZXNjcmlwdG9yLCBhcyBpcyB1c2VkIGluIHVuaWNvZGUtcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFUrMD8/ICBvciBVKzAwQTEtMDBBOVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pY29kZURlc2NyaXB0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1ZCA9IHBhcnNlcklucHV0LiRyZSgvXlVcXCtbMC05YS1mQS1GP10rKFxcLVswLTlhLWZBLUY/XSspPy8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuVW5pY29kZURlc2NyaXB0b3IpKHVkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBKYXZhU2NyaXB0IGNvZGUgdG8gYmUgZXZhbHVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYHdpbmRvdy5sb2NhdGlvbi5ocmVmYFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgamF2YXNjcmlwdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIganM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZSA9IHBhcnNlcklucHV0LiRjaGFyKCd+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqc1F1b3RlID0gcGFyc2VySW5wdXQuJGNoYXIoJ2AnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqc1F1b3RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAganMgPSBwYXJzZXJJbnB1dC4kcmUoL15bXmBdKmAvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuSmF2YVNjcmlwdCkoanMuc3Vic3RyKDAsIGpzLmxlbmd0aCAtIDEpLCBCb29sZWFuKGVzY2FwZSksIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgnaW52YWxpZCBqYXZhc2NyaXB0IGRlZmluaXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIFRoZSB2YXJpYWJsZSBwYXJ0IG9mIGEgdmFyaWFibGUgZGVmaW5pdGlvbi4gVXNlZCBpbiB0aGUgYHJ1bGVgIHBhcnNlclxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICBAZmluazpcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnQCcgJiYgKG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oQFtcXHctXSspXFxzKjovKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGEgdmFyaWFibGUgdmFsdWUgdG8gcmV0cmlldmUgYSBkZXRhY2hlZCBydWxlc2V0XHJcbiAgICAgICAgICAgICAgICAvLyBvciBhIHZhbHVlIGZyb20gYSBkZXRhY2hlZCBydWxlc2V0J3MgcnVsZXMuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIEBmaW5rKCk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgQGZpbms7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgY29sb3I6IEBmaW5rW0Bjb2xvcl07XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVDYWxsOiBmdW5jdGlvbiAocGFyc2VkTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb29rdXBzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5WYWx1ZSA9ICEhcGFyc2VkTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnNlZE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIHx8IChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnQCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oQFtcXHctXSspKFxcKFxccypcXCkpPy8pKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9va3VwcyA9IHRoaXMubWl4aW4ucnVsZUxvb2t1cHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rdXBzICYmICgoaW5WYWx1ZSAmJiBwYXJzZXJJbnB1dC4kc3RyKCcoKScpICE9PSAnKCknKSB8fCAobmFtZVsyXSAhPT0gJygpJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdNaXNzaW5nIFxcJ1suLi5dXFwnIGxvb2t1cCBpbiB2YXJpYWJsZSBjYWxsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpblZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbCA9IG5ldyB0cmVlLlZhcmlhYmxlQ2FsbChuYW1lLCBpLCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5WYWx1ZSAmJiBwYXJzZXJzLmVuZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuTmFtZXNwYWNlVmFsdWUoY2FsbCwgbG9va3VwcywgaSwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kIHN5bnRheCAtIHVzZWQgdG8gZXh0ZW5kIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKGlzUnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZExpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRzdHIoaXNSdWxlID8gJyY6ZXh0ZW5kKCcgOiAnOmV4dGVuZCgnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIShvcHRpb24gPSBwYXJzZXJJbnB1dC4kcmUoL14oYWxsKSg/PVxccyooXFwpfCwpKS8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uICYmIG9wdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ01pc3NpbmcgdGFyZ2V0IHNlbGVjdG9yIGZvciA6ZXh0ZW5kKCkuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kID0gbmV3ICh0cmVlLkV4dGVuZCkobmV3ICh0cmVlLlNlbGVjdG9yKShlbGVtZW50cyksIG9wdGlvbiwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZExpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZExpc3QucHVzaChleHRlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGlzdCA9IFtleHRlbmRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocGFyc2VySW5wdXQuJGNoYXIoJywnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KC9eXFwpLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoL147Lyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRlbmRMaXN0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbmRSdWxlIC0gdXNlZCBpbiBhIHJ1bGUgdG8gZXh0ZW5kIGFsbCB0aGUgcGFyZW50IHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGV4dGVuZFJ1bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIE1peGluc1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIG1peGluOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIE1peGluIGNhbGwsIHdpdGggYW4gb3B0aW9uYWwgYXJndW1lbnQgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICNtaXhpbnMgPiAuc3F1YXJlKCNmZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAjbWl4aW5zLnNxdWFyZSgjZmZmKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgLnJvdW5kZWQoNHB4LCBibGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIC5idXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gbG9va3VwIC8gcmV0dXJuIGEgdmFsdWUgdXNpbmcgdGhlIGxvb2t1cCBzeW50YXg6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29sb3I6ICNtaXhpbi5zcXVhcmUoI2ZmZilbQGNvbG9yXTtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBgd2hpbGVgIGxvb3AgaXMgdGhlcmUgYmVjYXVzZSBtaXhpbnMgY2FuIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmFtZXNwYWNlZCwgYnV0IHdlIG9ubHkgc3VwcG9ydCB0aGUgY2hpbGQgYW5kIGRlc2NlbmRhbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvciBmb3Igbm93LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbDogZnVuY3Rpb24gKGluVmFsdWUsIGdldExvb2t1cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRhbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvb2t1cHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNQYXJlbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSAnLicgJiYgcyAhPT0gJyMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpOyAvLyBzdG9wIHVzIGFic29yYmluZyBwYXJ0IG9mIGFuIGludmFsaWQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5hcmdzKHRydWUpLmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0Q2hhcignKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1BhcmVucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TG9va3VwICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cHMgPSB0aGlzLnJ1bGVMb29rdXBzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TG9va3VwID09PSB0cnVlICYmICFsb29rdXBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblZhbHVlICYmICFsb29rdXBzICYmICFoYXNQYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzbid0IGEgdmFsaWQgaW4tdmFsdWUgbWl4aW4gY2FsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluVmFsdWUgJiYgcGFyc2Vycy5pbXBvcnRhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5WYWx1ZSB8fCBwYXJzZXJzLmVuZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1peGluID0gbmV3ICh0cmVlLm1peGluLkNhbGwpKGVsZW1lbnRzLCBhcmdzLCBpbmRleCwgZmlsZUluZm8sICFsb29rdXBzICYmIGltcG9ydGFudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2t1cHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLk5hbWVzcGFjZVZhbHVlKG1peGluLCBsb29rdXBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogTWF0Y2hpbmcgZWxlbWVudHMgZm9yIG1peGluc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIChTdGFydCB3aXRoIC4gb3IgIyBhbmQgY2FuIGhhdmUgPiApXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmUgPSAvXlsjLl0oPzpbXFx3LV18XFxcXCg/OltBLUZhLWYwLTldezEsNn0gP3xbXkEtRmEtZjAtOV0pKSsvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbUluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBwYXJzZXJJbnB1dC4kcmUocmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gbmV3ICh0cmVlLkVsZW1lbnQpKGMsIGUsIGZhbHNlLCBlbGVtSW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBwYXJzZXJJbnB1dC4kY2hhcignPicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGZ1bmN0aW9uIChpc0NhbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gcGFyc2Vycy5lbnRpdGllcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVyID0geyBhcmdzOiBudWxsLCB2YXJpYWRpYzogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzU2VtaUNvbG9uID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzQ29tbWEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2VtaUNvbG9uU2VwYXJhdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbkNvbnRhaW5zTmFtZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZUxvb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1NlcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBwYXJzZXJzLmRldGFjaGVkUnVsZXNldCgpIHx8IHBhcnNlcnMuZXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRzdHIoJy4uLicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVyLnZhcmlhZGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc7JykgJiYgIWlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wdXNoKHsgdmFyaWFkaWM6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBlbnRpdGllcy52YXJpYWJsZSgpIHx8IGVudGl0aWVzLnByb3BlcnR5KCkgfHwgZW50aXRpZXMubGl0ZXJhbCgpIHx8IGVudGl0aWVzLmtleXdvcmQoKSB8fCB0aGlzLmNhbGwodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZyB8fCAhaGFzU2VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lTG9vcCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnRocm93QXdheUNvbW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnRocm93QXdheUNvbW1lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy52YWx1ZSAmJiBhcmcudmFsdWUubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnLnZhbHVlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgJiYgKHZhbCBpbnN0YW5jZW9mIHRyZWUuVmFyaWFibGUgfHwgdmFsIGluc3RhbmNlb2YgdHJlZS5Qcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzonKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCBtaXggOyBhbmQgLCBhcyBkZWxpbWl0ZXIgdHlwZXMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250YWluc05hbWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlcnMuZGV0YWNoZWRSdWxlc2V0KCkgfHwgcGFyc2Vycy5leHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignY291bGQgbm90IHVuZGVyc3RhbmQgdmFsdWUgZm9yIG5hbWVkIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIuYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lTG9vcCA9IChuYW1lID0gdmFsLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXJJbnB1dC4kc3RyKCcuLi4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZXIudmFyaWFkaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc7JykgJiYgIWlzU2VtaUNvbG9uU2VwYXJhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZW1pQ29sb25TZXBhcmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzU2VtaUNvbG9uU2VwYXJhdGVkID8gYXJnc1NlbWlDb2xvbiA6IGFyZ3NDb21tYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHVzaCh7IG5hbWU6IGFyZy5uYW1lLCB2YXJpYWRpYzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lTG9vcCA9IHZhbC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzQ29tbWEucHVzaCh7IG5hbWU6IG5hbWVMb29wLCB2YWx1ZTogdmFsdWUsIGV4cGFuZDogZXhwYW5kIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNTZXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzU2VwID0gcGFyc2VySW5wdXQuJGNoYXIoJzsnKSA9PT0gJzsnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NlcCB8fCBpc1NlbWlDb2xvblNlcGFyYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uQ29udGFpbnNOYW1lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IG1peCA7IGFuZCAsIGFzIGRlbGltaXRlciB0eXBlcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlbWlDb2xvblNlcGFyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgKHRyZWUuVmFsdWUpKGV4cHJlc3Npb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1NlbWlDb2xvbi5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBleHBhbmQ6IGV4cGFuZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db250YWluc05hbWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVyLmFyZ3MgPSBpc1NlbWlDb2xvblNlcGFyYXRlZCA/IGFyZ3NTZW1pQ29sb24gOiBhcmdzQ29tbWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lcjtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBNaXhpbiBkZWZpbml0aW9uLCB3aXRoIGEgbGlzdCBvZiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgLnJvdW5kZWQgKEByYWRpdXM6IDJweCwgQGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBVbnRpbCB3ZSBoYXZlIGEgZmluZXIgZ3JhaW5lZCBzdGF0ZS1tYWNoaW5lLCB3ZSBoYXZlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYSBsb29rLWFoZWFkLCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBhIG1peGluIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIHRoZSBgcnVsZWAgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdGFydCBieSBtYXRjaGluZyBgLnJvdW5kZWQgKGAsIGFuZCB0aGVuIHByb2NlZWQgb24gdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYXJndW1lbnQgbGlzdCwgd2hpY2ggaGFzIG9wdGlvbmFsIGRlZmF1bHQgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHN0b3JlIHRoZSBwYXJhbWV0ZXJzIGluIGBwYXJhbXNgLCB3aXRoIGEgYHZhbHVlYCBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB2YWx1ZSwgc3VjaCBhcyBpbiB0aGUgY2FzZSBvZiBgQHJhZGl1c2AuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIHdlJ3ZlIGdvdCBvdXIgcGFyYW1zIGxpc3QsIGFuZCBhIGNsb3NpbmcgYClgLCB3ZSBwYXJzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgey4uLn1gIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhZGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJy4nICYmIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICcjJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnBlZWsoL15bXntdKlxcfS8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHBhcnNlcklucHV0LiRyZSgvXihbIy5dKD86W1xcdy1dfFxcXFwoPzpbQS1GYS1mMC05XXsxLDZ9ID98W15BLUZhLWYwLTldKSkrKVxccypcXCgvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnSW5mbyA9IHRoaXMuYXJncyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdJbmZvLmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWRpYyA9IGFyZ0luZm8udmFyaWFkaWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAubWl4aW5jYWxsKFwiQHthfVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2tzIGEgYml0IGxpa2UgYSBtaXhpbiBkZWZpbml0aW9uLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5taXhpbmNhbGwoQGE6IHtydWxlOiBzZXQ7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIGJlIG5pY2UgYW5kIHJlc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoJ01pc3NpbmcgY2xvc2luZyBcXCcpXFwnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cignd2hlbicpKSB7IC8vIEd1YXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZCA9IGV4cGVjdChwYXJzZXJzLmNvbmRpdGlvbnMsICdleHBlY3RlZCBjb25kaXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzZXQgPSBwYXJzZXJzLmJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUubWl4aW4uRGVmaW5pdGlvbikobmFtZSwgcGFyYW1zLCBydWxlc2V0LCBjb25kLCB2YXJpYWRpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVMb29rdXBzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9va3VwcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuY3VycmVudENoYXIoKSAhPT0gJ1snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUgPSB0aGlzLmxvb2t1cFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUgJiYgcnVsZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29rdXBzLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9va3Vwcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9va3VwcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwVmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCdbJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnNlcklucHV0LiRyZSgvXig/OltAJF17MCwyfSlbX2EtekEtWjAtOS1dKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCddJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSB8fCBuYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBFbnRpdGllcyBhcmUgdGhlIHNtYWxsZXN0IHJlY29nbml6ZWQgdG9rZW4sXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHJ1bGUncyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQoKSB8fCBlbnRpdGllcy5saXRlcmFsKCkgfHwgZW50aXRpZXMudmFyaWFibGUoKSB8fCBlbnRpdGllcy51cmwoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wcm9wZXJ0eSgpIHx8IGVudGl0aWVzLmNhbGwoKSB8fCBlbnRpdGllcy5rZXl3b3JkKCkgfHwgdGhpcy5taXhpbi5jYWxsKHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLmphdmFzY3JpcHQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQSBEZWNsYXJhdGlvbiB0ZXJtaW5hdG9yLiBOb3RlIHRoYXQgd2UgdXNlIGBwZWVrKClgIHRvIGNoZWNrIGZvciAnfScsXHJcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBgYmxvY2tgIHJ1bGUgd2lsbCBiZSBleHBlY3RpbmcgaXQsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIG1ha2Ugc3VyZVxyXG4gICAgICAgICAgICAgICAgLy8gaXQncyB0aGVyZSwgaWYgJzsnIHdhcyBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kY2hhcignOycpIHx8IHBhcnNlcklucHV0LnBlZWsoJ30nKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gSUUncyBhbHBoYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICBhbHBoYShvcGFjaXR5PTg4KVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGllQWxwaGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2FzZS1pbnNlbnNpdGl2ZS1yZWdleC12cy1zdHJ0b2xvd2VyLXRoZW4tcmVnZXgvMThcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRyZSgvXm9wYWNpdHk9L2kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJJbnB1dC4kcmUoL15cXGQrLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cGVjdChwYXJzZXJzLmVudGl0aWVzLnZhcmlhYmxlLCAnQ291bGQgbm90IHBhcnNlIGFscGhhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJAe1wiICsgdmFsdWUubmFtZS5zbGljZSgxKSArIFwifVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLlF1b3RlZCgnJywgXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEEgU2VsZWN0b3IgRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICBkaXZcclxuICAgICAgICAgICAgICAgIC8vICAgICArIGgxXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgI3NvY2tzXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgaW5wdXRbdHlwZT1cInRleHRcIl1cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50cyBhcmUgdGhlIGJ1aWxkaW5nIGJsb2NrcyBmb3IgU2VsZWN0b3JzLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgbWFkZSBvdXQgb2YgYSBgQ29tYmluYXRvcmAgKHNlZSBjb21iaW5hdG9yIHJ1bGUpLFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFuIGVsZW1lbnQgbmFtZSwgc3VjaCBhcyBhIHRhZyBhIGNsYXNzLCBvciBgKmAuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuY29tYmluYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBwYXJzZXJJbnB1dC4kcmUoL14oPzpcXGQrXFwuXFxkK3xcXGQrKSUvKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kcmUoL14oPzpbLiNdP3w6KikoPzpbXFx3LV18W15cXHgwMC1cXHg5Zl18XFxcXCg/OltBLUZhLWYwLTldezEsNn0gP3xbXkEtRmEtZjAtOV0pKSsvKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kY2hhcignKicpIHx8IHBhcnNlcklucHV0LiRjaGFyKCcmJykgfHwgdGhpcy5hdHRyaWJ1dGUoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC4kcmUoL15cXChbXiYoKUBdK1xcKS8pIHx8IHBhcnNlcklucHV0LiRyZSgvXltcXC4jOl0oPz1AKS8pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXRpZXMudmFyaWFibGVDdXJseSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHYgPSB0aGlzLnNlbGVjdG9yKGZhbHNlKSkgJiYgcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgKHRyZWUuUGFyZW4pKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgnTWlzc2luZyBjbG9zaW5nIFxcJylcXCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuRWxlbWVudCkoYywgZSwgZSBpbnN0YW5jZW9mIHRyZWUuVmFyaWFibGUsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5hdG9ycyBjb21iaW5lIGVsZW1lbnRzIHRvZ2V0aGVyLCBpbiBhIFNlbGVjdG9yLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugb3VyIHBhcnNlciBpc24ndCB3aGl0ZS1zcGFjZSBzZW5zaXRpdmUsIHNwZWNpYWwgY2FyZVxyXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRvIGJlIHRha2VuLCB3aGVuIHBhcnNpbmcgdGhlIGRlc2NlbmRhbnQgY29tYmluYXRvciwgYCBgLFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyBhbiBlbXB0eSBzcGFjZS4gV2UgaGF2ZSB0byBjaGVjayB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgaW5wdXQsIHRvIHNlZSBpZiBpdCdzIGEgYCBgIGNoYXJhY3Rlci4gTW9yZSBpbmZvIG9uIGhvd1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgZGVhbCB3aXRoIHRoaXMgaW4gKmNvbWJpbmF0b3IuanMqLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGNvbWJpbmF0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGFzaGVkQ29tYmluYXRvciA9IHBhcnNlcklucHV0LiRyZSgvXlxcL1thLXpdK1xcLy9pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsYXNoZWRDb21iaW5hdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQ29tYmluYXRvcikoc2xhc2hlZENvbWJpbmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICc+JyB8fCBjID09PSAnKycgfHwgYyA9PT0gJ34nIHx8IGMgPT09ICd8JyB8fCBjID09PSAnXicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nICYmIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgPT09ICdeJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdeXic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5Db21iaW5hdG9yKShjKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkNvbWJpbmF0b3IpKCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkNvbWJpbmF0b3IpKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQSBDU1MgU2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIC8vIHdpdGggbGVzcyBleHRlbnNpb25zIGUuZy4gdGhlIGFiaWxpdHkgdG8gZXh0ZW5kIGFuZCBndWFyZFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICAuY2xhc3MgPiBkaXYgKyBoMVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIGxpIGE6aG92ZXJcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3RvcnMgYXJlIG1hZGUgb3V0IG9mIG9uZSBvciBtb3JlIEVsZW1lbnRzLCBzZWUgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGZ1bmN0aW9uIChpc0xlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsRXh0ZW5kcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2hlbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzTGVzcyA9IGlzTGVzcyAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpc0xlc3MgJiYgKGV4dGVuZExpc3QgPSB0aGlzLmV4dGVuZCgpKSkgfHwgKGlzTGVzcyAmJiAod2hlbiA9IHBhcnNlcklucHV0LiRzdHIoJ3doZW4nKSkpIHx8IChlID0gdGhpcy5lbGVtZW50KCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSBleHBlY3QodGhpcy5jb25kaXRpb25zLCAnZXhwZWN0ZWQgY29uZGl0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignQ1NTIGd1YXJkIGNhbiBvbmx5IGJlIHVzZWQgYXQgdGhlIGVuZCBvZiBzZWxlY3RvcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dGVuZExpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxFeHRlbmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kcyA9IGFsbEV4dGVuZHMuY29uY2F0KGV4dGVuZExpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXh0ZW5kcyA9IGV4dGVuZExpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRXh0ZW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHRlbmQgY2FuIG9ubHkgYmUgdXNlZCBhdCB0aGUgZW5kIG9mIHNlbGVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gcGFyc2VySW5wdXQuY3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAneycgfHwgYyA9PT0gJ30nIHx8IGMgPT09ICc7JyB8fCBjID09PSAnLCcgfHwgYyA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5TZWxlY3RvcikoZWxlbWVudHMsIGFsbEV4dGVuZHMsIGNvbmRpdGlvbiwgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbEV4dGVuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4dGVuZCBtdXN0IGJlIHVzZWQgdG8gZXh0ZW5kIGEgc2VsZWN0b3IsIGl0IGNhbm5vdCBiZSB1c2VkIG9uIGl0cyBvd24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9ycztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdGhpcy5zZWxlY3RvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5jb25kaXRpb24gJiYgc2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiR3VhcmRzIGFyZSBvbmx5IGN1cnJlbnRseSBhbGxvd2VkIG9uIGEgc2luZ2xlIHNlbGVjdG9yLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLmNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoXCJHdWFyZHMgYXJlIG9ubHkgY3VycmVudGx5IGFsbG93ZWQgb24gYSBzaW5nbGUgc2VsZWN0b3IuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmNvbW1lbnRTdG9yZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJ1snKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRpdGllcyA9IHRoaXMuZW50aXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgPSBlbnRpdGllcy52YXJpYWJsZUN1cmx5KCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGV4cGVjdCgvXig/OltfQS1aYS16MC05LVxcKl0qXFx8KT8oPzpbX0EtWmEtejAtOS1dfFxcXFwuKSsvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBwYXJzZXJJbnB1dC4kcmUoL15bfH4qJF5dPz0vKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZW50aXRpZXMucXVvdGVkKCkgfHwgcGFyc2VySW5wdXQuJHJlKC9eWzAtOV0rJS8pIHx8IHBhcnNlcklucHV0LiRyZSgvXltcXHctXSsvKSB8fCBlbnRpdGllcy52YXJpYWJsZUN1cmx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdENoYXIoJ10nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkF0dHJpYnV0ZSkoa2V5LCBvcCwgdmFsKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGBibG9ja2AgcnVsZSBpcyB1c2VkIGJ5IGBydWxlc2V0YCBhbmQgYG1peGluLmRlZmluaXRpb25gLlxyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBgcHJpbWFyeWAgcnVsZSwgd2l0aCBhZGRlZCBge31gLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIGJsb2NrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCd7JykgJiYgKGNvbnRlbnQgPSB0aGlzLnByaW1hcnkoKSkgJiYgcGFyc2VySW5wdXQuJGNoYXIoJ30nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYmxvY2tSdWxlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5ibG9jaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IG5ldyB0cmVlLlJ1bGVzZXQobnVsbCwgYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2s7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGV0YWNoZWRSdWxlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFkaWM7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kcmUoL15bLiNdXFwoLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIERSIGFyZ3MgY3VycmVudGx5IG9ubHkgaW1wbGVtZW50ZWQgZm9yIGVhY2goKSBmdW5jdGlvbiwgYW5kIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB5ZXQgc2V0dGFibGUgYXMgYEBkcjogIyhAYXJnKSB7fWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBzaG91bGQgYmUgZG9uZSB3aGVuIERScyBhcmUgbWVyZ2VkIHdpdGggbWl4aW5zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNzL2xlc3MtbWV0YS9pc3N1ZXMvMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZm8gPSB0aGlzLm1peGluLmFyZ3MoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmdJbmZvLmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhZGljID0gYXJnSW5mby52YXJpYWRpYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrUnVsZXNldCA9IHRoaXMuYmxvY2tSdWxlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrUnVsZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLm1peGluLkRlZmluaXRpb24obnVsbCwgcGFyYW1zLCBibG9ja1J1bGVzZXQsIG51bGwsIHZhcmlhZGljKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRGV0YWNoZWRSdWxlc2V0KGJsb2NrUnVsZXNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gZGl2LCAuY2xhc3MsIGJvZHkgPiBwIHsuLi59XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgcnVsZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWJ1Z0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8gPSBnZXREZWJ1Z0luZm8ocGFyc2VySW5wdXQuaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHRoaXMuc2VsZWN0b3JzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ycyAmJiAocnVsZXMgPSB0aGlzLmJsb2NrKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZXNldCA9IG5ldyAodHJlZS5SdWxlc2V0KShzZWxlY3RvcnMsIHJ1bGVzLCBjb250ZXh0LnN0cmljdEltcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kdW1wTGluZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzZXQuZGVidWdJbmZvID0gZGVidWdJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNEUjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGFudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzVmFyaWFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcuJyB8fCBjID09PSAnIycgfHwgYyA9PT0gJyYnIHx8IGMgPT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy52YXJpYWJsZSgpIHx8IHRoaXMucnVsZVByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYXJpYWJsZSA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kZXRhY2hlZFJ1bGVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RSID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5jb21tZW50U3RvcmUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBuYW1lIHJldHVybmVkIGJ5IHRoaXMucnVsZVByb3BlcnR5KCkgaXMgYWx3YXlzIGFuIGFycmF5IG9mIHRoZSBmb3JtOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3N0cmluZy0xLCAuLi4sIHN0cmluZy1uLCBcIlwiXSBvciBbc3RyaW5nLTEsIC4uLiwgc3RyaW5nLW4sIFwiK1wiXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmUgZWFjaCBpdGVtIGlzIGEgdHJlZS5LZXl3b3JkIG9yIHRyZWUuVmFyaWFibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlID0gIWlzVmFyaWFibGUgJiYgbmFtZS5sZW5ndGggPiAxICYmIG5hbWUucG9wKCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXN0b20gcHJvcGVydHkgdmFsdWVzIGdldCBwZXJtaXNzaXZlIHBhcnNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lWzBdLnZhbHVlICYmIG5hbWVbMF0udmFsdWUuc2xpY2UoMCwgMikgPT09ICctLScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGVybWlzc2l2ZVZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gc3RvcmUgdmFsdWVzIGFzIGFub255bW91c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCB0aGUgdmFsdWUgbGF0ZXIgd2UnbGwgcmUtcGFyc2UgaXQgaW4gcnVsZXNldC5wYXJzZVZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYW5vbnltb3VzVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFub255bW91cyB2YWx1ZXMgYWJzb3JiIHRoZSBlbmQgJzsnIHdoaWNoIGlzIHJlcXVpcmVkIGZvciB0aGVtIHRvIHdvcmtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkRlY2xhcmF0aW9uKShuYW1lLCB2YWx1ZSwgZmFsc2UsIG1lcmdlLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gdGhpcy5pbXBvcnRhbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBhIGxhc3QgcmVzb3J0LCB0cnkgcGVybWlzc2l2ZVZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBlcm1pc3NpdmVWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAodGhpcy5lbmQoKSB8fCBoYXNEUikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5EZWNsYXJhdGlvbikobmFtZSwgdmFsdWUsIGltcG9ydGFudCwgbWVyZ2UsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzVmFsdWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHBhcnNlcklucHV0LiRyZSgvXihbXi4jQFxcJCtcXC8nXCIqYCg7e30tXSopOy8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkFub255bW91cykobWF0Y2hbMV0sIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVc2VkIGZvciBjdXN0b20gcHJvcGVydGllcywgYXQtcnVsZXMsIGFuZCB2YXJpYWJsZXMgKGFzIGZhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICogUGFyc2VzIGFsbW9zdCBhbnl0aGluZyBpbnNpZGUgb2Yge30gW10gKCkgXCJcIiBibG9ja3NcclxuICAgICAgICAgICAgICAgICAqIHVudGlsIGl0IHJlYWNoZXMgb3V0ZXItbW9zdCB0b2tlbnMuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogRmlyc3QsIGl0IHdpbGwgdHJ5IHRvIHBhcnNlIGNvbW1lbnRzIGFuZCBlbnRpdGllcyB0byByZWFjaFxyXG4gICAgICAgICAgICAgICAgICogdGhlIGVuZC4gVGhpcyBpcyBtb3N0bHkgbGlrZSB0aGUgRXhwcmVzc2lvbiBwYXJzZXIgZXhjZXB0IG5vXHJcbiAgICAgICAgICAgICAgICAgKiBtYXRoIGlzIGFsbG93ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBlcm1pc3NpdmVWYWx1ZTogZnVuY3Rpb24gKHVudGlsVG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2sgPSB1bnRpbFRva2VucyB8fCAnOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGVzdEN1cnJlbnRDaGFyKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIgPT09IHRvaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2sudGVzdChjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdEN1cnJlbnRDaGFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuY29tbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmVudGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0ZXN0Q3VycmVudENoYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyAodHJlZS5FeHByZXNzaW9uKSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgc3BhY2UgYmVmb3JlICRwYXJzZVVudGlsIGFzIGl0IHdpbGwgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5wcmV2Q2hhcigpID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyB0cmVlLkFub255bW91cygnICcsIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VySW5wdXQuJHBhcnNlVW50aWwodG9rKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgdmFsdWUgKyBcIidcIiwgJ1BhcnNlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZVswXSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5Bbm9ueW1vdXMoJycsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGFjdHVhbCBxdW90ZXMgYXMgbm9ybWFsIHF1b3RlZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgdHJlZS5RdW90ZWQoaXRlbVswXSwgaXRlbVsxXSwgdHJ1ZSwgaW5kZXgsIGZpbGVJbmZvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdmFsdWUubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGxpa2UgcXVvdGVkIHZhbHVlcywgYnV0IHJlcGxhY2UgdmFycyBsaWtlIHVucXVvdGVkIGV4cHJlc3Npb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1b3RlID0gbmV3IHRyZWUuUXVvdGVkKCdcXCcnLCBpdGVtLCB0cnVlLCBpbmRleCwgZmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlLnZhcmlhYmxlUmVnZXggPSAvQChbXFx3LV0rKS9nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlLnByb3BSZWdleCA9IC9cXCQoW1xcdy1dKykvZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChxdW90ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJlZS5FeHByZXNzaW9uKHJlc3VsdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQW4gQGltcG9ydCBhdHJ1bGVcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgQGltcG9ydCBcImxpYlwiO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiBvdXIgZW52aXJvbm1lbnQsIGltcG9ydGluZyBpcyBkb25lIGRpZmZlcmVudGx5OlxyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJyb3dzZXIsIGl0J3MgYW4gWEhSIHJlcXVlc3QsIGluIE5vZGUsIGl0IHdvdWxkIGJlIGFcclxuICAgICAgICAgICAgICAgIC8vIGZpbGUtc3lzdGVtIG9wZXJhdGlvbi4gVGhlIGZ1bmN0aW9uIHVzZWQgZm9yIGltcG9ydGluZyBpc1xyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmVkIGluIGBpbXBvcnRgLCB3aGljaCB3ZSBwYXNzIHRvIHRoZSBJbXBvcnQgY29uc3RydWN0b3IuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgJ2ltcG9ydCc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gcGFyc2VySW5wdXQuJHJlKC9eQGltcG9ydD9cXHMrLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IChkaXIgPyB0aGlzLmltcG9ydE9wdGlvbnMoKSA6IG51bGwpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhdGggPSB0aGlzLmVudGl0aWVzLnF1b3RlZCgpIHx8IHRoaXMuZW50aXRpZXMudXJsKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHRoaXMubWVkaWFGZWF0dXJlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignOycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuaSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdtaXNzaW5nIHNlbWktY29sb24gb3IgdW5yZWNvZ25pc2VkIG1lZGlhIGZlYXR1cmVzIG9uIGltcG9ydCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcyAmJiBuZXcgKHRyZWUuVmFsdWUpKGZlYXR1cmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuSW1wb3J0KShwYXRoLCBmZWF0dXJlcywgb3B0aW9ucywgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdtYWxmb3JtZWQgaW1wb3J0IHN0YXRlbWVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGltcG9ydE9wdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMsIHN1cnJvdW5kZWQgYnkgcGFyZW5zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB0aGlzLmltcG9ydE9wdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZSA9IG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjc3MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lID0gJ2xlc3MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdvbmNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZSA9ICdtdWx0aXBsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignLCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChvKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3RDaGFyKCcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW1wb3J0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IHBhcnNlcklucHV0LiRyZSgvXihsZXNzfGNzc3xtdWx0aXBsZXxvbmNlfGlubGluZXxyZWZlcmVuY2V8b3B0aW9uYWwpLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtZWRpYUZlYXR1cmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlbnRpdGllcy5rZXl3b3JkKCkgfHwgZW50aXRpZXMudmFyaWFibGUoKSB8fCBlbnRpdGllcy5taXhpbkxvb2t1cCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5wcm9wZXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMudmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyAodHJlZS5QYXJlbikobmV3ICh0cmVlLkRlY2xhcmF0aW9uKShwLCBlLCBudWxsLCBudWxsLCBwYXJzZXJJbnB1dC5pLCBmaWxlSW5mbywgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyAodHJlZS5QYXJlbikoZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ2JhZGx5IGZvcm1lZCBtZWRpYSBmZWF0dXJlIGRlZmluaXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignTWlzc2luZyBjbG9zaW5nIFxcJylcXCcnLCAnUGFyc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuRXhwcmVzc2lvbikobm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtZWRpYUZlYXR1cmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gdGhpcy5lbnRpdGllcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLm1lZGlhRmVhdHVyZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGVudGl0aWVzLnZhcmlhYmxlKCkgfHwgZW50aXRpZXMubWl4aW5Mb29rdXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVzLmxlbmd0aCA+IDAgPyBmZWF0dXJlcyA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbWVkaWE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWRpYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVidWdJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZHVtcExpbmVOdW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyA9IGdldERlYnVnSW5mbyhpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cignQG1lZGlhJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSB0aGlzLm1lZGlhRmVhdHVyZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLmJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdtZWRpYSBkZWZpbml0aW9ucyByZXF1aXJlIGJsb2NrIHN0YXRlbWVudHMgYWZ0ZXIgYW55IGZlYXR1cmVzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhID0gbmV3ICh0cmVlLk1lZGlhKShydWxlcywgZmVhdHVyZXMsIGluZGV4LCBmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmR1bXBMaW5lTnVtYmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWEuZGVidWdJbmZvID0gZGVidWdJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBIEBwbHVnaW4gZGlyZWN0aXZlLCB1c2VkIHRvIGltcG9ydCBwbHVnaW5zIGR5bmFtaWNhbGx5LlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICBAcGx1Z2luIChhcmdzKSBcImxpYlwiO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIHBsdWdpbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IHBhcnNlcklucHV0LiRyZSgvXkBwbHVnaW4/XFxzKy8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMucGx1Z2luQXJncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW5BcmdzOiBhcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUGx1Z2luOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgaXNQbHVnaW46IHRydWUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhdGggPSB0aGlzLmVudGl0aWVzLnF1b3RlZCgpIHx8IHRoaXMuZW50aXRpZXMudXJsKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCc7JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5pID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ21pc3Npbmcgc2VtaS1jb2xvbiBvbiBAcGx1Z2luJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0cmVlLkltcG9ydCkocGF0aCwgbnVsbCwgb3B0aW9ucywgaW5kZXgsIGZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmkgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdtYWxmb3JtZWQgQHBsdWdpbiBzdGF0ZW1lbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5BcmdzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBvcHRpb25zLCBzdXJyb3VuZGVkIGJ5IHBhcmVuc1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBwYXJzZXJJbnB1dC4kcmUoL15cXHMqKFteXFwpO10rKVxcKVxccyovKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5mb3JnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEEgQ1NTIEF0UnVsZVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vICAgICBAY2hhcnNldCBcInV0Zi04XCI7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgYXRydWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub25WZW5kb3JTcGVjaWZpY05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0V4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1Vua25vd247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0Jsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSb290ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpICE9PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNbJ2ltcG9ydCddKCkgfHwgdGhpcy5wbHVnaW4oKSB8fCB0aGlzLm1lZGlhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL15AW2Etei1dKy8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vblZlbmRvclNwZWNpZmljTmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICctJyAmJiBuYW1lLmluZGV4T2YoJy0nLCAyKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uVmVuZG9yU3BlY2lmaWNOYW1lID0gXCJAXCIgKyBuYW1lLnNsaWNlKG5hbWUuaW5kZXhPZignLScsIDIpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm9uVmVuZG9yU3BlY2lmaWNOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0BjaGFyc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0lkZW50aWZpZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdAbmFtZXNwYWNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0V4cHJlc3Npb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdAa2V5ZnJhbWVzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQGNvdW50ZXItc3R5bGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzSWRlbnRpZmllciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQGRvY3VtZW50JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQHN1cHBvcnRzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSb290ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuY29tbWVudFN0b3JlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0lkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmVudGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcImV4cGVjdGVkIFwiICsgbmFtZSArIFwiIGlkZW50aWZpZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcImV4cGVjdGVkIFwiICsgbmFtZSArIFwiIGV4cHJlc3Npb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzVW5rbm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGVybWlzc2l2ZVZhbHVlKC9eW3s7XS8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNCbG9jayA9IChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAneycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0Jsb2NrICYmIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgIT09ICc7Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKG5hbWUgKyBcIiBydWxlIGlzIG1pc3NpbmcgYmxvY2sgb3IgZW5kaW5nIHNlbWktY29sb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXZhbHVlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gdGhpcy5ibG9ja1J1bGVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzIHx8ICghaGFzQmxvY2sgJiYgdmFsdWUgJiYgcGFyc2VySW5wdXQuJGNoYXIoJzsnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuQXRSdWxlKShuYW1lLCB2YWx1ZSwgcnVsZXMsIGluZGV4LCBmaWxlSW5mbywgY29udGV4dC5kdW1wTGluZU51bWJlcnMgPyBnZXREZWJ1Z0luZm8oaW5kZXgpIDogbnVsbCwgaXNSb290ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdhdC1ydWxlIG9wdGlvbnMgbm90IHJlY29nbmlzZWQnKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQSBWYWx1ZSBpcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIEV4cHJlc3Npb25zXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGZvbnQtZmFtaWx5OiBCYXNrZXJ2aWxsZSwgR2VvcmdpYSwgc2VyaWY7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gYSBSdWxlLCBhIFZhbHVlIHJlcHJlc2VudHMgZXZlcnl0aGluZyBhZnRlciB0aGUgYDpgLFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGJlZm9yZSB0aGUgYDtgLlxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VySW5wdXQuaTtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmV4cHJlc3Npb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LiRjaGFyKCcsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRyZWUuVmFsdWUpKGV4cHJlc3Npb25zLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGltcG9ydGFudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC5jdXJyZW50Q2hhcigpID09PSAnIScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcklucHV0LiRyZSgvXiEgKmltcG9ydGFudC8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdWI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuYWRkaXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgJiYgcGFyc2VySW5wdXQuJGNoYXIoJyknKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3ICh0cmVlLkV4cHJlc3Npb24pKFthXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBhcmVucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCdFeHBlY3RlZCBcXCcpXFwnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpY2F0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3BhY2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB0aGlzLm9wZXJhbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NwYWNlZCA9IHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQucGVlaygvXlxcL1sqXFwvXS8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IHBhcnNlcklucHV0LiRjaGFyKCcvJykgfHwgcGFyc2VySW5wdXQuJGNoYXIoJyonKSB8fCBwYXJzZXJJbnB1dC4kc3RyKCcuLycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMub3BlcmFuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnBhcmVuc0luT3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wYXJlbnNJbk9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG5ldyAodHJlZS5PcGVyYXRpb24pKG9wLCBbb3BlcmF0aW9uIHx8IG0sIGFdLCBpc1NwYWNlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NwYWNlZCA9IHBhcnNlcklucHV0LmlzV2hpdGVzcGFjZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbiB8fCBtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1NwYWNlZDtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdGhpcy5tdWx0aXBsaWNhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gcGFyc2VySW5wdXQuJHJlKC9eWy0rXVxccysvKSB8fCAoIWlzU3BhY2VkICYmIChwYXJzZXJJbnB1dC4kY2hhcignKycpIHx8IHBhcnNlcklucHV0LiRjaGFyKCctJykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLm11bHRpcGxpY2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFyZW5zSW5PcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnBhcmVuc0luT3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbmV3ICh0cmVlLk9wZXJhdGlvbikob3AsIFtvcGVyYXRpb24gfHwgbSwgYV0sIGlzU3BhY2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BhY2VkID0gcGFyc2VySW5wdXQuaXNXaGl0ZXNwYWNlKC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uIHx8IG07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuY29uZGl0aW9uKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlcklucHV0LnBlZWsoL14sXFxzKihub3RcXHMqKT9cXCgvKSB8fCAhcGFyc2VySW5wdXQuJGNoYXIoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuY29uZGl0aW9uKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSBuZXcgKHRyZWUuQ29uZGl0aW9uKSgnb3InLCBjb25kaXRpb24gfHwgYSwgYiwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24gfHwgYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAobmVlZHNQYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dpY2FsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VySW5wdXQuJHN0cignb3InKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb25kaXRpb25BbmQobmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbG9naWNhbCA9IG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2ljYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuY29uZGl0aW9uKG5lZWRzUGFyZW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyAodHJlZS5Db25kaXRpb24pKGxvZ2ljYWwsIHJlc3VsdCwgbmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb25BbmQ6IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2ljYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluc2lkZUNvbmRpdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmQgPSBzZWxmLm5lZ2F0ZWRDb25kaXRpb24obmVlZHNQYXJlbnMpIHx8IHNlbGYucGFyZW50aGVzaXNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmQgJiYgIW5lZWRzUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5hdG9taWNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbmQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXJJbnB1dC4kc3RyKCdhbmQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5zaWRlQ29uZGl0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsb2dpY2FsID0gYW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2ljYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuY29uZGl0aW9uQW5kKG5lZWRzUGFyZW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyAodHJlZS5Db25kaXRpb24pKGxvZ2ljYWwsIHJlc3VsdCwgbmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZWdhdGVkQ29uZGl0aW9uOiBmdW5jdGlvbiAobmVlZHNQYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJHN0cignbm90JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyZW50aGVzaXNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubmVnYXRlID0gIXJlc3VsdC5uZWdhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGFyZW50aGVzaXNDb25kaXRpb246IGZ1bmN0aW9uIChuZWVkc1BhcmVucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyeUNvbmRpdGlvbkZvbGxvd2VkQnlQYXJlbnRoZXNpcyhtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gbWUuY29uZGl0aW9uKG5lZWRzUGFyZW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kc3RyKCcoJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0cnlDb25kaXRpb25Gb2xsb3dlZEJ5UGFyZW50aGVzaXModGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5hdG9taWNDb25kaXRpb24obmVlZHNQYXJlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC4kY2hhcignKScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LnJlc3RvcmUoXCJleHBlY3RlZCAnKScgZ290ICdcIiArIHBhcnNlcklucHV0LmN1cnJlbnRDaGFyKCkgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXRvbWljQ29uZGl0aW9uOiBmdW5jdGlvbiAobmVlZHNQYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbmQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZGl0aW9uKCkgfHwgZW50aXRpZXMua2V5d29yZCgpIHx8IGVudGl0aWVzLnF1b3RlZCgpIHx8IGVudGl0aWVzLm1peGluTG9va3VwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmQgPSBjb25kLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGNvbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9ICc+PSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9ICc+JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VySW5wdXQuJGNoYXIoJz0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJzw9JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJzwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlcklucHV0LiRjaGFyKCc9JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXJJbnB1dC4kY2hhcignPicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnPT4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VySW5wdXQuJGNoYXIoJzwnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz08JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJz0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGNvbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyAodHJlZS5Db25kaXRpb24pKG9wLCBhLCBiLCBpbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ2V4cGVjdGVkIGV4cHJlc3Npb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZXcgKHRyZWUuQ29uZGl0aW9uKSgnPScsIGEsIG5ldyAodHJlZS5LZXl3b3JkKSgndHJ1ZScpLCBpbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gQW4gb3BlcmFuZCBpcyBhbnl0aGluZyB0aGF0IGNhbiBiZSBwYXJ0IG9mIGFuIG9wZXJhdGlvbixcclxuICAgICAgICAgICAgICAgIC8vIHN1Y2ggYXMgYSBDb2xvciwgb3IgYSBWYXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIG9wZXJhbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50aXRpZXMgPSB0aGlzLmVudGl0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWdhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlcklucHV0LnBlZWsoL14tW0BcXCRcXChdLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRlID0gcGFyc2VySW5wdXQuJGNoYXIoJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLnN1YigpIHx8IGVudGl0aWVzLmRpbWVuc2lvbigpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLmNvbG9yKCkgfHwgZW50aXRpZXMudmFyaWFibGUoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wcm9wZXJ0eSgpIHx8IGVudGl0aWVzLmNhbGwoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5xdW90ZWQodHJ1ZSkgfHwgZW50aXRpZXMuY29sb3JLZXl3b3JkKCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMubWl4aW5Mb29rdXAoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGFyZW5zSW5PcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBuZXcgKHRyZWUuTmVnYXRpdmUpKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwcmVzc2lvbnMgZWl0aGVyIHJlcHJlc2VudCBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyxcclxuICAgICAgICAgICAgICAgIC8vIG9yIHdoaXRlLXNwYWNlIGRlbGltaXRlZCBFbnRpdGllcy5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgMXB4IHNvbGlkIGJsYWNrXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgQHZhciAqIDJcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudGl0aWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGltO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlcklucHV0Lmk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5jb21tZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRpdGllcy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuYWRkaXRpb24oKSB8fCB0aGlzLmVudGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHRyZWUuQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVyYXRpb25zIGRvIG5vdCBhbGxvdyBrZXl3b3JkIFwiL1wiIGRpbWVuc2lvbiAoZS5nLiBzbWFsbC8yMHB4KSBzbyB3ZSBzdXBwb3J0IHRoYXQgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJbnB1dC5wZWVrKC9eXFwvW1xcLypdLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9IHBhcnNlcklucHV0LiRjaGFyKCcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2gobmV3ICh0cmVlLkFub255bW91cykoZGVsaW0sIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodHJlZS5FeHByZXNzaW9uKShlbnRpdGllcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJzZXJJbnB1dC4kcmUoL14oXFwqPy0/W19hLXpBLVowLTktXSspXFxzKjovKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcnVsZVByb3BlcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJJbnB1dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpbXBsZVByb3BlcnR5ID0gcGFyc2VySW5wdXQuJHJlKC9eKFtfYS16QS1aMC05LV0rKVxccyo6Lyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbXBsZVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBbbmV3ICh0cmVlLktleXdvcmQpKHNpbXBsZVByb3BlcnR5WzFdKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcklucHV0LmZvcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBwYXJzZXJJbnB1dC5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSBwYXJzZXJJbnB1dC4kcmUocmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5wdXNoKGNodW5rWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCgvXihcXCo/KS8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2goL14oKD86W1xcdy1dKyl8KD86W0BcXCRdXFx7W1xcdy1dK1xcfSkpLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobmFtZS5sZW5ndGggPiAxKSAmJiBtYXRjaCgvXigoPzpcXCtffFxcKyk/KVxccyo6LykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQuZm9yZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IGxhc3QsIHdlIGhhdmUgdGhlIGNvbXBsZXRlIG1hdGNoIG5vdy4gbW92ZSBmb3J3YXJkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IG5hbWUgcGFydGljbGVzIHRvIHRyZWUgb2JqZWN0cyBhbmQgcmV0dXJuOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZVswXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5hbWUubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBuYW1lW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVtrXSA9IChzLmNoYXJBdCgwKSAhPT0gJ0AnICYmIHMuY2hhckF0KDApICE9PSAnJCcpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgKHRyZWUuS2V5d29yZCkocykgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzLmNoYXJBdCgwKSA9PT0gJ0AnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3ICh0cmVlLlZhcmlhYmxlKShcIkBcIiArIHMuc2xpY2UoMiwgLTEpLCBpbmRleFtrXSwgZmlsZUluZm8pIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3ICh0cmVlLlByb3BlcnR5KShcIiRcIiArIHMuc2xpY2UoMiwgLTEpLCBpbmRleFtrXSwgZmlsZUluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VySW5wdXQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBQYXJzZXIuc2VyaWFsaXplVmFycyA9IGZ1bmN0aW9uICh2YXJzKSB7XHJcbiAgICAgICAgdmFyIHMgPSAnJztcclxuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gdmFycykge1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFycywgbmFtZV8xKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFyc1tuYW1lXzFdO1xyXG4gICAgICAgICAgICAgICAgcyArPSAoKG5hbWVfMVswXSA9PT0gJ0AnKSA/ICcnIDogJ0AnKSArIG5hbWVfMSArIFwiOiBcIiArIHZhbHVlICsgKChTdHJpbmcodmFsdWUpLnNsaWNlKC0xKSA9PT0gJzsnKSA/ICcnIDogJzsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBib29sZWFuKGNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBLZXl3b3JkLlRydWUgOiBLZXl3b3JkLkZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbnMgd2l0aCBldmFsQXJncyBzZXQgdG8gZmFsc2UgYXJlIHNlbnQgY29udGV4dFxyXG4gICAgICogYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJZihjb250ZXh0LCBjb25kaXRpb24sIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjb25kaXRpb24uZXZhbChjb250ZXh0KSA/IHRydWVWYWx1ZS5ldmFsKGNvbnRleHQpXHJcbiAgICAgICAgICAgIDogKGZhbHNlVmFsdWUgPyBmYWxzZVZhbHVlLmV2YWwoY29udGV4dCkgOiBuZXcgQW5vbnltb3VzKTtcclxuICAgIH1cclxuICAgIElmLmV2YWxBcmdzID0gZmFsc2U7XHJcbiAgICBmdW5jdGlvbiBpc2RlZmluZWQoY29udGV4dCwgdmFyaWFibGUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXJpYWJsZS5ldmFsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gS2V5d29yZC5UcnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gS2V5d29yZC5GYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc2RlZmluZWQuZXZhbEFyZ3MgPSBmYWxzZTtcclxuICAgIHZhciBib29sZWFuJDEgPSB7IGlzZGVmaW5lZDogaXNkZWZpbmVkLCBib29sZWFuOiBib29sZWFuLCAnaWYnOiBJZiB9O1xuXG4gICAgdmFyIGNvbG9yRnVuY3Rpb25zO1xyXG4gICAgZnVuY3Rpb24gY2xhbXAkMSh2YWwpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdmFsKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoc2xhKG9yaWdDb2xvciwgaHNsKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gY29sb3JGdW5jdGlvbnMuaHNsYShoc2wuaCwgaHNsLnMsIGhzbC5sLCBoc2wuYSk7XHJcbiAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChvcmlnQ29sb3IudmFsdWUgJiZcclxuICAgICAgICAgICAgICAgIC9eKHJnYnxoc2wpLy50ZXN0KG9yaWdDb2xvci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yLnZhbHVlID0gb3JpZ0NvbG9yLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3IudmFsdWUgPSAncmdiJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdG9IU0woY29sb3IpIHtcclxuICAgICAgICBpZiAoY29sb3IudG9IU0wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLnRvSFNMKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGNhbm5vdCBiZSBldmFsdWF0ZWQgdG8gYSBjb2xvcicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRvSFNWKGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKGNvbG9yLnRvSFNWKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvci50b0hTVigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBjYW5ub3QgYmUgZXZhbHVhdGVkIHRvIGEgY29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBudW1iZXIobikge1xyXG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgRGltZW5zaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4udW5pdC5pcygnJScpID8gbi52YWx1ZSAvIDEwMCA6IG4udmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQXJndW1lbnQnLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2NvbG9yIGZ1bmN0aW9ucyB0YWtlIG51bWJlcnMgYXMgcGFyYW1ldGVycydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzY2FsZWQobiwgc2l6ZSkge1xyXG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgRGltZW5zaW9uICYmIG4udW5pdC5pcygnJScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4udmFsdWUgKiBzaXplIC8gMTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIobik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29sb3JGdW5jdGlvbnMgPSB7XHJcbiAgICAgICAgcmdiOiBmdW5jdGlvbiAociwgZywgYikge1xyXG4gICAgICAgICAgICB2YXIgYSA9IDE7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb21tYS1sZXNzIHN5bnRheFxyXG4gICAgICAgICAgICAgKiAgIGUuZy4gcmdiKDAgMTI4IDI1NSAvIDUwJSlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICByID0gdmFsWzBdO1xyXG4gICAgICAgICAgICAgICAgZyA9IHZhbFsxXTtcclxuICAgICAgICAgICAgICAgIGIgPSB2YWxbMl07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEB0b2RvIC0gc2hvdWxkIHRoaXMgYmUgbm9ybWFsaXplZCBpblxyXG4gICAgICAgICAgICAgICAgICogICBmdW5jdGlvbiBjYWxsZXI/IE9yIHBhcnNlZCBkaWZmZXJlbnRseT9cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBvcC5vcGVyYW5kc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gb3Aub3BlcmFuZHNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JGdW5jdGlvbnMucmdiYShyLCBnLCBiLCBhKTtcclxuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvci52YWx1ZSA9ICdyZ2InO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZ2JhOiBmdW5jdGlvbiAociwgZywgYiwgYSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBudW1iZXIoZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gci5hbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLnJnYiwgYSwgJ3JnYmEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZ2IgPSBbciwgZywgYl0ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBzY2FsZWQoYywgMjU1KTsgfSk7XHJcbiAgICAgICAgICAgICAgICBhID0gbnVtYmVyKGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IsIGEsICdyZ2JhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaHNsOiBmdW5jdGlvbiAoaCwgcywgbCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChoIGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGgudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBoID0gdmFsWzBdO1xyXG4gICAgICAgICAgICAgICAgcyA9IHZhbFsxXTtcclxuICAgICAgICAgICAgICAgIGwgPSB2YWxbMl07XHJcbiAgICAgICAgICAgICAgICBpZiAobCBpbnN0YW5jZW9mIE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IG9wLm9wZXJhbmRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBvcC5vcGVyYW5kc1sxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvckZ1bmN0aW9ucy5oc2xhKGgsIHMsIGwsIGEpO1xyXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yLnZhbHVlID0gJ2hzbCc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzbGE6IGZ1bmN0aW9uIChoLCBzLCBsLCBhKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaCBpbnN0YW5jZW9mIENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG51bWJlcihzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBoLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGgucmdiLCBhLCAnaHNsYScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG0xXzE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbTJfMTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGh1ZShoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IGggPCAwID8gaCArIDEgOiAoaCA+IDEgPyBoIC0gMSA6IGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoICogNiA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0xXzEgKyAobTJfMSAtIG0xXzEpICogaCAqIDY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGggKiAyIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTJfMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaCAqIDMgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtMV8xICsgKG0yXzEgLSBtMV8xKSAqICgyIC8gMyAtIGgpICogNjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtMV8xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGggPSAobnVtYmVyKGgpICUgMzYwKSAvIDM2MDtcclxuICAgICAgICAgICAgICAgIHMgPSBjbGFtcCQxKG51bWJlcihzKSk7XHJcbiAgICAgICAgICAgICAgICBsID0gY2xhbXAkMShudW1iZXIobCkpO1xyXG4gICAgICAgICAgICAgICAgYSA9IGNsYW1wJDEobnVtYmVyKGEpKTtcclxuICAgICAgICAgICAgICAgIG0yXzEgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcclxuICAgICAgICAgICAgICAgIG0xXzEgPSBsICogMiAtIG0yXzE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmdiID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIGh1ZShoICsgMSAvIDMpICogMjU1LFxyXG4gICAgICAgICAgICAgICAgICAgIGh1ZShoKSAqIDI1NSxcclxuICAgICAgICAgICAgICAgICAgICBodWUoaCAtIDEgLyAzKSAqIDI1NVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIGEgPSBudW1iZXIoYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYiwgYSwgJ2hzbGEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoc3Y6IGZ1bmN0aW9uIChoLCBzLCB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5oc3ZhKGgsIHMsIHYsIDEuMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoc3ZhOiBmdW5jdGlvbiAoaCwgcywgdiwgYSkge1xyXG4gICAgICAgICAgICBoID0gKChudW1iZXIoaCkgJSAzNjApIC8gMzYwKSAqIDM2MDtcclxuICAgICAgICAgICAgcyA9IG51bWJlcihzKTtcclxuICAgICAgICAgICAgdiA9IG51bWJlcih2KTtcclxuICAgICAgICAgICAgYSA9IG51bWJlcihhKTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIHZhciBmO1xyXG4gICAgICAgICAgICBpID0gTWF0aC5mbG9vcigoaCAvIDYwKSAlIDYpO1xyXG4gICAgICAgICAgICBmID0gKGggLyA2MCkgLSBpO1xyXG4gICAgICAgICAgICB2YXIgdnMgPSBbdixcclxuICAgICAgICAgICAgICAgIHYgKiAoMSAtIHMpLFxyXG4gICAgICAgICAgICAgICAgdiAqICgxIC0gZiAqIHMpLFxyXG4gICAgICAgICAgICAgICAgdiAqICgxIC0gKDEgLSBmKSAqIHMpXTtcclxuICAgICAgICAgICAgdmFyIHBlcm0gPSBbWzAsIDMsIDFdLFxyXG4gICAgICAgICAgICAgICAgWzIsIDAsIDFdLFxyXG4gICAgICAgICAgICAgICAgWzEsIDAsIDNdLFxyXG4gICAgICAgICAgICAgICAgWzEsIDIsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzMsIDEsIDBdLFxyXG4gICAgICAgICAgICAgICAgWzAsIDEsIDJdXTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLnJnYmEodnNbcGVybVtpXVswXV0gKiAyNTUsIHZzW3Blcm1baV1bMV1dICogMjU1LCB2c1twZXJtW2ldWzJdXSAqIDI1NSwgYSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBodWU6IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih0b0hTTChjb2xvcikuaCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYXR1cmF0aW9uOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odG9IU0woY29sb3IpLnMgKiAxMDAsICclJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaWdodG5lc3M6IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih0b0hTTChjb2xvcikubCAqIDEwMCwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzdmh1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHRvSFNWKGNvbG9yKS5oKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzdnNhdHVyYXRpb246IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih0b0hTVihjb2xvcikucyAqIDEwMCwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzdnZhbHVlOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24odG9IU1YoY29sb3IpLnYgKiAxMDAsICclJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWQ6IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5yZ2JbMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3JlZW46IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5yZ2JbMV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmx1ZTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGNvbG9yLnJnYlsyXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhbHBoYTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHRvSFNMKGNvbG9yKS5hKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGx1bWE6IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihjb2xvci5sdW1hKCkgKiBjb2xvci5hbHBoYSAqIDEwMCwgJyUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGx1bWluYW5jZTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBsdW1pbmFuY2UgPSAoMC4yMTI2ICogY29sb3IucmdiWzBdIC8gMjU1KSArXHJcbiAgICAgICAgICAgICAgICAoMC43MTUyICogY29sb3IucmdiWzFdIC8gMjU1KSArXHJcbiAgICAgICAgICAgICAgICAoMC4wNzIyICogY29sb3IucmdiWzJdIC8gMjU1KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24obHVtaW5hbmNlICogY29sb3IuYWxwaGEgKiAxMDAsICclJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYXR1cmF0ZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICAvLyBmaWx0ZXI6IHNhdHVyYXRlKDMuMik7XHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBrZXB0IGFzIGlzLCBzbyBjaGVjayBmb3IgY29sb3JcclxuICAgICAgICAgICAgaWYgKCFjb2xvci5yZ2IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoc2wgPSB0b0hTTChjb2xvcik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJyAmJiBtZXRob2QudmFsdWUgPT09ICdyZWxhdGl2ZScpIHtcclxuICAgICAgICAgICAgICAgIGhzbC5zICs9IGhzbC5zICogYW1vdW50LnZhbHVlIC8gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHNsLnMgKz0gYW1vdW50LnZhbHVlIC8gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhzbC5zID0gY2xhbXAkMShoc2wucyk7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhKGNvbG9yLCBoc2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICB2YXIgaHNsID0gdG9IU0woY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcgJiYgbWV0aG9kLnZhbHVlID09PSAncmVsYXRpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICBoc2wucyAtPSBoc2wucyAqIGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhzbC5zIC09IGFtb3VudC52YWx1ZSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoc2wucyA9IGNsYW1wJDEoaHNsLnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaHNsYShjb2xvciwgaHNsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpZ2h0ZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xyXG4gICAgICAgICAgICAgICAgaHNsLmwgKz0gaHNsLmwgKiBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoc2wubCArPSBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHNsLmwgPSBjbGFtcCQxKGhzbC5sKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkYXJrZW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xyXG4gICAgICAgICAgICAgICAgaHNsLmwgLT0gaHNsLmwgKiBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoc2wubCAtPSBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHNsLmwgPSBjbGFtcCQxKGhzbC5sKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWRlaW46IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50LCBtZXRob2QpIHtcclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICd1bmRlZmluZWQnICYmIG1ldGhvZC52YWx1ZSA9PT0gJ3JlbGF0aXZlJykge1xyXG4gICAgICAgICAgICAgICAgaHNsLmEgKz0gaHNsLmEgKiBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoc2wuYSArPSBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHNsLmEgPSBjbGFtcCQxKGhzbC5hKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWRlb3V0OiBmdW5jdGlvbiAoY29sb3IsIGFtb3VudCwgbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHZhciBoc2wgPSB0b0hTTChjb2xvcik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAndW5kZWZpbmVkJyAmJiBtZXRob2QudmFsdWUgPT09ICdyZWxhdGl2ZScpIHtcclxuICAgICAgICAgICAgICAgIGhzbC5hIC09IGhzbC5hICogYW1vdW50LnZhbHVlIC8gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHNsLmEgLT0gYW1vdW50LnZhbHVlIC8gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhzbC5hID0gY2xhbXAkMShoc2wuYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhKGNvbG9yLCBoc2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmFkZTogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgaHNsLmEgPSBhbW91bnQudmFsdWUgLyAxMDA7XHJcbiAgICAgICAgICAgIGhzbC5hID0gY2xhbXAkMShoc2wuYSk7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhKGNvbG9yLCBoc2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BpbjogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcclxuICAgICAgICAgICAgdmFyIGhzbCA9IHRvSFNMKGNvbG9yKTtcclxuICAgICAgICAgICAgdmFyIGh1ZSA9IChoc2wuaCArIGFtb3VudC52YWx1ZSkgJSAzNjA7XHJcbiAgICAgICAgICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEoY29sb3IsIGhzbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEhhbXB0b24gQ2F0bGluLCBOYXRhbGllIFdlaXplbmJhdW0sIGFuZCBDaHJpcyBFcHBzdGVpblxyXG4gICAgICAgIC8vIGh0dHA6Ly9zYXNzLWxhbmcuY29tXHJcbiAgICAgICAgLy9cclxuICAgICAgICBtaXg6IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMiwgd2VpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmICghd2VpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSBuZXcgRGltZW5zaW9uKDUwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcCA9IHdlaWdodC52YWx1ZSAvIDEwMC4wO1xyXG4gICAgICAgICAgICB2YXIgdyA9IHAgKiAyIC0gMTtcclxuICAgICAgICAgICAgdmFyIGEgPSB0b0hTTChjb2xvcjEpLmEgLSB0b0hTTChjb2xvcjIpLmE7XHJcbiAgICAgICAgICAgIHZhciB3MSA9ICgoKHcgKiBhID09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XHJcbiAgICAgICAgICAgIHZhciB3MiA9IDEgLSB3MTtcclxuICAgICAgICAgICAgdmFyIHJnYiA9IFtjb2xvcjEucmdiWzBdICogdzEgKyBjb2xvcjIucmdiWzBdICogdzIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjEucmdiWzFdICogdzEgKyBjb2xvcjIucmdiWzFdICogdzIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjEucmdiWzJdICogdzEgKyBjb2xvcjIucmdiWzJdICogdzJdO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjb2xvcjEuYWxwaGEgKiBwICsgY29sb3IyLmFscGhhICogKDEgLSBwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IsIGFscGhhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyZXlzY2FsZTogZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5kZXNhdHVyYXRlKGNvbG9yLCBuZXcgRGltZW5zaW9uKDEwMCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvciwgZGFyaywgbGlnaHQsIHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAvLyBmaWx0ZXI6IGNvbnRyYXN0KDMuMik7XHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBrZXB0IGFzIGlzLCBzbyBjaGVjayBmb3IgY29sb3JcclxuICAgICAgICAgICAgaWYgKCFjb2xvci5yZ2IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlnaHQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBsaWdodCA9IGNvbG9yRnVuY3Rpb25zLnJnYmEoMjU1LCAyNTUsIDI1NSwgMS4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhcmsgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkYXJrID0gY29sb3JGdW5jdGlvbnMucmdiYSgwLCAwLCAwLCAxLjApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggaXMgYWN0dWFsbHkgbGlnaHQgYW5kIGRhcms6XHJcbiAgICAgICAgICAgIGlmIChkYXJrLmx1bWEoKSA+IGxpZ2h0Lmx1bWEoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBsaWdodDtcclxuICAgICAgICAgICAgICAgIGxpZ2h0ID0gZGFyaztcclxuICAgICAgICAgICAgICAgIGRhcmsgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhyZXNob2xkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gMC40MztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IG51bWJlcih0aHJlc2hvbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb2xvci5sdW1hKCkgPCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXJrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBDaGFuZ2VzIG1hZGUgaW4gMi43LjAgLSBSZXZlcnRlZCBpbiAzLjAuMFxyXG4gICAgICAgIC8vIGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IsIGNvbG9yMSwgY29sb3IyLCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAvLyAgICAgLy8gUmV0dXJuIHdoaWNoIG9mIGBjb2xvcjFgIGFuZCBgY29sb3IyYCBoYXMgdGhlIGdyZWF0ZXN0IGNvbnRyYXN0IHdpdGggYGNvbG9yYFxyXG4gICAgICAgIC8vICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIHN0YW5kYXJkIFdDQUcgY29udHJhc3QgcmF0aW8gY2FsY3VsYXRpb24uXHJcbiAgICAgICAgLy8gICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcclxuICAgICAgICAvLyAgICAgLy8gVGhlIHRocmVzaG9sZCBwYXJhbSBpcyBubyBsb25nZXIgdXNlZCwgaW4gbGluZSB3aXRoIFNBU1MuXHJcbiAgICAgICAgLy8gICAgIC8vIGZpbHRlcjogY29udHJhc3QoMy4yKTtcclxuICAgICAgICAvLyAgICAgLy8gc2hvdWxkIGJlIGtlcHQgYXMgaXMsIHNvIGNoZWNrIGZvciBjb2xvclxyXG4gICAgICAgIC8vICAgICBpZiAoIWNvbG9yLnJnYikge1xyXG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgaWYgKHR5cGVvZiBjb2xvcjEgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb2xvcjEgPSBjb2xvckZ1bmN0aW9ucy5yZ2JhKDAsIDAsIDAsIDEuMCk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgaWYgKHR5cGVvZiBjb2xvcjIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb2xvcjIgPSBjb2xvckZ1bmN0aW9ucy5yZ2JhKDI1NSwgMjU1LCAyNTUsIDEuMCk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgdmFyIGNvbnRyYXN0MSwgY29udHJhc3QyO1xyXG4gICAgICAgIC8vICAgICB2YXIgbHVtYSA9IGNvbG9yLmx1bWEoKTtcclxuICAgICAgICAvLyAgICAgdmFyIGx1bWExID0gY29sb3IxLmx1bWEoKTtcclxuICAgICAgICAvLyAgICAgdmFyIGx1bWEyID0gY29sb3IyLmx1bWEoKTtcclxuICAgICAgICAvLyAgICAgLy8gQ2FsY3VsYXRlIGNvbnRyYXN0IHJhdGlvcyBmb3IgZWFjaCBjb2xvclxyXG4gICAgICAgIC8vICAgICBpZiAobHVtYSA+IGx1bWExKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb250cmFzdDEgPSAobHVtYSArIDAuMDUpIC8gKGx1bWExICsgMC4wNSk7XHJcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb250cmFzdDEgPSAobHVtYTEgKyAwLjA1KSAvIChsdW1hICsgMC4wNSk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgaWYgKGx1bWEgPiBsdW1hMikge1xyXG4gICAgICAgIC8vICAgICAgICAgY29udHJhc3QyID0gKGx1bWEgKyAwLjA1KSAvIChsdW1hMiArIDAuMDUpO1xyXG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgY29udHJhc3QyID0gKGx1bWEyICsgMC4wNSkgLyAobHVtYSArIDAuMDUpO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIGlmIChjb250cmFzdDEgPiBjb250cmFzdDIpIHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiBjb2xvcjE7XHJcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gY29sb3IyO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICBhcmdiOiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMoY29sb3IudG9BUkdCKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sb3I6IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGlmICgoYyBpbnN0YW5jZW9mIFF1b3RlZCkgJiZcclxuICAgICAgICAgICAgICAgICgvXiMoW0EtRmEtZjAtOV17OH18W0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17Myw0fSkkL2kudGVzdChjLnZhbHVlKSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjLnZhbHVlLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih2YWwsIHVuZGVmaW5lZCwgXCIjXCIgKyB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoYyBpbnN0YW5jZW9mIENvbG9yKSB8fCAoYyA9IENvbG9yLmZyb21LZXl3b3JkKGMudmFsdWUpKSkge1xyXG4gICAgICAgICAgICAgICAgYy52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdBcmd1bWVudCcsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnYXJndW1lbnQgbXVzdCBiZSBhIGNvbG9yIGtleXdvcmQgb3IgM3w0fDZ8OCBkaWdpdCBoZXggZS5nLiAjRkZGJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGludDogZnVuY3Rpb24gKGNvbG9yLCBhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yRnVuY3Rpb25zLm1peChjb2xvckZ1bmN0aW9ucy5yZ2IoMjU1LCAyNTUsIDI1NSksIGNvbG9yLCBhbW91bnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hhZGU6IGZ1bmN0aW9uIChjb2xvciwgYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckZ1bmN0aW9ucy5taXgoY29sb3JGdW5jdGlvbnMucmdiKDAsIDAsIDApLCBjb2xvciwgYW1vdW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGNvbG9yID0gY29sb3JGdW5jdGlvbnM7XG5cbiAgICAvLyBDb2xvciBCbGVuZGluZ1xyXG4gICAgLy8gcmVmOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jb21wb3NpdGluZy0xXHJcbiAgICBmdW5jdGlvbiBjb2xvckJsZW5kKG1vZGUsIGNvbG9yMSwgY29sb3IyKSB7XHJcbiAgICAgICAgdmFyIGFiID0gY29sb3IxLmFscGhhOyAvLyByZXN1bHRcclxuICAgICAgICB2YXIgLy8gYmFja2Ryb3BcclxuICAgICAgICBjYjtcclxuICAgICAgICB2YXIgYXMgPSBjb2xvcjIuYWxwaGE7XHJcbiAgICAgICAgdmFyIC8vIHNvdXJjZVxyXG4gICAgICAgIGNzO1xyXG4gICAgICAgIHZhciBhcjtcclxuICAgICAgICB2YXIgY3I7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuICAgICAgICBhciA9IGFzICsgYWIgKiAoMSAtIGFzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICBjYiA9IGNvbG9yMS5yZ2JbaV0gLyAyNTU7XHJcbiAgICAgICAgICAgIGNzID0gY29sb3IyLnJnYltpXSAvIDI1NTtcclxuICAgICAgICAgICAgY3IgPSBtb2RlKGNiLCBjcyk7XHJcbiAgICAgICAgICAgIGlmIChhcikge1xyXG4gICAgICAgICAgICAgICAgY3IgPSAoYXMgKiBjcyArIGFiICogKGNiIC1cclxuICAgICAgICAgICAgICAgICAgICBhcyAqIChjYiArIGNzIC0gY3IpKSkgLyBhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW2ldID0gY3IgKiAyNTU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgYXIpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zID0ge1xyXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYiAqIGNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NyZWVuOiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYiArIGNzIC0gY2IgKiBjcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG92ZXJsYXk6IGZ1bmN0aW9uIChjYiwgY3MpIHtcclxuICAgICAgICAgICAgY2IgKj0gMjtcclxuICAgICAgICAgICAgcmV0dXJuIChjYiA8PSAxKSA/XHJcbiAgICAgICAgICAgICAgICBjb2xvckJsZW5kTW9kZUZ1bmN0aW9ucy5tdWx0aXBseShjYiwgY3MpIDpcclxuICAgICAgICAgICAgICAgIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLnNjcmVlbihjYiAtIDEsIGNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNvZnRsaWdodDogZnVuY3Rpb24gKGNiLCBjcykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IDE7XHJcbiAgICAgICAgICAgIHZhciBlID0gY2I7XHJcbiAgICAgICAgICAgIGlmIChjcyA+IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBkID0gKGNiID4gMC4yNSkgPyBNYXRoLnNxcnQoY2IpXHJcbiAgICAgICAgICAgICAgICAgICAgOiAoKDE2ICogY2IgLSAxMikgKiBjYiArIDQpICogY2I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNiIC0gKDEgLSAyICogY3MpICogZSAqIChkIC0gY2IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFyZGxpZ2h0OiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckJsZW5kTW9kZUZ1bmN0aW9ucy5vdmVybGF5KGNzLCBjYik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhjYiAtIGNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4Y2x1c2lvbjogZnVuY3Rpb24gKGNiLCBjcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2IgKyBjcyAtIDIgKiBjYiAqIGNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gbm9uLXczYyBmdW5jdGlvbnM6XHJcbiAgICAgICAgYXZlcmFnZTogZnVuY3Rpb24gKGNiLCBjcykge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNiICsgY3MpIC8gMjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5lZ2F0aW9uOiBmdW5jdGlvbiAoY2IsIGNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5hYnMoY2IgKyBjcyAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBmIGluIGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zKSB7XHJcbiAgICAgICAgaWYgKGNvbG9yQmxlbmRNb2RlRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGYpKSB7XHJcbiAgICAgICAgICAgIGNvbG9yQmxlbmRbZl0gPSBjb2xvckJsZW5kLmJpbmQobnVsbCwgY29sb3JCbGVuZE1vZGVGdW5jdGlvbnNbZl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cblxuICAgIHZhciBkYXRhVXJpID0gKGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uIChmdW5jdGlvblRoaXMsIG5vZGUpIHsgcmV0dXJuIG5ldyBVUkwobm9kZSwgZnVuY3Rpb25UaGlzLmluZGV4LCBmdW5jdGlvblRoaXMuY3VycmVudEZpbGVJbmZvKS5ldmFsKGZ1bmN0aW9uVGhpcy5jb250ZXh0KTsgfTtcclxuICAgICAgICByZXR1cm4geyAnZGF0YS11cmknOiBmdW5jdGlvbiAobWltZXR5cGVOb2RlLCBmaWxlUGF0aE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZmlsZVBhdGhOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGhOb2RlID0gbWltZXR5cGVOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbWV0eXBlTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbWltZXR5cGUgPSBtaW1ldHlwZU5vZGUgJiYgbWltZXR5cGVOb2RlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVQYXRoID0gZmlsZVBhdGhOb2RlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWxlSW5mbyA9IHRoaXMuY3VycmVudEZpbGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREaXJlY3RvcnkgPSBjdXJyZW50RmlsZUluZm8ucmV3cml0ZVVybHMgP1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5IDogY3VycmVudEZpbGVJbmZvLmVudHJ5UGF0aDtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gZmlsZVBhdGguaW5kZXhPZignIycpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnRTdGFydCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZpbGVQYXRoLnNsaWNlKGZyYWdtZW50U3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGguc2xpY2UoMCwgZnJhZ21lbnRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNsb25lKHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJhd0J1ZmZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU1hbmFnZXIgPSBlbnZpcm9ubWVudC5nZXRGaWxlTWFuYWdlcihmaWxlUGF0aCwgY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlTWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayh0aGlzLCBmaWxlUGF0aE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHVzZUJhc2U2NCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHRoZSBtaW1ldHlwZSBpZiBub3QgZ2l2ZW5cclxuICAgICAgICAgICAgICAgIGlmICghbWltZXR5cGVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWltZXR5cGUgPSBlbnZpcm9ubWVudC5taW1lTG9va3VwKGZpbGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWltZXR5cGUgPT09ICdpbWFnZS9zdmcreG1sJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VCYXNlNjQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBiYXNlIDY0IHVubGVzcyBpdCdzIGFuIEFTQ0lJIG9yIFVURi04IGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnNldCA9IGVudmlyb25tZW50LmNoYXJzZXRMb29rdXAobWltZXR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VCYXNlNjQgPSBbJ1VTLUFTQ0lJJywgJ1VURi04J10uaW5kZXhPZihjaGFyc2V0KSA8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VCYXNlNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWltZXR5cGUgKz0gJztiYXNlNjQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZUJhc2U2NCA9IC87YmFzZTY0JC8udGVzdChtaW1ldHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVN5bmMgPSBmaWxlTWFuYWdlci5sb2FkRmlsZVN5bmMoZmlsZVBhdGgsIGN1cnJlbnREaXJlY3RvcnksIGNvbnRleHQsIGVudmlyb25tZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghZmlsZVN5bmMuY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlNraXBwZWQgZGF0YS11cmkgZW1iZWRkaW5nIG9mIFwiICsgZmlsZVBhdGggKyBcIiBiZWNhdXNlIGZpbGUgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayh0aGlzLCBmaWxlUGF0aE5vZGUgfHwgbWltZXR5cGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBidWYgPSBmaWxlU3luYy5jb250ZW50cztcclxuICAgICAgICAgICAgICAgIGlmICh1c2VCYXNlNjQgJiYgIWVudmlyb25tZW50LmVuY29kZUJhc2U2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayh0aGlzLCBmaWxlUGF0aE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnVmID0gdXNlQmFzZTY0ID8gZW52aXJvbm1lbnQuZW5jb2RlQmFzZTY0KGJ1ZikgOiBlbmNvZGVVUklDb21wb25lbnQoYnVmKTtcclxuICAgICAgICAgICAgICAgIHZhciB1cmkgPSBcImRhdGE6XCIgKyBtaW1ldHlwZSArIFwiLFwiICsgYnVmICsgZnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVSTChuZXcgUXVvdGVkKFwiXFxcIlwiICsgdXJpICsgXCJcXFwiXCIsIHVyaSwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xyXG4gICAgICAgICAgICB9IH07XHJcbiAgICB9KTtcblxuICAgIHZhciBnZXRJdGVtc0Zyb21Ob2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAvLyBoYW5kbGUgbm9uLWFycmF5IHZhbHVlcyBhcyBhbiBhcnJheSBvZiBsZW5ndGggMVxyXG4gICAgICAgIC8vIHJldHVybiAndW5kZWZpbmVkJyBpZiBpbmRleCBpcyBpbnZhbGlkXHJcbiAgICAgICAgdmFyIGl0ZW1zID0gQXJyYXkuaXNBcnJheShub2RlLnZhbHVlKSA/XHJcbiAgICAgICAgICAgIG5vZGUudmFsdWUgOiBBcnJheShub2RlKTtcclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9O1xyXG4gICAgdmFyIGxpc3QgPSB7XHJcbiAgICAgICAgX1NFTEY6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ34nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBleHByID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleHByW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwclswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlKGV4cHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXh0cmFjdDogZnVuY3Rpb24gKHZhbHVlcywgaW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gKDEtYmFzZWQgaW5kZXgpXHJcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXgudmFsdWUgLSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0SXRlbXNGcm9tTm9kZSh2YWx1ZXMpW2luZGV4XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihnZXRJdGVtc0Zyb21Ob2RlKHZhbHVlcykubGVuZ3RoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBMZXNzIGxpc3Qgb2YgaW5jcmVtZW50YWwgdmFsdWVzLlxyXG4gICAgICAgICAqIE1vZGVsZWQgYWZ0ZXIgTG9kYXNoJ3MgcmFuZ2UgZnVuY3Rpb24sIGFsc28gZXhpc3RzIG5hdGl2ZWx5IGluIFBIUFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtEaW1lbnNpb259IFtzdGFydD0xXVxyXG4gICAgICAgICAqIEBwYXJhbSB7RGltZW5zaW9ufSBlbmQgIC0gZS5nLiAxMCBvciAxMHB4IC0gdW5pdCBpcyBhZGRlZCB0byBvdXRwdXRcclxuICAgICAgICAgKiBAcGFyYW0ge0RpbWVuc2lvbn0gW3N0ZXA9MV1cclxuICAgICAgICAgKi9cclxuICAgICAgICByYW5nZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApIHtcclxuICAgICAgICAgICAgdmFyIGZyb207XHJcbiAgICAgICAgICAgIHZhciB0bztcclxuICAgICAgICAgICAgdmFyIHN0ZXBWYWx1ZSA9IDE7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgZnJvbSA9IHN0YXJ0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwVmFsdWUgPSBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZnJvbSA9IDE7XHJcbiAgICAgICAgICAgICAgICB0byA9IHN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDw9IHRvLnZhbHVlOyBpICs9IHN0ZXBWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG5ldyBEaW1lbnNpb24oaSwgdG8udW5pdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihsaXN0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChsaXN0LCBycykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIG5ld1J1bGVzO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciB0cnlFdmFsID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmV2YWwoX3RoaXMuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAobGlzdC52YWx1ZSAmJiAhKGxpc3QgaW5zdGFuY2VvZiBRdW90ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbGlzdC52YWx1ZS5tYXAodHJ5RXZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IFt0cnlFdmFsKGxpc3QudmFsdWUpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsaXN0LnJ1bGVzZXQpIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gdHJ5RXZhbChsaXN0LnJ1bGVzZXQpLnJ1bGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxpc3QucnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbGlzdC5ydWxlcy5tYXAodHJ5RXZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBsaXN0Lm1hcCh0cnlFdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gW3RyeUV2YWwobGlzdCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU5hbWUgPSAnQHZhbHVlJztcclxuICAgICAgICAgICAgdmFyIGtleU5hbWUgPSAnQGtleSc7XHJcbiAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSAnQGluZGV4JztcclxuICAgICAgICAgICAgaWYgKHJzLnBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVOYW1lID0gcnMucGFyYW1zWzBdICYmIHJzLnBhcmFtc1swXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAga2V5TmFtZSA9IHJzLnBhcmFtc1sxXSAmJiBycy5wYXJhbXNbMV0ubmFtZTtcclxuICAgICAgICAgICAgICAgIGluZGV4TmFtZSA9IHJzLnBhcmFtc1syXSAmJiBycy5wYXJhbXNbMl0ubmFtZTtcclxuICAgICAgICAgICAgICAgIHJzID0gcnMucnVsZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBycyA9IHJzLnJ1bGVzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlcmF0b3JbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdHlwZW9mIGl0ZW0ubmFtZSA9PT0gJ3N0cmluZycgPyBpdGVtLm5hbWUgOiBpdGVtLm5hbWVbMF0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV3IERpbWVuc2lvbihpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdSdWxlcyA9IHJzLnJ1bGVzLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1J1bGVzLnB1c2gobmV3IERlY2xhcmF0aW9uKHZhbHVlTmFtZSwgdmFsdWUsIGZhbHNlLCBmYWxzZSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdSdWxlcy5wdXNoKG5ldyBEZWNsYXJhdGlvbihpbmRleE5hbWUsIG5ldyBEaW1lbnNpb24oaSArIDEpLCBmYWxzZSwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1J1bGVzLnB1c2gobmV3IERlY2xhcmF0aW9uKGtleU5hbWUsIGtleSwgZmFsc2UsIGZhbHNlLCB0aGlzLmluZGV4LCB0aGlzLmN1cnJlbnRGaWxlSW5mbykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChuZXcgUnVsZXNldChbbmV3IChTZWxlY3RvcikoW25ldyBFbGVtZW50KFwiXCIsICcmJyldKV0sIG5ld1J1bGVzLCBycy5zdHJpY3RJbXBvcnRzLCBycy52aXNpYmlsaXR5SW5mbygpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdWxlc2V0KFtuZXcgKFNlbGVjdG9yKShbbmV3IEVsZW1lbnQoXCJcIiwgJyYnKV0pXSwgcnVsZXMsIHJzLnN0cmljdEltcG9ydHMsIHJzLnZpc2liaWxpdHlJbmZvKCkpLmV2YWwodGhpcy5jb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIE1hdGhIZWxwZXIgPSBmdW5jdGlvbiAoZm4sIHVuaXQsIG4pIHtcclxuICAgICAgICBpZiAoIShuIGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsIG1lc3NhZ2U6ICdhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodW5pdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSBuLnVuaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuID0gbi51bmlmeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihmbihwYXJzZUZsb2F0KG4udmFsdWUpKSwgdW5pdCk7XHJcbiAgICB9O1xuXG4gICAgdmFyIG1hdGhGdW5jdGlvbnMgPSB7XHJcbiAgICAgICAgLy8gbmFtZSwgIHVuaXRcclxuICAgICAgICBjZWlsOiBudWxsLFxyXG4gICAgICAgIGZsb29yOiBudWxsLFxyXG4gICAgICAgIHNxcnQ6IG51bGwsXHJcbiAgICAgICAgYWJzOiBudWxsLFxyXG4gICAgICAgIHRhbjogJycsXHJcbiAgICAgICAgc2luOiAnJyxcclxuICAgICAgICBjb3M6ICcnLFxyXG4gICAgICAgIGF0YW46ICdyYWQnLFxyXG4gICAgICAgIGFzaW46ICdyYWQnLFxyXG4gICAgICAgIGFjb3M6ICdyYWQnXHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgZiQxIGluIG1hdGhGdW5jdGlvbnMpIHtcclxuICAgICAgICBpZiAobWF0aEZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShmJDEpKSB7XHJcbiAgICAgICAgICAgIG1hdGhGdW5jdGlvbnNbZiQxXSA9IE1hdGhIZWxwZXIuYmluZChudWxsLCBNYXRoW2YkMV0sIG1hdGhGdW5jdGlvbnNbZiQxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0aEZ1bmN0aW9ucy5yb3VuZCA9IGZ1bmN0aW9uIChuLCBmKSB7XHJcbiAgICAgICAgdmFyIGZyYWN0aW9uID0gdHlwZW9mIGYgPT09ICd1bmRlZmluZWQnID8gMCA6IGYudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIE1hdGhIZWxwZXIoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gbnVtLnRvRml4ZWQoZnJhY3Rpb24pOyB9LCBudWxsLCBuKTtcclxuICAgIH07XG5cbiAgICB2YXIgbWluTWF4ID0gZnVuY3Rpb24gKGlzTWluLCBhcmdzKSB7XHJcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xyXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAwOiB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsIG1lc3NhZ2U6ICdvbmUgb3IgbW9yZSBhcmd1bWVudHMgcmVxdWlyZWQnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpOyAvLyBrZXkgaXMgdGhlIHVuaXQudG9TdHJpbmcoKSBmb3IgdW5pZmllZCBEaW1lbnNpb24gdmFsdWVzLFxyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIHZhciBjdXJyZW50O1xyXG4gICAgICAgIHZhciBjdXJyZW50VW5pZmllZDtcclxuICAgICAgICB2YXIgcmVmZXJlbmNlVW5pZmllZDtcclxuICAgICAgICB2YXIgdW5pdDtcclxuICAgICAgICB2YXIgdW5pdFN0YXRpYztcclxuICAgICAgICB2YXIgdW5pdENsb25lO1xyXG4gICAgICAgIHZhciAvLyBlbGVtcyBvbmx5IGNvbnRhaW5zIG9yaWdpbmFsIGFyZ3VtZW50IHZhbHVlcy5cclxuICAgICAgICBvcmRlciA9IFtdO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgICAgICAvLyB2YWx1ZSBpcyB0aGUgaW5kZXggaW50byB0aGUgb3JkZXIgYXJyYXkuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICghKGN1cnJlbnQgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzW2ldLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3NbaV0udmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRVbmlmaWVkID0gY3VycmVudC51bml0LnRvU3RyaW5nKCkgPT09ICcnICYmIHVuaXRDbG9uZSAhPT0gdW5kZWZpbmVkID8gbmV3IERpbWVuc2lvbihjdXJyZW50LnZhbHVlLCB1bml0Q2xvbmUpLnVuaWZ5KCkgOiBjdXJyZW50LnVuaWZ5KCk7XHJcbiAgICAgICAgICAgIHVuaXQgPSBjdXJyZW50VW5pZmllZC51bml0LnRvU3RyaW5nKCkgPT09ICcnICYmIHVuaXRTdGF0aWMgIT09IHVuZGVmaW5lZCA/IHVuaXRTdGF0aWMgOiBjdXJyZW50VW5pZmllZC51bml0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHVuaXRTdGF0aWMgPSB1bml0ICE9PSAnJyAmJiB1bml0U3RhdGljID09PSB1bmRlZmluZWQgfHwgdW5pdCAhPT0gJycgJiYgb3JkZXJbMF0udW5pZnkoKS51bml0LnRvU3RyaW5nKCkgPT09ICcnID8gdW5pdCA6IHVuaXRTdGF0aWM7XHJcbiAgICAgICAgICAgIHVuaXRDbG9uZSA9IHVuaXQgIT09ICcnICYmIHVuaXRDbG9uZSA9PT0gdW5kZWZpbmVkID8gY3VycmVudC51bml0LnRvU3RyaW5nKCkgOiB1bml0Q2xvbmU7XHJcbiAgICAgICAgICAgIGogPSB2YWx1ZXNbJyddICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gJycgJiYgdW5pdCA9PT0gdW5pdFN0YXRpYyA/IHZhbHVlc1snJ10gOiB2YWx1ZXNbdW5pdF07XHJcbiAgICAgICAgICAgIGlmIChqID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1bml0U3RhdGljICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gdW5pdFN0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ2luY29tcGF0aWJsZSB0eXBlcycgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhbHVlc1t1bml0XSA9IG9yZGVyLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWZlcmVuY2VVbmlmaWVkID0gb3JkZXJbal0udW5pdC50b1N0cmluZygpID09PSAnJyAmJiB1bml0Q2xvbmUgIT09IHVuZGVmaW5lZCA/IG5ldyBEaW1lbnNpb24ob3JkZXJbal0udmFsdWUsIHVuaXRDbG9uZSkudW5pZnkoKSA6IG9yZGVyW2pdLnVuaWZ5KCk7XHJcbiAgICAgICAgICAgIGlmIChpc01pbiAmJiBjdXJyZW50VW5pZmllZC52YWx1ZSA8IHJlZmVyZW5jZVVuaWZpZWQudmFsdWUgfHxcclxuICAgICAgICAgICAgICAgICFpc01pbiAmJiBjdXJyZW50VW5pZmllZC52YWx1ZSA+IHJlZmVyZW5jZVVuaWZpZWQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG9yZGVyW2pdID0gY3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3JkZXIubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yZGVyWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcmdzID0gb3JkZXIubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnRvQ1NTKHRoaXMuY29udGV4dCk7IH0pLmpvaW4odGhpcy5jb250ZXh0LmNvbXByZXNzID8gJywnIDogJywgJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMoKGlzTWluID8gJ21pbicgOiAnbWF4JykgKyBcIihcIiArIGFyZ3MgKyBcIilcIik7XHJcbiAgICB9O1xyXG4gICAgdmFyIG51bWJlciQxID0ge1xyXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWluTWF4KHRydWUsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1heDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWluTWF4KGZhbHNlLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbiAodmFsLCB1bml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWwuY29udmVydFRvKHVuaXQudmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oTWF0aC5QSSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2Q6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGEudmFsdWUgJSBiLnZhbHVlLCBhLnVuaXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG93OiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInICYmIHR5cGVvZiB5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgeCA9IG5ldyBEaW1lbnNpb24oeCk7XHJcbiAgICAgICAgICAgICAgICB5ID0gbmV3IERpbWVuc2lvbih5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghKHggaW5zdGFuY2VvZiBEaW1lbnNpb24pIHx8ICEoeSBpbnN0YW5jZW9mIERpbWVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ2FyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMnIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oTWF0aC5wb3coeC52YWx1ZSwgeS52YWx1ZSksIHgudW5pdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwZXJjZW50YWdlOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aEhlbHBlcihmdW5jdGlvbiAobnVtKSB7IHJldHVybiBudW0gKiAxMDA7IH0sICclJywgbik7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcblxuICAgIHZhciBzdHJpbmcgPSB7XHJcbiAgICAgICAgZTogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1b3RlZCgnXCInLCBzdHIgaW5zdGFuY2VvZiBKYXZhU2NyaXB0ID8gc3RyLmV2YWx1YXRlZCA6IHN0ci52YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc2NhcGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMoZW5jb2RlVVJJKHN0ci52YWx1ZSkucmVwbGFjZSgvPS9nLCAnJTNEJykucmVwbGFjZSgvOi9nLCAnJTNBJykucmVwbGFjZSgvIy9nLCAnJTIzJykucmVwbGFjZSgvOy9nLCAnJTNCJylcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCgvZywgJyUyOCcpLnJlcGxhY2UoL1xcKS9nLCAnJTI5JykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24gKHN0cmluZywgcGF0dGVybiwgcmVwbGFjZW1lbnQsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcudmFsdWU7XHJcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gKHJlcGxhY2VtZW50LnR5cGUgPT09ICdRdW90ZWQnKSA/XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC52YWx1ZSA6IHJlcGxhY2VtZW50LnRvQ1NTKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybi52YWx1ZSwgZmxhZ3MgPyBmbGFncy52YWx1ZSA6ICcnKSwgcmVwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1b3RlZChzdHJpbmcucXVvdGUgfHwgJycsIHJlc3VsdCwgc3RyaW5nLmVzY2FwZWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyUnOiBmdW5jdGlvbiAoc3RyaW5nIC8qIGFyZywgYXJnLCAuLi4gKi8pIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyVbc2RhXS9pLCBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAoKGFyZ3NbaV0udHlwZSA9PT0gJ1F1b3RlZCcpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoKC9zL2kpKSA/IGFyZ3NbaV0udmFsdWUgOiBhcmdzW2ldLnRvQ1NTKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLm1hdGNoKC9bQS1aXSQvKSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyUlL2csICclJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVvdGVkKHN0cmluZy5xdW90ZSB8fCAnJywgcmVzdWx0LCBzdHJpbmcuZXNjYXBlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcblxuICAgIHZhciBzdmcgPSAoZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgJ3N2Zy1ncmFkaWVudCc6IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdG9wcztcclxuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudERpcmVjdGlvblN2ZztcclxuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFR5cGUgPSAnbGluZWFyJztcclxuICAgICAgICAgICAgICAgIHZhciByZWN0YW5nbGVEaW1lbnNpb24gPSAneD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIic7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyRW52ID0geyBjb21wcmVzczogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5lcjtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25WYWx1ZSA9IGRpcmVjdGlvbi50b0NTUyhyZW5kZXJFbnYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25WYWx1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBhbHBoYTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3N2Zy1ncmFkaWVudCBleHBlY3RzIGRpcmVjdGlvbiwgc3RhcnRfY29sb3IgW3N0YXJ0X3Bvc2l0aW9uXSwgW2NvbG9yIHBvc2l0aW9uLF0uLi4sJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGVuZF9jb2xvciBbZW5kX3Bvc2l0aW9uXSBvciBkaXJlY3Rpb24sIGNvbG9yIGxpc3QnIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1sxXS52YWx1ZS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BzID0gYXJndW1lbnRzWzFdLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0FyZ3VtZW50RGVzY3JpcHRvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb25WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvIGJvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIwJVwiIHkyPVwiMTAwJVwiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG8gcmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudERpcmVjdGlvblN2ZyA9ICd4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMTAwJVwiIHkyPVwiMCVcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvIGJvdHRvbSByaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50RGlyZWN0aW9uU3ZnID0gJ3gxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIxMDAlXCIgeTI9XCIxMDAlXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0byB0b3AgcmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudERpcmVjdGlvblN2ZyA9ICd4MT1cIjAlXCIgeTE9XCIxMDAlXCIgeDI9XCIxMDAlXCIgeTI9XCIwJVwiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzZSBhdCBjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudFR5cGUgPSAncmFkaWFsJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnREaXJlY3Rpb25TdmcgPSAnY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI3NSVcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZURpbWVuc2lvbiA9ICd4PVwiLTUwXCIgeT1cIi01MFwiIHdpZHRoPVwiMTAxXCIgaGVpZ2h0PVwiMTAxXCInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsIG1lc3NhZ2U6ICdzdmctZ3JhZGllbnQgZGlyZWN0aW9uIG11c3QgYmUgXFwndG8gYm90dG9tXFwnLCBcXCd0byByaWdodFxcJywnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFxcJ3RvIGJvdHRvbSByaWdodFxcJywgXFwndG8gdG9wIHJpZ2h0XFwnIG9yIFxcJ2VsbGlwc2UgYXQgY2VudGVyXFwnJyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuZXIgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMSAxXFxcIj48XCIgKyBncmFkaWVudFR5cGUgKyBcIkdyYWRpZW50IGlkPVxcXCJnXFxcIiBcIiArIGdyYWRpZW50RGlyZWN0aW9uU3ZnICsgXCI+XCI7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcHNbaV0gaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3RvcHNbaV0udmFsdWVbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gc3RvcHNbaV0udmFsdWVbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHN0b3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikgfHwgKCEoKGkgPT09IDAgfHwgaSArIDEgPT09IHN0b3BzLmxlbmd0aCkgJiYgcG9zaXRpb24gPT09IHVuZGVmaW5lZCkgJiYgIShwb3NpdGlvbiBpbnN0YW5jZW9mIERpbWVuc2lvbikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93QXJndW1lbnREZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVmFsdWUgPSBwb3NpdGlvbiA/IHBvc2l0aW9uLnRvQ1NTKHJlbmRlckVudikgOiBpID09PSAwID8gJzAlJyA6ICcxMDAlJztcclxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGNvbG9yLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVyICs9IFwiPHN0b3Agb2Zmc2V0PVxcXCJcIiArIHBvc2l0aW9uVmFsdWUgKyBcIlxcXCIgc3RvcC1jb2xvcj1cXFwiXCIgKyBjb2xvci50b1JHQigpICsgXCJcXFwiXCIgKyAoYWxwaGEgPCAxID8gXCIgc3RvcC1vcGFjaXR5PVxcXCJcIiArIGFscGhhICsgXCJcXFwiXCIgOiAnJykgKyBcIi8+XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm5lciArPSBcIjwvXCIgKyBncmFkaWVudFR5cGUgKyBcIkdyYWRpZW50PjxyZWN0IFwiICsgcmVjdGFuZ2xlRGltZW5zaW9uICsgXCIgZmlsbD1cXFwidXJsKCNnKVxcXCIgLz48L3N2Zz5cIjtcclxuICAgICAgICAgICAgICAgIHJldHVybmVyID0gZW5jb2RlVVJJQ29tcG9uZW50KHJldHVybmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybmVyID0gXCJkYXRhOmltYWdlL3N2Zyt4bWwsXCIgKyByZXR1cm5lcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKG5ldyBRdW90ZWQoXCInXCIgKyByZXR1cm5lciArIFwiJ1wiLCByZXR1cm5lciwgZmFsc2UsIHRoaXMuaW5kZXgsIHRoaXMuY3VycmVudEZpbGVJbmZvKSwgdGhpcy5pbmRleCwgdGhpcy5jdXJyZW50RmlsZUluZm8pO1xyXG4gICAgICAgICAgICB9IH07XHJcbiAgICB9KTtcblxuICAgIHZhciBpc2EgPSBmdW5jdGlvbiAobiwgVHlwZSkgeyByZXR1cm4gKG4gaW5zdGFuY2VvZiBUeXBlKSA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7IH07XHJcbiAgICB2YXIgaXN1bml0ID0gZnVuY3Rpb24gKG4sIHVuaXQpIHtcclxuICAgICAgICBpZiAodW5pdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IHsgdHlwZTogJ0FyZ3VtZW50JywgbWVzc2FnZTogJ21pc3NpbmcgdGhlIHJlcXVpcmVkIHNlY29uZCBhcmd1bWVudCB0byBpc3VuaXQuJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB1bml0ID0gdHlwZW9mIHVuaXQudmFsdWUgPT09ICdzdHJpbmcnID8gdW5pdC52YWx1ZSA6IHVuaXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsIG1lc3NhZ2U6ICdTZWNvbmQgYXJndW1lbnQgdG8gaXN1bml0IHNob3VsZCBiZSBhIHVuaXQgb3IgYSBzdHJpbmcuJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKG4gaW5zdGFuY2VvZiBEaW1lbnNpb24pICYmIG4udW5pdC5pcyh1bml0KSA/IEtleXdvcmQuVHJ1ZSA6IEtleXdvcmQuRmFsc2U7XHJcbiAgICB9O1xyXG4gICAgdmFyIHR5cGVzID0ge1xyXG4gICAgICAgIGlzcnVsZXNldDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzYShuLCBEZXRhY2hlZFJ1bGVzZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNjb2xvcjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzYShuLCBDb2xvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc251bWJlcjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzYShuLCBEaW1lbnNpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNzdHJpbmc6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc2EobiwgUXVvdGVkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlza2V5d29yZDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzYShuLCBLZXl3b3JkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzdXJsOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNhKG4sIFVSTCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc3BpeGVsOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXN1bml0KG4sICdweCcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNwZXJjZW50YWdlOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXN1bml0KG4sICclJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc2VtOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXN1bml0KG4sICdlbScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXN1bml0OiBpc3VuaXQsXHJcbiAgICAgICAgdW5pdDogZnVuY3Rpb24gKHZhbCwgdW5pdCkge1xyXG4gICAgICAgICAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBEaW1lbnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyB7IHR5cGU6ICdBcmd1bWVudCcsIG1lc3NhZ2U6IFwidGhlIGZpcnN0IGFyZ3VtZW50IHRvIHVuaXQgbXVzdCBiZSBhIG51bWJlclwiICsgKHZhbCBpbnN0YW5jZW9mIE9wZXJhdGlvbiA/ICcuIEhhdmUgeW91IGZvcmdvdHRlbiBwYXJlbnRoZXNpcz8nIDogJycpIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVuaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1bml0IGluc3RhbmNlb2YgS2V5d29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXQgPSB1bml0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHVuaXQudG9DU1MoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbih2YWwudmFsdWUsIHVuaXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2dldC11bml0JzogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXMobi51bml0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xuXG4gICAgdmFyIGZ1bmN0aW9ucyA9IChmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcclxuICAgICAgICB2YXIgZnVuY3Rpb25zID0geyBmdW5jdGlvblJlZ2lzdHJ5OiBmdW5jdGlvblJlZ2lzdHJ5LCBmdW5jdGlvbkNhbGxlcjogZnVuY3Rpb25DYWxsZXIgfTtcclxuICAgICAgICAvLyByZWdpc3RlciBmdW5jdGlvbnNcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGJvb2xlYW4kMSk7XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGQoJ2RlZmF1bHQnLCBkZWZhdWx0RnVuYy5ldmFsLmJpbmQoZGVmYXVsdEZ1bmMpKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGNvbG9yKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKGNvbG9yQmxlbmQpO1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUoZGF0YVVyaShlbnZpcm9ubWVudCkpO1xyXG4gICAgICAgIGZ1bmN0aW9uUmVnaXN0cnkuYWRkTXVsdGlwbGUobGlzdCk7XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShtYXRoRnVuY3Rpb25zKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKG51bWJlciQxKTtcclxuICAgICAgICBmdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKHN0cmluZyk7XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShzdmcoKSk7XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZSh0eXBlcyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtVHJlZSAocm9vdCwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBldmFsZFJvb3Q7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IG9wdGlvbnMudmFyaWFibGVzO1xyXG4gICAgICAgIHZhciBldmFsRW52ID0gbmV3IGNvbnRleHRzLkV2YWwob3B0aW9ucyk7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBBbGxvd3Mgc2V0dGluZyB2YXJpYWJsZXMgd2l0aCBhIGhhc2gsIHNvOlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gICBgeyBjb2xvcjogbmV3IHRyZWUuQ29sb3IoJyNmMDEnKSB9YCB3aWxsIGJlY29tZTpcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgbmV3IHRyZWUuRGVjbGFyYXRpb24oJ0Bjb2xvcicsXHJcbiAgICAgICAgLy8gICAgIG5ldyB0cmVlLlZhbHVlKFtcclxuICAgICAgICAvLyAgICAgICBuZXcgdHJlZS5FeHByZXNzaW9uKFtcclxuICAgICAgICAvLyAgICAgICAgIG5ldyB0cmVlLkNvbG9yKCcjZjAxJylcclxuICAgICAgICAvLyAgICAgICBdKVxyXG4gICAgICAgIC8vICAgICBdKVxyXG4gICAgICAgIC8vICAgKVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YXJpYWJsZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhcmlhYmxlcykpIHtcclxuICAgICAgICAgICAgdmFyaWFibGVzID0gT2JqZWN0LmtleXModmFyaWFibGVzKS5tYXAoZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhcmlhYmxlc1trXTtcclxuICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHJlZS5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIHRyZWUuRXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgdHJlZS5FeHByZXNzaW9uKFt2YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyB0cmVlLlZhbHVlKFt2YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkRlY2xhcmF0aW9uKFwiQFwiICsgaywgdmFsdWUsIGZhbHNlLCBudWxsLCAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGV2YWxFbnYuZnJhbWVzID0gW25ldyB0cmVlLlJ1bGVzZXQobnVsbCwgdmFyaWFibGVzKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2aXNpdG9ycyQxID0gW1xyXG4gICAgICAgICAgICBuZXcgdmlzaXRvcnMuSm9pblNlbGVjdG9yVmlzaXRvcigpLFxyXG4gICAgICAgICAgICBuZXcgdmlzaXRvcnMuTWFya1Zpc2libGVTZWxlY3RvcnNWaXNpdG9yKHRydWUpLFxyXG4gICAgICAgICAgICBuZXcgdmlzaXRvcnMuRXh0ZW5kVmlzaXRvcigpLFxyXG4gICAgICAgICAgICBuZXcgdmlzaXRvcnMuVG9DU1NWaXNpdG9yKHsgY29tcHJlc3M6IEJvb2xlYW4ob3B0aW9ucy5jb21wcmVzcykgfSlcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBwcmVFdmFsVmlzaXRvcnMgPSBbXTtcclxuICAgICAgICB2YXIgdjtcclxuICAgICAgICB2YXIgdmlzaXRvckl0ZXJhdG9yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGZpcnN0KCkgLyBnZXQoKSBhbGxvd3MgdmlzaXRvcnMgdG8gYmUgYWRkZWQgd2hpbGUgdmlzaXRpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0b2RvIEFkZCBzY29waW5nIGZvciB2aXNpdG9ycyBqdXN0IGxpa2UgZnVuY3Rpb25zIGZvciBAcGx1Z2luOyByaWdodCBub3cgdGhleSdyZSBnbG9iYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAob3B0aW9ucy5wbHVnaW5NYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHZpc2l0b3JJdGVyYXRvciA9IG9wdGlvbnMucGx1Z2luTWFuYWdlci52aXNpdG9yKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpdG9ySXRlcmF0b3IuZmlyc3QoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodiA9IHZpc2l0b3JJdGVyYXRvci5nZXQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5pc1ByZUV2YWxWaXNpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IHByZUV2YWxWaXNpdG9ycy5pbmRleE9mKHYpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlRXZhbFZpc2l0b3JzLnB1c2godik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LnJ1bihyb290KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgdmlzaXRvcnMkMS5pbmRleE9mKHYpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuaXNQcmVWaXNpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRvcnMkMS51bnNoaWZ0KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRvcnMkMS5wdXNoKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2YWxkUm9vdCA9IHJvb3QuZXZhbChldmFsRW52KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2l0b3JzJDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmlzaXRvcnMkMVtpXS5ydW4oZXZhbGRSb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUnVuIGFueSByZW1haW5pbmcgdmlzaXRvcnMgYWRkZWQgYWZ0ZXIgZXZhbCBwYXNzXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGx1Z2luTWFuYWdlcikge1xyXG4gICAgICAgICAgICB2aXNpdG9ySXRlcmF0b3IuZmlyc3QoKTtcclxuICAgICAgICAgICAgd2hpbGUgKCh2ID0gdmlzaXRvckl0ZXJhdG9yLmdldCgpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0b3JzJDEuaW5kZXhPZih2KSA9PT0gLTEgJiYgcHJlRXZhbFZpc2l0b3JzLmluZGV4T2YodikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5ydW4oZXZhbGRSb290KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZhbGRSb290O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBQbHVnaW4gTWFuYWdlclxyXG4gICAgICovXHJcbiAgICB2YXIgUGx1Z2luTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQbHVnaW5NYW5hZ2VyKGxlc3MpIHtcclxuICAgICAgICAgICAgdGhpcy5sZXNzID0gbGVzcztcclxuICAgICAgICAgICAgdGhpcy52aXNpdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnByZVByb2Nlc3NvcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbGxlZFBsdWdpbnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5maWxlTWFuYWdlcnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvciA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbkNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuTG9hZGVyID0gbmV3IGxlc3MuUGx1Z2luTG9hZGVyKGxlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFsbCB0aGUgcGx1Z2lucyBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwbHVnaW5zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkUGx1Z2lucyA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW5zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBsdWdpbihwbHVnaW5zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcGx1Z2luXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuYWRkUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbiwgZmlsZW5hbWUsIGZ1bmN0aW9uUmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcclxuICAgICAgICAgICAgaWYgKGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbkNhY2hlW2ZpbGVuYW1lXSA9IHBsdWdpbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKHRoaXMubGVzcywgdGhpcywgZnVuY3Rpb25SZWdpc3RyeSB8fCB0aGlzLmxlc3MuZnVuY3Rpb25zLmZ1bmN0aW9uUmVnaXN0cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBmaWxlbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5DYWNoZVtmaWxlbmFtZV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgdmlzaXRvci4gVGhlIHZpc2l0b3Igb2JqZWN0IGhhcyBvcHRpb25zIG9uIGl0c2VsZiB0byBkZXRlcm1pbmVcclxuICAgICAgICAgKiB3aGVuIGl0IHNob3VsZCBydW4uXHJcbiAgICAgICAgICogQHBhcmFtIHZpc2l0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRWaXNpdG9yID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpdG9ycy5wdXNoKHZpc2l0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIHByZSBwcm9jZXNzb3Igb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByZVByb2Nlc3NvclxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmlvcml0eSAtIGd1aWRlbGluZXMgMSA9IGJlZm9yZSBpbXBvcnQsIDEwMDAgPSBpbXBvcnQsIDIwMDAgPSBhZnRlciBpbXBvcnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLnByb3RvdHlwZS5hZGRQcmVQcm9jZXNzb3IgPSBmdW5jdGlvbiAocHJlUHJvY2Vzc29yLCBwcmlvcml0eSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXhUb0luc2VydEF0O1xyXG4gICAgICAgICAgICBmb3IgKGluZGV4VG9JbnNlcnRBdCA9IDA7IGluZGV4VG9JbnNlcnRBdCA8IHRoaXMucHJlUHJvY2Vzc29ycy5sZW5ndGg7IGluZGV4VG9JbnNlcnRBdCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVQcm9jZXNzb3JzW2luZGV4VG9JbnNlcnRBdF0ucHJpb3JpdHkgPj0gcHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnByZVByb2Nlc3NvcnMuc3BsaWNlKGluZGV4VG9JbnNlcnRBdCwgMCwgeyBwcmVQcm9jZXNzb3I6IHByZVByb2Nlc3NvciwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIHBvc3QgcHJvY2Vzc29yIG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3N0UHJvY2Vzc29yXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IC0gZ3VpZGVsaW5lcyAxID0gYmVmb3JlIGNvbXByZXNzaW9uLCAxMDAwID0gY29tcHJlc3Npb24sIDIwMDAgPSBhZnRlciBjb21wcmVzc2lvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZFBvc3RQcm9jZXNzb3IgPSBmdW5jdGlvbiAocG9zdFByb2Nlc3NvciwgcHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4VG9JbnNlcnRBdDtcclxuICAgICAgICAgICAgZm9yIChpbmRleFRvSW5zZXJ0QXQgPSAwOyBpbmRleFRvSW5zZXJ0QXQgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaW5kZXhUb0luc2VydEF0KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvc3RQcm9jZXNzb3JzW2luZGV4VG9JbnNlcnRBdF0ucHJpb3JpdHkgPj0gcHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzLnNwbGljZShpbmRleFRvSW5zZXJ0QXQsIDAsIHsgcG9zdFByb2Nlc3NvcjogcG9zdFByb2Nlc3NvciwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gbWFuYWdlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmFkZEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24gKG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlTWFuYWdlcnMucHVzaChtYW5hZ2VyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0UHJlUHJvY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHByZVByb2Nlc3NvcnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZVByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHByZVByb2Nlc3NvcnMucHVzaCh0aGlzLnByZVByb2Nlc3NvcnNbaV0ucHJlUHJvY2Vzc29yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJlUHJvY2Vzc29ycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0UG9zdFByb2Nlc3NvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3N0UHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzb3JzLnB1c2godGhpcy5wb3N0UHJvY2Vzc29yc1tpXS5wb3N0UHJvY2Vzc29yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NvcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLmdldFZpc2l0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdG9ycztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIucHJvdG90eXBlLnZpc2l0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pdGVyYXRvciA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnZpc2l0b3JzW3NlbGYuaXRlcmF0b3JdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXRlcmF0b3IgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi52aXNpdG9yc1tzZWxmLml0ZXJhdG9yXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUGx1Z2luTWFuYWdlci5wcm90b3R5cGUuZ2V0RmlsZU1hbmFnZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlTWFuYWdlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUGx1Z2luTWFuYWdlcjtcclxuICAgIH0oKSk7XHJcbiAgICB2YXIgcG07XHJcbiAgICB2YXIgUGx1Z2luTWFuYWdlckZhY3RvcnkgPSBmdW5jdGlvbiAobGVzcywgbmV3RmFjdG9yeSkge1xyXG4gICAgICAgIGlmIChuZXdGYWN0b3J5IHx8ICFwbSkge1xyXG4gICAgICAgICAgICBwbSA9IG5ldyBQbHVnaW5NYW5hZ2VyKGxlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG07XHJcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU291cmNlTWFwT3V0cHV0IChlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIHZhciBTb3VyY2VNYXBPdXRwdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNvdXJjZU1hcE91dHB1dChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jc3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlID0gb3B0aW9ucy5yb290Tm9kZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRzTWFwID0gb3B0aW9ucy5jb250ZW50c01hcDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwID0gb3B0aW9ucy5jb250ZW50c0lnbm9yZWRDaGFyc01hcDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcEZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwRmlsZW5hbWUgPSBvcHRpb25zLnNvdXJjZU1hcEZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dEZpbGVuYW1lID0gb3B0aW9ucy5vdXRwdXRGaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gb3B0aW9ucy5zb3VyY2VNYXBVUkw7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXBCYXNlcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcEJhc2VwYXRoID0gb3B0aW9ucy5zb3VyY2VNYXBCYXNlcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXBSb290cGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoID0gb3B0aW9ucy5zb3VyY2VNYXBSb290cGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoLmNoYXJBdCh0aGlzLl9zb3VyY2VNYXBSb290cGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcFJvb3RwYXRoICs9ICcvJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBSb290cGF0aCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0U291cmNlRmlsZXMgPSBvcHRpb25zLm91dHB1dFNvdXJjZUZpbGVzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yQ29uc3RydWN0b3IgPSBlbnZpcm9ubWVudC5nZXRTb3VyY2VNYXBHZW5lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVOdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sdW1uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTb3VyY2VNYXBPdXRwdXQucHJvdG90eXBlLnJlbW92ZUJhc2VwYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VNYXBCYXNlcGF0aCAmJiBwYXRoLmluZGV4T2YodGhpcy5fc291cmNlTWFwQmFzZXBhdGgpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKHRoaXMuX3NvdXJjZU1hcEJhc2VwYXRoLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnXFxcXCcgfHwgcGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcE91dHB1dC5wcm90b3R5cGUubm9ybWFsaXplRmlsZW5hbWUgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSB0aGlzLnJlbW92ZUJhc2VwYXRoKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fc291cmNlTWFwUm9vdHBhdGggfHwgJycpICsgZmlsZW5hbWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcE91dHB1dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNodW5rLCBmaWxlSW5mbywgaW5kZXgsIG1hcExpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYWRkaW5nIGVtcHR5IHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIGlmICghY2h1bmspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMsIHNvdXJjZUxpbmVzLCBjb2x1bW5zLCBzb3VyY2VDb2x1bW5zLCBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVJbmZvICYmIGZpbGVJbmZvLmZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0U291cmNlID0gdGhpcy5fY29udGVudHNNYXBbZmlsZUluZm8uZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB2YXJzL2Jhbm5lciBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVJbmZvLmZpbGVuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IC09IHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVJbmZvLmZpbGVuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgc291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U291cmNlID0gaW5wdXRTb3VyY2Uuc2xpY2UodGhpcy5fY29udGVudHNJZ25vcmVkQ2hhcnNNYXBbZmlsZUluZm8uZmlsZW5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogaWdub3JlIGVtcHR5IGNvbnRlbnQsIG9yIGZhaWxzYWZlXHJcbiAgICAgICAgICAgICAgICAgICAgICogaWYgY29udGVudHMgbWFwIGlzIGluY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nzcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFNvdXJjZSA9IGlucHV0U291cmNlLnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTGluZXMgPSBpbnB1dFNvdXJjZS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQ29sdW1ucyA9IHNvdXJjZUxpbmVzW3NvdXJjZUxpbmVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGluZXMgPSBjaHVuay5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUluZm8gJiYgZmlsZUluZm8uZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcExpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZU1hcEdlbmVyYXRvci5hZGRNYXBwaW5nKHsgZ2VuZXJhdGVkOiB7IGxpbmU6IHRoaXMuX2xpbmVOdW1iZXIgKyAxLCBjb2x1bW46IHRoaXMuX2NvbHVtbiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6IHsgbGluZTogc291cmNlTGluZXMubGVuZ3RoLCBjb2x1bW46IHNvdXJjZUNvbHVtbnMubGVuZ3RoIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMubm9ybWFsaXplRmlsZW5hbWUoZmlsZUluZm8uZmlsZW5hbWUpIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VNYXBHZW5lcmF0b3IuYWRkTWFwcGluZyh7IGdlbmVyYXRlZDogeyBsaW5lOiB0aGlzLl9saW5lTnVtYmVyICsgaSArIDEsIGNvbHVtbjogaSA9PT0gMCA/IHRoaXMuX2NvbHVtbiA6IDAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbDogeyBsaW5lOiBzb3VyY2VMaW5lcy5sZW5ndGggKyBpLCBjb2x1bW46IGkgPT09IDAgPyBzb3VyY2VDb2x1bW5zLmxlbmd0aCA6IDAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMubm9ybWFsaXplRmlsZW5hbWUoZmlsZUluZm8uZmlsZW5hbWUpIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbiArPSBjb2x1bW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVOdW1iZXIgKz0gbGluZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSBjb2x1bW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2Nzcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwT3V0cHV0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nzcy5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcE91dHB1dC5wcm90b3R5cGUudG9DU1MgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yID0gbmV3IHRoaXMuX3NvdXJjZU1hcEdlbmVyYXRvckNvbnN0cnVjdG9yKHsgZmlsZTogdGhpcy5fb3V0cHV0RmlsZW5hbWUsIHNvdXJjZVJvb3Q6IG51bGwgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3V0cHV0U291cmNlRmlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWxlbmFtZSBpbiB0aGlzLl9jb250ZW50c01hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudHNNYXAuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fY29udGVudHNNYXBbZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRzSWdub3JlZENoYXJzTWFwW2ZpbGVuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zbGljZSh0aGlzLl9jb250ZW50c0lnbm9yZWRDaGFyc01hcFtmaWxlbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQodGhpcy5ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSksIHNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290Tm9kZS5nZW5DU1MoY29udGV4dCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3NzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwVVJMID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5fc291cmNlTWFwR2VuZXJhdG9yLnRvSlNPTigpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXBVUkwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwVVJMID0gdGhpcy5zb3VyY2VNYXBVUkw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NvdXJjZU1hcEZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcFVSTCA9IHRoaXMuX3NvdXJjZU1hcEZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZU1hcFVSTCA9IHNvdXJjZU1hcFVSTDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZU1hcCA9IHNvdXJjZU1hcENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3NzLmpvaW4oJycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU291cmNlTWFwT3V0cHV0O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcmV0dXJuIFNvdXJjZU1hcE91dHB1dDtcclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEJ1aWxkZXIgKFNvdXJjZU1hcE91dHB1dCwgZW52aXJvbm1lbnQpIHtcclxuICAgICAgICB2YXIgU291cmNlTWFwQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU291cmNlTWFwQnVpbGRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLnRvQ1NTID0gZnVuY3Rpb24gKHJvb3ROb2RlLCBvcHRpb25zLCBpbXBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwT3V0cHV0ID0gbmV3IFNvdXJjZU1hcE91dHB1dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNJZ25vcmVkQ2hhcnNNYXA6IGltcG9ydHMuY29udGVudHNJZ25vcmVkQ2hhcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGU6IHJvb3ROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzTWFwOiBpbXBvcnRzLmNvbnRlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcEZpbGVuYW1lOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwRmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwVVJMOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwVVJMLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEZpbGVuYW1lOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwT3V0cHV0RmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwQmFzZXBhdGg6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBCYXNlcGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBSb290cGF0aDogdGhpcy5vcHRpb25zLnNvdXJjZU1hcFJvb3RwYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNvdXJjZUZpbGVzOiB0aGlzLm9wdGlvbnMub3V0cHV0U291cmNlRmlsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwR2VuZXJhdG9yOiB0aGlzLm9wdGlvbnMuc291cmNlTWFwR2VuZXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcEZpbGVJbmxpbmU6IHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlSW5saW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVTb3VyY2VtYXBBbm5vdGF0aW9uOiB0aGlzLm9wdGlvbnMuZGlzYWJsZVNvdXJjZW1hcEFubm90YXRpb25cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNzcyA9IHNvdXJjZU1hcE91dHB1dC50b0NTUyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwT3V0cHV0LnNvdXJjZU1hcDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwT3V0cHV0LnNvdXJjZU1hcFVSTDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSA9IHNvdXJjZU1hcE91dHB1dC5ub3JtYWxpemVGaWxlbmFtZSh0aGlzLm9wdGlvbnMuc291cmNlTWFwSW5wdXRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZU1hcEJhc2VwYXRoICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zb3VyY2VNYXBVUkwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwVVJMID0gc291cmNlTWFwT3V0cHV0LnJlbW92ZUJhc2VwYXRoKHRoaXMuc291cmNlTWFwVVJMKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjc3MgKyB0aGlzLmdldENTU0FwcGVuZGFnZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRDU1NBcHBlbmRhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwVVJMID0gdGhpcy5zb3VyY2VNYXBVUkw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZU1hcEZpbGVJbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcFVSTCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGVudmlyb25tZW50LmVuY29kZUJhc2U2NCh0aGlzLnNvdXJjZU1hcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVTb3VyY2VtYXBBbm5vdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU1hcFVSTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgc291cmNlTWFwVVJMICsgXCIgKi9cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0RXh0ZXJuYWxTb3VyY2VNYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLnNldEV4dGVybmFsU291cmNlTWFwID0gZnVuY3Rpb24gKHNvdXJjZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VNYXAgPSBzb3VyY2VNYXA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmlzSW5saW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3VyY2VNYXBGaWxlSW5saW5lO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTb3VyY2VNYXBCdWlsZGVyLnByb3RvdHlwZS5nZXRTb3VyY2VNYXBVUkwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXBVUkw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNvdXJjZU1hcEJ1aWxkZXIucHJvdG90eXBlLmdldE91dHB1dEZpbGVuYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3VyY2VNYXBPdXRwdXRGaWxlbmFtZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRGaWxlbmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hcElucHV0RmlsZW5hbWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTb3VyY2VNYXBCdWlsZGVyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEJ1aWxkZXI7XHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQYXJzZVRyZWUgKFNvdXJjZU1hcEJ1aWxkZXIpIHtcclxuICAgICAgICB2YXIgUGFyc2VUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXJzZVRyZWUocm9vdCwgaW1wb3J0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0cyA9IGltcG9ydHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUGFyc2VUcmVlLnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZhbGRSb290O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcEJ1aWxkZXI7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2YWxkUm9vdCA9IHRyYW5zZm9ybVRyZWUodGhpcy5yb290LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlc3NFcnJvcihlLCB0aGlzLmltcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcHJlc3MgPSBCb29sZWFuKG9wdGlvbnMuY29tcHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wcmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybignVGhlIGNvbXByZXNzIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdXZSByZWNvbW1lbmQgeW91IHVzZSBhIGRlZGljYXRlZCBjc3MgbWluaWZpZXIsIGZvciBpbnN0YW5jZSBzZWUgbGVzcy1wbHVnaW4tY2xlYW4tY3NzLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9DU1NPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzczogY29tcHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1bXBMaW5lTnVtYmVyczogb3B0aW9ucy5kdW1wTGluZU51bWJlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdFVuaXRzOiBCb29sZWFuKG9wdGlvbnMuc3RyaWN0VW5pdHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1QcmVjaXNpb246IDhcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBCdWlsZGVyID0gbmV3IFNvdXJjZU1hcEJ1aWxkZXIob3B0aW9ucy5zb3VyY2VNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3NzID0gc291cmNlTWFwQnVpbGRlci50b0NTUyhldmFsZFJvb3QsIHRvQ1NTT3B0aW9ucywgdGhpcy5pbXBvcnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBldmFsZFJvb3QudG9DU1ModG9DU1NPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBMZXNzRXJyb3IoZSwgdGhpcy5pbXBvcnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBsdWdpbk1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zdFByb2Nlc3NvcnMgPSBvcHRpb25zLnBsdWdpbk1hbmFnZXIuZ2V0UG9zdFByb2Nlc3NvcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jc3MgPSBwb3N0UHJvY2Vzc29yc1tpXS5wcm9jZXNzKHJlc3VsdC5jc3MsIHsgc291cmNlTWFwOiBzb3VyY2VNYXBCdWlsZGVyLCBvcHRpb25zOiBvcHRpb25zLCBpbXBvcnRzOiB0aGlzLmltcG9ydHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1hcCA9IHNvdXJjZU1hcEJ1aWxkZXIuZ2V0RXh0ZXJuYWxTb3VyY2VNYXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5pbXBvcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWxlIGluIHRoaXMuaW1wb3J0cy5maWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydHMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZSkgJiYgZmlsZSAhPT0gdGhpcy5pbXBvcnRzLnJvb3RGaWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaW1wb3J0cy5wdXNoKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVRyZWU7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICByZXR1cm4gUGFyc2VUcmVlO1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW1wb3J0TWFuYWdlciAoZW52aXJvbm1lbnQpIHtcclxuICAgICAgICAvLyBGaWxlSW5mbyA9IHtcclxuICAgICAgICAvLyAgJ3Jld3JpdGVVcmxzJyAtIG9wdGlvbiAtIHdoZXRoZXIgdG8gYWRqdXN0IFVSTCdzIHRvIGJlIHJlbGF0aXZlXHJcbiAgICAgICAgLy8gICdmaWxlbmFtZScgLSBmdWxsIHJlc29sdmVkIGZpbGVuYW1lIG9mIGN1cnJlbnQgZmlsZVxyXG4gICAgICAgIC8vICAncm9vdHBhdGgnIC0gcGF0aCB0byBhcHBlbmQgdG8gbm9ybWFsIFVSTHMgZm9yIHRoaXMgbm9kZVxyXG4gICAgICAgIC8vICAnY3VycmVudERpcmVjdG9yeScgLSBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIGFic29sdXRlXHJcbiAgICAgICAgLy8gICdyb290RmlsZW5hbWUnIC0gZmlsZW5hbWUgb2YgdGhlIGJhc2UgZmlsZVxyXG4gICAgICAgIC8vICAnZW50cnlQYXRoJyAtIGFic29sdXRlIHBhdGggdG8gdGhlIGVudHJ5IGZpbGVcclxuICAgICAgICAvLyAgJ3JlZmVyZW5jZScgLSB3aGV0aGVyIHRoZSBmaWxlIHNob3VsZCBub3QgYmUgb3V0cHV0IGFuZCBvbmx5IG91dHB1dCBwYXJ0cyB0aGF0IGFyZSByZWZlcmVuY2VkXHJcbiAgICAgICAgdmFyIEltcG9ydE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEltcG9ydE1hbmFnZXIobGVzcywgY29udGV4dCwgcm9vdEZpbGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlc3MgPSBsZXNzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290RmlsZW5hbWUgPSByb290RmlsZUluZm8uZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhzID0gY29udGV4dC5wYXRocyB8fCBbXTsgLy8gU2VhcmNoIHBhdGhzLCB3aGVuIGltcG9ydGluZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IHt9OyAvLyBtYXAgLSBmaWxlbmFtZSB0byBjb250ZW50cyBvZiBhbGwgdGhlIGZpbGVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRzSWdub3JlZENoYXJzID0ge307IC8vIG1hcCAtIGZpbGVuYW1lIHRvIGxpbmVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBmaWxlIHRvIGlnbm9yZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5taW1lID0gY29udGV4dC5taW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZD8gVW51c2VkIG91dHNpZGUgb2YgaGVyZSwgY291bGQgYmUgdXNlZnVsLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdOyAvLyBGaWxlcyB3aGljaCBoYXZlbid0IGJlZW4gaW1wb3J0ZWQgeWV0XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzID0ge307IC8vIEhvbGRzIHRoZSBpbXBvcnRlZCBwYXJzZSB0cmVlcy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkIGFuIGltcG9ydCB0byBiZSBpbXBvcnRlZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSByYXcgcGF0aFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdHJ5QXBwZW5kRXh0ZW5zaW9uIC0gd2hldGhlciB0byB0cnkgYXBwZW5kaW5nIGEgZmlsZSBleHRlbnNpb24gKC5sZXNzIG9yIC5qcyBpZiB0aGUgcGF0aCBoYXMgbm8gZXh0ZW5zaW9uKVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gY3VycmVudEZpbGVJbmZvIC0gdGhlIGN1cnJlbnQgZmlsZSBpbmZvICh1c2VkIGZvciBpbnN0YW5jZSB0byB3b3JrIG91dCByZWxhdGl2ZSBwYXRocylcclxuICAgICAgICAgICAgICogQHBhcmFtIGltcG9ydE9wdGlvbnMgLSBpbXBvcnQgb3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBjYWxsYmFjayBmb3Igd2hlbiBpdCBpcyBpbXBvcnRlZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW1wb3J0TWFuYWdlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChwYXRoLCB0cnlBcHBlbmRFeHRlbnNpb24sIGN1cnJlbnRGaWxlSW5mbywgaW1wb3J0T3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRNYW5hZ2VyID0gdGhpcywgcGx1Z2luTG9hZGVyID0gdGhpcy5jb250ZXh0LnBsdWdpbk1hbmFnZXIuTG9hZGVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVQYXJzZWRGdW5jID0gZnVuY3Rpb24gKGUsIHJvb3QsIGZ1bGxQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0TWFuYWdlci5xdWV1ZS5zcGxpY2UoaW1wb3J0TWFuYWdlci5xdWV1ZS5pbmRleE9mKHBhdGgpLCAxKTsgLy8gUmVtb3ZlIHRoZSBwYXRoIGZyb20gdGhlIHF1ZXVlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGVkRXF1YWxzUm9vdCA9IGZ1bGxQYXRoID09PSBpbXBvcnRNYW5hZ2VyLnJvb3RGaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0T3B0aW9ucy5vcHRpb25hbCAmJiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgcnVsZXM6IFtdIH0sIGZhbHNlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJUaGUgZmlsZSBcIiArIGZ1bGxQYXRoICsgXCIgd2FzIHNraXBwZWQgYmVjYXVzZSBpdCB3YXMgbm90IGZvdW5kIGFuZCB0aGUgaW1wb3J0IHdhcyBtYXJrZWQgb3B0aW9uYWwuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5saW5lIGltcG9ydHMgYXJlbid0IGNhY2hlZCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdGFydCB0byBjYWNoZSB0aGVtLCBwbGVhc2UgbWFrZSBzdXJlIHRoZXkgd29uJ3QgY29uZmxpY3Qgd2l0aCBub24taW5saW5lIGltcG9ydHMgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgbmFtZSBhcyB0aGV5IHVzZWQgdG8gZG8gYmVmb3JlIHRoaXMgY29tbWVudCBhbmQgdGhlIGNvbmRpdGlvbiBiZWxvdyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0TWFuYWdlci5maWxlc1tmdWxsUGF0aF0gJiYgIWltcG9ydE9wdGlvbnMuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLmZpbGVzW2Z1bGxQYXRoXSA9IHsgcm9vdDogcm9vdCwgb3B0aW9uczogaW1wb3J0T3B0aW9ucyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlICYmICFpbXBvcnRNYW5hZ2VyLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRNYW5hZ2VyLmVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCByb290LCBpbXBvcnRlZEVxdWFsc1Jvb3QsIGZ1bGxQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpbGVJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJld3JpdGVVcmxzOiB0aGlzLmNvbnRleHQucmV3cml0ZVVybHMsXHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnlQYXRoOiBjdXJyZW50RmlsZUluZm8uZW50cnlQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RwYXRoOiBjdXJyZW50RmlsZUluZm8ucm9vdHBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBjdXJyZW50RmlsZUluZm8ucm9vdEZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVNYW5hZ2VyID0gZW52aXJvbm1lbnQuZ2V0RmlsZU1hbmFnZXIocGF0aCwgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIHRoaXMuY29udGV4dCwgZW52aXJvbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlTWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXJzZWRGdW5jKHsgbWVzc2FnZTogXCJDb3VsZCBub3QgZmluZCBhIGZpbGUtbWFuYWdlciBmb3IgXCIgKyBwYXRoIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsb2FkRmlsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGxvYWRlZEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZEZpbGVuYW1lID0gbG9hZGVkRmlsZS5maWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBsb2FkZWRGaWxlLmNvbnRlbnRzLnJlcGxhY2UoL15cXHVGRUZGLywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3Mgb24gYW4gdXBkYXRlZCByb290cGF0aCBpZiBwYXRoIG9mIGltcG9ydGVkIGZpbGUgaXMgcmVsYXRpdmUgYW5kIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBpbiBhIChzdWJ8c3VwKSBkaXJlY3RvcnlcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4YW1wbGVzOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSWYgcGF0aCBvZiBpbXBvcnRlZCBmaWxlIGlzICdtb2R1bGUvbmF2L25hdi5sZXNzJyBhbmQgcm9vdHBhdGggaXMgJ2xlc3MvJyxcclxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRoZW4gcm9vdHBhdGggc2hvdWxkIGJlY29tZSAnbGVzcy9tb2R1bGUvbmF2LydcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIElmIHBhdGggb2YgaW1wb3J0ZWQgZmlsZSBpcyAnLi4vbWl4aW5zLmxlc3MnIGFuZCByb290cGF0aCBpcyAnbGVzcy8nLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhlbiByb290cGF0aCBzaG91bGQgYmVjb21lICdsZXNzLy4uLydcclxuICAgICAgICAgICAgICAgICAgICBuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5ID0gZmlsZU1hbmFnZXIuZ2V0UGF0aChyZXNvbHZlZEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RmlsZUluZm8ucmV3cml0ZVVybHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBmaWxlTWFuYWdlci5qb2luKChpbXBvcnRNYW5hZ2VyLmNvbnRleHQucm9vdHBhdGggfHwgJycpLCBmaWxlTWFuYWdlci5wYXRoRGlmZihuZXdGaWxlSW5mby5jdXJyZW50RGlyZWN0b3J5LCBuZXdGaWxlSW5mby5lbnRyeVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlTWFuYWdlci5pc1BhdGhBYnNvbHV0ZShuZXdGaWxlSW5mby5yb290cGF0aCkgJiYgZmlsZU1hbmFnZXIuYWx3YXlzTWFrZVBhdGhzQWJzb2x1dGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZUluZm8ucm9vdHBhdGggPSBmaWxlTWFuYWdlci5qb2luKG5ld0ZpbGVJbmZvLmVudHJ5UGF0aCwgbmV3RmlsZUluZm8ucm9vdHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpbGVJbmZvLmZpbGVuYW1lID0gcmVzb2x2ZWRGaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RW52ID0gbmV3IGNvbnRleHRzLlBhcnNlKGltcG9ydE1hbmFnZXIuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RW52LnByb2Nlc3NJbXBvcnRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0TWFuYWdlci5jb250ZW50c1tyZXNvbHZlZEZpbGVuYW1lXSA9IGNvbnRlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmlsZUluZm8ucmVmZXJlbmNlIHx8IGltcG9ydE9wdGlvbnMucmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZpbGVJbmZvLnJlZmVyZW5jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRPcHRpb25zLmlzUGx1Z2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IHBsdWdpbkxvYWRlci5ldmFsUGx1Z2luKGNvbnRlbnRzLCBuZXdFbnYsIGltcG9ydE1hbmFnZXIsIGltcG9ydE9wdGlvbnMucGx1Z2luQXJncywgbmV3RmlsZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luIGluc3RhbmNlb2YgTGVzc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhwbHVnaW4sIG51bGwsIHJlc29sdmVkRmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMobnVsbCwgcGx1Z2luLCByZXNvbHZlZEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBvcnRPcHRpb25zLmlubGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhudWxsLCBjb250ZW50cywgcmVzb2x2ZWRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgKG11bHRpcGxlKSBwYXJzZSB0cmVlcyBhcHBhcmVudGx5IGdldCBhbHRlcmVkIGFuZCBjYW4ndCBiZSBjYWNoZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIHdoeSB0aGlzIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRNYW5hZ2VyLmZpbGVzW3Jlc29sdmVkRmlsZW5hbWVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhaW1wb3J0TWFuYWdlci5maWxlc1tyZXNvbHZlZEZpbGVuYW1lXS5vcHRpb25zLm11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhaW1wb3J0T3B0aW9ucy5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMobnVsbCwgaW1wb3J0TWFuYWdlci5maWxlc1tyZXNvbHZlZEZpbGVuYW1lXS5yb290LCByZXNvbHZlZEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYXJzZXIobmV3RW52LCBpbXBvcnRNYW5hZ2VyLCBuZXdGaWxlSW5mbykucGFyc2UoY29udGVudHMsIGZ1bmN0aW9uIChlLCByb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMoZSwgcm9vdCwgcmVzb2x2ZWRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9hZGVkRmlsZTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjbG9uZSh0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyeUFwcGVuZEV4dGVuc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXh0ID0gaW1wb3J0T3B0aW9ucy5pc1BsdWdpbiA/ICcuanMnIDogJy5sZXNzJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRPcHRpb25zLmlzUGx1Z2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5taW1lID0gJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN5bmNJbXBvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkRmlsZSA9IHBsdWdpbkxvYWRlci5sb2FkUGx1Z2luU3luYyhwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwbHVnaW5Mb2FkZXIubG9hZFBsdWdpbihwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zeW5jSW1wb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZEZpbGUgPSBmaWxlTWFuYWdlci5sb2FkRmlsZVN5bmMocGF0aCwgY3VycmVudEZpbGVJbmZvLmN1cnJlbnREaXJlY3RvcnksIGNvbnRleHQsIGVudmlyb25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBmaWxlTWFuYWdlci5sb2FkRmlsZShwYXRoLCBjdXJyZW50RmlsZUluZm8uY3VycmVudERpcmVjdG9yeSwgY29udGV4dCwgZW52aXJvbm1lbnQsIGZ1bmN0aW9uIChlcnIsIGxvYWRlZEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyc2VkRnVuYyhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEZpbGVDYWxsYmFjayhsb2FkZWRGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZEZpbGUuZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhcnNlZEZ1bmMobG9hZGVkRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4obG9hZEZpbGVDYWxsYmFjaywgZmlsZVBhcnNlZEZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gSW1wb3J0TWFuYWdlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiBJbXBvcnRNYW5hZ2VyO1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUGFyc2UgKGVudmlyb25tZW50LCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIpIHtcclxuICAgICAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvcHlPcHRpb25zKHRoaXMub3B0aW9ucywge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvcHlPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlLmNhbGwoc2VsZl8xLCBpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0XzE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEZpbGVJbmZvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbk1hbmFnZXJfMSA9IG5ldyBQbHVnaW5NYW5hZ2VyRmFjdG9yeSh0aGlzLCAhb3B0aW9ucy5yZVVzZVBsdWdpbk1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wbHVnaW5NYW5hZ2VyID0gcGx1Z2luTWFuYWdlcl8xO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dF8xID0gbmV3IGNvbnRleHRzLlBhcnNlKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucm9vdEZpbGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVJbmZvID0gb3B0aW9ucy5yb290RmlsZUluZm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lIHx8ICdpbnB1dCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5UGF0aCA9IGZpbGVuYW1lLnJlcGxhY2UoL1teXFwvXFxcXF0qJC8sICcnKTtcclxuICAgICAgICAgICAgICAgICAgICByb290RmlsZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZVVybHM6IGNvbnRleHRfMS5yZXdyaXRlVXJscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHBhdGg6IGNvbnRleHRfMS5yb290cGF0aCB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERpcmVjdG9yeTogZW50cnlQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeVBhdGg6IGVudHJ5UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEZpbGVuYW1lOiBmaWxlbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGluIGEgbWlzc2luZyB0cmFpbGluZyBzbGFzaFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290RmlsZUluZm8ucm9vdHBhdGggJiYgcm9vdEZpbGVJbmZvLnJvb3RwYXRoLnNsaWNlKC0xKSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RGaWxlSW5mby5yb290cGF0aCArPSAnLyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydHNfMSA9IG5ldyBJbXBvcnRNYW5hZ2VyKHRoaXMsIGNvbnRleHRfMSwgcm9vdEZpbGVJbmZvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0TWFuYWdlciA9IGltcG9ydHNfMTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsbG93IHRoZSBwbHVnaW5zIHRvIGJlIGp1c3QgYSBsaXN0IG9mIHBhdGhzIG9yIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBhbiBhc3luYyBwbHVnaW4gcXVldWUgbGlrZSBsZXNzY1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGx1Z2lucykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2YWxSZXN1bHQsIGNvbnRlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmZpbGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IHBsdWdpbi5maWxlQ29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxSZXN1bHQgPSBwbHVnaW5NYW5hZ2VyXzEuTG9hZGVyLmV2YWxQbHVnaW4oY29udGVudHMsIGNvbnRleHRfMSwgaW1wb3J0c18xLCBwbHVnaW4ub3B0aW9ucywgcGx1Z2luLmZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsUmVzdWx0IGluc3RhbmNlb2YgTGVzc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2YWxSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luTWFuYWdlcl8xLmFkZFBsdWdpbihwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXcgUGFyc2VyKGNvbnRleHRfMSwgaW1wb3J0c18xLCByb290RmlsZUluZm8pXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlKGlucHV0LCBmdW5jdGlvbiAoZSwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcm9vdCwgaW1wb3J0c18xLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcGFyc2U7XHJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZW5kZXIgKGVudmlyb25tZW50LCBQYXJzZVRyZWUsIEltcG9ydE1hbmFnZXIpIHtcclxuICAgICAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb3B5T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb3B5T3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIuY2FsbChzZWxmXzEsIGlucHV0LCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBvdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZShpbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcm9vdCwgaW1wb3J0cywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlVHJlZSA9IG5ldyBQYXJzZVRyZWUocm9vdCwgaW1wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVHJlZS50b0NTUyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyO1xyXG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSBcIjQuMS4xXCI7XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vZGVWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgIHZhciBtYXRjaCA9IHZlcnNpb24ubWF0Y2goL152KFxcZHsxLDJ9KVxcLihcXGR7MSwyfSlcXC4oXFxkezEsMn0pKD86LShbMC05QS1aYS16LS5dKykpPyg/OlxcKyhbMC05QS1aYS16LS5dKykpPyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlOiAnICsgdmVyc2lvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIG1ham9yOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgICAgICBtaW5vcjogcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSxcbiAgICAgICAgcGF0Y2g6IHBhcnNlSW50KG1hdGNoWzNdLCAxMCksXG4gICAgICAgIHByZTogbWF0Y2hbNF0gfHwgJycsXG4gICAgICAgIGJ1aWxkOiBtYXRjaFs1XSB8fCAnJyxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlTm9kZVZlcnNpb25fMSA9IHBhcnNlTm9kZVZlcnNpb247XG5cbiAgICBmdW5jdGlvbiBsZXNzUm9vdCAoZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2Vycykge1xyXG4gICAgICAgIHZhciBzb3VyY2VNYXBPdXRwdXQsIHNvdXJjZU1hcEJ1aWxkZXIsIHBhcnNlVHJlZSwgaW1wb3J0TWFuYWdlcjtcclxuICAgICAgICBlbnZpcm9ubWVudCA9IG5ldyBFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgZmlsZU1hbmFnZXJzKTtcclxuICAgICAgICBzb3VyY2VNYXBPdXRwdXQgPSBTb3VyY2VNYXBPdXRwdXQoZW52aXJvbm1lbnQpO1xyXG4gICAgICAgIHNvdXJjZU1hcEJ1aWxkZXIgPSBTb3VyY2VNYXBCdWlsZGVyKHNvdXJjZU1hcE91dHB1dCwgZW52aXJvbm1lbnQpO1xyXG4gICAgICAgIHBhcnNlVHJlZSA9IFBhcnNlVHJlZShzb3VyY2VNYXBCdWlsZGVyKTtcclxuICAgICAgICBpbXBvcnRNYW5hZ2VyID0gSW1wb3J0TWFuYWdlcihlbnZpcm9ubWVudCk7XHJcbiAgICAgICAgdmFyIHJlbmRlciA9IFJlbmRlcihlbnZpcm9ubWVudCwgcGFyc2VUcmVlKTtcclxuICAgICAgICB2YXIgcGFyc2UgPSBQYXJzZShlbnZpcm9ubWVudCwgcGFyc2VUcmVlLCBpbXBvcnRNYW5hZ2VyKTtcclxuICAgICAgICB2YXIgdiA9IHBhcnNlTm9kZVZlcnNpb25fMShcInZcIiArIHZlcnNpb24pO1xyXG4gICAgICAgIHZhciBpbml0aWFsID0ge1xyXG4gICAgICAgICAgICB2ZXJzaW9uOiBbdi5tYWpvciwgdi5taW5vciwgdi5wYXRjaF0sXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgIHRyZWU6IHRyZWUsXHJcbiAgICAgICAgICAgIEVudmlyb25tZW50OiBFbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgQWJzdHJhY3RGaWxlTWFuYWdlcjogQWJzdHJhY3RGaWxlTWFuYWdlcixcclxuICAgICAgICAgICAgQWJzdHJhY3RQbHVnaW5Mb2FkZXI6IEFic3RyYWN0UGx1Z2luTG9hZGVyLFxyXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgIHZpc2l0b3JzOiB2aXNpdG9ycyxcclxuICAgICAgICAgICAgUGFyc2VyOiBQYXJzZXIsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uczogZnVuY3Rpb25zKGVudmlyb25tZW50KSxcclxuICAgICAgICAgICAgY29udGV4dHM6IGNvbnRleHRzLFxyXG4gICAgICAgICAgICBTb3VyY2VNYXBPdXRwdXQ6IHNvdXJjZU1hcE91dHB1dCxcclxuICAgICAgICAgICAgU291cmNlTWFwQnVpbGRlcjogc291cmNlTWFwQnVpbGRlcixcclxuICAgICAgICAgICAgUGFyc2VUcmVlOiBwYXJzZVRyZWUsXHJcbiAgICAgICAgICAgIEltcG9ydE1hbmFnZXI6IGltcG9ydE1hbmFnZXIsXHJcbiAgICAgICAgICAgIHJlbmRlcjogcmVuZGVyLFxyXG4gICAgICAgICAgICBwYXJzZTogcGFyc2UsXHJcbiAgICAgICAgICAgIExlc3NFcnJvcjogTGVzc0Vycm9yLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1UcmVlOiB0cmFuc2Zvcm1UcmVlLFxyXG4gICAgICAgICAgICB1dGlsczogdXRpbHMsXHJcbiAgICAgICAgICAgIFBsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXJGYWN0b3J5LFxyXG4gICAgICAgICAgICBsb2dnZXI6IGxvZ2dlclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHVibGljIEFQSVxyXG4gICAgICAgIHZhciBjdG9yID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKTtcclxuICAgICAgICAgICAgICAgIHQuYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdDtcclxuICAgICAgICB2YXIgYXBpID0gT2JqZWN0LmNyZWF0ZShpbml0aWFsKTtcclxuICAgICAgICBmb3IgKHZhciBuIGluIGluaXRpYWwudHJlZSkge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXHJcbiAgICAgICAgICAgIHQgPSBpbml0aWFsLnRyZWVbbl07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgYXBpW24udG9Mb3dlckNhc2UoKV0gPSBjdG9yKHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXBpW25dID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG8gaW4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cclxuICAgICAgICAgICAgICAgICAgICBhcGlbbl1bby50b0xvd2VyQ2FzZSgpXSA9IGN0b3IodFtvXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU29tZSBvZiB0aGUgZnVuY3Rpb25zIGFzc3VtZSBhIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBBUEkgb2JqZWN0LFxyXG4gICAgICAgICAqIHdoaWNoIGNhdXNlcyBpdCB0byBmYWlsIHdoZW4gd3JhcHBlZCBmb3IgRVM2IGltcG9ydHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBBbiBhc3N1bWVkIGB0aGlzYCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXRpYWwucGFyc2UgPSBpbml0aWFsLnBhcnNlLmJpbmQoYXBpKTtcclxuICAgICAgICBpbml0aWFsLnJlbmRlciA9IGluaXRpYWwucmVuZGVyLmJpbmQoYXBpKTtcclxuICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgfVxuXG4gICAgLyogZ2xvYmFsIHdpbmRvdywgWE1MSHR0cFJlcXVlc3QgKi9cclxuICAgIHZhciBvcHRpb25zO1xyXG4gICAgdmFyIGxvZ2dlciQxO1xyXG4gICAgdmFyIGZpbGVDYWNoZSA9IHt9O1xyXG4gICAgLy8gVE9ET1MgLSBtb3ZlIGxvZyBzb21ld2hlcmUuIHBhdGhEaWZmIGFuZCBkb2luZyBzb21ldGhpbmcgc2ltaWxhciBpbiBub2RlLiB1c2UgcGF0aERpZmYgaW4gdGhlIG90aGVyIGJyb3dzZXIgZmlsZSBmb3IgdGhlIGluaXRpYWwgbG9hZFxyXG4gICAgdmFyIEZpbGVNYW5hZ2VyID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgRmlsZU1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgQWJzdHJhY3RGaWxlTWFuYWdlcigpLCB7XHJcbiAgICAgICAgYWx3YXlzTWFrZVBhdGhzQWJzb2x1dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBqb2luOiBmdW5jdGlvbiAoYmFzZVBhdGgsIGxhdGVyUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoIWJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXJQYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RVcmxQYXJ0cyhsYXRlclBhdGgsIGJhc2VQYXRoKS5wYXRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZG9YSFI6IGZ1bmN0aW9uICh1cmwsIHR5cGUsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgdmFyIGFzeW5jID0gb3B0aW9ucy5pc0ZpbGVQcm90b2NvbCA/IG9wdGlvbnMuZmlsZUFzeW5jIDogdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIub3ZlcnJpZGVNaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvY3NzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9nZ2VyJDEuZGVidWcoXCJYSFI6IEdldHRpbmcgJ1wiICsgdXJsICsgXCInXCIpO1xyXG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBhc3luYyk7XHJcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCB0eXBlIHx8ICd0ZXh0L3gtbGVzcywgdGV4dC9jc3M7IHE9MC45LCAqLyo7IHE9MC41Jyk7XHJcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZSh4aHIsIGNhbGxiYWNrLCBlcnJiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQsIHhoci5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlcnJiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyYmFjayh4aHIuc3RhdHVzLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlzRmlsZVByb3RvY29sICYmICFvcHRpb25zLmZpbGVBc3luYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgfHwgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJiYWNrKHhoci5zdGF0dXMsIHVybCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXN5bmMpIHtcclxuICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UoeGhyLCBjYWxsYmFjaywgZXJyYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKHhociwgY2FsbGJhY2ssIGVycmJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdXBwb3J0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyRmlsZUNhY2hlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZpbGVDYWNoZSA9IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZEZpbGU6IGZ1bmN0aW9uIChmaWxlbmFtZSwgY3VycmVudERpcmVjdG9yeSwgb3B0aW9ucywgZW52aXJvbm1lbnQpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogQWRkIHByZWZpeCBzdXBwb3J0IGxpa2UgbGVzcy1ub2RlP1xyXG4gICAgICAgICAgICAvLyBXaGF0IGFib3V0IG11bHRpcGxlIHBhdGhzP1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudERpcmVjdG9yeSAmJiAhdGhpcy5pc1BhdGhBYnNvbHV0ZShmaWxlbmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gY3VycmVudERpcmVjdG9yeSArIGZpbGVuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbGVuYW1lID0gb3B0aW9ucy5leHQgPyB0aGlzLnRyeUFwcGVuZEV4dGVuc2lvbihmaWxlbmFtZSwgb3B0aW9ucy5leHQpIDogZmlsZW5hbWU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICAvLyBzaGVldCBtYXkgYmUgc2V0IHRvIHRoZSBzdHlsZXNoZWV0IGZvciB0aGUgaW5pdGlhbCBsb2FkIG9yIGEgY29sbGVjdGlvbiBvZiBwcm9wZXJ0aWVzIGluY2x1ZGluZ1xyXG4gICAgICAgICAgICAvLyBzb21lIGNvbnRleHQgdmFyaWFibGVzIGZvciBpbXBvcnRzXHJcbiAgICAgICAgICAgIHZhciBocmVmUGFydHMgPSB0aGlzLmV4dHJhY3RVcmxQYXJ0cyhmaWxlbmFtZSwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgICAgICAgICB2YXIgaHJlZiA9IGhyZWZQYXJ0cy51cmw7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUZpbGVDYWNoZSAmJiBmaWxlQ2FjaGVbaHJlZl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVzc1RleHQgPSBmaWxlQ2FjaGVbaHJlZl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgY29udGVudHM6IGxlc3NUZXh0LCBmaWxlbmFtZTogaHJlZiwgd2ViSW5mbzogeyBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkgfSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh7IGZpbGVuYW1lOiBocmVmLCBtZXNzYWdlOiBcIkVycm9yIGxvYWRpbmcgZmlsZSBcIiArIGhyZWYgKyBcIiBlcnJvciB3YXMgXCIgKyBlLm1lc3NhZ2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi5kb1hIUihocmVmLCBvcHRpb25zLm1pbWUsIGZ1bmN0aW9uIGRvWEhSQ2FsbGJhY2soZGF0YSwgbGFzdE1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyIGZpbGUgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICBmaWxlQ2FjaGVbaHJlZl0gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSByZW1vdGUgY29weSAocmUtcGFyc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGNvbnRlbnRzOiBkYXRhLCBmaWxlbmFtZTogaHJlZiwgd2ViSW5mbzogeyBsYXN0TW9kaWZpZWQ6IGxhc3RNb2RpZmllZCB9IH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gZG9YSFJFcnJvcihzdGF0dXMsIHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IHR5cGU6ICdGaWxlJywgbWVzc2FnZTogXCInXCIgKyB1cmwgKyBcIicgd2Fzbid0IGZvdW5kIChcIiArIHN0YXR1cyArIFwiKVwiLCBocmVmOiBocmVmIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIEZNID0gKGZ1bmN0aW9uIChvcHRzLCBsb2cpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0cztcclxuICAgICAgICBsb2dnZXIkMSA9IGxvZztcclxuICAgICAgICByZXR1cm4gRmlsZU1hbmFnZXI7XHJcbiAgICB9KTtcblxuICAgIC8vIFRPRE86IEFkZCB0ZXN0cyBmb3IgYnJvd3NlciBAcGx1Z2luXHJcbiAgICAvKipcclxuICAgICAqIEJyb3dzZXIgUGx1Z2luIExvYWRlclxyXG4gICAgICovXHJcbiAgICB2YXIgUGx1Z2luTG9hZGVyID0gZnVuY3Rpb24gKGxlc3MpIHtcclxuICAgICAgICB0aGlzLmxlc3MgPSBsZXNzO1xyXG4gICAgICAgIC8vIFNob3VsZCB3ZSBzaGltIHRoaXMucmVxdWlyZSBmb3IgYnJvd3Nlcj8gUHJvYmFibHkgbm90P1xyXG4gICAgfTtcclxuICAgIFBsdWdpbkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKG5ldyBBYnN0cmFjdFBsdWdpbkxvYWRlcigpLCB7XHJcbiAgICAgICAgbG9hZFBsdWdpbjogZnVuY3Rpb24gKGZpbGVuYW1lLCBiYXNlUGF0aCwgY29udGV4dCwgZW52aXJvbm1lbnQsIGZpbGVNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlTWFuYWdlci5sb2FkRmlsZShmaWxlbmFtZSwgYmFzZVBhdGgsIGNvbnRleHQsIGVudmlyb25tZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIExvZ0xpc3RlbmVyID0gKGZ1bmN0aW9uIChsZXNzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGxvZ0xldmVsX2RlYnVnID0gNDtcclxuICAgICAgICB2YXIgbG9nTGV2ZWxfaW5mbyA9IDM7XHJcbiAgICAgICAgdmFyIGxvZ0xldmVsX3dhcm4gPSAyO1xyXG4gICAgICAgIHZhciBsb2dMZXZlbF9lcnJvciA9IDE7XHJcbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiBsb2dnaW5nIGluIHRoZSBqYXZhc2NyaXB0IGNvbnNvbGUuXHJcbiAgICAgICAgLy8gMyAtIERlYnVnLCBpbmZvcm1hdGlvbiBhbmQgZXJyb3JzXHJcbiAgICAgICAgLy8gMiAtIEluZm9ybWF0aW9uIGFuZCBlcnJvcnNcclxuICAgICAgICAvLyAxIC0gRXJyb3JzXHJcbiAgICAgICAgLy8gMCAtIE5vbmVcclxuICAgICAgICAvLyBEZWZhdWx0cyB0byAyXHJcbiAgICAgICAgb3B0aW9ucy5sb2dMZXZlbCA9IHR5cGVvZiBvcHRpb25zLmxvZ0xldmVsICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubG9nTGV2ZWwgOiAob3B0aW9ucy5lbnYgPT09ICdkZXZlbG9wbWVudCcgPyBsb2dMZXZlbF9pbmZvIDogbG9nTGV2ZWxfZXJyb3IpO1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5sb2dnZXJzKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubG9nZ2VycyA9IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfZGVidWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfaW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dMZXZlbCA+PSBsb2dMZXZlbF93YXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPj0gbG9nTGV2ZWxfZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubG9nZ2Vycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXNzLmxvZ2dlci5hZGRMaXN0ZW5lcihvcHRpb25zLmxvZ2dlcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xuXG4gICAgdmFyIEVycm9yUmVwb3J0aW5nID0gKGZ1bmN0aW9uICh3aW5kb3csIGxlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICBmdW5jdGlvbiBlcnJvckhUTUwoZSwgcm9vdEhyZWYpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gXCJsZXNzLWVycm9yLW1lc3NhZ2U6XCIgKyBleHRyYWN0SWQocm9vdEhyZWYgfHwgJycpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSAnPGxpPjxsYWJlbD57bGluZX08L2xhYmVsPjxwcmUgY2xhc3M9XCJ7Y2xhc3N9XCI+e2NvbnRlbnR9PC9wcmU+PC9saT4nO1xyXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgdmFyIHRpbWVyO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudDtcclxuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBlLmZpbGVuYW1lIHx8IHJvb3RIcmVmO1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWVOb1BhdGggPSBmaWxlbmFtZS5tYXRjaCgvKFteXFwvXSsoXFw/LiopPykkLylbMV07XHJcbiAgICAgICAgICAgIGVsZW0uaWQgPSBpZDtcclxuICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSAnbGVzcy1lcnJvci1tZXNzYWdlJztcclxuICAgICAgICAgICAgY29udGVudCA9IFwiPGgzPlwiICsgKGUudHlwZSB8fCAnU3ludGF4JykgKyBcIkVycm9yOiBcIiArIChlLm1lc3NhZ2UgfHwgJ1RoZXJlIGlzIGFuIGVycm9yIGluIHlvdXIgLmxlc3MgZmlsZScpICtcclxuICAgICAgICAgICAgICAgIChcIjwvaDM+PHA+aW4gPGEgaHJlZj1cXFwiXCIgKyBmaWxlbmFtZSArIFwiXFxcIj5cIiArIGZpbGVuYW1lTm9QYXRoICsgXCI8L2E+IFwiKTtcclxuICAgICAgICAgICAgdmFyIGVycm9ybGluZSA9IGZ1bmN0aW9uIChlLCBpLCBjbGFzc25hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmV4dHJhY3RbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRlbXBsYXRlLnJlcGxhY2UoL1xce2xpbmVcXH0vLCAocGFyc2VJbnQoZS5saW5lLCAxMCkgfHwgMCkgKyAoaSAtIDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7Y2xhc3NcXH0vLCBjbGFzc25hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjb250ZW50XFx9LywgZS5leHRyYWN0W2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChlLmxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGVycm9ybGluZShlLCAwLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBlcnJvcmxpbmUoZSwgMSwgJ2xpbmUnKTtcclxuICAgICAgICAgICAgICAgIGVycm9ybGluZShlLCAyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwib24gbGluZSBcIiArIGUubGluZSArIFwiLCBjb2x1bW4gXCIgKyAoZS5jb2x1bW4gKyAxKSArIFwiOjwvcD48dWw+XCIgKyBlcnJvcnMuam9pbignJykgKyBcIjwvdWw+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGUuc3RhY2sgJiYgKGUuZXh0cmFjdCB8fCBvcHRpb25zLmxvZ0xldmVsID49IDQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwiPGJyLz5TdGFjayBUcmFjZTwvYnIgLz5cIiArIGUuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLmpvaW4oJzxici8+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG4gICAgICAgICAgICAvLyBDU1MgZm9yIGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgICAgICAgIGJyb3dzZXIuY3JlYXRlQ1NTKHdpbmRvdy5kb2N1bWVudCwgW1xyXG4gICAgICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgdWwsIC5sZXNzLWVycm9yLW1lc3NhZ2UgbGkgeycsXHJcbiAgICAgICAgICAgICAgICAnbGlzdC1zdHlsZS10eXBlOiBub25lOycsXHJcbiAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0OiAxNXB4OycsXHJcbiAgICAgICAgICAgICAgICAncGFkZGluZzogNHB4IDA7JyxcclxuICAgICAgICAgICAgICAgICdtYXJnaW46IDA7JyxcclxuICAgICAgICAgICAgICAgICd9JyxcclxuICAgICAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGxhYmVsIHsnLFxyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZTogMTJweDsnLFxyXG4gICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodDogMTVweDsnLFxyXG4gICAgICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXHJcbiAgICAgICAgICAgICAgICAnY29sb3I6ICNjYzc3Nzc7JyxcclxuICAgICAgICAgICAgICAgICd9JyxcclxuICAgICAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIHByZSB7JyxcclxuICAgICAgICAgICAgICAgICdjb2xvcjogI2RkNjY2NjsnLFxyXG4gICAgICAgICAgICAgICAgJ3BhZGRpbmc6IDRweCAwOycsXHJcbiAgICAgICAgICAgICAgICAnbWFyZ2luOiAwOycsXHJcbiAgICAgICAgICAgICAgICAnZGlzcGxheTogaW5saW5lLWJsb2NrOycsXHJcbiAgICAgICAgICAgICAgICAnfScsXHJcbiAgICAgICAgICAgICAgICAnLmxlc3MtZXJyb3ItbWVzc2FnZSBwcmUubGluZSB7JyxcclxuICAgICAgICAgICAgICAgICdjb2xvcjogI2ZmMDAwMDsnLFxyXG4gICAgICAgICAgICAgICAgJ30nLFxyXG4gICAgICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgaDMgeycsXHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplOiAyMHB4OycsXHJcbiAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQ6IGJvbGQ7JyxcclxuICAgICAgICAgICAgICAgICdwYWRkaW5nOiAxNXB4IDAgNXB4IDA7JyxcclxuICAgICAgICAgICAgICAgICdtYXJnaW46IDA7JyxcclxuICAgICAgICAgICAgICAgICd9JyxcclxuICAgICAgICAgICAgICAgICcubGVzcy1lcnJvci1tZXNzYWdlIGEgeycsXHJcbiAgICAgICAgICAgICAgICAnY29sb3I6ICMxMGEnLFxyXG4gICAgICAgICAgICAgICAgJ30nLFxyXG4gICAgICAgICAgICAgICAgJy5sZXNzLWVycm9yLW1lc3NhZ2UgLmVycm9yIHsnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiByZWQ7JyxcclxuICAgICAgICAgICAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxyXG4gICAgICAgICAgICAgICAgJ3BhZGRpbmctYm90dG9tOiAycHg7JyxcclxuICAgICAgICAgICAgICAgICdib3JkZXItYm90dG9tOiAxcHggZGFzaGVkIHJlZDsnLFxyXG4gICAgICAgICAgICAgICAgJ30nXHJcbiAgICAgICAgICAgIF0uam9pbignXFxuJyksIHsgdGl0bGU6ICdlcnJvci1tZXNzYWdlJyB9KTtcclxuICAgICAgICAgICAgZWxlbS5zdHlsZS5jc3NUZXh0ID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZicsXHJcbiAgICAgICAgICAgICAgICAnYm9yZGVyOiAxcHggc29saWQgI2UwMCcsXHJcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcjogI2VlZScsXHJcbiAgICAgICAgICAgICAgICAnYm9yZGVyLXJhZGl1czogNXB4JyxcclxuICAgICAgICAgICAgICAgICctd2Via2l0LWJvcmRlci1yYWRpdXM6IDVweCcsXHJcbiAgICAgICAgICAgICAgICAnLW1vei1ib3JkZXItcmFkaXVzOiA1cHgnLFxyXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZTAwJyxcclxuICAgICAgICAgICAgICAgICdwYWRkaW5nOiAxNXB4JyxcclxuICAgICAgICAgICAgICAgICdtYXJnaW4tYm90dG9tOiAxNXB4J1xyXG4gICAgICAgICAgICBdLmpvaW4oJzsnKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW52ID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkucmVwbGFjZUNoaWxkKGVsZW0sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShlbGVtLCBib2R5LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFcnJvckhUTUwocGF0aCkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlc3MtZXJyb3ItbWVzc2FnZTpcIiArIGV4dHJhY3RJZChwYXRoKSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3IocGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgfHwgb3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2h0bWwnKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVFcnJvckhUTUwocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5lcnJvclJlcG9ydGluZyA9PT0gJ2NvbnNvbGUnKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yUmVwb3J0aW5nKCdyZW1vdmUnLCBwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBlcnJvckNvbnNvbGUoZSwgcm9vdEhyZWYpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gJ3tsaW5lfSB7Y29udGVudH0nO1xyXG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBlLmZpbGVuYW1lIHx8IHJvb3RIcmVmO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gKGUudHlwZSB8fCAnU3ludGF4JykgKyBcIkVycm9yOiBcIiArIChlLm1lc3NhZ2UgfHwgJ1RoZXJlIGlzIGFuIGVycm9yIGluIHlvdXIgLmxlc3MgZmlsZScpICsgXCIgaW4gXCIgKyBmaWxlbmFtZTtcclxuICAgICAgICAgICAgdmFyIGVycm9ybGluZSA9IGZ1bmN0aW9uIChlLCBpLCBjbGFzc25hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmV4dHJhY3RbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRlbXBsYXRlLnJlcGxhY2UoL1xce2xpbmVcXH0vLCAocGFyc2VJbnQoZS5saW5lLCAxMCkgfHwgMCkgKyAoaSAtIDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7Y2xhc3NcXH0vLCBjbGFzc25hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtjb250ZW50XFx9LywgZS5leHRyYWN0W2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChlLmxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGVycm9ybGluZShlLCAwLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBlcnJvcmxpbmUoZSwgMSwgJ2xpbmUnKTtcclxuICAgICAgICAgICAgICAgIGVycm9ybGluZShlLCAyLCAnJyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIG9uIGxpbmUgXCIgKyBlLmxpbmUgKyBcIiwgY29sdW1uIFwiICsgKGUuY29sdW1uICsgMSkgKyBcIjpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZS5zdGFjayAmJiAoZS5leHRyYWN0IHx8IG9wdGlvbnMubG9nTGV2ZWwgPj0gNCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCJcXG5TdGFjayBUcmFjZVxcblwiICsgZS5zdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXNzLmxvZ2dlci5lcnJvcihjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZXJyb3IoZSwgcm9vdEhyZWYpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmVycm9yUmVwb3J0aW5nIHx8IG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdodG1sJykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIVE1MKGUsIHJvb3RIcmVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmVycm9yUmVwb3J0aW5nID09PSAnY29uc29sZScpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yQ29uc29sZShlLCByb290SHJlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JSZXBvcnRpbmcoJ2FkZCcsIGUsIHJvb3RIcmVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhZGQ6IGVycm9yLFxyXG4gICAgICAgICAgICByZW1vdmU6IHJlbW92ZUVycm9yXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xuXG4gICAgLy8gQ2FjaGUgc3lzdGVtIGlzIGEgYml0IG91dGRhdGVkIGFuZCBjb3VsZCBkbyB3aXRoIHdvcmtcclxuICAgIHZhciBDYWNoZSA9IChmdW5jdGlvbiAod2luZG93LCBvcHRpb25zLCBsb2dnZXIpIHtcclxuICAgICAgICB2YXIgY2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmVudiAhPT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUgPSAodHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPT09ICd1bmRlZmluZWQnKSA/IG51bGwgOiB3aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0Q1NTOiBmdW5jdGlvbiAocGF0aCwgbGFzdE1vZGlmaWVkLCBtb2RpZnlWYXJzLCBzdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwic2F2aW5nIFwiICsgcGF0aCArIFwiIHRvIGNhY2hlLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRJdGVtKHBhdGgsIHN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEl0ZW0ocGF0aCArIFwiOnRpbWVzdGFtcFwiLCBsYXN0TW9kaWZpZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZ5VmFycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0SXRlbShwYXRoICsgXCI6dmFyc1wiLCBKU09OLnN0cmluZ2lmeShtb2RpZnlWYXJzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtIGNvdWxkIGRvIHdpdGggYWRkaW5nIG1vcmUgcm9idXN0IGVycm9yIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcImZhaWxlZCB0byBzYXZlIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgdG8gbG9jYWwgc3RvcmFnZSBmb3IgY2FjaGluZy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRDU1M6IGZ1bmN0aW9uIChwYXRoLCB3ZWJJbmZvLCBtb2RpZnlWYXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3NzID0gY2FjaGUgJiYgY2FjaGUuZ2V0SXRlbShwYXRoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBjYWNoZSAmJiBjYWNoZS5nZXRJdGVtKHBhdGggKyBcIjp0aW1lc3RhbXBcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFycyA9IGNhY2hlICYmIGNhY2hlLmdldEl0ZW0ocGF0aCArIFwiOnZhcnNcIik7XHJcbiAgICAgICAgICAgICAgICBtb2RpZnlWYXJzID0gbW9kaWZ5VmFycyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhcnMgPSB2YXJzIHx8IFwie31cIjsgLy8gaWYgbm90IHNldCwgdHJlYXQgYXMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gZW1wdHkgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wICYmIHdlYkluZm8ubGFzdE1vZGlmaWVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG5ldyBEYXRlKHdlYkluZm8ubGFzdE1vZGlmaWVkKS52YWx1ZU9mKCkgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKHRpbWVzdGFtcCkudmFsdWVPZigpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1vZGlmeVZhcnMpID09PSB2YXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGxvY2FsIGNvcHlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xuXG4gICAgdmFyIEltYWdlU2l6ZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaW1hZ2VTaXplKCkge1xyXG4gICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUnVudGltZScsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW1hZ2Ugc2l6ZSBmdW5jdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIGxlc3MnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbWFnZUZ1bmN0aW9ucyA9IHtcclxuICAgICAgICAgICAgJ2ltYWdlLXNpemUnOiBmdW5jdGlvbiAoZmlsZVBhdGhOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ2ltYWdlLXdpZHRoJzogZnVuY3Rpb24gKGZpbGVQYXRoTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdpbWFnZS1oZWlnaHQnOiBmdW5jdGlvbiAoZmlsZVBhdGhOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb25SZWdpc3RyeS5hZGRNdWx0aXBsZShpbWFnZUZ1bmN0aW9ucyk7XHJcbiAgICB9KTtcblxuICAgIC8vXHJcbiAgICB2YXIgcm9vdCA9IChmdW5jdGlvbiAod2luZG93LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xyXG4gICAgICAgIHZhciBsZXNzID0gbGVzc1Jvb3QoKTtcclxuICAgICAgICBsZXNzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHZhciBlbnZpcm9ubWVudCA9IGxlc3MuZW52aXJvbm1lbnQ7XHJcbiAgICAgICAgdmFyIEZpbGVNYW5hZ2VyID0gRk0ob3B0aW9ucywgbGVzcy5sb2dnZXIpO1xyXG4gICAgICAgIHZhciBmaWxlTWFuYWdlciA9IG5ldyBGaWxlTWFuYWdlcigpO1xyXG4gICAgICAgIGVudmlyb25tZW50LmFkZEZpbGVNYW5hZ2VyKGZpbGVNYW5hZ2VyKTtcclxuICAgICAgICBsZXNzLkZpbGVNYW5hZ2VyID0gRmlsZU1hbmFnZXI7XHJcbiAgICAgICAgbGVzcy5QbHVnaW5Mb2FkZXIgPSBQbHVnaW5Mb2FkZXI7XHJcbiAgICAgICAgTG9nTGlzdGVuZXIobGVzcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGVycm9ycyA9IEVycm9yUmVwb3J0aW5nKHdpbmRvdywgbGVzcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNhY2hlID0gbGVzcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgQ2FjaGUod2luZG93LCBvcHRpb25zLCBsZXNzLmxvZ2dlcik7XHJcbiAgICAgICAgSW1hZ2VTaXplKGxlc3MuZW52aXJvbm1lbnQpO1xyXG4gICAgICAgIC8vIFNldHVwIHVzZXIgZnVuY3Rpb25zIC0gRGVwcmVjYXRlP1xyXG4gICAgICAgIGlmIChvcHRpb25zLmZ1bmN0aW9ucykge1xyXG4gICAgICAgICAgICBsZXNzLmZ1bmN0aW9ucy5mdW5jdGlvblJlZ2lzdHJ5LmFkZE11bHRpcGxlKG9wdGlvbnMuZnVuY3Rpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHR5cGVQYXR0ZXJuID0gL150ZXh0XFwvKHgtKT9sZXNzJC87XHJcbiAgICAgICAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZWQgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb25seSByZWFsbHkgbmVlZGVkIGZvciBwaGFudG9tXHJcbiAgICAgICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyeUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjdXJyeUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRTdHlsZXMobW9kaWZ5VmFycykge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnR5cGUubWF0Y2godHlwZVBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlT3B0aW9ucyA9IGNsb25lKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5tb2RpZnlWYXJzID0gbW9kaWZ5VmFycztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVzc1RleHQgPSBzdHlsZS5pbm5lckhUTUwgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zLmZpbGVuYW1lID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiokLywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGNsb3N1cmUgdG8gc3RvcmUgY3VycmVudCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxlc3MucmVuZGVyKGxlc3NUZXh0LCBpbnN0YW5jZU9wdGlvbnMsIGJpbmQoZnVuY3Rpb24gKHN0eWxlLCBlLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hZGQoZSwgJ2lubGluZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlc3VsdC5jc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSByZXN1bHQuY3NzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgc3R5bGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBsb2FkU3R5bGVTaGVldChzaGVldCwgY2FsbGJhY2ssIHJlbG9hZCwgcmVtYWluaW5nLCBtb2RpZnlWYXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnMgPSBjbG9uZShvcHRpb25zKTtcclxuICAgICAgICAgICAgYWRkRGF0YUF0dHIoaW5zdGFuY2VPcHRpb25zLCBzaGVldCk7XHJcbiAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5taW1lID0gc2hlZXQudHlwZTtcclxuICAgICAgICAgICAgaWYgKG1vZGlmeVZhcnMpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5tb2RpZnlWYXJzID0gbW9kaWZ5VmFycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2FkSW5pdGlhbEZpbGVDYWxsYmFjayhsb2FkZWRGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGxvYWRlZEZpbGUuY29udGVudHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGxvYWRlZEZpbGUuZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2ViSW5mbyA9IGxvYWRlZEZpbGUud2ViSW5mbztcclxuICAgICAgICAgICAgICAgIHZhciBuZXdGaWxlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0b3J5OiBmaWxlTWFuYWdlci5nZXRQYXRoKHBhdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RGaWxlbmFtZTogcGF0aCxcclxuICAgICAgICAgICAgICAgICAgICByZXdyaXRlVXJsczogaW5zdGFuY2VPcHRpb25zLnJld3JpdGVVcmxzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbmV3RmlsZUluZm8uZW50cnlQYXRoID0gbmV3RmlsZUluZm8uY3VycmVudERpcmVjdG9yeTtcclxuICAgICAgICAgICAgICAgIG5ld0ZpbGVJbmZvLnJvb3RwYXRoID0gaW5zdGFuY2VPcHRpb25zLnJvb3RwYXRoIHx8IG5ld0ZpbGVJbmZvLmN1cnJlbnREaXJlY3Rvcnk7XHJcbiAgICAgICAgICAgICAgICBpZiAod2ViSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYkluZm8ucmVtYWluaW5nID0gcmVtYWluaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSBjYWNoZS5nZXRDU1MocGF0aCwgd2ViSW5mbywgaW5zdGFuY2VPcHRpb25zLm1vZGlmeVZhcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVsb2FkICYmIGNzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJJbmZvLmxvY2FsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY3NzLCBkYXRhLCBzaGVldCwgd2ViSW5mbywgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGFkZCB0ZXN0cyBhcm91bmQgaG93IHRoaXMgYmVoYXZlcyB3aGVuIHJlbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzLnJlbW92ZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5yb290RmlsZUluZm8gPSBuZXdGaWxlSW5mbztcclxuICAgICAgICAgICAgICAgIGxlc3MucmVuZGVyKGRhdGEsIGluc3RhbmNlT3B0aW9ucywgZnVuY3Rpb24gKGUsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaHJlZiA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0Q1NTKHNoZWV0LmhyZWYsIHdlYkluZm8ubGFzdE1vZGlmaWVkLCBpbnN0YW5jZU9wdGlvbnMubW9kaWZ5VmFycywgcmVzdWx0LmNzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5jc3MsIGRhdGEsIHNoZWV0LCB3ZWJJbmZvLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaWxlTWFuYWdlci5sb2FkRmlsZShzaGVldC5ocmVmLCBudWxsLCBpbnN0YW5jZU9wdGlvbnMsIGVudmlyb25tZW50KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxvYWRlZEZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGxvYWRJbml0aWFsRmlsZUNhbGxiYWNrKGxvYWRlZEZpbGUpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRTdHlsZVNoZWV0cyhjYWxsYmFjaywgcmVsb2FkLCBtb2RpZnlWYXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVzcy5zaGVldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0KGxlc3Muc2hlZXRzW2ldLCBjYWxsYmFjaywgcmVsb2FkLCBsZXNzLnNoZWV0cy5sZW5ndGggLSAoaSArIDEpLCBtb2RpZnlWYXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBpbml0UnVubmluZ01vZGUoKSB7XHJcbiAgICAgICAgICAgIGlmIChsZXNzLmVudiA9PT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgbGVzcy53YXRjaFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZXNzLndhdGNoTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTWFuYWdlci5jbGVhckZpbGVDYWNoZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkU3R5bGVTaGVldHMoZnVuY3Rpb24gKGUsIGNzcywgXywgc2hlZXQsIHdlYkluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFkZChlLCBlLmhyZWYgfHwgc2hlZXQuaHJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLmNyZWF0ZUNTUyh3aW5kb3cuZG9jdW1lbnQsIGNzcywgc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnBvbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2F0Y2ggbW9kZVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgbGVzcy53YXRjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFsZXNzLndhdGNoTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgbGVzcy5lbnYgPSAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgICAgICAgICAgICAgaW5pdFJ1bm5pbmdNb2RlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53YXRjaE1vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxlc3MudW53YXRjaCA9IGZ1bmN0aW9uICgpIHsgY2xlYXJJbnRlcnZhbChsZXNzLndhdGNoVGltZXIpOyB0aGlzLndhdGNoTW9kZSA9IGZhbHNlOyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTeW5jaHJvbm91c2x5IGdldCBhbGwgPGxpbms+IHRhZ3Mgd2l0aCB0aGUgJ3JlbCcgYXR0cmlidXRlIHNldCB0b1xyXG4gICAgICAgIC8vIFwic3R5bGVzaGVldC9sZXNzXCIuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHNJbW1lZGlhdGVseSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKTtcclxuICAgICAgICAgICAgbGVzcy5zaGVldHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtzW2ldLnJlbCA9PT0gJ3N0eWxlc2hlZXQvbGVzcycgfHwgKGxpbmtzW2ldLnJlbC5tYXRjaCgvc3R5bGVzaGVldC8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGxpbmtzW2ldLnR5cGUubWF0Y2godHlwZVBhdHRlcm4pKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXNzLnNoZWV0cy5wdXNoKGxpbmtzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBBc3luY2hyb25vdXNseSBnZXQgYWxsIDxsaW5rPiB0YWdzIHdpdGggdGhlICdyZWwnIGF0dHJpYnV0ZSBzZXQgdG9cclxuICAgICAgICAvLyBcInN0eWxlc2hlZXQvbGVzc1wiLCByZXR1cm5pbmcgYSBQcm9taXNlLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgbGVzcy5yZWdpc3RlclN0eWxlc2hlZXRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBsZXNzLnJlZ2lzdGVyU3R5bGVzaGVldHNJbW1lZGlhdGVseSgpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7IH07XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXaXRoIHRoaXMgZnVuY3Rpb24sIGl0J3MgcG9zc2libGUgdG8gYWx0ZXIgdmFyaWFibGVzIGFuZCByZS1yZW5kZXJcclxuICAgICAgICAvLyBDU1Mgd2l0aG91dCByZWxvYWRpbmcgbGVzcy1maWxlc1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgbGVzcy5tb2RpZnlWYXJzID0gZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gbGVzcy5yZWZyZXNoKHRydWUsIHJlY29yZCwgZmFsc2UpOyB9O1xyXG4gICAgICAgIGxlc3MucmVmcmVzaCA9IGZ1bmN0aW9uIChyZWxvYWQsIG1vZGlmeVZhcnMsIGNsZWFyRmlsZUNhY2hlKSB7XHJcbiAgICAgICAgICAgIGlmICgocmVsb2FkIHx8IGNsZWFyRmlsZUNhY2hlKSAmJiBjbGVhckZpbGVDYWNoZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVNYW5hZ2VyLmNsZWFyRmlsZUNhY2hlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kVGltZTtcclxuICAgICAgICAgICAgICAgIHZhciB0b3RhbE1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdTaGVldHM7XHJcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBlbmRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjb3VudGVyIGZvciByZW1haW5pbmcgdW5wcm9jZXNzZWQgc2hlZXRzXHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmdTaGVldHMgPSBsZXNzLnNoZWV0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nU2hlZXRzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNaWxsaXNlY29uZHMgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oJ0xlc3MgaGFzIGZpbmlzaGVkIGFuZCBubyBzaGVldHMgd2VyZSBsb2FkZWQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kczogdG90YWxNaWxsaXNlY29uZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0czogbGVzcy5zaGVldHMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWxpZXMgb24gbGVzcy5zaGVldHMgYXJyYXksIGNhbGxiYWNrIHNlZW1zIHRvIGJlIGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50IG9mIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRTdHlsZVNoZWV0cyhmdW5jdGlvbiAoZSwgY3NzLCBfLCBzaGVldCwgd2ViSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFkZChlLCBlLmhyZWYgfHwgc2hlZXQuaHJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYkluZm8ubG9jYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlc3MubG9nZ2VyLmluZm8oXCJMb2FkaW5nIFwiICsgc2hlZXQuaHJlZiArIFwiIGZyb20gY2FjaGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbyhcIlJlbmRlcmVkIFwiICsgc2hlZXQuaHJlZiArIFwiIHN1Y2Nlc3NmdWxseS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jcmVhdGVDU1Mod2luZG93LmRvY3VtZW50LCBjc3MsIHNoZWV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVzcy5sb2dnZXIuaW5mbyhcIkNTUyBmb3IgXCIgKyBzaGVldC5ocmVmICsgXCIgZ2VuZXJhdGVkIGluIFwiICsgKG5ldyBEYXRlKCkgLSBlbmRUaW1lKSArIFwibXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50IGNvbXBsZXRlZCBzaGVldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdTaGVldHMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxhc3QgcmVtYWluaW5nIHNoZWV0IHdhcyBwcm9jZXNzZWQgYW5kIHRoZW4gY2FsbCB0aGUgcHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nU2hlZXRzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbE1pbGxpc2Vjb25kcyA9IG5ldyBEYXRlKCkgLSBzdGFydFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXNzLmxvZ2dlci5pbmZvKFwiTGVzcyBoYXMgZmluaXNoZWQuIENTUyBnZW5lcmF0ZWQgaW4gXCIgKyB0b3RhbE1pbGxpc2Vjb25kcyArIFwibXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTWlsbGlzZWNvbmRzOiB0b3RhbE1pbGxpc2Vjb25kcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVldHM6IGxlc3Muc2hlZXRzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVsb2FkLCBtb2RpZnlWYXJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvYWRTdHlsZXMobW9kaWZ5VmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGVzcy5yZWZyZXNoU3R5bGVzID0gbG9hZFN0eWxlcztcclxuICAgICAgICByZXR1cm4gbGVzcztcclxuICAgIH0pO1xuXG4gICAgLyoqXHJcbiAgICAgKiBLaWNrcyBvZmYgbGVzcyBhbmQgY29tcGlsZXMgYW55IHN0eWxlc2hlZXRzXHJcbiAgICAgKiB1c2VkIGluIHRoZSBicm93c2VyIGRpc3RyaWJ1dGVkIHZlcnNpb24gb2YgbGVzc1xyXG4gICAgICogdG8ga2ljay1zdGFydCBsZXNzIHVzaW5nIHRoZSBicm93c2VyIGFwaVxyXG4gICAgICovXHJcbiAgICB2YXIgb3B0aW9ucyQxID0gZGVmYXVsdE9wdGlvbnMoKTtcclxuICAgIGlmICh3aW5kb3cubGVzcykge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB3aW5kb3cubGVzcykge1xyXG4gICAgICAgICAgICBpZiAod2luZG93Lmxlc3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyQxW2tleV0gPSB3aW5kb3cubGVzc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkRGVmYXVsdE9wdGlvbnMod2luZG93LCBvcHRpb25zJDEpO1xyXG4gICAgb3B0aW9ucyQxLnBsdWdpbnMgPSBvcHRpb25zJDEucGx1Z2lucyB8fCBbXTtcclxuICAgIGlmICh3aW5kb3cuTEVTU19QTFVHSU5TKSB7XHJcbiAgICAgICAgb3B0aW9ucyQxLnBsdWdpbnMgPSBvcHRpb25zJDEucGx1Z2lucy5jb25jYXQod2luZG93LkxFU1NfUExVR0lOUyk7XHJcbiAgICB9XHJcbiAgICB2YXIgbGVzcyA9IHJvb3Qod2luZG93LCBvcHRpb25zJDEpO1xyXG4gICAgd2luZG93Lmxlc3MgPSBsZXNzO1xyXG4gICAgdmFyIGNzcztcclxuICAgIHZhciBoZWFkO1xyXG4gICAgdmFyIHN0eWxlO1xyXG4gICAgLy8gQWx3YXlzIHJlc3RvcmUgcGFnZSB2aXNpYmlsaXR5XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlT3JSZWplY3QoZGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhLmZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvcHRpb25zJDEuYXN5bmMpIHtcclxuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMkMS5vblJlYWR5KSB7XHJcbiAgICAgICAgaWYgKC8hd2F0Y2gvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhhc2gpKSB7XHJcbiAgICAgICAgICAgIGxlc3Mud2F0Y2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2ltdWxhdGUgc3luY2hyb25vdXMgc3R5bGVzaGVldCBsb2FkaW5nIGJ5IGhpZGluZyBwYWdlIHJlbmRlcmluZ1xyXG4gICAgICAgIGlmICghb3B0aW9ucyQxLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGNzcyA9ICdib2R5IHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50IH0nO1xyXG4gICAgICAgICAgICBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gICAgICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlc3MucmVnaXN0ZXJTdHlsZXNoZWV0c0ltbWVkaWF0ZWx5KCk7XHJcbiAgICAgICAgbGVzcy5wYWdlTG9hZEZpbmlzaGVkID0gbGVzcy5yZWZyZXNoKGxlc3MuZW52ID09PSAnZGV2ZWxvcG1lbnQnKS50aGVuKHJlc29sdmVPclJlamVjdCwgcmVzb2x2ZU9yUmVqZWN0KTtcclxuICAgIH1cblxuICAgIHJldHVybiBsZXNzO1xuXG59KSkpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgRm9udEZhY2VPYnNlcnZlciBmcm9tICcuL2ZvbnRmYWNlb2JzZXJ2ZXIuanMnXG5pbXBvcnQgeyBpbWFnZUNvbXByZXNzaW9uLCBlbnN1cmVBbGxJbWFnZXNMb2FkZWQgfSBmcm9tICcuL3BhZ2VTZXR1cC5qcydcbmltcG9ydCB7IGR5bmFtaWNSZXBsYWNlIH0gZnJvbSAnLi9yZXBsYWNlLmpzJztcbmltcG9ydCBzZXR1cFBsYWNlaG9sZGVyIGZyb20gJy4vcGxhY2Vob2xkZXIuanMnO1xuaW1wb3J0IHRleHRGaXQgZnJvbSAnLi90ZXh0Rml0LmpzJztcbmltcG9ydCB7IHNldHVwTVRPIH0gZnJvbSAnLi9tdG8uanMnO1xuaW1wb3J0IHsgY2hhckxpbWl0LCBkeW5hbWljQXNzaWduLCBtYXhIZWlnaHRDaGVjaywgbWF4TGluZUNoZWNrLCBnZXRIZWlnaHQsIGdldFdpZHRoLCBjb3VudExpbmVzLCBsaW5lQ2xhbXAsIGNhbGN1bGF0ZVRleHRNZXRyaWNzIH0gZnJvbSAnLi9saW1pdGVycyc7XG5cbmNvbnN0IGhpZ2hlc3RaID0gKCkgPT4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdib2R5IConKSlcbiAgICAubWFwKGEgPT4gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS56SW5kZXgpKVxuICAgIC5maWx0ZXIoYSA9PiAhaXNOYU4oYSkpXG4gICAgLnNvcnQoKVxuICAgIC5wb3AoKSArIDE7XG59XG5cbi8vIGRpc3BsYXkgYSBtZXNzYWdlIHRvIGJsb2NrIHJlbmRlcmluZyBmb3IgbWFqb3IgaXNzdWVzXG5jb25zdCBibG9ja1JlbmRlciA9ICh2KSA9PiB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpLmlubmVySFRNTCA9IGA8c3R5bGU+aHRtbCB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYmFja2dyb3VuZDogIzExMTgyMDsgY29sb3I6IHdoaXRlOyBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgZm9udC1zaXplOiAwLjVyZW07IHotaW5kZXg6ICR7aGlnaGVzdFooKX07IGhlaWdodDogMTAwJTsgd2lkdGg6IDEwMCU7fSAgYm9keSB7IG1hcmdpbjogMXJlbTsgd2lkdGg6IDgwJSFpbXBvcnRhbnQ7IH0gcCB7IGZvbnQtc2l6ZTogMC40cmVtOyB9IDwvc3R5bGU+XG4gIDxoMj7imqDvuI8gTGVnYWN5IHJlbmRlciBkZXRlY3RlZDwvaDI+XG4gIDxoND7imqBQbGVhc2UgZW5hYmxlIDxjb2RlPnsgYWxsb3dMZWdhY3lSZW5kZXJpbmc6IHRydWUgfTwvY29kZT5cbiAgIGluIHRoZSBib2lsZXJwbGF0ZSBvciB1cGRhdGUgdGhpcyB0ZW1wbGF0ZSB0byB2ZXJzaW9uIDEuMSBvciAyLjE8L2g0PlxuICAgPHA+VGhpcyB0ZW1wbGF0ZSBpcyB1c2luZyByZW5kZXJlciAke3Z9PC9wPlxuICAgPHA+UGxlYXNlIGNvbnRhY3Qgc3VwcG9ydCBpZiB5b3Ugc2VlIHRoaXMgbWVzc2FnZS48L3A+YDtcbiAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdwcmludHJlYWR5JykpO1xufVxuXG4vLyB3YWl0IGZvciB0aGUgZG9tIHRvIGxhb2Qgb3IgY29udGludWUgaWYgaXQgaGFzIGFscmVhZHkgbG9hZGVkXG5jb25zdCBkb21SZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgaWYgKFxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGVkXCIgfHxcbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCJcbiAgKSB7XG4gICAgcmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCByZXNvbHZlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gIH1cbn0pO1xuLy8gd2FpdCBmb3IgdGhlIHdpbmRvdyB0byBsYW9kIG9yIGNvbnRpbnVlIGlmIGl0IGhhcyBhbHJlYWR5IGxvYWRlZFxuY29uc3Qgd2luTG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgIHJlc29sdmUoKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVzb2x2ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICB9XG59KTtcbiBcbmNvbnN0IGxvYWRMRVNTID0gKHZhcmlhYmxlcyA9IHt9KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGxldCBzdHlsZUNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAvLyBzdHlsZUNvZGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAvLyBzdHlsZUNvZGUuc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgICAgLy8gc3R5bGVDb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvT3V0Zml0RGVsaXZlcnkvYm9pbGVycGxhdGVAdjMuMC9jc3MvbWFpbi5taW4uY3NzJyk7XG4gICAgICAvLyBkb2N1bWVudC5oZWFkLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJiZWdpbicsIHN0eWxlQ29kZSk7XG4gIFxuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1t0eXBlPVwidGV4dC9sZXNzXCJdJykgIT09IG51bGwpIHtcbiAgICAgICAgd2luZG93Lmxlc3MgPSB7XG4gICAgICAgICAgZ2xvYmFsVmFyczogdmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXF1aXJlKCdsZXNzJyk7XG4gICAgICAgIC8vIHJlcXVpcmUoJ3ByZWZpeGZyZWUnKTtcbiAgICAgICAgXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW21lZGlhPVwiXCJdW2RhdGEtaHJlZiQ9XCIubGVzc1wiXTpub3QoW2hyZWZdKScpLmZvckVhY2goZSA9PiBlLnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGJvaWxlcnBsYXRlIHtcbiAgY29uc3RydWN0b3IoeyBcbiAgICBmb250cyA9IFtdLFxuICAgIGVuc3VyZUltYWdlc0xvYWQgPSB0cnVlLFxuICAgIGVuc3VyZU5vT3ZlcmZsb3dzID0gZmFsc2UsXG4gICAgYWxsb3dMZWdhY3lSZW5kZXJpbmcgPSBmYWxzZSxcbiAgICBleHBvcnRSZWR1Y2VGb250ID0gMCxcbiAgICBmaXJlZm94UmVkdWNlRm9udCA9IDAsXG4gICAgd2FpdEZvckltYWdlcyA9IGZhbHNlLFxuICAgIHRyaW1NYXJrcyA9IGZhbHNlLFxuICAgIGFsbG93Tm9NZXRhRGF0YSA9IGZhbHNlLFxuICAgIHZhcmlhYmxlcyA9IHt9XG4gICB9ID0ge30pIHtcbiAgICAgdGhpcy5mb250cyA9IGZvbnRzIHx8ICcnO1xuICAgICB0aGlzLmVuc3VyZU5vT3ZlcmZsb3dzID0gZW5zdXJlTm9PdmVyZmxvd3M7XG4gICAgIHRoaXMud2FpdEZvckltYWdlcyA9IHdhaXRGb3JJbWFnZXM7XG4gICAgIHRoaXMuZW5zdXJlSW1hZ2VzTG9hZCA9IGVuc3VyZUltYWdlc0xvYWQ7XG4gICAgIHRoaXMuYWxsb3dMZWdhY3lSZW5kZXJpbmcgPSBhbGxvd0xlZ2FjeVJlbmRlcmluZztcbiAgICAgdGhpcy5leHBvcnRSZWR1Y2VGb250ID0gZXhwb3J0UmVkdWNlRm9udDtcbiAgICAgdGhpcy5maXJlZm94UmVkdWNlRm9udCA9IGZpcmVmb3hSZWR1Y2VGb250O1xuICAgICB0aGlzLnRyaW1NYXJrcyA9IHRyaW1NYXJrcztcbiAgICAgdGhpcy5hbGxvd05vTWV0YURhdGEgPSBhbGxvd05vTWV0YURhdGE7XG4gICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgIGlmICghdGhpcy5rZWVwQ29uc29sZSkge1xuICAgICAgY29uc29sZS5jbGVhcigpO1xuICAgIH1cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkodmFyaWFibGVzKSAhPT0gJ3t9Jykge1xuICAgICAgY29uc29sZS50YWJsZSh2YXJpYWJsZXMpXG4gICAgfVxuICB9XG4gIHN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBhbGwgdGhlc2UgY2hlY2tzIG5lZWQgdG8gYmUgZG9uZSBiZWZvcmUgdGhlIHRlbXBhbHRlIGNvZGUgY2FuIGJlIHJ1biBcbiAgICAgIGxldCBjaGVja0xpc3QgPSBbXG4gICAgICAgIGRvbVJlYWR5LFxuICAgICAgICBsb2FkTEVTUyh0aGlzLnZhcmlhYmxlcyksXG4gICAgICAgIHRoaXMuc2V0T3V0Zml0U3RhdGUoKSxcbiAgICAgICAgdGhpcy5mb250c0xvYWRlZCgpLFxuICAgICAgICB0aGlzLnNldEJyb3dzZXJUeXBlKCksXG4gICAgICAgIHRoaXMuc2V0U2l6ZSgpLFxuICAgICAgICB0aGlzLmFkZENyb3AoKVxuICAgICAgXTtcbiAgICAgIGlmICh0aGlzLndhaXRGb3JJbWFnZXMpIHtcbiAgICAgICAgY2hlY2tMaXN0LnB1c2goZW5zdXJlQWxsSW1hZ2VzTG9hZGVkKCkpXG4gICAgICB9XG4gICAgICBQcm9taXNlLmFsbChjaGVja0xpc3QpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5vblRleHRDaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgd2luZG93Lm9uVGV4dENoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRTaXplKCk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IFwicHJldmlld1wiICYmIHR5cGVvZiBvblRleHRDaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB3aW5kb3cub25UZXh0Q2hhbmdlKCdyZXNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIC8vIE91dGZpdElmcmFtZVNoYXJlZC5ldmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAvLyAgICd0b2tlbi12YWx1ZTpjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gICBpZiAoc3RhdGUgIT09IFwicHJldmlld1wiICYmIHR5cGVvZiB3aW5kb3cub25UZXh0Q2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vICAgICAgIHdpbmRvdy5vblRleHRDaGFuZ2UoZS5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgICB3aW5kb3cub25UZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgIGltYWdlQ29tcHJlc3Npb24oKTtcbiAgICAgICAgICAgIC8vIHNldCB0aW1lb3V0IGlzIHVzZWQgaGVyZSB0byBwdXNoIHRoaXMgdG8gdGhlIGVuZCBvZiB0aGUgaGVhcCB3aGljaCBtZWFucyBpdCB3aWxsIGxvYWQgYWZ0ZXIgZXZlcnl0aGluZyBlbHNlIFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IFxuICAgICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dOb01ldGFEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0c1JlbW92ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5sb2coXCJDb250ZW50IGNoZWNrcyByYW4g8J+YjlwiKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZW5zdXJlIHRoYXQgYWxsIGZvbnRzIGFyZSBsb2FkZWQgY2hlY2tcbiAgZm9udHNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBmb250c0xpc3RlZCA9IHRoaXMuZm9udHNcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShmb250c0xpc3RlZCkpIHtcbiAgICAgICAgICBmb250c0xpc3RlZCA9IFtmb250c0xpc3RlZF1cbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgIWZvbnRzTGlzdGVkIHx8XG4gICAgICAgIChmb250c0xpc3RlZCAmJiBmb250c0xpc3RlZC5sZW5ndGggPCAxKSB8fFxuICAgICAgICBmb250c0xpc3RlZFswXSA9PT0gXCJQVVRfQUxMX0ZPTlRfTkFNRVNfSEVSRVwiXG4gICAgICApIHtcbiAgICAgICAgcmVqZWN0KFwiTm8gZm9udHMgd2VyZSBwdXQgaW4gdGhlIGJvaWxlcnBsYXRlIGNvbmZpZy4gRm9yIGV4YW1wbGUgeyBmb250czogWydJQk0gUGxleCBTYW5zJ10gfVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUHJvbWlzZS5hbGwoZm9udHNMaXN0ZWQubWFwKChmb250KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRm9udEZhY2VPYnNlcnZlcihmb250KS5sb2FkKCk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50aGVuKGVsID0+IHtcbiAgICAgICAgICAgICAgLy8gVE9ETyBkZXRlY3QgZm9udHMgbG9hZGVkIHRoYXQgYXJlIG5vdCBpbiB0aGUgYXJyYXkgbGlzdCBcbiAgICAgICAgICAgICAgLy8gbGV0IHsgZm9udHMgfSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgICAvLyBjb25zdCBpdCA9IGZvbnRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBsZXQgYXJyID0gW107XG4gICAgICAgICAgICAgIC8vIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgIC8vICAgY29uc3QgZm9udCA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgLy8gICBpZiAoIWZvbnQuZG9uZSkge1xuICAgICAgICAgICAgICAvLyAgICAgYXJyLnB1c2goZm9udC52YWx1ZVswXS5mYW1pbHkpO1xuICAgICAgICAgICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vICAgICBkb25lID0gZm9udC5kb25lO1xuICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIGxldCBsb2FkZWRGb250cyA9IFsuLi5uZXcgU2V0KGFycildXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGxvYWRlZEZvbnRzKVxuXG4gICAgICAgICAgICAgIHJlc29sdmUoZWwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0QnJvd3NlclR5cGUgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IGJyb3dzZXIgPSB7XG4gICAgICAgIC8vIE9wZXJhIDguMCtcbiAgICAgICAgaXNPcGVyYTogKCEhd2luZG93Lm9wciAmJiAhIW9wci5hZGRvbnMpIHx8ICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwLFxuICAgICAgICAvLyBGaXJlZm94IDEuMCtcbiAgICAgICAgaXNGaXJlZm94OiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICAvLyBTYWZhcmkgMy4wKyBcIltvYmplY3QgSFRNTEVsZW1lbnRDb25zdHJ1Y3Rvcl1cIiBcbiAgICAgICAgaXNTYWZhcmk6IC9jb25zdHJ1Y3Rvci9pLnRlc3Qod2luZG93LkhUTUxFbGVtZW50KSB8fCAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl1cIjsgfSkoIXdpbmRvd1snc2FmYXJpJ10gfHwgKHR5cGVvZiBzYWZhcmkgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snc2FmYXJpJ10ucHVzaE5vdGlmaWNhdGlvbikpLFxuICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciA2LTExXG4gICAgICAgIGlzSUU6IC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlLFxuICAgICAgICAvLyBDaHJvbWUgMSAtIDc5XG4gICAgICAgIGlzQ2hyb21lOiAgISF3aW5kb3cuY2hyb21lICYmICghIXdpbmRvdy5jaHJvbWUud2Vic3RvcmUgfHwgISF3aW5kb3cuY2hyb21lLnJ1bnRpbWUpLFxuICAgICAgICAvLyBtYWMgZGV0ZWN0aW9uXG4gICAgICAgIGlzTWFjOiB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24uaW5jbHVkZXMoXCJNYWNcIilcbiAgICAgIH1cbiAgICAgIC8vICBFZGdlIDIwK1xuICAgICAgYnJvd3NlclsnaXNFZGdlJ10gPSAhYnJvd3Nlci5pc0lFICYmICEhd2luZG93LlN0eWxlTWVkaWE7XG4gICAgICAvLyBFZGdlIChiYXNlZCBvbiBjaHJvbWl1bSkgZGV0ZWN0aW9uXG4gICAgICBicm93c2VyWydpc0VkZ2VDaHJvbWl1bSddID0gYnJvd3Nlci5pc0Nocm9tZSAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRWRnXCIpICE9IC0xKTtcbiAgICAgIC8vIEJsaW5rIGVuZ2luZSBkZXRlY3Rpb25cbiAgICAgIGJyb3dzZXJbJ2lzQmxpbmsnXSA9IChicm93c2VyLmlzQ2hyb21lIHx8IGJyb3dzZXIuaXNPcGVyYSkgJiYgISF3aW5kb3cuQ1NTO1xuICBcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0ICs9ICcgJyArIE9iamVjdC5rZXlzKGJyb3dzZXIpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBicm93c2VyW2tleV1cbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgIHRoaXMuYnJvd3NlciA9IGJyb3dzZXI7XG4gICAgICByZXNvbHZlKGJyb3dzZXIpXG4gICAgfSk7XG4gIH1cbiAgXG4gIHNldE91dGZpdFN0YXRlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHZhciBtb2RlID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImV4cG9ydHNcIikgPiAtMSA/IFwiZXhwb3J0XCIgOiBmYWxzZTtcbiAgICAgIG1vZGUgPVxuICAgICAgICAhbW9kZSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwidGVtcGxhdGVzXCIpID4gLTFcbiAgICAgICAgICA/IFwidGVtcGxhdGVcIlxuICAgICAgICAgIDogbW9kZTtcbiAgICAgIG1vZGUgPVxuICAgICAgICAhbW9kZSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKFwicHJvamVjdHNcIikgPiAtMVxuICAgICAgICAgID8gXCJkb2N1bWVudFwiXG4gICAgICAgICAgOiBtb2RlO1xuICAgICAgbW9kZSA9XG4gICAgICAgICFtb2RlICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJwcmV2aWV3XCIpID4gLTEgPyBcInByZXZpZXdcIiA6IG1vZGU7XG4gICAgICBtb2RlID1cbiAgICAgICAgIW1vZGUgJiYgd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImxvY2FsaG9zdFwiKSA+IC0xID8gXCJsb2NhbFwiIDogbW9kZTtcbiAgICAgIGlmICghbW9kZSkge1xuICAgICAgICBtb2RlID0gXCJlcnJvclwiO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJkb2N1bWVudC1zdGF0ZVwiLCBtb2RlKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKFwiZGF0YS10cmltXCIsIHRoaXMudHJpbU1hcmtzKTtcbiAgICAgIHdpbmRvdy5zdGF0ZSA9IG1vZGU7XG4gICAgICB0aGlzLnN0YXRlID0gbW9kZTtcbiAgICAgIHJlc29sdmUobW9kZSk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIHNldFNpemUgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgdncgPVxuICAgICAgICAodGhpcy50cmltTWFya3MgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHdpbmRvdy5pbm5lcldpZHRoICsgNTcuNjIpIC8gMTAwO1xuICAgICAgY29uc3QgdmggPVxuICAgICAgICAodGhpcy50cmltTWFya3MgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHQgKyA1Ny42MikgLyAxMDA7XG4gICAgICBjb25zdCB2bWluID0gTWF0aC5taW4odncsIHZoKTtcbiAgICAgIGNvbnN0IHZtYXggPSBNYXRoLm1heCh2dywgdmgpO1xuICBcbiAgICAgIC8vIFNhdmluZyB0aGUgcHJlbGltaW5hcnkgZm9udCBzaXplIGNhbGN1bGF0aW9uXG4gICAgICBjb25zdCBwcmVsaW1pbmFyeUNhbGMgPSB2bWluICogMiArIHZtYXggKiAxLjQgKyB2aCAqIDI7XG4gIFxuICAgICAgLy8gQ2hlY2tpbmcgaWYgdGhlIGRvY3VtZW50IGlzIGN1cnJlbnRseSBpbiBleHBvcnQgbW9kZVxuICAgICAgY29uc3QgaXNFeHBvcnRNb2RlID0gd2luZG93LnN0YXRlID09PSBcImV4cG9ydHNcIjtcbiAgXG4gICAgICAvLyBDaGVja2luZyBpZiB0aGUgYWN0aXZlIGJyb3dzZXIgaXMgRmlyZWZveFxuICAgICAgY29uc3QgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3hcIik7XG4gIFxuICAgICAgY29uc3QgZXhwb3J0TW9kZUZvbnRTaXplID1cbiAgICAgICAgcHJlbGltaW5hcnlDYWxjIC0gKHRoaXMuZXhwb3J0UmVkdWNlRm9udCAvIDEwMCkgKiBwcmVsaW1pbmFyeUNhbGM7XG4gICAgICBjb25zdCBmaXJlZm94Rm9udFNpemUgPVxuICAgICAgICBwcmVsaW1pbmFyeUNhbGMgLSAodGhpcy5maXJlZm94UmVkdWNlRm9udCAvIDEwMCkgKiBwcmVsaW1pbmFyeUNhbGM7XG4gIFxuICAgICAgLy8gUmVkdWNpbmcgdGhlIHByZWxpbWluYXJ5Q2FsYyB2YWx1ZSBieSByZWR1Y2VWYWwgaW4gZXhwb3J0IG1vZGUgYW5kIGluIEZpcmVmb3ggcHJldmlldyBtb2RlXG4gICAgICBjb25zdCBmaW5hbENhbGMgPSBpc0V4cG9ydE1vZGVcbiAgICAgICAgPyBleHBvcnRNb2RlRm9udFNpemVcbiAgICAgICAgOiBpc0ZpcmVmb3hcbiAgICAgICAgPyBmaXJlZm94Rm9udFNpemVcbiAgICAgICAgOiBwcmVsaW1pbmFyeUNhbGM7XG4gIFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gYCR7ZmluYWxDYWxjfXB4YDtcbiAgXG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cblxuICBwYWdlSGVpZ2h0U2V0dXAoKSB7XG4gICAgbGV0IGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBpZiAoYWdlbnQuaW5jbHVkZXMoJ09QVElPTiAyLjEnKSkge1xuICAgICAgY29uc29sZS5pbmZvKFwiUmVuZGVyZXIgMi4xIFNldFwiKTtcbiAgICAgIGlmICghdGhpcy50cmltTWFya3MpIHtcbiAgICAgICAgcmV0dXJuIFwiY2FsYygxMDB2aCAtIDFweClcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjEwMHZoXCI7XG4gICAgfSBlbHNlIGlmIChhZ2VudC5pbmNsdWRlcygnT1BUSU9OIDEuMScpKSB7XG4gICAgICBjb25zb2xlLmluZm8oXCJSZW5kZXJlciAxLjEgU2V0XCIpO1xuICAgICAgcmV0dXJuIFwiMTAwdmhcIjtcbiAgICB9IGVsc2UgaWYgKGFnZW50LmluY2x1ZGVzKCdPUFRJT04gMS4wJykpIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0xlZ2FjeVJlbmRlcmluZykge1xuICAgICAgICBibG9ja1JlbmRlcignMS4wJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjEwMHZoXCI7XG4gICAgfSBlbHNlIGlmIChhZ2VudC5pbmNsdWRlcygnT1BUSU9OIDIuMCcpKSB7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dMZWdhY3lSZW5kZXJpbmcpIHtcbiAgICAgICAgYmxvY2tSZW5kZXIoJzIuMCcpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMudHJpbU1hcmtzKSB7XG4gICAgICAgIHJldHVybiBcImNhbGMoMTAwdmggLSAxcHgpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCIxMDB2aFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKFwiUmVuZGVyZXIgTm90IFNldFwiKTtcbiAgICAgIHJldHVybiBcIjEwMHZoXCI7XG4gICAgfVxuICB9XG4gIFxuICAvLyBGaXggZm9yIHRoZSByZXNpemFibGUgYmFja2dyb3VuZCBpbWFnZXMgLSBmdWxsc2NyZWVuIGFuZCBkaWdpdGFsIHZhaXJhaXRvbnMgb25seVxuICBhZGRDcm9wKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gY3JvcCBhbmQgYmxlZWRcbiAgICAgIHZhciBjcm9wU1ZHID1cbiAgICAgICAgJzxzdmcgY2xhc3M9XCJjcm9wLW1hcmtcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyMS42IDIxLjZcIiB4bWxuczp2PVwiaHR0cHM6Ly92ZWN0YS5pby9uYW5vXCI+PHBhdGggZD1cIk0yMSAxNVYwbS02IDIxSDBcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIwLjI1XCIgc3Ryb2tlLW1pdGVybGltaXQ9XCIxMC4wMTMxXCIvPjwvc3ZnPic7XG5cbiAgICAgIGxldCBwYWdlSGVpZ2h0ID0gdGhpcy5wYWdlSGVpZ2h0U2V0dXAoKTtcblxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5wYWdlXCIpLmZvckVhY2goKHBhZ2UpID0+IHtcbiAgICAgICAgcGFnZS5zdHlsZS5oZWlnaHQgPSBwYWdlSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy50cmltTWFya3MpIHtcbiAgICAgICAgICBwYWdlLmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgICAgIFwiYWZ0ZXJiZWdpblwiLFxuICAgICAgICAgICAgYDxkaXYgY2xhc3M9XCJjcm9wLW1hcmtzXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY3JvcC1tYXJrIHRvcC1sZWZ0XCI+JHtjcm9wU1ZHfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNyb3AtbWFyayB0b3AtcmlnaHRcIj4ke2Nyb3BTVkd9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY3JvcC1tYXJrIGJvdHRvbS1sZWZ0XCI+JHtjcm9wU1ZHfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNyb3AtbWFyayBib3R0b20tcmlnaHRcIj4ke2Nyb3BTVkd9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ibGVlZFwiKSlcbiAgICAgICAgLmZvckVhY2goKGJsZWVkKSA9PiB7XG4gICAgICAgICAgYmxlZWQuc3R5bGUuY3NzVGV4dCA9IHRoaXMudHJpbU1hcmtzXG4gICAgICAgICAgICA/IFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDQuNDFtbTsgcmlnaHQ6IDQuNDFtbTsgYm90dG9tOiA0LjQxbW07IGxlZnQ6IDQuNDFtbTtcIlxuICAgICAgICAgICAgOiBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtM21tOyByaWdodDogLTNtbTsgYm90dG9tOiAtM21tOyBsZWZ0OiAtM21tXCI7XG4gICAgICAgIH0pO1xuXG4gICAgICBkb2N1bWVudFxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXRyaW09J2ZhbHNlJ10gLm91dGZpdC1yZXNpemFibGUtYmFja2dyb3VuZFwiKVxuICAgICAgICAuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgZWwucGFyZW50Tm9kZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICB9KTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGVuc3VyZU5vT3ZlcmZsb3dzKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgb3ZlcmZsb3dzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm92ZXJmbG93LCBbb3ZlcmZsb3ddJyk7XG4gICAgICBpZiAob3ZlcmZsb3dzKSB7XG4gICAgICAgIHJlamVjdChvdmVyZmxvd3MpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHNlbmQgYSBldmVudCB0byBzdG9wIGEgcmVuZGVyIFxuICBjb21wbGV0ZVJlbmRlcigpIHtcbiAgICBsZXQgY2hlY2tMaXN0ID0gW3dpbkxvYWRdXG4gICAgaWYgKHRoaXMuZW5zdXJlSW1hZ2VzTG9hZCkge1xuICAgICAgY2hlY2tMaXN0LnB1c2goZW5zdXJlQWxsSW1hZ2VzTG9hZGVkKVxuICAgIH1cbiAgICBpZiAodGhpcy5lbnN1cmVOb092ZXJmbG93cykge1xuICAgICAgY2hlY2tMaXN0LnB1c2goZW5zdXJlTm9PdmVyZmxvd3MpXG4gICAgfVxuICAgIFByb21pc2UuYWxsKGNoZWNrTGlzdCkudGhlbigodmFsdWVzKSA9PiB7XG4gICAgICBsZXQgbG9hZFRpbWUgPSBEYXRlLm5vdygpIC0gd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcbiAgICAgIGNvbnNvbGUuaW5mbyhgRG9jdW1lbnQgaGFzIGZpbmlzaGVkIHJlbmRlcmluZyBpbiAke2xvYWRUaW1lfW1zYCk7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncHJpbnRyZWFkeScpKVxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhyb3cgJ+KaoO+4jyBSZW5kZXIgZmFpbGVkIGZvciBsb2dnZWQgcmVhc29uIOKktO+4jydcbiAgICB9KTtcbiAgfVxuICBkZWZhdWx0c1JlbW92ZWQgKCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkIGltcG9ydGFudCB0ZW1wYWx0ZSBtZXRhZGF0YVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgdGl0bGUgPSBkb2N1bWVudC50aXRsZTtcbiAgICAgIGlmICh0aXRsZSA9PT0gJycgfHwgdGl0bGUgPT09ICdQVVRfVEVNUExBVEVfTkFNRV9IRVJFJykge1xuICAgICAgICByZWplY3QoJ1BsZWFzZSBwdXQgdGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIGluIHRoZSB0aXRsZSBvZiB0aGUgZG9jdW1lbnQnKVxuICAgICAgfVxuICAgICAgbGV0IGJ1aWx0QnkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJ0ZW1wbGF0ZS1idWlsdC1ieVwiXScpLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xuICAgICAgaWYgKGJ1aWx0QnkgPT09ICcnIHx8IGJ1aWx0QnkgPT09ICdQVVRfWU9VUl9OQU1FX0hFUkUnKSB7XG4gICAgICAgIHJlamVjdCgnUGxlYXNlIGFkZCB5b3VyIG5hbWUgaW4gdGhlIGRvY3VtZW50IG1ldGEgdGFncycpXG4gICAgICB9IFxuICAgICAgbGV0IHNjb3BlQ2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInNjb3BlXCJdJykuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICBpZiAoc2NvcGVDYXJkID09PSAnJyB8fCBzY29wZUNhcmQgPT09ICdEVEItUFVUX0pJUkFfTlVNQkVSX0hFUkUnKSB7XG4gICAgICAgIHJlamVjdCgnUGxlYXNlIGFkZCB0aGUgc2NvcGUgY2FyZCBJRCBpbiB0aGUgZG9jdW1lbnQgbWV0YSB0YWdzJylcbiAgICAgIH1cbiAgICAgIGxldCBidWlsdENhcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJidWlsZFwiXScpLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xuICAgICAgaWYgKGJ1aWx0Q2FyZCA9PT0gJycgfHwgYnVpbHRDYXJkID09PSAnRFRCLVBVVF9KSVJBX05VTUJFUl9IRVJFJykge1xuICAgICAgICByZWplY3QoJ1BsZWFzZSBhZGQgdGhlIGJ1aWxkIGNhcmQgSUQgaW4gdGhlIGRvY3VtZW50IG1ldGEgdGFncycpXG4gICAgICB9IFxuICAgICAgaWYgKFsuLi5kb2N1bWVudC5oZWFkLmNoaWxkTm9kZXNdLnNvbWUobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZGF0YSAmJiBub2RlLm5vZGVUeXBlICA9PT0gOCkge1xuICAgICAgICAgIHJldHVybiBub2RlLmRhdGEuaW5jbHVkZXMoJ1RlbXBsYXRlIEFkbWluIEJ1aWxkIEluc3RydWN0aW9ucycpXG4gICAgICAgIH1cbiAgICAgIH0pKSB7XG4gICAgICAgIHJlamVjdCgnUGxlYXNlIHJlbW92ZSB0aGUgXCJUZW1wbGF0ZSBBZG1pbiBCdWlsZCBJbnN0cnVjdGlvbnNcIiBjb21tZW50IGZyb20gdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQnKVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG4gIGhvdFJlbG9hZE9uQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2RvY3VtZW50JyAmJiB0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoJ2ZzLXN5bmMnKTtcbiAgICAgIGJjLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgICAgICBpZiAoIXdpbmRvdy50b3AucmVsb2FkaW5nKSB7XG4gICAgICAgICAgd2luZG93LnRvcC5yZWxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIHdpbmRvdy50b3AubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkeW5hbWljUmVwbGFjZSAoKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNSZXBsYWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICB0ZXh0Rml0ICgpIHtcbiAgIHJldHVybiB0ZXh0Rml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBzZXR1cFBsYWNlaG9sZGVyICgpIHtcbiAgICByZXR1cm4gc2V0dXBQbGFjZWhvbGRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgbWF4TGluZUNoZWNrICgpIHtcbiAgICByZXR1cm4gbWF4TGluZUNoZWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBtYXhIZWlnaHRDaGVjayAoKSB7XG4gICAgcmV0dXJuIG1heEhlaWdodENoZWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBjaGFyTGltaXQgKCkge1xuICAgIHJldHVybiBjaGFyTGltaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGR5bmFtaWNBc3NpZ24gKCkge1xuICAgIHJldHVybiBkeW5hbWljQXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBoaWdoZXN0WmluZGV4ICgpIHtcbiAgICByZXR1cm4gaGlnaGVzdFooKVxuICB9XG4gIGVuc3VyZUFsbEltYWdlc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gZW5zdXJlQWxsSW1hZ2VzTG9hZGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBzZXR1cE1UTygpIHtcbiAgICByZXR1cm4gc2V0dXBNVE8uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiBnZXRXaWR0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiBnZXRIZWlnaHQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGNvdW50TGluZXMoKSB7XG4gICAgcmV0dXJuIGNvdW50TGluZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGNhbGN1bGF0ZVRleHRNZXRyaWNzKCkge1xuICAgIHJldHVybiBjYWxjdWxhdGVUZXh0TWV0cmljcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgbGluZUNsYW1wKCkge1xuICAgIHJldHVybiBsaW5lQ2xhbXAuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9